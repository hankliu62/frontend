<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具集合</title><link rel="icon" href="/toolbox-frontend/favicon.ico"/><meta name="description" content="卡鲁秋的前端工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋"/><meta name="author" content="Hank.Liu"/><meta name="next-head-count" content="7"/><link rel="stylesheet" href="/toolbox-frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/toolbox-frontend/_next/static/css/e443953a41d4ccca.css" as="style"/><link rel="stylesheet" href="/toolbox-frontend/_next/static/css/e443953a41d4ccca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/toolbox-frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/toolbox-frontend/_next/static/chunks/webpack-c5f674d417b86779.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/framework-aec4381329cec0e4.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/main-82d23b26b43cd32b.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/_app-baf3db6f3e140b26.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/6396-e9161609a76be07a.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/8490-2f2be535c5ee8413.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/1664-f865873e77459860.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/2555-3011663e4a0eccc6.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/questions/%5Bid%5D-ab2a432415dd9bf2.js" defer=""></script><script src="/toolbox-frontend/_next/static/0k7uM9gvhcyBu0gp_2bk9/_buildManifest.js" defer=""></script><script src="/toolbox-frontend/_next/static/0k7uM9gvhcyBu0gp_2bk9/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-12jzuas"><div class="ant-card-body"><article><header><h1 class="mb-5 text-4xl font-bold">TypeScript 中的 any、unknown、never 和 void 作用和区别</h1></header><section class="mb-12 flex items-center space-x-8"><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center group cursor-pointer"><div class="ant-space-item" style="margin-right:8px"><span role="img" aria-label="branches" class="anticon anticon-branches group-hover:text-[#1171ee]"><svg viewBox="64 64 896 896" focusable="false" data-icon="branches" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M740 161c-61.8 0-112 50.2-112 112 0 50.1 33.1 92.6 78.5 106.9v95.9L320 602.4V318.1c44.2-15 76-56.9 76-106.1 0-61.8-50.2-112-112-112s-112 50.2-112 112c0 49.2 31.8 91 76 106.1V706c-44.2 15-76 56.9-76 106.1 0 61.8 50.2 112 112 112s112-50.2 112-112c0-49.2-31.8-91-76-106.1v-27.8l423.5-138.7a50.52 50.52 0 0034.9-48.2V378.2c42.9-15.8 73.6-57 73.6-105.2 0-61.8-50.2-112-112-112zm-504 51a48.01 48.01 0 0196 0 48.01 48.01 0 01-96 0zm96 600a48.01 48.01 0 01-96 0 48.01 48.01 0 0196 0zm408-491a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"></path></svg></span></div><div class="ant-space-item"><span class="group-hover:text-[#1171ee]">#570</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center group cursor-pointer"><div class="ant-space-item"><span class="group-hover:text-sky-500">hankliu62</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center"><div class="ant-space-item"><span class="text-[#8a919f]">2024-03-05 03:17:06</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center"><div class="ant-space-item"><div class="flex items-center justify-start"><span class="ant-tag ant-tag-has-color css-12jzuas" style="background-color:#487E6B">typescript</span></div></div></div></section><section><div><div class="ant-skeleton ant-skeleton-active css-12jzuas"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-12jzuas"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="### any" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/toolbox-frontend/questions/570#any"><div class="truncate" style="padding-left:16px">any</div></a></li><li id="### unknown" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/570#unknown"><div class="truncate" style="padding-left:16px">unknown</div></a></li><li id="### never" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/570#never"><div class="truncate" style="padding-left:16px">never</div></a></li><li id="#### （1）一个无法走到 return 返回值的函数，比如一定会抛出错误或死循环：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/570#1%E4%B8%80%E4%B8%AA%E6%97%A0%E6%B3%95%E8%B5%B0%E5%88%B0-return-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%E6%AF%94%E5%A6%82%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%E6%88%96%E6%AD%BB%E5%BE%AA%E7%8E%AF"><div class="truncate" style="padding-left:32px">（1）一个无法走到 return 返回值的函数，比如一定会抛出错误或死循环：</div></a></li><li id="#### （2）TS 在判断条件下会做类型的收窄，当类型收缩到无类型可用，类型就变成了 never：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/570#2ts-%E5%9C%A8%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E4%B8%8B%E4%BC%9A%E5%81%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%94%B6%E7%AA%84%E5%BD%93%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%BC%A9%E5%88%B0%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%8F%AF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%B0%B1%E5%8F%98%E6%88%90%E4%BA%86-never"><div class="truncate" style="padding-left:32px">（2）TS 在判断条件下会做类型的收窄，当类型收缩到无类型可用，类型就变成了 never：</div></a></li><li id="#### （3）类型编程中，在做模式匹配时，如果匹配失败，还是要返回一个类型的。为了表示失败，返回一个 never 表示返回的类型是无法被使用的。" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/570#3%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%9C%A8%E5%81%9A%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%97%B6%E5%A6%82%E6%9E%9C%E5%8C%B9%E9%85%8D%E5%A4%B1%E8%B4%A5%E8%BF%98%E6%98%AF%E8%A6%81%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%BA%E4%BA%86%E8%A1%A8%E7%A4%BA%E5%A4%B1%E8%B4%A5%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-never-%E8%A1%A8%E7%A4%BA%E8%BF%94%E5%9B%9E%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E6%97%A0%E6%B3%95%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84"><div class="truncate" style="padding-left:32px">（3）类型编程中，在做模式匹配时，如果匹配失败，还是要返回一个类型的。为了表示失败，返回一个 never 表示返回的类型是无法被使用的。</div></a></li><li id="#### （4）类型编程中，将一些类型丢弃。never 在联合类型以及重映射的 key 中会被丢弃。" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/570#4%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%B0%86%E4%B8%80%E4%BA%9B%E7%B1%BB%E5%9E%8B%E4%B8%A2%E5%BC%83never-%E5%9C%A8%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%98%A0%E5%B0%84%E7%9A%84-key-%E4%B8%AD%E4%BC%9A%E8%A2%AB%E4%B8%A2%E5%BC%83"><div class="truncate" style="padding-left:32px">（4）类型编程中，将一些类型丢弃。never 在联合类型以及重映射的 key 中会被丢弃。</div></a></li><li id="### void" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/570#void"><div class="truncate" style="padding-left:16px">void</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/570#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:16px">总结</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/570","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/570/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/570/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/570/events","html_url":"https://github.com/hankliu62/interview/issues/570","id":2168212872,"node_id":"I_kwDOLNphd86BPE2I","number":570,"title":"TypeScript 中的 any、unknown、never 和 void 作用和区别","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468429,"node_id":"LA_kwDOLNphd88AAAABhkJwjQ","url":"https://api.github.com/repos/hankliu62/interview/labels/typescript","name":"typescript","color":"487E6B","default":false,"description":"Typescript相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-03-05T03:17:06Z","updated_at":"2024-03-09T03:00:06Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### any\r\n\r\nany 表示 任意类型。\r\n\r\n它是任意类型的父类，任意类型的值都可以赋予给 any 类型：\r\n\r\n``` ts\r\n// 编译不会报错\r\nlet anything: any = '前端西瓜哥';\r\n\r\nlet flag: boolean = true;\r\nanything = flag;\r\n\r\nanything = { num: 2 };\r\n```\r\n\r\n它可以表示任何类型，并使用它们的语法，就像写没有类型的原生 JS 一样。\r\n\r\n``` ts\r\n// 编译不会报错\r\nconst a: any = 6;\r\n\r\na();\r\na.key1 = true;\r\n```\r\n\r\nany 相当于抛弃了类型系统，会让代码变得不可预测和难以维护，需要程序员小心维护，一有不慎会造成运行时的错误，所以尽量少用。\r\n\r\n但在引入一些没有提供类型的第三方纯 JS 库时，还是得将它们标为 any，这个确实没啥办法。\r\n\r\n除非你自己给第三方库写类型声明，但太不现实，因为你不熟悉第三方库的 API，且可能有很复杂的类型推导要实现。\r\n\r\nany 的存在是为了兼容无类型的 JS。TS 作为 JS 的超集，用 any 开后门是不得不做的事情。\r\n\r\n### unknown\r\n\r\nunknown 可以认为是 类型更安全的 any。\r\n\r\n和 any 一样，unknown 也是任何类型的子类型，所有类型都可以传给 unknown，包括 any。\r\n\r\n``` ts\r\n// 编译不会报错\r\nlet a: unknown = '前端西瓜哥';\r\n\r\nlet b: any;\r\na = b;\r\n\r\na = { num: 2 };\r\n```\r\n\r\n说 unknown 更安全，是因为 unknown 是不能进行任何操作的。如果要使用，需要用 as 来进行显式的类型断言。\r\n\r\n``` ts\r\ndeclare const user: known;\r\n\r\n// 报错，unknown 不能被使用\r\nuser.toLowerCase();\r\n\r\n// 开发者认为 user 是个字符串\r\n// 使用 as 进行类型推断才能使用\r\n(user as string).toLowerCase();\r\n```\r\n\r\n或者我们可以用类型收窄（Type Narrowing）；\r\n\r\n```\r\ndeclare const user: unknown;\r\n\r\nif (typeof user === 'string') {\r\n  user.toLowerCase();\r\n}\r\n```\r\n\r\n对于一些可疑的没有类型的变量，如果你不希望它被不小心使用，此时就可以用 unknown。\r\n\r\n总结就是：unknown 能看不能用，想用先类型断言。\r\n\r\n### never\r\nnever 表示一个 无法被观测的类型，被赋予了该类型的变量什么都不能做。\r\n\r\n使用 never 的一些场景。\r\n\r\n#### （1）一个无法走到 return 返回值的函数，比如一定会抛出错误或死循环：\r\n\r\n``` ts\r\n// 这里的 never 表示无法执行到函数返回它的返回值\r\nfunction foo(): never {\r\n  throw new Error('something wrong!')\r\n}\r\n```\r\n\r\n#### （2）TS 在判断条件下会做类型的收窄，当类型收缩到无类型可用，类型就变成了 never：\r\n\r\n``` ts\r\nfunction getData(id: number | string) {\r\n  if (typeof id === 'string') {\r\n    // id 类型变成了 string\r\n  } else if (typeof id === 'number') {\r\n    // id 类型变成了 number\r\n  } else {\r\n    // id 类型变成了 never\r\n  }\r\n}\r\n```\r\n\r\n或者做了一种不可能为 true 的类型收窄：\r\n\r\n``` ts\r\nif (typeof id === 'number' \u0026\u0026 typeof id === 'string') {\r\n  // id 不可能同时是 number 和 string\r\n  // 所以会变成 never\r\n}\r\n```\r\n\r\n或无法求出交集的交叉类型：\r\n\r\n``` ts\r\n// ImpossibleType 会得到 never\r\ntype ImpossibleType = string \u0026 number;\r\n```\r\n\r\n#### （3）类型编程中，在做模式匹配时，如果匹配失败，还是要返回一个类型的。为了表示失败，返回一个 never 表示返回的类型是无法被使用的。\r\n\r\n比如 TS 内置的 Parameters 高级类型，会通过模式匹配提取函数的参数数组类型。如果无法匹配到参数，会返回 never：\r\n\r\n``` ts\r\ntype Parameters\u003cT extends (...args: any) =\u003e any\u003e = T extends (...args: infer P) =\u003e any ? P : never\r\n```\r\n\r\n#### （4）类型编程中，将一些类型丢弃。never 在联合类型以及重映射的 key 中会被丢弃。\r\n\r\n比如 TS 内置的 Exclude 高级类型，会将联合类型 T 中的不属于 U 的 key 丢弃掉。\r\n\r\n``` ts\r\ntype Exclude\u003cT, U\u003e = T extends U ? never : T\r\n\r\ntype T = Exclude\u003c\"a\" | \"b\" | \"c\", \"a\"\u003e;\r\n// T 的类型为 \"b\" | \"c\"\r\n// 其实应该是 never | \"b\" | \"c\"，但 never 无意义，被丢掉了\r\n```\r\n\r\n### void\r\n\r\nvoid 用于表示一个 函数没有返回值。\r\n\r\n``` ts\r\nfunction sayHi(): void {\r\n  console.log('Hi!');\r\n}\r\n```\r\n\r\n当然在实际 JS 运行时，还是会返回一个默认的 undefined 的。但 TS 给返回值设置为 void，语义更好些。\r\n\r\n### 总结\r\n- any 是任意类型，具有所有类型的行为，可被执行，可访问属性，超脱于类型系统之外。\r\n- unknown 则是类型更安全的 any，同样可以将任何类型赋给它，但不能执行任何操作，必须用类型断言来显示说明类型才能去执行操作。\r\n- never 是无法观测的类型，比如不会执行完的函数的返回值，合并结果不存在的交叉类型。在类型编程中非常活跃，常用于丢弃一些子类型。\r\n- void 就比较简单，只是代表函数没有返回值，没有其他的场景了。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/570/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/570/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### any","### unknown","### never","#### （1）一个无法走到 return 返回值的函数，比如一定会抛出错误或死循环：","#### （2）TS 在判断条件下会做类型的收窄，当类型收缩到无类型可用，类型就变成了 never：","#### （3）类型编程中，在做模式匹配时，如果匹配失败，还是要返回一个类型的。为了表示失败，返回一个 never 表示返回的类型是无法被使用的。","#### （4）类型编程中，将一些类型丢弃。never 在联合类型以及重映射的 key 中会被丢弃。","### void","### 总结"]},"__N_SSG":true},"page":"/questions/[id]","query":{"id":"570"},"buildId":"0k7uM9gvhcyBu0gp_2bk9","assetPrefix":"/toolbox-frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>