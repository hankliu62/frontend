<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具集合</title><link rel="icon" href="/toolbox-frontend/favicon.ico"/><meta name="description" content="卡鲁秋的前端工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋"/><meta name="author" content="Hank.Liu"/><meta name="next-head-count" content="7"/><link rel="stylesheet" href="/toolbox-frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/toolbox-frontend/_next/static/css/e443953a41d4ccca.css" as="style"/><link rel="stylesheet" href="/toolbox-frontend/_next/static/css/e443953a41d4ccca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/toolbox-frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/toolbox-frontend/_next/static/chunks/webpack-c5f674d417b86779.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/framework-aec4381329cec0e4.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/main-82d23b26b43cd32b.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/_app-baf3db6f3e140b26.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/6396-e9161609a76be07a.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/8490-2f2be535c5ee8413.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/1664-f865873e77459860.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/2555-3011663e4a0eccc6.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/questions/%5Bid%5D-ab2a432415dd9bf2.js" defer=""></script><script src="/toolbox-frontend/_next/static/0k7uM9gvhcyBu0gp_2bk9/_buildManifest.js" defer=""></script><script src="/toolbox-frontend/_next/static/0k7uM9gvhcyBu0gp_2bk9/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-12jzuas"><div class="ant-card-body"><article><header><h1 class="mb-5 text-4xl font-bold">React Fiber架构中，迭代器和requestIdleCallback结合的优势</h1></header><section class="mb-12 flex items-center space-x-8"><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center group cursor-pointer"><div class="ant-space-item" style="margin-right:8px"><span role="img" aria-label="branches" class="anticon anticon-branches group-hover:text-[#1171ee]"><svg viewBox="64 64 896 896" focusable="false" data-icon="branches" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M740 161c-61.8 0-112 50.2-112 112 0 50.1 33.1 92.6 78.5 106.9v95.9L320 602.4V318.1c44.2-15 76-56.9 76-106.1 0-61.8-50.2-112-112-112s-112 50.2-112 112c0 49.2 31.8 91 76 106.1V706c-44.2 15-76 56.9-76 106.1 0 61.8 50.2 112 112 112s112-50.2 112-112c0-49.2-31.8-91-76-106.1v-27.8l423.5-138.7a50.52 50.52 0 0034.9-48.2V378.2c42.9-15.8 73.6-57 73.6-105.2 0-61.8-50.2-112-112-112zm-504 51a48.01 48.01 0 0196 0 48.01 48.01 0 01-96 0zm96 600a48.01 48.01 0 01-96 0 48.01 48.01 0 0196 0zm408-491a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"></path></svg></span></div><div class="ant-space-item"><span class="group-hover:text-[#1171ee]">#120</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center group cursor-pointer"><div class="ant-space-item"><span class="group-hover:text-sky-500">hankliu62</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center"><div class="ant-space-item"><span class="text-[#8a919f]">2024-02-12 05:35:31</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center"><div class="ant-space-item"><div class="flex items-center justify-start"><span class="ant-tag ant-tag-has-color css-12jzuas" style="background-color:#0052CC">react</span></div></div></div></section><section><div><div class="ant-skeleton ant-skeleton-active css-12jzuas"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-12jzuas"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="### requestIdleCallback API" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/toolbox-frontend/questions/120#requestidlecallback-api"><div class="truncate" style="padding-left:16px">requestIdleCallback API</div></a></li><li id="#### API 介绍" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#api-%E4%BB%8B%E7%BB%8D"><div class="truncate" style="padding-left:32px">API 介绍</div></a></li><li id="#### 浏览器空余时间" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4"><div class="truncate" style="padding-left:32px">浏览器空余时间</div></a></li><li id="#### 应用场景" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><div class="truncate" style="padding-left:32px">应用场景</div></a></li><li id="#### 使用方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:32px">使用方式</div></a></li><li id="#### 功能体验" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#%E5%8A%9F%E8%83%BD%E4%BD%93%E9%AA%8C"><div class="truncate" style="padding-left:32px">功能体验</div></a></li><li id="### Fiber 出现的目的" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#fiber-%E5%87%BA%E7%8E%B0%E7%9A%84%E7%9B%AE%E7%9A%84"><div class="truncate" style="padding-left:16px">Fiber 出现的目的</div></a></li><li id="#### React 16之前的版本存在的问题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#react-16%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:32px">React 16之前的版本存在的问题</div></a></li><li id="### Stack 算法模拟" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#stack-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F"><div class="truncate" style="padding-left:16px">Stack 算法模拟</div></a></li><li id="### React 16 解决方案 - Fiber" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#react-16-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88---fiber"><div class="truncate" style="padding-left:16px">React 16 解决方案 - Fiber</div></a></li><li id="### 实现思路" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><div class="truncate" style="padding-left:16px">实现思路</div></a></li><li id="### 什么是 Fiber" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#%E4%BB%80%E4%B9%88%E6%98%AF-fiber"><div class="truncate" style="padding-left:16px">什么是 Fiber</div></a></li><li id="#### 执行单元" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83"><div class="truncate" style="padding-left:32px">执行单元</div></a></li><li id="#### 数据结构" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/120#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><div class="truncate" style="padding-left:32px">数据结构</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/120","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/120/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/120/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/120/events","html_url":"https://github.com/hankliu62/interview/issues/120","id":2129451809,"node_id":"I_kwDOLNphd85-7Nsh","number":120,"title":"React Fiber架构中，迭代器和requestIdleCallback结合的优势","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468371,"node_id":"LA_kwDOLNphd88AAAABhkJwUw","url":"https://api.github.com/repos/hankliu62/interview/labels/react","name":"react","color":"0052CC","default":false,"description":"React相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-12T05:35:31Z","updated_at":"2024-03-04T14:15:55Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### requestIdleCallback API\r\n\r\nrequestIdleCallback 是浏览器提供的 Web API，它是 React Fiber 中用到的核心 API。\r\n\r\n#### API 介绍\r\n\r\n[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 利用浏览器的空余时间执行任务，如果浏览器没有空余时间，可以随时终止这些任务。\r\n\r\n这样可以实现如果有更高优先级的任务要执行时，当前执行的任务可以被终止，优先执行高级别的任务。\r\n\r\n原理是该方法将 在浏览器的空闲时段内调用的函数 排队。\r\n\r\n这样使得开发者能够在主事件循环上 执行后台和低优先级的任务，而不会影响 像动画和用户交互 这些关键的延迟触发的事件。\r\n\r\n这里的“延迟”指的是大量计算导致运行时间较长。\r\n\r\n#### 浏览器空余时间\r\n\r\n页面是一帧一帧绘制出来的，当每秒绘制的帧数达到 60 时，页面时流畅的，小于这个值时，用户会感觉到卡顿。\r\n\r\n1秒60帧意思是1秒中60张画面在切换。\r\n\r\n当帧数低于人眼的捕捉频率（有说24帧或30帧，考虑到视觉残留现象，这个数值可能会更低）时，人脑会识别这是几张图片在切换，也就是静态的。\r\n\r\n当帧数高于人眼的捕捉频率，人脑会认为画面是连续的，也就是动态的动画。\r\n\r\n帧数越高画面就看起来更流畅。\r\n\r\n1秒60帧（大约 1000/60 ≈ 16ms 切换一个画面）差不多是人眼能识别卡顿的分界线。\r\n\r\n如果每一帧执行的时间小于 16 ms，就说明浏览器有空余时间。\r\n\r\n一帧时间内浏览器要做的事情包括：脚本执行、样式计算、布局、重绘、合成等。\r\n\r\n如果某一项内容执行时间过长，浏览器会推迟渲染，造成丢帧卡顿，就没有剩余时间。\r\n\r\n#### 应用场景\r\n\r\n比如现在有一项计算任务，这项任务需要花费比较长的时间(例如超过16ms）去执行。\r\n\r\n在执行任务的过程当中，浏览器的主线程会被一直占用。\r\n\r\n在主线程被占用的过程中，浏览器是被阻塞的，并不能执行其他的任务。\r\n\r\n如果此时用户想要操作页面，比如向下滑动页面查看其它内容，浏览器是不能响应用户的操作的，给用户的感觉就是页面卡死了，体验非常差。\r\n\r\n**如何解决呢？**\r\n\r\n可以将这项任务注册到 `requestIdleCallback` 中，利用浏览器的空余时间执行它。\r\n\r\n当用户操作页面时，就是**优先级比较高的任务**被执行时，此时计算任务会被终止，优先响应用户的操作，这样用户就不会感觉页面发生卡顿了。\r\n\r\n当高优先级的任务执行完成后，再继续执行计算任务。\r\n\r\n`requestIdleCallback` 的作用就是利用浏览器的空余时间执行这些需要大量计算的任务，当空余时间结束，会中断计算任务，执行高优先级的任务，以达到不阻塞主线程任务（例如浏览器 UI 渲染）的目的。\r\n\r\n#### 使用方式\r\n\r\n``` js\r\nvar handle = window.requestIdleCallback(callback[, options])\r\n```\r\n\r\n- callback：一个在空闲时间即将被调用的回调函数\r\n    - 该函数接收一个形参：IdleDeadline，它提供一个方法和一个属性：\r\n      - 方法：timeRemaining()\r\n        - 用于获取浏览器空闲期的剩余时间，也就是空余时间\r\n          - 返回值是毫秒数\r\n          - 如果闲置期结束，则返回 0\r\n        - 根据时间的多少可以来决定是否要执行任务\r\n      - 属性：didTimeout(Boolean，只读)\r\n        - 表示是否是上一次空闲期因为超时而没有执行的回调函数\r\n        - 超时时间由 requestIdleCallback 的参数options.timeout 定义\r\n- options：可选配置，目前只有一个配置项\r\n    - timeout：超时时间，如果设置了超时时间并超时，回调函数还没有被调用，则会在下一次空闲期强制被调用\r\n\r\n#### 功能体验\r\n\r\n页面中有两个按钮和一个 DIV，点击第一个按钮执行一项昂贵的计算，使其长期占用主线程，当计算任务执行的时候去点击第二个按钮更改页面中 DIV 的背景颜色。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\" /\u003e\r\n    \u003ctitle\u003erequestIdleCallback\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n      #box {\r\n        background: palegoldenrod;\r\n        padding: 20px;\r\n        margin-bottom: 10px;\r\n      }\r\n    \u003c/style\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n    \u003cdiv id=\"box\"\u003eplayground\u003c/div\u003e\r\n    \u003cbutton id=\"btn1\"\u003e执行计算任务\u003c/button\u003e\r\n    \u003cbutton id=\"btn2\"\u003e更改背景颜色\u003c/button\u003e\r\n\r\n    \u003cscript\u003e\r\n      var box = document.querySelector('#box');\r\n      var btn1 = document.querySelector('#btn1');\r\n      var btn2 = document.querySelector('#btn2');\r\n      var number = 100000000;\r\n      var value = 0;\r\n\r\n      function calc() {\r\n        while (number \u003e 0) {\r\n          value = Math.random() \u003c 0.5 ? Math.random() : Math.random();\r\n          number--;\r\n        }\r\n      }\r\n\r\n      btn1.onclick = function () {\r\n        calc();\r\n      }\r\n\r\n      btn2.onclick = function () {\r\n        console.log(number); // 0：计算任务执行完\r\n        box.style.background = 'palegreen';\r\n      }\r\n    \u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n![requestIdleCallback功能体验1](https://user-images.githubusercontent.com/8088864/125783134-1435e780-a620-4cbf-b8c3-c04fccd4b145.png)\r\n\r\n使用 requestIdleCallback可以完美解决这个卡顿问题：\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\" /\u003e\r\n    \u003ctitle\u003erequestIdleCallback\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n      #box {\r\n        background: palegoldenrod;\r\n        padding: 20px;\r\n        margin-bottom: 10px;\r\n      }\r\n    \u003c/style\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n    \u003cdiv id=\"box\"\u003eplayground\u003c/div\u003e\r\n    \u003cbutton id=\"btn1\"\u003e执行计算任务\u003c/button\u003e\r\n    \u003cbutton id=\"btn2\"\u003e更改背景颜色\u003c/button\u003e\r\n\r\n    \u003cscript\u003e\r\n      var box = document.querySelector('#box');\r\n      var btn1 = document.querySelector('#btn1');\r\n      var btn2 = document.querySelector('#btn2');\r\n      var number = 100000000;\r\n      var value = 0;\r\n\r\n      function calc(IdleDeadline) {\r\n        while (number \u003e 0 \u0026\u0026 IdleDeadline.timeRemaining() \u003e 1) {\r\n          value = Math.random() \u003c 0.5 ? Math.random() : Math.random();\r\n          number--;\r\n        }\r\n\r\n        if (number \u003e 0) {\r\n          requestIdleCallback(calc);\r\n        } else {\r\n          console.log('计算结束');\r\n        }\r\n      }\r\n\r\n      btn1.onclick = function () {\r\n        requestIdleCallback(calc);\r\n      }\r\n\r\n      btn2.onclick = function () {\r\n        console.log(number); // 0：计算任务执行完\r\n        box.style.background = 'palegreen';\r\n      }\r\n    \u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n![requestIdleCallback功能体验2](https://user-images.githubusercontent.com/8088864/125783529-12c4da73-fe20-4757-b858-169f381efce4.png)\r\n\r\n- 浏览器在空余时间执行 calc 函数\r\n- 当空余时间小于 1ms 时，跳出while循环\r\n- calc 根据 number 判断计算任务是否执行完成，如果没有完成，则继续注册新的空闲期的任务\r\n- 当 btn2 点击事件触发，会等到当前空闲期任务执行完后执行“更改背景颜色”的任务\r\n- “更改背景颜色”任务执行完成后，继续进入空闲期，执行后面的任务\r\n\r\n由此可见，所谓执行优先级更高的任务，是手动将计算任务拆分到浏览器的空闲期，以实现每次进入空闲期之前优先执行主线程的任务。\r\n\r\n### Fiber 出现的目的\r\n\r\nFiber 其实是 React 16 新的 DOM 比对算法的名字，旧的 DOM 比对算法的名字是 Stack。\r\n\r\n#### React 16之前的版本存在的问题\r\n\r\nReact 16之前的版本对比更新 VirtualDOM 的过程是采用**循环加递归**实现的。\r\n\r\n这种对比方式有一个问题，就是一旦任务开始进行就无法中断（由于递归需要一层一层的进入，一层一层的退出，所以过程不能中断）。\r\n\r\n如果应用中组件数量庞大，主线程被长期占用，直到整棵 VirtualDOM 树对比更新完成之后主线程才能被释放，主线程才能执行其它任务。\r\n\r\n这就会导致一些用户交互、动画等任务无法立即得到执行，页面就会产生卡顿，非常影响用户的体验。\r\n\r\n因为递归利用的 **JavaScript 自身的执行栈**，所以旧版 DOM 比对的算法称为 **Stack(堆栈)**。\r\n\r\n**核心问题：递归无法中断，执行重任务耗时长，JavaScript 又是单线程的，无法同时执行其它任务，导致在绘制页面的过程当中不能执行其它任务，比如元素动画、用户交互等任务必须延后，给用户的感觉就是页面变得卡顿，用户体验差。**\r\n\r\n### Stack 算法模拟\r\n\r\n模拟 React 16 之前将虚拟 DOM 转化成真实 DOM 的递归算法：\r\n\r\n``` jsx\r\n// 要渲染的 jsx\r\nconst jsx = (\r\n  \u003cdiv id=\"a1\"\u003e\r\n    \u003cdiv id=\"b1\"\u003e\r\n      \u003cdiv id=\"c1\"\u003e\u003c/div\u003e\r\n      \u003cdiv id=\"c2\"\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv id=\"b2\"\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n)\r\n```\r\n\r\njsx 会被 Babel 转化成 `React.createElement()` 的调用，最终返回一个虚拟 DOM 对象：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nconst jsx = /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"a1\"\r\n}, /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"b1\"\r\n}, /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"c1\"\r\n}), /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"c2\"\r\n})), /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"b2\"\r\n}));\r\n```\r\n\r\n去掉一些属性，打印结果：\r\n\r\n``` js\r\nconst jsx = {\r\n  type: 'div',\r\n  props: {\r\n    id: 'a1',\r\n    children: [\r\n      {\r\n        type: 'div',\r\n        props: {\r\n          id: 'b1',\r\n          children: [\r\n            {\r\n              type: 'div',\r\n              props: {\r\n                id: 'c1'\r\n              }\r\n            },\r\n            {\r\n              type: 'div',\r\n              props: {\r\n                id: 'c2'\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      {\r\n        type: 'div',\r\n        props: {\r\n          id: 'b2'\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n递归转化真实 DOM：\r\n\r\n``` js\r\nconst jsx = {...}\r\nfunction render(vdom, container) {\r\n  // 创建元素\r\n  const element = document.createElement(vdom.type);\r\n  // 为元素添加属性\r\n  Object.keys(vdom.props)\r\n    .filter(prop =\u003e prop !== 'children')\r\n    .forEach(prop =\u003e (element[prop] = vdom.props[prop]));\r\n  // 递归创建子元素\r\n  if (Array.isArray(vdom.props.children)) {\r\n    vdom.props.children.forEach(child =\u003e render(child, element));\r\n  }\r\n  // 将元素添加到页面中\r\n  container.appendChild(element);\r\n}\r\n\r\nrender(jsx, document.getElementById('root'));\r\n```\r\n\r\nDOM 更新就是在上面递归的过程中加入了 Virtual DOM 对比的过程。\r\n\r\n可以看到递归是无法中断的。\r\n\r\n### React 16 解决方案 - Fiber\r\n\r\n1. 利用浏览器空余时间执行任务，拒绝长时间占用主线程\r\n    - 在新版本的 React 版本中，使用了 requestIdleCallback API\r\n    - 利用浏览器空余时间执行 VirtualDOM 比对任务，也就表示 VirtualDOM 比对不会长期占用主线程\r\n    - 如果有高优先级的任务要执行，就会暂时终止 VirtualDOM 的比对过程，先去执行高优先级的任务\r\n    - 高优先级任务执行完成，再回来继续执行 VirtualDOM 比对任务\r\n    - 这样页面就不会出现卡顿现象\r\n2. 放弃递归，只采用循环，因为循环可以被中断\r\n    - 由于递归必须一层一层进入，一层一层退出，所以过程无法中断\r\n    - 所以要实现任务的终止再继续，就必须放弃递归，只采用循环的方式执行比对的过程\r\n    - 因为循环是可以终止的，只需要将循环的条件保存下来，下一次任务就可以从中断的地方执行了\r\n3. 任务拆分，将任务拆分成一个个的小任务\r\n    - 如果任务要实现终止再继续，任务的单元就必须要小\r\n    - 这样任务即使没有执行完就被终止，重新执行任务的代价就会小很多\r\n    - 所以要进行任务的拆分，将一个大的任务拆分成一个个小的任务\r\n    - VirtualDOM 比对任务如何拆分？\r\n        - 以前将整棵 VirtualDOM 树的比对看作一个任务\r\n        - 现在将树中每一个节点的比对看作一个任务\r\n\r\n新版 React 的解决方案核心就是第 1 点，第 2、3 点都是为了实现第 1 点而存在的，\r\n\r\nFiber 翻译过来是“纤维”，意思就是执行任务的颗粒度变得细腻，像纤维一样。\r\n\r\n可以通过这个 [Demo](https://claudiopro.github.io/react-fiber-vs-stack-demo/) 查看 Stack 算法 和 Fiber 算法的效果区别。\r\n\r\n### 实现思路\r\n\r\n在 Fiber 方案中，为了实现任务的终止再继续，DOM 对比算法被拆分成了两阶段：\r\n\r\n1. render 阶段（可中断）\r\n    - VirtualDOM 的比对，构建 Fiber 对象，构建链表\r\n\r\n2. commit 阶段（不可中断）\r\n    - 根据构建的链表进行 DOM 操作\r\n\r\n过程就是：\r\n\r\n1. 在使用 React 编写用户界面的时候仍然使用 JSX 语法\r\n2. Babel 会将 JSX 语法转换成 `React.createElement()` 方法的调用\r\n3. `React.createElement()` 方法调用后会返回 VirtualDOM 对象\r\n4. 接下来就可以执行第一个阶段了：**构建 Fiber 对象**\r\n    - 采用循环的方式从 VirtualDOM 对象中，找到每一个内部的 VirtualDOM 对象\r\n    - 为每一个 VirtualDOM 对象构建 Fiber 对象\r\n    - Fiber 对象也是 JavaScript 对象，它是从 VirtualDOM 对象衍化来的，它除了 type、props、children以外还存储了更多节点的信息，其中包含的一个核心信息是：当前节点要进行的操作，例如删除、更新、新增\r\n    - 在构建 Fiber 的过程中还要构建链表\r\n5. 接着进行第二阶段的操作：**执行 DOM 操作**\r\n\r\n总结：\r\n\r\n- DOM 初始渲染：`根据 VirtualDOM` --\u003e `创建 Fiber 对象 及 构建链表` --\u003e `将 Fiber 对象存储的操作应用到真实 DOM 中`\r\n- DOM 更新操作：`newFiber(重新获取所有 Fiber 对象)` --\u003e `newFiber vs oldFiber(获取旧的 Fiber 对象，进行比对) 将差异操作追加到链表` --\u003e `将 Fiber 对象应用到真实 DOM 中`\r\n\r\n### 什么是 Fiber\r\n\r\nFiber 有两层含义：\r\n\r\n- Fiber 是一个执行单元\r\n- Fiber 是一种数据结构\r\n\r\n#### 执行单元\r\n\r\n在 React 16 之前，将 Virtual DOM 树整体看成一个任务进行递归处理，任务整体庞大执行耗时且不能中断。\r\n\r\n在 React 16，将整个任务拆分成一个个小的任务进行处理，每个小的任务指的就是一个 Fiber 节点的构建。\r\n\r\n任务会在浏览器的空闲时间被执行，每个单元执行完成后，React 都会检查是否还有空余时间，如果有继续执行下一个人物单元，直到没有空余时间或者所有任务执行完毕，如果没有空余时间就交还主线程的控制权。\r\n\r\n![React Fiber 执行单元流程图](https://user-images.githubusercontent.com/8088864/125878368-317a2c5c-8b16-4877-981c-3883075423bc.png)\r\n\r\n#### 数据结构\r\n\r\nFiber 是一种数据结构，支撑 React 构建任务的运转。\r\n\r\nFiber 其实就是 JavaScript 对象，对象中存储了当前节点的父节点、第一个子节点、下一个兄弟节点，以便在构建链表和执行 DOM 操作的时候知道它们的关系。\r\n\r\n在 render 阶段的时候，React 会从上（root）向下，再从下向上构建所有节点对应的 Fiber 对象，在从下向上的同时还会构建链表，最后将链头存储到 Root Fiber。\r\n\r\n- 从上向下\r\n    - 从 Root 节点开始构建，优先构建子节点\r\n\r\n- 从下向上\r\n    - 如果当前节点没有子节点，就会构建下一个兄弟节点\r\n    - 如果当前节点没有子节点，也没有下一个兄弟节点，就会返回父节点，构建父节点的兄弟节点\r\n    - 如果父节点的下一个兄弟节点有子节点，就继续向下构建\r\n    - 如果父节点没有下一个兄弟节点，就继续向上查找\r\n\r\n在第二阶段的时候，通过链表结构的属性（child、sibling、parent）准确构建出完整的 DOM 节点树，从而才能将 DOM 对象追加到页面当中。\r\n\r\n``` js\r\n// Fiber 对象\r\n{\r\n  type // 节点类型（元素、文本、组件）（具体的类型）\r\n  props // 节点属性（props中包含children属性，标识当前节点的子级 VirtualDOM）\r\n  stateNode // 节点的真实 DOM 对象 | 类组件实例对象 | 函数组件的定义方法\r\n  tag // 节点标记（对具体类型的分类 host_root[顶级节点root] || host_component[普通DOM节点] || class_component[类组件] || function_component[函数组件]）\r\n  effectTag // 当前 Fiber 在 commit 阶段需要被执行的副作用类型/操作（新增、删除、修改）\r\n  nextEffect // 单链表用来快速查找下一个 sideEffect\r\n  lastEffect // 存储最新副作用，用于构建链表的 nextEffect\r\n  firstEffect // 存储第一个要执行的副作用，用于向 root 传递第一个要操作的 DOM\r\n  parent // 当前 Fiber 的父级 Fiber（React 中是 `return`）\r\n  child // 当前 Fiber 的第一个子级 Fiber\r\n  sibling // 当前 Fiber 的下一个兄弟 Fiber\r\n  alternate // 当前节点对应的旧 Fiber 的备份，用于新旧 Fiber 比对\r\n}\r\n```\r\n\r\n以上面的示例为例：\r\n\r\n``` jsx\r\n\u003cdiv id=\"a1\"\u003e\r\n  \u003cdiv id=\"b1\"\u003e\r\n    \u003cdiv id=\"c1\"\u003e\u003c/div\u003e\r\n    \u003cdiv id=\"c2\"\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv id=\"b2\"\u003e\u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n![React Fiber 数据结构](https://user-images.githubusercontent.com/8088864/125878754-89f402ab-cb4b-466a-bef3-c6f20b9e10f8.png)\r\n\r\n``` js\r\n// B1 的 Fiber 对象包含这几个属性：\r\n{\r\n  child: C1_Fiber,\r\n  sibling: B2_Fiber,\r\n  parent: A1_Fiber\r\n}\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/120/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/120/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### requestIdleCallback API","#### API 介绍","#### 浏览器空余时间","#### 应用场景","#### 使用方式","#### 功能体验","### Fiber 出现的目的","#### React 16之前的版本存在的问题","### Stack 算法模拟","### React 16 解决方案 - Fiber","### 实现思路","### 什么是 Fiber","#### 执行单元","#### 数据结构"]},"__N_SSG":true},"page":"/questions/[id]","query":{"id":"120"},"buildId":"0k7uM9gvhcyBu0gp_2bk9","assetPrefix":"/toolbox-frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>