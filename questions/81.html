<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具集合</title><link rel="icon" href="/toolbox-frontend/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="stylesheet" href="/toolbox-frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/toolbox-frontend/_next/static/css/51d8a56149ba6279.css" as="style"/><link rel="stylesheet" href="/toolbox-frontend/_next/static/css/51d8a56149ba6279.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/toolbox-frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/toolbox-frontend/_next/static/chunks/webpack-d8c74d555dfcd83e.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/framework-aec4381329cec0e4.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/main-82d23b26b43cd32b.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/_app-de65346d7a9879b5.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/6323-cb9a5af06cb8b62c.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/9220-ed2c3d046b64293b.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/3768-7808c15c6cbd96b7.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/9691-52831ba1a45a37ee.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/8652-7937a7ee3ed74ad6.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/1664-f865873e77459860.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/399-ba166b0f61c90e3f.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/questions/%5Bid%5D-c4badb3c79061c73.js" defer=""></script><script src="/toolbox-frontend/_next/static/PexJpVasDScDlKmlFjm0T/_buildManifest.js" defer=""></script><script src="/toolbox-frontend/_next/static/PexJpVasDScDlKmlFjm0T/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-12jzuas"><div class="ant-card-body"><article><header><h1 class="mb-5 text-4xl font-bold">Fetch API使用的常见问题及其解决办法</h1></header><section class="mb-12 flex items-center space-x-8"><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center group cursor-pointer"><div class="ant-space-item" style="margin-right:8px"><span role="img" aria-label="branches" class="anticon anticon-branches group-hover:text-[#1171ee]"><svg viewBox="64 64 896 896" focusable="false" data-icon="branches" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M740 161c-61.8 0-112 50.2-112 112 0 50.1 33.1 92.6 78.5 106.9v95.9L320 602.4V318.1c44.2-15 76-56.9 76-106.1 0-61.8-50.2-112-112-112s-112 50.2-112 112c0 49.2 31.8 91 76 106.1V706c-44.2 15-76 56.9-76 106.1 0 61.8 50.2 112 112 112s112-50.2 112-112c0-49.2-31.8-91-76-106.1v-27.8l423.5-138.7a50.52 50.52 0 0034.9-48.2V378.2c42.9-15.8 73.6-57 73.6-105.2 0-61.8-50.2-112-112-112zm-504 51a48.01 48.01 0 0196 0 48.01 48.01 0 01-96 0zm96 600a48.01 48.01 0 01-96 0 48.01 48.01 0 0196 0zm408-491a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"></path></svg></span></div><div class="ant-space-item"><span class="group-hover:text-[#1171ee]">#81</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center group cursor-pointer"><div class="ant-space-item"><span class="group-hover:text-sky-500">hankliu62</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center"><div class="ant-space-item"><span class="text-[#8a919f]">2024-02-07 03:39:12</span></div></div><div class="ant-space css-12jzuas ant-space-horizontal ant-space-align-center"><div class="ant-space-item"><div class="flex items-center justify-start"><span class="ant-tag ant-tag-has-color css-12jzuas" style="background-color:#722ed1">interview questions</span><span class="ant-tag ant-tag-has-color css-12jzuas" style="background-color:#383040">javascript</span></div></div></div></section><section><div class="ant-skeleton ant-skeleton-active css-12jzuas"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-12jzuas"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[520px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="### Fetch 兼容性问题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/toolbox-frontend/questions/81#fetch-%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:16px">Fetch 兼容性问题</div></a></li><li id="### fetch默认不携带cookie" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/81#fetch%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%90%BA%E5%B8%A6cookie"><div class="truncate" style="padding-left:16px">fetch默认不携带cookie</div></a></li><li id="### fetch请求对某些错误http状态不会reject" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/81#fetch%E8%AF%B7%E6%B1%82%E5%AF%B9%E6%9F%90%E4%BA%9B%E9%94%99%E8%AF%AFhttp%E7%8A%B6%E6%80%81%E4%B8%8D%E4%BC%9Areject"><div class="truncate" style="padding-left:16px">fetch请求对某些错误http状态不会reject</div></a></li><li id="### fetch不支持超时timeout处理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/81#fetch%E4%B8%8D%E6%94%AF%E6%8C%81%E8%B6%85%E6%97%B6timeout%E5%A4%84%E7%90%86"><div class="truncate" style="padding-left:16px">fetch不支持超时timeout处理</div></a></li><li id="### fetch不支持JSONP" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/81#fetch%E4%B8%8D%E6%94%AF%E6%8C%81jsonp"><div class="truncate" style="padding-left:16px">fetch不支持JSONP</div></a></li><li id="### fetch不支持progress事件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/81#fetch%E4%B8%8D%E6%94%AF%E6%8C%81progress%E4%BA%8B%E4%BB%B6"><div class="truncate" style="padding-left:16px">fetch不支持progress事件</div></a></li><li id="### fetch跨域问题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/questions/81#fetch%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:16px">fetch跨域问题</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/81","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/81/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/81/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/81/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/81","id":2122120468,"node_id":"I_kwDOBiJZIc5-fP0U","number":81,"title":"Fetch API使用的常见问题及其解决办法","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6527252877,"node_id":"LA_kwDOBiJZIc8AAAABhQ35jQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview%20questions","name":"interview questions","color":"722ed1","default":false,"description":"面试题"},{"id":6536118829,"node_id":"LA_kwDOBiJZIc8AAAABhZVCLQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/javascript","name":"javascript","color":"383040","default":false,"description":"面试题-Javascript相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-07T03:39:12Z","updated_at":"2024-02-09T08:31:28Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"XMLHttpRequest在发送web请求时需要开发者配置相关请求信息和成功后的回调，尽管开发者只关心请求成功后的业务处理，但是也要配置其他繁琐内容，导致配置和调用比较混乱，也不符合关注分离的原则；fetch的出现正是为了解决XHR存在的这些问题。\r\n\r\n**fetch是基于Promise设计的**，让开发者只关注请求成功后的业务逻辑处理，其他的不用关心，相当简单，FetchAPI的优点如下:\r\n\r\n- 语法简单，更加语义化\r\n- 基于标准的Promise实现，支持async/await\r\n- 使用isomorphic-fetch可以方便同构\r\n\r\n使用fetch来进行项目开发时，也是有一些常见问题的，下面就来说说fetch使用的常见问题。\r\n\r\n### Fetch 兼容性问题\r\n\r\nfetch是相对较新的技术，当然就会存在浏览器兼容性的问题，借用上面应用文章的一幅图加以说明fetch在各种浏览器的原生支持情况：\r\n\r\n![Fetch兼容性](https://user-images.githubusercontent.com/8088864/125045722-e03edb80-e0cf-11eb-9457-f56b13350846.png)\r\n\r\n从上图可以看出各个浏览器的低版本都不支持fetch技术。\r\n\r\n如何在所有浏览器中通用fetch呢，当然就要考虑fetch的polyfill了。\r\n\r\nfetch是基于Promise来实现的，所以在低版本浏览器中Promise可能也未被原生支持，所以还需要Promise的polyfill；大多数情况下，实现fetch的polyfill需要涉及到的：\r\n\r\n- promise的polyfill，例如es6-promise、babel-polyfill提供的promise实现。\r\n- fetch的polyfill实现，例如isomorphic-fetch和whatwg-fetch\r\n\r\nIE浏览器中IE8/9还比较特殊：IE8它使用的是ES3，而IE9则对ES5部分支持。这种情况下还需要ES5的polyfill es5-shim支持了。\r\n\r\n上述有关promise的polyfill实现，需要说明的是：\r\n\r\nbabel-runtime是不能作为Promise的polyfill的实现的，否则在IE8/9下使用fetch会报Promise未定义。为什么？我想大家猜到了，因为babel-runtime实现的polyfill是局部实现而不是全局实现，fetch底层实现用到Promise就是从全局中去取的，拿不到这报上述错误。\r\n\r\nfetch的polyfill实现思路:\r\n\r\n首先判断浏览器是否原生支持fetch，否则结合Promise使用XMLHttpRequest的方式来实现；这正是whatwg-fetch的实现思路，而同构应用中使用的isomorphic-fetch，其客户端fetch的实现是直接require(\"whatwg-fetch\")来实现的。\r\n\r\n### fetch默认不携带cookie\r\n\r\nfetch发送请求默认是不发送cookie的，不管是同域还是跨域；\r\n\r\n对于那些需要权限验证的请求就可能无法正常获取数据，可以配置其credentials项，其有3个值：\r\n\r\n- omit: 默认值，忽略cookie的发送\r\n- same-origin: 表示cookie只能同域发送，不能跨域发送\r\n- include: cookie既可以同域发送，也可以跨域发送\r\n\r\ncredentials所表达的含义，其实与XHR2中的withCredentials属性类似，表示请求是否携带cookie；\r\n\r\n若要fetch请求携带cookie信息，只需设置一下credentials选项即可，例如fetch(url, {credentials: 'include'});\r\n\r\nfetch默认对服务端通过Set-Cookie头设置的cookie也会忽略，若想选择接受来自服务端的cookie信息，也必须要配置credentials选项；\r\n\r\n### fetch请求对某些错误http状态不会reject\r\n\r\n主要是由fetch返回promise导致的，因为fetch返回的promise在某些错误的http状态下如400、500等不会reject，相反它会被resolve；只有网络错误会导致请求不能完成时，fetch 才会被 reject；所以一般会对fetch请求做一层封装。\r\n\r\n``` js\r\nfunction checkStatus(response) {\r\n  if (response.status \u003e= 200 \u0026\u0026 response.status \u003c 300) {\r\n    return response;\r\n  }\r\n  const error = new Error(response.statusText);\r\n  error.response = response;\r\n  throw error;\r\n}\r\n\r\nfunction parseJSON(response) {\r\n  return response.json();\r\n}\r\n\r\nexport default function request(url, options = {}) {\r\n  return fetch(url, { credentials: 'include', ...options })\r\n    .then(checkStatus)\r\n    .then(parseJSON)\r\n    .then((data) =\u003e data)\r\n    .catch((err) =\u003e err);\r\n}\r\n```\r\n\r\n### fetch不支持超时timeout处理\r\n\r\nfetch不像大多数ajax库那样对请求设置超时timeout，它没有有关请求超时的功能，所以在fetch标准添加超时功能之前，都需要polyfill该特性。\r\n\r\n实际上，我们真正需要的是abort()， timeout可以通过timeout+abort方式来实现，起到真正超时丢弃当前的请求。\r\n\r\n目前的fetch指导规范中，fetch并不是一个具体实例，而只是一个方法；其返回的promise实例根据Promise指导规范标准是不能abort的，也不能手动改变promise实例的状态，只能由内部来根据请求结果来改变promise的状态。\r\n\r\n实现fetch的timeout功能，其思想就是新创建一个可以手动控制promise状态的实例，根据不同情况来对新promise实例进行resolve或者reject，从而达到实现timeout的功能；\r\n\r\n根据github上[timeout handling](https://github.com/github/fetch/issues/175)上的讨论，目前可以有两种不同的解决方法：\r\n\r\n方法一: 单纯setTimeout方法\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  return new Promise(function(resolve, reject) {\r\n    var timerId;\r\n    if (options.timeout) {\r\n      timerId = setTimeout(function() {\r\n        reject(new Error('fetch timeout'));\r\n      }, options.timeout);\r\n    }\r\n\r\n    fetchOrigin(url, option).then(function(response) {\r\n      timerId \u0026\u0026 clearTimeout(timerId);\r\n      resolve(response);\r\n    }, function(error) {\r\n      timerId \u0026\u0026 clearTimeout(timerId);\r\n      reject(error);\r\n    });\r\n  });\r\n}\r\n```\r\n\r\n使用这种方式还可模拟XHR的abort方法\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  return new Promise(function(resolve, reject) {\r\n    var abort = function() {\r\n      reject(new Error('fetch abort'));\r\n    };\r\n\r\n    const p = fetchOrigin(url, option).then(resolve, reject);\r\n    p.abort = abort;\r\n\r\n    return p;\r\n  });\r\n}\r\n```\r\n\r\n方法二: 利用Promise.race方法\r\n\r\nPromise.race方法接受一个promise实例数组参数，表示多个promise实例中任何一个最先改变状态，那么race方法返回的promise实例状态就跟着改变\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  var abortFn = null;\r\n  var timeoutFn = null;\r\n\r\n  var timeoutPromise = new Promise(function(resolve, reject) {\r\n    timeoutFn = function () {\r\n      reject(new Error('fetch timeout'));\r\n    }\r\n  });\r\n\r\n  var abortPromise = new Promise(function(resolve, reject) {\r\n    abortFn = function () {\r\n      reject(new Error('fetch abort'));\r\n    }\r\n  });\r\n\r\n  const fetchPromise = fetchOrigin(url, option);\r\n\r\n  if (option.timeout) {\r\n    setTimeout(timeoutFn, option.timeout);\r\n  }\r\n\r\n  const promise = Promise.race(\r\n    timeoutPromise,\r\n    abortPromise,\r\n    fetchPromise,\r\n  );\r\n\r\n  promise.abort = abortFn;\r\n\r\n  return promise;\r\n}\r\n```\r\n\r\n对fetch的timeout的上述实现方式补充几点：\r\n\r\n- timeout不是请求连接超时的含义，它表示发送请求到接收响应的时间，包括请求的连接、服务器处理及服务器响应回来的时间。\r\n- fetch的timeout即使超时发生了，本次请求也不会被abort丢弃掉，它在后台仍然会发送到服务器端，只是本次请求的响应内容被丢弃而已。\r\n\r\n### fetch不支持JSONP\r\n\r\nfetch是与服务器端进行异步交互的，而JSONP是外链一个javascript资源，是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题，并不是真正ajax，所以fetch与JSONP没有什么直接关联，当然至少目前是不支持JSONP的。\r\n\r\n这里我们把JSONP与fetch关联在一起有点差强人意，fetch只是一个ajax库，我们不可能使fetch支持JSONP；只是我们要实现一个JSONP，只不过这个JSONP的实现要与fetch的实现类似，即基于Promise来实现一个JSONP；而其外在表现给人感觉是fetch支持JSONP一样；\r\n\r\n目前比较成熟的开源JSONP实现[fetch-jsonp](https://github.com/camsong/fetch-jsonp)给我们提供了解决方案，想了解可以自行前往。不过再次想唠叨一下其JSONP的实现步骤，因为在本人面试的前端候选人中大部分人对JSONP的实现语焉不详；\r\n\r\n使用它非常简单，首先需要用npm安装fetch-jsonp\r\n\r\n``` shell\r\nnpm install fetch-jsonp --save-dev\r\n```\r\n\r\nfetch-jsonp源码如下所示:\r\n\r\n``` js\r\nconst defaultOptions = {\r\n  timeout: 5000,\r\n  jsonpCallback: 'callback',\r\n  jsonpCallbackFunction: null,\r\n};\r\n\r\nfunction generateCallbackFunction() {\r\n  return `jsonp_${Date.now()}_${Math.ceil(Math.random() * 100000)}`;\r\n}\r\n\r\nfunction clearFunction(functionName) {\r\n  // IE8 throws an exception when you try to delete a property on window\r\n  // http://stackoverflow.com/a/1824228/751089\r\n  try {\r\n    delete window[functionName];\r\n  } catch (e) {\r\n    window[functionName] = undefined;\r\n  }\r\n}\r\n\r\nfunction removeScript(scriptId) {\r\n  const script = document.getElementById(scriptId);\r\n  if (script) {\r\n    document.getElementsByTagName('head')[0].removeChild(script);\r\n  }\r\n}\r\n\r\nfunction fetchJsonp(_url, options = {}) {\r\n  // to avoid param reassign\r\n  let url = _url;\r\n  const timeout = options.timeout || defaultOptions.timeout;\r\n  const jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;\r\n\r\n  let timeoutId;\r\n\r\n  return new Promise((resolve, reject) =\u003e {\r\n    const callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();\r\n    const scriptId = `${jsonpCallback}_${callbackFunction}`;\r\n\r\n    window[callbackFunction] = (response) =\u003e {\r\n      resolve({\r\n        ok: true,\r\n        // keep consistent with fetch API\r\n        json: () =\u003e Promise.resolve(response),\r\n      });\r\n\r\n      if (timeoutId) clearTimeout(timeoutId);\r\n\r\n      removeScript(scriptId);\r\n\r\n      clearFunction(callbackFunction);\r\n    };\r\n\r\n    // Check if the user set their own params, and if not add a ? to start a list of params\r\n    url += (url.indexOf('?') === -1) ? '?' : '\u0026';\r\n\r\n    const jsonpScript = document.createElement('script');\r\n    jsonpScript.setAttribute('src', `${url}${jsonpCallback}=${callbackFunction}`);\r\n    if (options.charset) {\r\n      jsonpScript.setAttribute('charset', options.charset);\r\n    }\r\n    jsonpScript.id = scriptId;\r\n    document.getElementsByTagName('head')[0].appendChild(jsonpScript);\r\n\r\n    timeoutId = setTimeout(() =\u003e {\r\n      reject(new Error(`JSONP request to ${_url} timed out`));\r\n\r\n      removeScript(scriptId);\r\n\r\n      clearFunction(callbackFunction);\r\n\r\n      // 当前超时，请求并没有丢弃，请求完成的时候还是会调用该方法，如果直接干掉，会报错，修改函数体，回调过来时删除从全局上删除该函数\r\n      window[callbackFunction] = () =\u003e {\r\n        clearFunction(callbackFunction);\r\n      };\r\n    }, timeout);\r\n\r\n    // Caught if got 404/500\r\n    jsonpScript.onerror = () =\u003e {\r\n      reject(new Error(`JSONP request to ${_url} failed`));\r\n\r\n      clearFunction(callbackFunction);\r\n      removeScript(scriptId);\r\n      if (timeoutId) clearTimeout(timeoutId);\r\n    };\r\n  });\r\n}\r\n\r\nexport default fetchJsonp;\r\n```\r\n\r\n具体的使用方式:\r\n\r\n``` js\r\nfetchJsonp('/users.jsonp', {\r\n  timeout: 3000,\r\n  jsonpCallback: 'custom_callback'\r\n})\r\n.then(function(response) {\r\n  return response.json()\r\n}).catch(function(ex) {\r\n  console.log('parsing failed', ex)\r\n});\r\n```\r\n\r\n### fetch不支持progress事件\r\n\r\nXHR是原生支持progress事件的，例如下面代码这样：\r\n\r\n``` js\r\nvar xhr = new XMLHttpRequest();\r\nxhr.open('POST', '/uploads');\r\nxhr.onload = function() {}\r\nxhr.onerror = function() {}\r\nvar uploadProgress = function(event) {\r\n  if (event.lengthComputable) {\r\n    var percent = Math.round((event.loaded / event.total) * 100);\r\n    console.log(percent);\r\n  }\r\n};\r\n\r\n// 上传的progress事件\r\nxhr.upload.onprogress = uploadProgress;\r\n// 下载的progress事件\r\nxhr.onprogress = uploadProgress;\r\n```\r\n\r\n但是fetch是不支持有关progress事件的；不过可喜的是，根据fetch的指导规范标准，其内部设计实现了Request和Response类；其中Response封装一些方法和属性，通过Response实例可以访问这些方法和属性，例如response.json()、response.body等等；\r\n\r\n值得关注的地方是，response.body是一个可读字节流对象，其实现了一个getRender()方法，其具体作用是：\r\n\r\ngetRender()方法用于读取响应的原始字节流，该字节流是可以循环读取的，直至body内容传输完成；\r\n\r\n因此，利用到这点可以模拟出fetch的progress。\r\n\r\n代码实现如下:\r\n\r\n``` js\r\n// fetch() returns a promise that resolves once headers have been received\r\nfetch(url).then(response =\u003e {\r\n  // response.body is a readable stream.\r\n  // Calling getReader() gives us exclusive access to the stream's content\r\n  var reader = response.body.getReader();\r\n  var bytesReceived = 0;\r\n\r\n  // read() returns a promise that resolves when a value has been received\r\n  reader.read().then(function processResult(result) {\r\n    // Result objects contain two properties:\r\n    // done  - true if the stream has already given you all its data.\r\n    // value - some data. Always undefined when done is true.\r\n    if (result.done) {\r\n      console.log(\"Fetch complete\");\r\n      return;\r\n    }\r\n\r\n    // result.value for fetch streams is a Uint8Array\r\n    bytesReceived += result.value.length;\r\n    console.log('Received', bytesReceived, 'bytes of data so far');\r\n\r\n    // Read some more, and call this function again\r\n    return reader.read().then(processResult);\r\n  });\r\n});\r\n```\r\n\r\ngithub上也有使用Promise+XHR结合的方式实现类fetch的progress效果(当然这跟fetch完全不搭边）可以参考[这里](https://github.com/github/fetch/issues/89#issuecomment-256610849)，具体代码如下：\r\n\r\n``` js\r\nfunction fetchProgress(url, opts={}, onProgress) {\r\n  return new Promise((resolve, reject)=\u003e{\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(opts.method || 'get', url);\r\n\r\n    for (var key in opts.headers||{}) {\r\n      xhr.setRequestHeader(key, opts.headers[key]);\r\n    }\r\n\r\n    xhr.onload = function(event) {\r\n      resolve(e.target.responseText)\r\n    };\r\n\r\n    xhr.onerror = reject;\r\n\r\n    if (xhr.upload \u0026\u0026 onProgress) {\r\n      xhr.upload.onprogress = onProgress; // event.loaded / event.total * 100 ; //event.lengthComputable\r\n    }\r\n\r\n    xhr.send(opts.body);\r\n  });\r\n}\r\n\r\nfetchProgress('/').then(console.log)\r\n```\r\n\r\n### fetch跨域问题\r\n\r\n既然是ajax库，就不可避免与跨域扯上关系；XHR2是支持跨域请求的，只不过要满足浏览器端支持CORS，服务器通过Access-Control-Allow-Origin来允许指定的源进行跨域，仅此一种方式。\r\n\r\n与XHR2一样，fetch也是支持跨域请求的，只不过其跨域请求做法与XHR2一样，需要客户端与服务端支持；另外，fetch还支持一种跨域，不需要服务器支持的形式，具体可以通过其mode的配置项来说明。\r\n\r\nfetch的mode配置项有3个值，如下：\r\n\r\n- same-origin：该模式是不允许跨域的，它需要遵守同源策略，否则浏览器会返回一个error告知不能跨域；其对应的response type为basic。\r\n- cors: 该模式支持跨域请求，顾名思义它是以CORS的形式跨域；当然该模式也可以同域请求不需要后端额外的CORS支持；其对应的response type为cors。\r\n- no-cors: 该模式用于跨域请求但是服务器不带CORS响应头，也就是服务端不支持CORS；这也是fetch的特殊跨域请求方式；其对应的response type为opaque。\r\n\r\n针对跨域请求，cors模式是常见跨域请求实现，但是fetch自带的no-cors跨域请求模式则较为陌生，该模式有一个比较明显的特点：\r\n\r\n该模式允许浏览器发送本次跨域请求，但是不能访问响应返回的内容，这也是其response type为opaque不透明的原因。\r\n\r\n这与\u003cimg \\/\u003e发送的请求类似，只是该模式不能访问响应的内容信息；但是它可以被其他APIs进行处理，例如ServiceWorker。另外，该模式返回的response可以在Cache API中被存储起来以便后续的对它的使用，这点对script、css和图片的CDN资源是非常合适的，因为这些资源响应头中都没有CORS头。\r\n\r\n总的来说，fetch的跨域请求是使用CORS方式，需要浏览器和服务端的支持。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/81/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/81/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### Fetch 兼容性问题","### fetch默认不携带cookie","### fetch请求对某些错误http状态不会reject","### fetch不支持超时timeout处理","### fetch不支持JSONP","### fetch不支持progress事件","### fetch跨域问题"]},"__N_SSG":true},"page":"/questions/[id]","query":{"id":"81"},"buildId":"PexJpVasDScDlKmlFjm0T","assetPrefix":"/toolbox-frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>