<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>前端小技术集合 - H.L Frontend</title><link rel="icon" href="/frontend/favicon.ico"/><meta name="description" content="H.L Frontend，前端技术和工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋,Hank,HankLiu"/><meta name="author" content="Hank.Liu"/><meta name="copyright" content="卡鲁秋"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="/frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/frontend/_next/static/css/48e12760546808a2.css" as="style"/><link rel="stylesheet" href="/frontend/_next/static/css/48e12760546808a2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/frontend/_next/static/chunks/webpack-eb44c437bf7e459b.js" defer=""></script><script src="/frontend/_next/static/chunks/framework-0e8d27528ba61906.js" defer=""></script><script src="/frontend/_next/static/chunks/main-d236bc00457e5dc2.js" defer=""></script><script src="/frontend/_next/static/chunks/pages/_app-d90534c1986642b8.js" defer=""></script><script src="/frontend/_next/static/chunks/5367-33ed0c98355cb6dc.js" defer=""></script><script src="/frontend/_next/static/chunks/4853-4e02ebf21637e379.js" defer=""></script><script src="/frontend/_next/static/chunks/3239-4699acf95684b42e.js" defer=""></script><script src="/frontend/_next/static/chunks/1664-e769dc1505626ddd.js" defer=""></script><script src="/frontend/_next/static/chunks/418-4f5393ca512af857.js" defer=""></script><script src="/frontend/_next/static/chunks/7202-08c1445bfc3a1826.js" defer=""></script><script src="/frontend/_next/static/chunks/pages/questions/%5Bid%5D-41ea2e32e7cffd3d.js" defer=""></script><script src="/frontend/_next/static/sU2iERWyzsgD586oQgu3i/_buildManifest.js" defer=""></script><script src="/frontend/_next/static/sU2iERWyzsgD586oQgu3i/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-1okl62o"><div class="ant-card-body"><article><header><h1 class="mb-5 text-4xl font-bold">JavaScript</h1></header><section class="mb-12 flex items-center space-x-8"><div class="ant-space css-1okl62o ant-space-horizontal ant-space-align-center ant-space-gap-row-small ant-space-gap-col-small group cursor-pointer"><div class="ant-space-item"><span role="img" aria-label="branches" class="anticon anticon-branches group-hover:text-[#1171ee]"><svg viewBox="64 64 896 896" focusable="false" data-icon="branches" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M740 161c-61.8 0-112 50.2-112 112 0 50.1 33.1 92.6 78.5 106.9v95.9L320 602.4V318.1c44.2-15 76-56.9 76-106.1 0-61.8-50.2-112-112-112s-112 50.2-112 112c0 49.2 31.8 91 76 106.1V706c-44.2 15-76 56.9-76 106.1 0 61.8 50.2 112 112 112s112-50.2 112-112c0-49.2-31.8-91-76-106.1v-27.8l423.5-138.7a50.52 50.52 0 0034.9-48.2V378.2c42.9-15.8 73.6-57 73.6-105.2 0-61.8-50.2-112-112-112zm-504 51a48.01 48.01 0 0196 0 48.01 48.01 0 01-96 0zm96 600a48.01 48.01 0 01-96 0 48.01 48.01 0 0196 0zm408-491a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"></path></svg></span></div><div class="ant-space-item"><span class="group-hover:text-[#1171ee]">#234</span></div></div><div class="ant-space css-1okl62o ant-space-horizontal ant-space-align-center ant-space-gap-row-small ant-space-gap-col-small group cursor-pointer"><div class="ant-space-item"><span class="group-hover:text-sky-500">hankliu62</span></div></div><div class="ant-space css-1okl62o ant-space-horizontal ant-space-align-center ant-space-gap-row-small ant-space-gap-col-small"><div class="ant-space-item"><span class="text-[#8a919f]">2024-02-12 06:40:21</span></div></div><div class="ant-space css-1okl62o ant-space-horizontal ant-space-align-center ant-space-gap-row-small ant-space-gap-col-small"><div class="ant-space-item"><div class="flex items-center justify-start"><span class="ant-tag ant-tag-has-color css-1okl62o" style="background-color:#383040">javascript</span></div></div></div><div class="ant-space css-1okl62o ant-space-horizontal ant-space-align-center ant-space-gap-row-small ant-space-gap-col-small"><div class="ant-space-item"><ul class="ant-rate css-1okl62o ant-rate-disabled" tabindex="-1" role="radiogroup"><li class="ant-rate-star ant-rate-star-zero"><div role="radio" aria-checked="false" aria-posinset="1" aria-setsize="5" tabindex="-1"><div class="ant-rate-star-first"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div><div class="ant-rate-star-second"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div></div></li><li class="ant-rate-star ant-rate-star-zero"><div role="radio" aria-checked="false" aria-posinset="2" aria-setsize="5" tabindex="-1"><div class="ant-rate-star-first"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div><div class="ant-rate-star-second"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div></div></li><li class="ant-rate-star ant-rate-star-zero"><div role="radio" aria-checked="false" aria-posinset="3" aria-setsize="5" tabindex="-1"><div class="ant-rate-star-first"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div><div class="ant-rate-star-second"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div></div></li><li class="ant-rate-star ant-rate-star-zero"><div role="radio" aria-checked="false" aria-posinset="4" aria-setsize="5" tabindex="-1"><div class="ant-rate-star-first"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div><div class="ant-rate-star-second"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div></div></li><li class="ant-rate-star ant-rate-star-zero"><div role="radio" aria-checked="false" aria-posinset="5" aria-setsize="5" tabindex="-1"><div class="ant-rate-star-first"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div><div class="ant-rate-star-second"><span role="img" aria-label="star" class="anticon anticon-star"><svg viewBox="64 64 896 896" focusable="false" data-icon="star" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z"></path></svg></span></div></div></li></ul></div></div></section><section><div><div class="ant-skeleton ant-skeleton-active css-1okl62o"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-1okl62o"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/234","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/234/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/234/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/234/events","html_url":"https://github.com/hankliu62/interview/issues/234","id":2129511477,"node_id":"I_kwDOLNphd85-7cQ1","number":234,"title":"JavaScript","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468110,"node_id":"LA_kwDOLNphd88AAAABhkJvTg","url":"https://api.github.com/repos/hankliu62/interview/labels/javascript","name":"javascript","color":"383040","default":false,"description":"Javascript相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-12T06:40:21Z","updated_at":"2024-04-01T17:58:59Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"**JavaScript的组成**\r\n\r\n- JavaScript 由以下三部分组成：\r\n    - ECMAScript（核心）：JavaScript 语言基础\r\n    - DOM（文档对象模型）：规定了访问HTML和XML的接口\r\n    - BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法\r\n\r\n**JS的基本数据类型和引用数据类型**\r\n\r\n- 基本数据类型：undefined、null、boolean、number、string、symbol\r\n- 引用数据类型：object、array、function\r\n\r\n**检测浏览器版本版本有哪些方式？**\r\n- 根据 navigator.userAgent   //  UA.toLowerCase().indexOf('chrome')\r\n- 根据 window 对象的成员       // 'ActiveXObject' in window\r\n\r\n**介绍JS有哪些内置对象？**\r\n\r\n- 数据封装类对象：Object、Array、Boolean、Number、String\r\n- 其他对象：Function、Arguments、Math、Date、RegExp、Error\r\n- ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect\r\n\r\n**说几条写JavaScript的基本规范？**\r\n\r\n- 代码缩进，建议使用“四个空格”缩进\r\n- 代码段使用花括号{}包裹\r\n- 语句结束使用分号;\r\n- 变量和函数在使用前进行声明\r\n- 以大写字母开头命名构造函数，全大写命名常量\r\n- 规范定义JSON对象，补全双引号\r\n- 用{}和[]声明对象和数组\r\n\r\n**如何编写高性能的JavaScript？**\r\n\r\n* 遵循严格模式：\"use strict\";\r\n* 将js脚本放在页面底部，加快渲染页面\r\n* 将js脚本将脚本成组打包，减少请求\r\n* 使用非阻塞方式下载js脚本\r\n* 尽量使用局部变量来保存全局变量\r\n* 尽量减少使用闭包\r\n* 使用 window 对象属性方法时，省略 window\r\n* 尽量减少对象成员嵌套\r\n* 缓存 DOM 节点的访问\r\n* 通过避免使用 eval() 和 Function() 构造器\r\n* 给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数\r\n* 尽量使用直接量创建对象和数组\r\n* 最小化重绘(repaint)和回流(reflow)\r\n\r\n\r\n**描述浏览器的渲染过程，DOM树和渲染树的区别？**\r\n\r\n- 浏览器的渲染过程：\r\n  - 解析HTML构建 DOM(DOM树)，并行请求 css/image/js\r\n  - CSS 文件下载完成，开始构建 CSSOM(CSS树)\r\n  - CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)\r\n  - 布局(Layout)：计算出每个节点在屏幕中的位置\r\n  - 显示(Painting)：通过显卡把页面画到屏幕上\r\n\r\n- DOM树 和 渲染树 的区别：\r\n  - DOM树与HTML标签一一对应，包括head和隐藏元素\r\n  - 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性\r\n\r\n**重绘和回流（重排）的区别和关系？**\r\n\r\n- 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘\r\n- 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流\r\n- 注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值\r\n- 回流必将引起重绘，而重绘不一定会引起回流\r\n\r\n\r\n**如何最小化重绘(repaint)和回流(reflow)？**\r\n\r\n- 需要要对元素进行复杂的操作时，可以先隐藏(display:\"none\")，操作完成后再显示\r\n- 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document\r\n- 缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流\r\n- 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）\r\n- 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）\r\n- 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color\r\n- 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx\r\n\r\n**script 的位置是否会影响首屏显示时间？**\r\n\r\n- 在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。\r\n- 浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则\r\n- 因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间\r\n\r\n**解释JavaScript中的作用域与变量声明提升？**\r\n\r\n在JavaScript中，作用域（Scope）是一个非常重要的概念，它决定了变量、函数和对象的可访问性。作用域定义了变量和函数的可访问范围，以及它们的生命周期。\r\n\r\n在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域；\r\n\r\nJavaScript中有两种主要的作用域类型：全局作用域和局部作用域。\r\n\r\n1. **全局作用域**：在代码的任何位置都可以访问全局作用域中的变量和函数。当你在代码的任何地方声明一个变量或函数，而没有使用任何函数或块级作用域时，它们就位于全局作用域中。\r\n2. **局部作用域**：局部作用域通常是在函数或块（如if语句或循环）内部声明的变量或函数的范围。这些变量和函数只能在声明它们的函数或块内部访问。\r\n    - **函数作用域**：在函数内部声明的变量和函数具有函数作用域。这些变量和函数只能在该函数内部访问。\r\n    - **块级作用域（ES6引入）**：使用let和const关键字声明的变量具有块级作用域。这些变量只在其声明的块或任何包含块中可见。\r\n\r\n- JavaScript变量声明提升：\r\n  -  在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。\r\n  -  声明语句中的赋值部分并不会被提升，只有名称被提升\r\n  -  函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明\r\n  -  如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数\r\n\r\n**介绍JavaScript的原型，原型链？有什么特点？**\r\n\r\n- 原型：\r\n  - JavaScript的所有对象中都包含了一个 `[__proto__]` 内部属性，这个属性所对应的就是该对象的原型\r\n  - JavaScript的函数对象，除了原型 `[__proto__]` 之外，还预置了 prototype 属性\r\n  - 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 `[__proto__]`。\r\n- 原型链：\r\n  -  当一个对象调用的属性/方法自身不存在时，就会去自己 `[__proto__]` 关联的前辈 prototype 对象上去找\r\n  -  如果没找到，就会去该 prototype 原型 `[__proto__]` 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”\r\n- 原型特点：\r\n  - JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变\r\n\r\n**JavaScript有几种类型的值？，你能画一下他们的内存图吗**\r\n\r\n- 原始数据类型（Undefined，Null，Boolean，Number、String）-- 栈\r\n- 引用数据类型（对象、数组和函数）-- 堆\r\n- 两种类型的区别是：存储位置不同：\r\n- 原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；\r\n- 引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；\r\n- 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。\r\n- 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\r\n\r\n**JavaScript如何实现一个类，怎么实例化这个类？**\r\n\r\n- 构造函数法（this + prototype） -- 用 new 关键字 生成实例对象\r\n    - 缺点：用到了 this 和 prototype，编写复杂，可读性差\r\n\r\n```javascript\r\nfunction Mobile(name, price){\r\n  this.name = name;\r\n  this.price = price;\r\n}\r\nMobile.prototype.sell = function(){\r\n  alert(this.name + \"，售价 $\" + this.price);\r\n}\r\nvar iPhone7 = new Mobile(\"iPhone7\", 1000);\r\niPhone7.sell();\r\n```\r\n- Object.create 法 -- 用 Object.create() 生成实例对象\r\n- 缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据\r\n\r\n```javascript\r\nvar Person = {\r\n  firstname: \"Mark\",\r\n  lastname: \"Yun\",\r\n  age: 25,\r\n  introduce: function(){\r\n    alert('I am ' + Person.firstname + ' ' + Person.lastname);\r\n  }\r\n};\r\n\r\nvar person = Object.create(Person);\r\nperson.introduce();\r\n\r\n// Object.create 要求 IE9+，低版本浏览器可以自行部署：\r\nif (!Object.create) {\r\n  Object.create = function (o) {\r\n    function F() {}\r\n    F.prototype = o;\r\n    return new F();\r\n  };\r\n}\r\n```\r\n- 极简主义法（消除 this 和 prototype） -- 调用 createNew() 得到实例对象\r\n    - 优点：容易理解，结构清晰优雅，符合传统的\"面向对象编程\"的构造\r\n\r\n```javascript\r\nvar Cat = {\r\n  age: 3, // 共享数据 -- 定义在类对象内，createNew() 外\r\n  createNew: function () {\r\n    var cat = {};\r\n    // var cat = Animal.createNew(); // 继承 Animal 类\r\n    cat.name = \"小咪\";\r\n    var sound = \"喵喵喵\"; // 私有属性--定义在 createNew() 内，输出对象外\r\n    cat.makeSound = function () {\r\n      alert(sound);  // 暴露私有属性\r\n    };\r\n    cat.changeAge = function(num){\r\n      Cat.age = num; // 修改共享数据\r\n    };\r\n    return cat; // 输出对象\r\n  }\r\n};\r\n\r\nvar cat = Cat.createNew();\r\ncat.makeSound();\r\n```\r\n\r\n- ES6 语法糖 class -- 用 new 关键字 生成实例对象\r\n\r\n```javascript\r\nclass Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n  toString() {\r\n    return '(' + this.x + ', ' + this.y + ')';\r\n  }\r\n}\r\n\r\nvar point = new Point(2, 3);\r\n```\r\n\r\n**Javascript如何实现继承？**\r\n\r\n- 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上\r\n\r\n```javascript\r\nfunction Cat(name,color){\r\n  Animal.apply(this, arguments);\r\n  this.name = name;\r\n  this.color = color;\r\n}\r\n```\r\n- 实例继承：将子对象的 prototype 指向父对象的一个实例\r\n\r\n```javascript\r\nCat.prototype = new Animal();\r\nCat.prototype.constructor = Cat;\r\n```\r\n\r\n- 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象\r\n\r\n```javascript　\r\nfunction extend(Child, Parent) {\r\n  var p = Parent.prototype;\r\n  var c = Child.prototype;\r\n  for (var i in p) {\r\n    c[i] = p[i];\r\n  }\r\n  c.uber = p;\r\n}\r\n```\r\n- 原型继承：将子对象的 prototype 指向父对象的 prototype\r\n\r\n```javascript\r\nfunction extend(Child, Parent) {\r\n  var F = function(){};\r\n  F.prototype = Parent.prototype;\r\n  Child.prototype = new F();\r\n  Child.prototype.constructor = Child;\r\n  Child.uber = Parent.prototype;\r\n}\r\n```\r\n- ES6 语法糖 extends：class ColorPoint extends Point {}\r\n\r\n```javascript\r\nclass ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    super(x, y); // 调用父类的constructor(x, y)\r\n    this.color = color;\r\n  }\r\n  toString() {\r\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\r\n  }\r\n}\r\n```\r\n\r\n**Javascript作用链域?**\r\n\r\n在JavaScript中，作用域（Scope）是一个非常重要的概念，它决定了变量、函数和对象的可访问性。作用域定义了变量和函数的可访问范围，以及它们的生命周期。\r\n\r\n在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域；\r\n\r\nJavaScript中有两种主要的作用域类型：全局作用域和局部作用域。\r\n\r\n1. **全局作用域**：在代码的任何位置都可以访问全局作用域中的变量和函数。当你在代码的任何地方声明一个变量或函数，而没有使用任何函数或块级作用域时，它们就位于全局作用域中。\r\n2. **局部作用域**：局部作用域通常是在函数或块（如if语句或循环）内部声明的变量或函数的范围。这些变量和函数只能在声明它们的函数或块内部访问。\r\n    - **函数作用域**：在函数内部声明的变量和函数具有函数作用域。这些变量和函数只能在该函数内部访问。\r\n    - **块级作用域（ES6引入）**：使用let和const关键字声明的变量具有块级作用域。这些变量只在其声明的块或任何包含块中可见。\r\n\r\n如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链\r\n\r\n**谈谈this对象的理解**\r\n\r\n- this 总是指向函数的直接调用者\r\n- 如果有 new 关键字，this 指向 new 出来的实例对象\r\n- 在事件中，this指向触发这个事件的对象\r\n- IE下 attachEvent 中的this总是指向全局对象Window\r\n\r\n**eval是做什么的？**\r\n\r\n**eval的功能是把对应的字符串解析成JS代码并运行**\r\n\r\n- 应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行）\r\n- 由JSON字符串转换为JSON对象的时候可以用 eval('('+ str +')');\r\n\r\n**什么是 Window 对象? 什么是 Document 对象?**\r\n\r\n- Window 对象表示当前浏览器的窗口，是JavaScript的顶级对象。\r\n- 我们创建的所有对象、函数、变量都是 Window 对象的成员。\r\n- Window 对象的方法和属性是在全局范围内有效的。\r\n- Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）\r\n- Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问\r\n- Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问\r\n\r\n**介绍 DOM 的发展**\r\n\r\n- DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关\r\n- DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms['login']\r\n- DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象\r\n- DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo)\r\n- DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator\r\n\r\n**介绍DOM0，DOM2，DOM3事件处理方式区别**\r\n\r\n- DOM0级事件处理方式：\r\n    - `btn.onclick = func;`\r\n    - `btn.onclick = null;`\r\n- DOM2级事件处理方式：\r\n    - `btn.addEventListener('click', func, false);`\r\n    - `btn.removeEventListener('click', func, false);`\r\n    - `btn.attachEvent(\"onclick\", func);`\r\n    - `btn.detachEvent(\"onclick\", func);`\r\n- DOM3级事件处理方式：\r\n    - `eventUtil.addListener(input, \"textInput\", func);`\r\n    -  `eventUtil` 是自定义对象，`textInput` 是DOM3级事件\r\n\r\n**事件的三个阶段**\r\n\r\n- 捕获、目标、冒泡\r\n\r\n**介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？**\r\n\r\n- 按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段\r\n- 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数\r\n    - 注意1：前提是事件被确实触发\r\n    - 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”\r\n- 事件执行顺序：判断的关键是否目标元素\r\n    - 非目标元素：根据W3C的标准执行：捕获-\u003e目标元素-\u003e冒泡（不依据事件绑定顺序）\r\n    - 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）\r\n    - 最终顺序：父元素捕获-\u003e目标元素事件1-\u003e目标元素事件2-\u003e子元素捕获-\u003e子元素冒泡-\u003e父元素冒泡\r\n    - 注意：子元素事件执行前提    事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系\r\n\r\n**在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？**\r\n\r\n* 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）\r\n* 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获\r\n* 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡\r\n\r\n\r\n**事件的代理/委托**\r\n\r\n* 事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件\r\n* 优点：\r\n    - 可以减少事件注册，节省大量内存占用\r\n    - 可以将事件应用于动态添加的子元素上\r\n* 缺点：\r\n    - 使用不当会造成事件在不应该触发时触发\r\n* 示例：\r\n\r\n``` js\r\nulEl.addEventListener('click', function(e){\r\n    var target = event.target || event.srcElement;\r\n    if(!!target \u0026\u0026 target.nodeName.toUpperCase() === \"LI\"){\r\n        console.log(target.innerHTML);\r\n    }\r\n}, false);\r\n```\r\n\r\n**IE与火狐的事件机制有什么区别？ 如何阻止冒泡？**\r\n\r\n* IE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获\r\n\r\n**IE的事件处理和W3C的事件处理有哪些区别？**\r\n\r\n* 绑定事件\r\n    - W3C: targetEl.addEventListener('click', handler, false);\r\n    - IE: targetEl.attachEvent('onclick', handler);\r\n\r\n* 删除事件\r\n    - W3C: targetEl.removeEventListener('click', handler, false);\r\n    - IE: targetEl.detachEvent(event, handler);\r\n\r\n* 事件对象\r\n    - W3C: var e = arguments.callee.caller.arguments[0]\r\n    - IE: window.event\r\n\r\n* 事件目标\r\n    - W3C: e.target\r\n    - IE: window.event.srcElement\r\n\r\n* 阻止事件默认行为\r\n    - W3C: e.preventDefault()\r\n    - IE: window.event.returnValue = false\r\n\r\n* 阻止事件传播\r\n    - W3C: e.stopPropagation()\r\n    - IE: window.event.cancelBubble = true\r\n\r\n\r\n**W3C事件的 target 与 currentTarget 的区别？**\r\n\r\n* target 只会出现在事件流的目标阶段\r\n* currentTarget 可能出现在事件流的任何阶段\r\n* 当事件流处在目标阶段时，二者的指向相同\r\n* 当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级)\r\n\r\n**如何派发事件(dispatchEvent)？（如何进行事件广播？）**\r\n\r\n* W3C: 使用 dispatchEvent 方法\r\n* IE: 使用 fireEvent 方法\r\n\r\n```javascript\r\nvar fireEvent = function(element, event){\r\n    if (document.createEventObject){\r\n        var mockEvent = document.createEventObject();\r\n        return element.fireEvent('on' + event, mockEvent)\r\n    }else{\r\n        var mockEvent = document.createEvent('HTMLEvents');\r\n        mockEvent.initEvent(event, true, true);\r\n        return !element.dispatchEvent(mockEvent);\r\n    }\r\n}\r\n```\r\n\r\n**什么是函数节流？介绍一下应用场景和原理？**\r\n\r\n* 函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。\r\n只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。\r\n但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）\r\n* 函数节流用于 onresize, onscroll 等短时间内会多次触发的事件\r\n* 函数节流的原理：使用定时器做时间节流。\r\n当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。\r\n如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器，\r\n再 setTimeout 一个新的定时器重复以上流程。\r\n\r\n* 函数节流简单实现：\r\n\r\n```javascript\r\nfunction throttle(method, context) {\r\n     clearTimeout(methor.tId);\r\n     method.tId = setTimeout(function(){\r\n         method.call(context);\r\n     }， 100); // 两次调用至少间隔 100ms\r\n}\r\n// 调用\r\nwindow.onresize = function(){\r\n    throttle(myFunc, window);\r\n}\r\n```\r\n\r\n**区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？**\r\n\r\n* 客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)\r\n* 页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY)\r\n* 屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)\r\n\r\n**如何获得一个DOM元素的绝对位置？**\r\n\r\n* elem.offsetLeft：返回元素相对于其定位父级左侧的距离\r\n* elem.offsetTop：返回元素相对于其定位父级顶部的距离\r\n* elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素\r\n\r\n**分析 ['1', '2', '3'].map(parseInt) 答案是多少？**\r\n\r\n- 答案:[1, NaN, NaN]\r\n* parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析\r\n* map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引\r\n* 因此，map 遍历 [\"1\", \"2\", \"3\"]，相应 parseInt 接收参数如下\r\n\r\n``` js\r\nparseInt('1', 0);  // 1\r\nparseInt('2', 1);  // NaN\r\nparseInt('3', 2);  // NaN\r\n```\r\n- 所以，parseInt 参数 radix 不合法，导致返回值为 NaN\r\n\r\n**new 操作符具体干了什么？**\r\n\r\n- 创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型\r\n- 属性和方法被加入到 this 引用的对象中\r\n- 新创建的对象由 this 所引用，并且最后隐式的返回 this\r\n\r\n**用原生JavaScript的实现过什么功能吗？**\r\n\r\n- 封装选择器、调用第三方API、设置和获取样式\r\n\r\n**解释一下这段代码的意思吗？**\r\n\r\n```javascript\r\n  [].forEach.call($$(\"*\"), function(el){\r\n      el.style.outline = \"1px solid #\" + (~~(Math.random()*(1\u003c\u003c24))).toString(16);\r\n  })\r\n ```\r\n- 解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓(outline)\r\n1. `$$(sel)` // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel)\r\n2. `[].forEach.call(NodeLists)` // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表\r\n3. `el.style.outline = \"1px solid #333\"` // 样式 outline 位于盒模型之外，不影响元素布局位置\r\n4. `(1\u003c\u003c24)` // parseInt(\"ffffff\", 16) == 16777215 == 2^24 - 1 // 1\u003c\u003c24 == 2^24 == 16777216\r\n5. `Math.random()*(1\u003c\u003c24)` // 表示一个位于 0 到 16777216 之间的随机浮点数\r\n6. `~~Math.random()*(1\u003c\u003c24)` // `~~` 作用相当于 parseInt 取整\r\n7. `(~~(Math.random()*(1\u003c\u003c24))).toString(16)` // 转换为一个十六进制-\r\n\r\n\r\n** JavaScript实现异步编程的方法？**\r\n\r\n* 回调函数\r\n* 事件监听\r\n* 发布/订阅\r\n* Promises对象\r\n* Async函数[ES7]\r\n\r\n**web开发中会话跟踪的方法有哪些**\r\n\r\n- cookie\r\n- session\r\n- url重写\r\n- 隐藏input\r\n- ip地址\r\n\r\n**介绍js的基本数据类型**\r\n\r\n- Undefined、Null、Boolean、Number、String\r\n\r\n**介绍js有哪些内置对象？**\r\n\r\n- Object 是 JavaScript 中所有对象的父对象\r\n- 数据封装类对象：Object、Array、Boolean、Number 和 String\r\n- 其他对象：Function、Arguments、Math、Date、RegExp、Error\r\n\r\n\r\n**说几条写JavaScript的基本规范？**\r\n\r\n- 不要在同一行声明多个变量\r\n- 请使用 ===/!==来比较true/false或者数值\r\n- 使用对象字面量替代new Array这种形式\r\n- 不要使用全局函数\r\n- Switch语句必须带有default分支\r\n- 函数不应该有时候有返回值，有时候没有返回值\r\n- If语句必须使用大括号\r\n- for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污\r\n\r\n**JavaScript原型，原型链 ? 有什么特点？**\r\n\r\n- 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时\r\n- 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念\r\n- 关系：`instance.constructor.prototype = instance.__proto__`\r\n- 特点：\r\n    - JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。\r\n-  当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的\r\n-  就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象\r\n\r\n**JavaScript有几种类型的值？，你能画一下他们的内存图吗？**\r\n\r\n- 栈：原始数据类型（Undefined，Null，Boolean，Number、String）\r\n- 堆：引用数据类型（对象、数组和函数）\r\n- 两种类型的区别是：存储位置不同；\r\n- 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\r\n- 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\r\n- 在栈中的地址，取得地址后从堆中获得实体\r\n\r\n![image](https://github.com/hankliu62/interview/assets/8088864/bfc03fd3-6f5b-4e5e-a81e-58d6499aa9fd)\r\n\r\n**Javascript如何实现继承？**\r\n\r\n- 构造继承\r\n- 原型继承\r\n- 实例继承\r\n- 拷贝继承\r\n- 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式\r\n\r\n``` js\r\nfunction Parent() {\r\n    this.name = 'wang';\r\n}\r\n\r\nfunction Child() {\r\n    this.age = 28;\r\n}\r\n\r\nChild.prototype = new Parent();//继承了Parent，通过原型\r\n\r\nvar demo = new Child();\r\nalert(demo.age);\r\nalert(demo.name);//得到被继承的属性\r\n```\r\n\r\n**javascript创建对象的几种方式？**\r\n\r\n\u003e javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用\r\n\r\n- 对象字面量的方式\r\n\r\n``` js\r\nperson={firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"};\r\n```\r\n\r\n- 用function来模拟无参的构造函数\r\n\r\n``` js\r\nfunction Person() {}\r\nvar person = new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class\r\nperson.name = \"Mark\";\r\nperson.age = \"25\";\r\nperson.work = function() {\r\n  console.log(person.name + \" hello...\");\r\n}\r\nperson.work();\r\n```\r\n\r\n- 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\r\n\r\n``` js\r\nfunction Pet(name,age,hobby) {\r\n  this.name = name;//this作用域：当前对象\r\n  this.age = age;\r\n  this.hobby = hobby;\r\n  this.eat = function() {\r\n    alert(\"我叫\" + this.name + \",我喜欢\" + this.hobby + \",是个程序员\");\r\n  }\r\n}\r\nvar maidou = new Pet(\"麦兜\", 25, \"coding\");//实例化、创建对象\r\nmaidou.eat();//调用eat方法\r\n```\r\n\r\n- 用工厂方式来创建（内置对象）\r\n\r\n``` js\r\nvar wcDog = new Object();\r\nwcDog.name = \"旺财\";\r\nwcDog.age = 3;\r\nwcDog.work = function() {\r\n  alert(\"我是\" + wcDog.name + \",汪汪汪......\");\r\n}\r\nwcDog.work();\r\n```\r\n\r\n- 用原型方式来创建\r\n\r\n``` js\r\nfunction Dog() {\r\n}\r\nDog.prototype.name = \"旺财\";\r\nDog.prototype.eat = function() {\r\n  alert(this.name+\"是个吃货\");\r\n}\r\nvar wangcai = new Dog();\r\nwangcai.eat();\r\n```\r\n\r\n- 用混合方式来创建\r\n\r\n``` js\r\nfunction Car(name,price) {\r\n  this.name=name;\r\n  this.price=price;\r\n}\r\nCar.prototype.sell = function() {\r\n  alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\");\r\n}\r\nvar camry =new Car(\"凯美瑞\",27);\r\ncamry.sell();\r\n```\r\n\r\n**Javascript作用链域?**\r\n\r\n在JavaScript中，作用域（Scope）是一个非常重要的概念，它决定了变量、函数和对象的可访问性。作用域定义了变量和函数的可访问范围，以及它们的生命周期。\r\n\r\n在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域；\r\n\r\nJavaScript中有两种主要的作用域类型：全局作用域和局部作用域。\r\n\r\n1. **全局作用域**：在代码的任何位置都可以访问全局作用域中的变量和函数。当你在代码的任何地方声明一个变量或函数，而没有使用任何函数或块级作用域时，它们就位于全局作用域中。\r\n2. **局部作用域**：局部作用域通常是在函数或块（如if语句或循环）内部声明的变量或函数的范围。这些变量和函数只能在声明它们的函数或块内部访问。\r\n    - **函数作用域**：在函数内部声明的变量和函数具有函数作用域。这些变量和函数只能在该函数内部访问。\r\n    - **块级作用域（ES6引入）**：使用let和const关键字声明的变量具有块级作用域。这些变量只在其声明的块或任何包含块中可见。\r\n\r\n如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链\r\n\r\n**谈谈This对象的理解**\r\n\r\n- this总是指向函数的直接调用者（而非间接调用者）\r\n- 如果有new关键字，this指向new出来的那个对象\r\n- 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window\r\n\r\n\r\n**eval是做什么的？**\r\n\r\n- 它的功能是把对应的字符串解析成JS代码并运行\r\n- 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）\r\n- 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')')\r\n\r\n**null，undefined 的区别？**\r\n\r\n- undefined   表示不存在这个值。\r\n- undefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined\r\n- 例如变量被声明了，但没有赋值时，就等于undefined\r\n- null 表示一个对象被定义了，值为“空值”\r\n- null : 是一个对象(空对象, 没有任何属性和方法)\r\n- 例如作为函数的参数，表示该函数的参数不是对象；\r\n-  在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined\r\n\r\n**写一个通用的事件侦听器函数**\r\n\r\n``` js\r\n// event(事件)工具集，来源：github.com/markyun\r\nmarkyun.Event = {\r\n    // 页面加载完成后\r\n    readyEvent : function(fn) {\r\n        if (fn==null) {\r\n            fn=document;\r\n        }\r\n        var oldonload = window.onload;\r\n        if (typeof window.onload != 'function') {\r\n            window.onload = fn;\r\n        } else {\r\n            window.onload = function() {\r\n                oldonload();\r\n                fn();\r\n            };\r\n        }\r\n    },\r\n    // 视能力分别使用dom0||dom2||IE方式 来绑定事件\r\n    // 参数： 操作的元素,事件名称 ,事件处理程序\r\n    addEvent : function(element, type, handler) {\r\n        if (element.addEventListener) {\r\n            //事件类型、需要执行的函数、是否捕捉\r\n            element.addEventListener(type, handler, false);\r\n        } else if (element.attachEvent) {\r\n            element.attachEvent('on' + type, function() {\r\n                handler.call(element);\r\n            });\r\n        } else {\r\n            element['on' + type] = handler;\r\n        }\r\n    },\r\n    // 移除事件\r\n    removeEvent : function(element, type, handler) {\r\n        if (element.removeEventListener) {\r\n            element.removeEventListener(type, handler, false);\r\n        } else if (element.datachEvent) {\r\n            element.detachEvent('on' + type, handler);\r\n        } else {\r\n            element['on' + type] = null;\r\n        }\r\n    },\r\n    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)\r\n    stopPropagation : function(ev) {\r\n        if (ev.stopPropagation) {\r\n            ev.stopPropagation();\r\n        } else {\r\n            ev.cancelBubble = true;\r\n        }\r\n    },\r\n    // 取消事件的默认行为\r\n    preventDefault : function(event) {\r\n        if (event.preventDefault) {\r\n            event.preventDefault();\r\n        } else {\r\n            event.returnValue = false;\r\n        }\r\n    },\r\n    // 获取事件目标\r\n    getTarget : function(event) {\r\n        return event.target || event.srcElement;\r\n    },\r\n    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；\r\n    getEvent : function(e) {\r\n        var ev = e || window.event;\r\n        if (!ev) {\r\n            var c = this.getEvent.caller;\r\n            while (c) {\r\n                ev = c.arguments[0];\r\n                if (ev \u0026\u0026 Event == ev.constructor) {\r\n                    break;\r\n                }\r\n                c = c.caller;\r\n            }\r\n        }\r\n        return ev;\r\n    }\r\n};\r\n```\r\n\r\n**[\"1\", \"2\", \"3\"].map(parseInt) 答案是多少？**\r\n\r\n- [1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。\r\n- map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。\r\n\r\n**事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？**\r\n\r\n- 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为\r\n- 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件\r\n- ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）\r\n\r\n**什么是闭包（closure），为什么要用它？**\r\n\r\n- 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\r\n\r\n- 闭包的特性：\r\n  - 函数内再嵌套函数\r\n  - 内部函数可以引用外层的参数和变量\r\n  - 参数和变量不会被垃圾回收机制回收\r\n\r\n**javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？**\r\n\r\n- use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为\r\n\r\n**如何判断一个对象是否属于某个类？**\r\n\r\n```\r\n// 使用instanceof （待完善）\r\n   if(a instanceof Person){\r\n       alert('yes');\r\n   }\r\n```\r\n\r\n**new操作符具体干了什么呢?**\r\n\r\n- 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型\r\n- 属性和方法被加入到 this 引用的对象中\r\n- 新创建的对象由 this 所引用，并且最后隐式的返回 this\r\n\r\n``` js\r\nvar obj  = {};\r\nobj.__proto__ = Base.prototype;\r\nBase.call(obj);\r\n```\r\n\r\n**js延迟加载的方式有哪些？**\r\n\r\n- defer和async、动态创建DOM方式（用得最多）、按需异步载入js\r\n\r\n**Ajax 是什么? 如何创建一个Ajax？**\r\n\r\n\u003e ajax的全称：Asynchronous Javascript And XML\r\n\r\n- 异步传输+js+xml\r\n- 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验\r\n    - 创建XMLHttpRequest对象,也就是创建一个异步调用对象\r\n    - 建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\r\n    - 设置响应HTTP请求状态变化的函数\r\n    - 发送HTTP请求\r\n    - 获取异步调用返回的数据\r\n    - 用JavaScript和DOM实现局部刷新\r\n\r\n**同步和异步的区别?**\r\n\r\n- 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作\r\n- 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容\r\n\r\n**异步加载JS的方式有哪些？**\r\n\r\n- defer，只支持IE\r\n- async：\r\n- 创建script，插入到DOM中，加载完毕后callBack\r\n\r\n**documen.write和 innerHTML的区别**\r\n\r\n- document.write只能重绘整个页面\r\n- innerHTML可以重绘页面的一部分\r\n\r\n**DOM操作——怎样添加、移除、移动、复制、创建和查找节点?**\r\n\r\n- （1）创建新节点\r\n    - createDocumentFragment() //创建一个DOM片段\r\n    - createElement()   //创建一个具体的元素\r\n    - createTextNode()   //创建一个文本节点\r\n- （2）添加、移除、替换、插入\r\n    - appendChild()\r\n    - removeChild()\r\n    - replaceChild()\r\n    - insertBefore() //在已有的子节点前插入一个新的子节点\r\n- （3）查找\r\n    - getElementsByTagName()    //通过标签名称\r\n    - getElementsByName()    // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)\r\n    - getElementById()    //通过元素Id，唯一性\r\n\r\n**那些操作会造成内存泄漏？**\r\n\r\n- 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\r\n- 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收\r\n- setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏\r\n- 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\r\n\r\n**渐进增强和优雅降级**\r\n\r\n- 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\r\n- 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容\r\n\r\n\r\n**Javascript垃圾回收方法**\r\n\r\n- 标记清除（mark and sweep）\r\n\r\n\u003e - 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”\r\n\u003e - 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了\r\n\r\n**引用计数(reference counting)**\r\n\r\n\u003e 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间\r\n\r\n**js继承方式及其优缺点**\r\n\r\n- 原型链继承的缺点\r\n  - 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。\r\n\r\n- 借用构造函数（类式继承）\r\n  - 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承\r\n\r\n- 组合式继承\r\n  - 组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。\r\n\r\n**defer和async**\r\n\r\n- defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行\r\n\r\n**用过哪些设计模式？**\r\n\r\n- 工厂模式：\r\n    - 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复\r\n    - 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例\r\n``` js\r\nfunction createObject(name,age,profession){//集中实例化的函数var obj = new Object();\r\n    obj.name = name;\r\n    obj.age = age;\r\n    obj.profession = profession;\r\n    obj.move = function () {\r\n        return this.name + ' at ' + this.age + ' engaged in ' + this.profession;\r\n    };\r\n    return obj;\r\n}\r\nvar test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例\r\n```\r\n\r\n- 构造函数模式\r\n    - 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于\r\n- 构造函数方法没有显示的创建对象 (new Object());\r\n- 直接将属性和方法赋值给 this 对象;\r\n- 没有 renturn 语句\r\n\r\n**说说你对闭包的理解**\r\n\r\n- 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念\r\n- 闭包有三个特性：\r\n    1. 函数嵌套函数\r\n    2. 函数内部可以引用外部的参数和变量\r\n    3. 参数和变量不会被垃圾回收机制回收\r\n\r\n\r\n\r\n**请解释一下 JavaScript 的同源策略**\r\n\r\n- 概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议\r\n- 指一段脚本只能读取来自同一来源的窗口和文档的属性\r\n\r\n**为什么要有同源限制？**\r\n\r\n- 我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。\r\n- 缺点\r\n    - 现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节\r\n\r\n**实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制**\r\n\r\n``` js\r\nObject.prototype.clone = function(){\r\n    var o = this.constructor === Array ? [] : {};\r\n    for(var e in this){\r\n        o[e] = typeof this[e] === \"object\" ? this[e].clone() : this[e];\r\n    }\r\n\r\n    return o;\r\n}\r\n```\r\n\r\n**说说严格模式的限制**\r\n- 严格模式主要有以下限制：\r\n- 变量必须声明后再使用\r\n- 函数的参数不能有同名属性，否则报错\r\n- 不能使用with语句\r\n- 不能对只读属性赋值，否则报错\r\n- 不能使用前缀0表示八进制数，否则报错\r\n- 不能删除不可删除的属性，否则报错\r\n- 不能删除变量delete prop，会报错，只能删除属性delete global[prop]\r\n- eval不会在它的外层作用域引入变量\r\n- eval和arguments不能被重新赋值\r\n- arguments不会自动反映函数参数的变化\r\n- 不能使用arguments.callee\r\n- 不能使用arguments.caller\r\n- 禁止this指向全局对象\r\n- 不能使用fn.caller和fn.arguments获取函数调用的堆栈\r\n- 增加了保留字（比如protected、static和interface）\r\n\r\n**如何删除一个cookie**\r\n\r\n- 将时间设为当前时间往前一点\r\n\r\n``` js\r\nvar date = new Date();\r\n\r\ndate.setDate(date.getDate() - 1);//真正的删除\r\n```\r\nsetDate()方法用于设置一个月的某一天\r\n\r\n- expires的设置\r\n\r\n``` js\r\n  document.cookie = 'user='+ encodeURIComponent('name')  + ';expires = ' + new Date(0)\r\n```\r\n\r\n**编写一个方法 求一个字符串的字节长度**\r\n\r\n- 假设：一个英文字符占用一个字节，一个中文字符占用两个字节\r\n\r\n``` js\r\nfunction GetBytes(str){\r\n    var len = str.length;\r\n    var bytes = len;\r\n    for(var i=0; i\u003clen; i++){\r\n        if (str.charCodeAt(i) \u003e 255) bytes++;\r\n    }\r\n    return bytes;\r\n}\r\n\r\nalert(GetBytes(\"你好,as\"));\r\n```\r\n\r\n**请解释什么是事件代理**\r\n\r\n- 事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能\r\n\r\n**attribute和property的区别是什么？**\r\n\r\n- attribute是dom元素在文档中作为html标签拥有的属性；\r\n- property就是dom元素在js中作为对象拥有的属性。\r\n- 对于html的标准属性来说，attribute和property是同步的，是会自动更新的\r\n- 但是对于自定义的属性来说，他们是不同步的\r\n\r\n**页面编码和被请求的资源编码如果不一致如何处理？**\r\n\r\n* 后端响应头设置 charset\r\n* 前端页面`\u003cmeta\u003e`设置 charset\r\n\r\n\r\n**把`\u003cscript\u003e`放在`\u003c/body\u003e`之前和之后有什么区别？浏览器会如何解析它们？**\r\n\r\n* 按照HTML标准，在`\u003c/body\u003e`结束后出现`\u003cscript\u003e`或任何元素的开始标签，都是解析错误\r\n* 虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在`\u003c/body\u003e`之前没有区别\r\n* 浏览器的容错机制会忽略`\u003cscript\u003e`之前的`\u003c/body\u003e`，视作`\u003cscript\u003e`仍在 body 体内。省略`\u003c/body\u003e`和`\u003c/html\u003e`闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容\r\n\r\n**延迟加载JS的方式有哪些？**\r\n\r\n* 设置`\u003cscript\u003e`属性 defer=\"defer\" （脚本将在页面完成解析时执行）\r\n* 动态创建 script DOM：document.createElement('script');\r\n* XmlHttpRequest 脚本注入\r\n* 延迟加载工具 LazyLoad\r\n\r\n**异步加载JS的方式有哪些？**\r\n\r\n* 设置`\u003cscript\u003e`属性 async=\"async\" （一旦脚本可用，则会异步执行）\r\n* 动态创建 script DOM：document.createElement('script');\r\n* XmlHttpRequest 脚本注入\r\n* 异步加载库 LABjs\r\n* 模块加载器 Sea.js\r\n\r\n**JavaScript 中，调用函数有哪几种方式？**\r\n\r\n* 方法调用模式          Foo.foo(arg1, arg2);\r\n* 函数调用模式          foo(arg1, arg2);\r\n* 构造器调用模式        (new Foo())(arg1, arg2);\r\n* call/applay调用模式   Foo.foo.call(that, arg1, arg2);\r\n* bind调用模式          Foo.foo.bind(that)(arg1, arg2)();\r\n\r\n\r\n**简单实现 Function.bind 函数？**\r\n\r\n```javascript\r\nif (!Function.prototype.bind) {\r\n  Function.prototype.bind = function(that) {\r\n    var func = this, args = arguments;\r\n    return function() {\r\n      return func.apply(that, Array.prototype.slice.call(args, 1));\r\n    }\r\n  }\r\n}\r\n// 只支持 bind 阶段的默认参数：\r\nfunc.bind(that, arg1, arg2)();\r\n\r\n// 不支持以下调用阶段传入的参数：\r\nfunc.bind(that)(arg1, arg2);\r\n```\r\n\r\n**列举一下JavaScript数组和对象有哪些原生方法？**\r\n\r\n* 数组：\r\n    - arr.concat(arr1, arr2, arrn);\r\n    - arr.join(\",\");\r\n    - arr.sort(func);\r\n    - arr.pop();\r\n    - arr.push(e1, e2, en);\r\n    - arr.shift();\r\n    - unshift(e1, e2, en);\r\n    - arr.reverse();\r\n    - arr.slice(start, end);\r\n    - arr.splice(index, count, e1, e2, en);\r\n    - arr.indexOf(el);\r\n    - arr.includes(el);   // ES6\r\n\r\n* 对象：\r\n    - object.hasOwnProperty(prop);\r\n    - object.propertyIsEnumerable(prop);\r\n    - object.valueOf();\r\n    - object.toString();\r\n    - object.toLocaleString();\r\n    - Class.prototype.isPropertyOf(object);\r\n\r\n**Array.splice() 与 Array.splice() 的区别？**\r\n\r\n* slice -- “读取”数组指定的元素，不会对原数组进行修改\r\n    - 语法：arr.slice(start, end)\r\n    - start 指定选取开始位置（含）\r\n    - end 指定选取结束位置（不含）\r\n\r\n* splice\r\n    - “操作”数组指定的元素，会修改原数组，返回被删除的元素\r\n    - 语法：arr.splice(index, count, [insert Elements])\r\n    - index 是操作的起始位置\r\n    - count = 0 插入元素，count \u003e 0 删除元素\r\n    - [insert Elements] 向数组新插入的元素\r\n\r\n**JavaScript 对象生命周期的理解？**\r\n\r\n* 当创建一个对象时，JavaScript 会自动为该对象分配适当的内存\r\n* 垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量\r\n* 如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收\r\n\r\n**哪些操作会造成内存泄漏？**\r\n\r\n-  JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收\r\n- 未使用 var 声明的全局变量\r\n- 闭包函数(Closures)\r\n- 循环引用(两个对象相互引用)\r\n- 控制台日志(console.log)\r\n- 移除存在绑定事件的DOM元素(IE)","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/234/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/234/timeline","performed_via_github_app":null,"state_reason":null},"menus":[]},"__N_SSG":true},"page":"/questions/[id]","query":{"id":"234"},"buildId":"sU2iERWyzsgD586oQgu3i","assetPrefix":"/frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>