<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具</title><link rel="icon" href="/toolbox-frontend/favicon.ico"/><meta name="description" content="卡鲁秋的前端工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋,Hank,HankLiu"/><meta name="author" content="Hank.Liu"/><meta name="next-head-count" content="7"/><link rel="stylesheet" href="/toolbox-frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/toolbox-frontend/_next/static/css/f5460a021fc371e8.css" as="style"/><link rel="stylesheet" href="/toolbox-frontend/_next/static/css/f5460a021fc371e8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/toolbox-frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/toolbox-frontend/_next/static/chunks/webpack-d3f168008ea5a34b.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/framework-aec4381329cec0e4.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/main-82d23b26b43cd32b.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/_app-5f178c658cd611e1.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/9691-52831ba1a45a37ee.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/8490-9c9cad1e305c687c.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/1664-f865873e77459860.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/articles/%5Bid%5D-b6bd1d5b4743d958.js" defer=""></script><script src="/toolbox-frontend/_next/static/eqHLrJmKCmctBZmrJMyBT/_buildManifest.js" defer=""></script><script src="/toolbox-frontend/_next/static/eqHLrJmKCmctBZmrJMyBT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1 overflow-x-hidden"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-12jzuas"><div class="ant-card-body"><article><div class="mx-auto mb-[36px] max-w-[1045px] px-[30px] lg:mb-[52px] lg:flex lg:px-0"><div id="banner" class="media-wrapper image-media-wrapper w-full overflow-hidden rounded-[8px] border-[1px] border-solid border-[#1D2129] lg:ml-0 lg:h-[320px] lg:w-[500px]"><div class="hidden before"></div><div class="hidden after"></div><div class="scale-103 h-full w-full border-[8px] border-solid border-white lg:scale-100 cover-wrapper"><img class="h-full w-full rounded-md object-cover cover" src="/toolbox-frontend/dashboard/images/banner.png" alt=""/></div></div><div class="mt-[60px] overflow-hidden lg:ml-[32px] lg:mt-0 lg:flex-1"><h1 class="leading-130 montserrat-bold mb-[9px] text-[36px] font-medium text-[#1D2129] lg:mb-[8px]">Vue相关的面试题</h1><div class="mb-[9px] flex whitespace-nowrap lg:mb-[10px]"><div class="leading-120 cursor-pointer truncate text-[24px] font-normal text-[#1D2129] underline-offset-2 hover:underline lg:text-[20px]" aria-hidden="true"># VOL.<!-- -->614</div><div class="leading-120 ml-[48px] text-[24px] font-normal text-[#1D2129] lg:ml-[32px] lg:text-[20px]">2024/02/13</div></div><div class="mb-[12px] flex flex-wrap lg:mb-0"><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">blog</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">vue</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">interview</div></div><div class="my-[30px] hidden w-[213px] border border-[#1D2129] lg:mb-[20px] lg:mt-[8px] lg:block"></div><div class="lg:rounded-0 rounded-[12px] bg-white/30 p-[36px] lg:flex lg:bg-transparent lg:p-0"><div class="float-left h-[118px] w-[118px] lg:float-none lg:h-[112px] lg:w-[112px]"><img src="https://avatars.githubusercontent.com/u/8088864?v=4" class="h-full w-full rounded-[8px] object-cover lg:rounded-[12px]" alt=""/></div><div class="lg:ml-[32px] lg:flex-1 lg:overflow-hidden"><div class="mb-[10px] flex h-[118px] flex-col justify-center pl-[36px] lg:h-auto lg:flex-row lg:items-center lg:justify-between lg:pl-0"><div class="leading-130 montserrat-bold mb-[12px] w-full truncate text-[30px] font-medium text-[#1D2129] lg:mb-0 lg:flex-1 lg:text-[24px]">hankliu62</div><a class="leading-170 ml-0 whitespace-pre-wrap text-[20px] font-normal !text-[#1D2129] !underline hover:!text-[#1D2129] hover:!underline focus:!text-[#1D2129] lg:ml-[5px] lg:text-[14px]" href="https://github.com/hankliu62" target="_blank" rel="noreferrer">TA的个人名片</a></div><div class="leading-170 text-[20px] font-normal text-[#4E5969] lg:text-[14px]">HankLiu前端开发工程师，精通前端，涉猎后端，对前端有着浓厚的兴趣，希望能够在前端这条路上一直走下去。努力去听风的声音，不必在意风的方向。</div></div></div></div></div><div class="ant-divider css-12jzuas ant-divider-horizontal !mt-0 !border-[#bfc3c7]" role="separator"></div><section><div><div class="ant-skeleton ant-skeleton-active css-12jzuas"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-12jzuas"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="## Vue.js虚拟DOM的优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/toolbox-frontend/articles/614#vue.js%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:16px">Vue.js虚拟DOM的优缺点</div></a></li><li id="### 1）优点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#1%E4%BC%98%E7%82%B9"><div class="truncate" style="padding-left:32px">1）优点</div></a></li><li id="### 2）缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#2%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:32px">2）缺点</div></a></li><li id="## vue的优点是什么？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">vue的优点是什么？</div></a></li><li id="## 对于 Vue 是一套渐进式框架的理解" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E5%AF%B9%E4%BA%8E-vue-%E6%98%AF%E4%B8%80%E5%A5%97%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3"><div class="truncate" style="padding-left:16px">对于 Vue 是一套渐进式框架的理解</div></a></li><li id="## Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue2.0-%E4%B8%AD%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%92%8C%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%A2%9E%E9%87%8F%E5%BC%80%E5%8F%91%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？</div></a></li><li id="## Vue computed 实现" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-computed-%E5%AE%9E%E7%8E%B0"><div class="truncate" style="padding-left:16px">Vue computed 实现</div></a></li><li id="## Vue complier 实现" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-complier-%E5%AE%9E%E7%8E%B0"><div class="truncate" style="padding-left:16px">Vue complier 实现</div></a></li><li id="## 如何编译 template 模板？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91-template-%E6%A8%A1%E6%9D%BF"><div class="truncate" style="padding-left:16px">如何编译 template 模板？</div></a></li><li id="## vue 中的性能优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:16px">vue 中的性能优化</div></a></li><li id="### 1）编码优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#1%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">1）编码优化</div></a></li><li id="### 2）用户体验优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#2%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">2）用户体验优化</div></a></li><li id="### 3）SEO优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#3seo%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">3）SEO优化</div></a></li><li id="### 4）打包优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#4%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">4）打包优化</div></a></li><li id="## Vue 的实例生命周期" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><div class="truncate" style="padding-left:16px">Vue 的实例生命周期</div></a></li><li id="## Vue 的双向数据绑定的原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">Vue 的双向数据绑定的原理</div></a></li><li id="## 为什么要替换 Object.defineProperty？（Proxy 相比于 defineProperty 的优势）" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%BF%E6%8D%A2-object.definepropertyproxy-%E7%9B%B8%E6%AF%94%E4%BA%8E-defineproperty-%E7%9A%84%E4%BC%98%E5%8A%BF"><div class="truncate" style="padding-left:16px">为什么要替换 Object.defineProperty？（Proxy 相比于 defineProperty 的优势）</div></a></li><li id="## 什么是 Proxy？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E4%BB%80%E4%B9%88%E6%98%AF-proxy"><div class="truncate" style="padding-left:16px">什么是 Proxy？</div></a></li><li id="### 含义：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E5%90%AB%E4%B9%89"><div class="truncate" style="padding-left:32px">含义：</div></a></li><li id="### 基本用法：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><div class="truncate" style="padding-left:32px">基本用法：</div></a></li><li id="### 示例：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E7%A4%BA%E4%BE%8B"><div class="truncate" style="padding-left:32px">示例：</div></a></li><li id="## 为什么避免 v-if 和 v-for 用在一起" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7"><div class="truncate" style="padding-left:16px">为什么避免 v-if 和 v-for 用在一起</div></a></li><li id="## 组件的设计原则" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><div class="truncate" style="padding-left:16px">组件的设计原则</div></a></li><li id="## vue 等单页面应用及其优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-%E7%AD%89%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:16px">vue 等单页面应用及其优缺点</div></a></li><li id="## `$route`和`$router`的区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%60$route%60%E5%92%8C%60$router%60%E7%9A%84%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">`$route`和`$router`的区别</div></a></li><li id="## 什么是 vue 的计算属性？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E4%BB%80%E4%B9%88%E6%98%AF-vue-%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><div class="truncate" style="padding-left:16px">什么是 vue 的计算属性？</div></a></li><li id="## watch的作用是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#watch%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">watch的作用是什么</div></a></li><li id="## 计算属性的缓存和方法调用的区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BC%93%E5%AD%98%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">计算属性的缓存和方法调用的区别</div></a></li><li id="## 指令 v-el 的作用是什么?" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%8C%87%E4%BB%A4-v-el-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88?"><div class="truncate" style="padding-left:16px">指令 v-el 的作用是什么?</div></a></li><li id="## vuex 有哪几种属性？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vuex-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7"><div class="truncate" style="padding-left:16px">vuex 有哪几种属性？</div></a></li><li id="## 不用 Vuex 会带来什么问题？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E4%B8%8D%E7%94%A8-vuex-%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:16px">不用 Vuex 会带来什么问题？</div></a></li><li id="## vue-router 有哪几种导航钩子（ 导航守卫 ）？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-router-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB-"><div class="truncate" style="padding-left:16px">vue-router 有哪几种导航钩子（ 导航守卫 ）？</div></a></li><li id="## vue-router 实现路由懒加载（ 动态加载路由 ）" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-router-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%B7%AF%E7%94%B1-"><div class="truncate" style="padding-left:16px">vue-router 实现路由懒加载（ 动态加载路由 ）</div></a></li><li id="### vue异步组件技术" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%8A%80%E6%9C%AF"><div class="truncate" style="padding-left:32px">vue异步组件技术</div></a></li><li id="### es提案的import()" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#es%E6%8F%90%E6%A1%88%E7%9A%84import()"><div class="truncate" style="padding-left:32px">es提案的import()</div></a></li><li id="### webpack提供的require.ensure()" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#webpack%E6%8F%90%E4%BE%9B%E7%9A%84require.ensure()"><div class="truncate" style="padding-left:32px">webpack提供的require.ensure()</div></a></li><li id="## 谈一谈 Vue.$nextTick 的原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E8%B0%88%E4%B8%80%E8%B0%88-vue.$nexttick-%E7%9A%84%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">谈一谈 Vue.$nextTick 的原理</div></a></li><li id="## Vue 的父组件和子组件生命周期钩子执行顺序是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">Vue 的父组件和子组件生命周期钩子执行顺序是什么</div></a></li><li id="## Vue实现通信方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:16px">Vue实现通信方式</div></a></li><li id="### 方式1: props" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%96%B9%E5%BC%8F1:-props"><div class="truncate" style="padding-left:32px">方式1: props</div></a></li><li id="### 方式2: vue自定义事件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%96%B9%E5%BC%8F2:-vue%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><div class="truncate" style="padding-left:32px">方式2: vue自定义事件</div></a></li><li id="### 方式3: 消息订阅与发布" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%96%B9%E5%BC%8F3:-%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><div class="truncate" style="padding-left:32px">方式3: 消息订阅与发布</div></a></li><li id="### 方式4: vuex" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%96%B9%E5%BC%8F4:-vuex"><div class="truncate" style="padding-left:32px">方式4: vuex</div></a></li><li id="### 方式5: slot" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%96%B9%E5%BC%8F5:-slot"><div class="truncate" style="padding-left:32px">方式5: slot</div></a></li><li id="## 说说Vue的MVVM实现原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E8%AF%B4%E8%AF%B4vue%E7%9A%84mvvm%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">说说Vue的MVVM实现原理</div></a></li><li id="## Vue.use是干什么的？原理是什么？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue.use%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">Vue.use是干什么的？原理是什么？</div></a></li><li id="## new Vue() 发生了什么？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#new-vue()-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">new Vue() 发生了什么？</div></a></li><li id="## 请说一下Vue响应式数据的理解？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8Bvue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%90%86%E8%A7%A3"><div class="truncate" style="padding-left:16px">请说一下Vue响应式数据的理解？</div></a></li><li id="## Vue如何检测数组变化？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96"><div class="truncate" style="padding-left:16px">Vue如何检测数组变化？</div></a></li><li id="## Vue.set 方法是如何实现的？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue.set-%E6%96%B9%E6%B3%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><div class="truncate" style="padding-left:16px">Vue.set 方法是如何实现的？</div></a></li><li id="## Vue3.x响应式数据原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue3.x%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">Vue3.x响应式数据原理</div></a></li><li id="## Vue3.x中Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue3.x%E4%B8%ADproxy%E5%8F%AA%E4%BC%9A%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AC%AC%E4%B8%80%E5%B1%82%E9%82%A3%E4%B9%88vue3%E5%8F%88%E6%98%AF%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E5%91%A2"><div class="truncate" style="padding-left:16px">Vue3.x中Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</div></a></li><li id="## Vue3.x中监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue3.x%E4%B8%AD%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E8%83%BD%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1get/set%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1%E5%91%A2"><div class="truncate" style="padding-left:16px">Vue3.x中监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</div></a></li><li id="## vue2.x中如何监测数组变化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue2.x%E4%B8%AD%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96"><div class="truncate" style="padding-left:16px">vue2.x中如何监测数组变化</div></a></li><li id="## Vue2.x和Vue3.x渲染器的diff算法分别说一下" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue2.x%E5%92%8Cvue3.x%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%88%86%E5%88%AB%E8%AF%B4%E4%B8%80%E4%B8%8B"><div class="truncate" style="padding-left:16px">Vue2.x和Vue3.x渲染器的diff算法分别说一下</div></a></li><li id="## Vue SSR了解吗？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-ssr%E4%BA%86%E8%A7%A3%E5%90%97"><div class="truncate" style="padding-left:16px">Vue SSR了解吗？</div></a></li><li id="## 组件中写 name选项有哪些好处及作用？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99-name%E9%80%89%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84%E5%8F%8A%E4%BD%9C%E7%94%A8"><div class="truncate" style="padding-left:16px">组件中写 name选项有哪些好处及作用？</div></a></li><li id="## vue的diff算法和react的diff算法的区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%92%8Creact%E7%9A%84diff%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">vue的diff算法和react的diff算法的区别</div></a></li><li id="## vue3带来的新特性/亮点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue3%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/%E4%BA%AE%E7%82%B9"><div class="truncate" style="padding-left:16px">vue3带来的新特性/亮点</div></a></li><li id="## keep-alive实现原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#keep-alive%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">keep-alive实现原理</div></a></li><li id="## 深入keep-alive组件实现" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%B7%B1%E5%85%A5keep-alive%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0"><div class="truncate" style="padding-left:16px">深入keep-alive组件实现</div></a></li><li id="### render" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#render"><div class="truncate" style="padding-left:32px">render</div></a></li><li id="### watch" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#watch"><div class="truncate" style="padding-left:32px">watch</div></a></li><li id="## vue修饰符" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E4%BF%AE%E9%A5%B0%E7%AC%A6"><div class="truncate" style="padding-left:16px">vue修饰符</div></a></li><li id="## v-model的实现原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#v-model%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">v-model的实现原理</div></a></li><li id="## vm.$isServer, vm.$attrs 和 vm.$listeners 含义" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vm.$isserver,-vm.$attrs-%E5%92%8C-vm.$listeners-%E5%90%AB%E4%B9%89"><div class="truncate" style="padding-left:16px">vm.$isServer, vm.$attrs 和 vm.$listeners 含义</div></a></li><li id="### vm.$isServer" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vm.$isserver"><div class="truncate" style="padding-left:32px">vm.$isServer</div></a></li><li id="### vm.$attrs" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vm.$attrs"><div class="truncate" style="padding-left:32px">vm.$attrs</div></a></li><li id="### vm.$listeners" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vm.$listeners"><div class="truncate" style="padding-left:32px">vm.$listeners</div></a></li><li id="## vue中methods与computed，filters，watch的区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E4%B8%ADmethods%E4%B8%8Ecomputedfilterswatch%E7%9A%84%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">vue中methods与computed，filters，watch的区别</div></a></li><li id="### methods" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#methods"><div class="truncate" style="padding-left:32px">methods</div></a></li><li id="### computed" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#computed"><div class="truncate" style="padding-left:32px">computed</div></a></li><li id="### filters" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#filters"><div class="truncate" style="padding-left:32px">filters</div></a></li><li id="### watch" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#watch"><div class="truncate" style="padding-left:32px">watch</div></a></li><li id="## Vue两个简易代替vuex的方法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E4%B8%A4%E4%B8%AA%E7%AE%80%E6%98%93%E4%BB%A3%E6%9B%BFvuex%E7%9A%84%E6%96%B9%E6%B3%95"><div class="truncate" style="padding-left:16px">Vue两个简易代替vuex的方法</div></a></li><li id="### eventBus" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#eventbus"><div class="truncate" style="padding-left:32px">eventBus</div></a></li><li id="### Vue.observable" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue.observable"><div class="truncate" style="padding-left:32px">Vue.observable</div></a></li><li id="## 如果让你封装一个通用的弹框组件，你会从哪些方面考虑" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E5%BC%B9%E6%A1%86%E7%BB%84%E4%BB%B6%E4%BD%A0%E4%BC%9A%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E8%80%83%E8%99%91"><div class="truncate" style="padding-left:16px">如果让你封装一个通用的弹框组件，你会从哪些方面考虑</div></a></li><li id="## Vue组件通信有哪些方式，适用场景分别是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">Vue组件通信有哪些方式，适用场景分别是什么</div></a></li><li id="## Vue哪个生命周期发送数据请求" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82"><div class="truncate" style="padding-left:16px">Vue哪个生命周期发送数据请求</div></a></li><li id="## Vue的data为什么必须是函数" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><div class="truncate" style="padding-left:16px">Vue的data为什么必须是函数</div></a></li><li id="## computed和watch使用场景有什么不同，实现原理呢" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#computed%E5%92%8Cwatch%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%91%A2"><div class="truncate" style="padding-left:16px">computed和watch使用场景有什么不同，实现原理呢</div></a></li><li id="### computed" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#computed"><div class="truncate" style="padding-left:32px">computed</div></a></li><li id="### watch" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#watch"><div class="truncate" style="padding-left:32px">watch</div></a></li><li id="## Vue怎么实现数据响应式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F"><div class="truncate" style="padding-left:16px">Vue怎么实现数据响应式</div></a></li><li id="## Vue2中怎么检测数组的变化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue2%E4%B8%AD%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96"><div class="truncate" style="padding-left:16px">Vue2中怎么检测数组的变化</div></a></li><li id="## 谈一谈对MVVM的理解？Vue实现双向数据绑定原理是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E8%B0%88%E4%B8%80%E8%B0%88%E5%AF%B9mvvm%E7%9A%84%E7%90%86%E8%A7%A3vue%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">谈一谈对MVVM的理解？Vue实现双向数据绑定原理是什么</div></a></li><li id="## 什么是虚拟DOM，有什么作用？有了解过diff算法吗" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9Fdom%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87diff%E7%AE%97%E6%B3%95%E5%90%97"><div class="truncate" style="padding-left:16px">什么是虚拟DOM，有什么作用？有了解过diff算法吗</div></a></li><li id="### 虚拟DOM的作用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E4%BD%9C%E7%94%A8"><div class="truncate" style="padding-left:32px">虚拟DOM的作用</div></a></li><li id="### Vue diff算法相关知识点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue-diff%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9"><div class="truncate" style="padding-left:32px">Vue diff算法相关知识点</div></a></li><li id="## Vue模板编译原理了解吗" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97"><div class="truncate" style="padding-left:16px">Vue模板编译原理了解吗</div></a></li><li id="## 怎么做Vue自动化测试" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%80%8E%E4%B9%88%E5%81%9Avue%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><div class="truncate" style="padding-left:16px">怎么做Vue自动化测试</div></a></li><li id="### 测试方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:32px">测试方案</div></a></li><li id="### 测什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%B5%8B%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:32px">测什么</div></a></li><li id="## 什么是自定义指令，怎么实现" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><div class="truncate" style="padding-left:16px">什么是自定义指令，怎么实现</div></a></li><li id="## keep-alive适用场景是什么，实现原理是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#keep-alive%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">keep-alive适用场景是什么，实现原理是什么</div></a></li><li id="## nextTick有什么作用，实现原理是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#nexttick%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">nextTick有什么作用，实现原理是什么</div></a></li><li id="## 讲一下你对SSR的了解" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9ssr%E7%9A%84%E4%BA%86%E8%A7%A3"><div class="truncate" style="padding-left:16px">讲一下你对SSR的了解</div></a></li><li id="## 有用过Vue3吗，和Vue2有哪些区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%9C%89%E7%94%A8%E8%BF%87vue3%E5%90%97%E5%92%8Cvue2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">有用过Vue3吗，和Vue2有哪些区别</div></a></li><li id="### 性能提升方面" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%96%B9%E9%9D%A2"><div class="truncate" style="padding-left:32px">性能提升方面</div></a></li><li id="### 组合API和Reactive API" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E7%BB%84%E5%90%88api%E5%92%8Creactive-api"><div class="truncate" style="padding-left:32px">组合API和Reactive API</div></a></li><li id="### TypeScript支持方面" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#typescript%E6%94%AF%E6%8C%81%E6%96%B9%E9%9D%A2"><div class="truncate" style="padding-left:32px">TypeScript支持方面</div></a></li><li id="### 自定义渲染器" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8"><div class="truncate" style="padding-left:32px">自定义渲染器</div></a></li><li id="### 更好的源码架构：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84"><div class="truncate" style="padding-left:32px">更好的源码架构：</div></a></li><li id="### 新的功能和组件：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E6%96%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%84%E4%BB%B6"><div class="truncate" style="padding-left:32px">新的功能和组件：</div></a></li><li id="## 你知道哪些Vue编码规范" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/614#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9Bvue%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><div class="truncate" style="padding-left:16px">你知道哪些Vue编码规范</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/614","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/614/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/614/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/614/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/614","id":2131539317,"node_id":"I_kwDOBiJZIc5_DLV1","number":614,"title":"Vue相关的面试题","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536119786,"node_id":"LA_kwDOBiJZIc8AAAABhZVF6g","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/vue","name":"vue","color":"0E8A16","default":false,"description":"分类-Vue相关"},{"id":6552343574,"node_id":"LA_kwDOBiJZIc8AAAABhozUFg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview","name":"interview","color":"79D677","default":false,"description":"分类-面试题相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-13T06:15:46Z","updated_at":"2024-02-13T08:51:35Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"---\r\n\r\ntitle: Vue相关的面试题\r\n\r\ndate: 2024-02-13 16:51:34\r\n\r\ntag: [blog, interview, vue]\r\n\r\n---\r\n\r\n## Vue.js虚拟DOM的优缺点\r\n\r\n### 1）优点\r\n\r\n- **保证性能下限**： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；\r\n- **无需手动操作 DOM**： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；\r\n- **跨平台**： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。\r\n\r\n### 2）缺点\r\n\r\n- **无法进行极致优化**： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如VScode采用直接手动操作DOM的方式进行极端的性能优化\r\n\r\n## vue的优点是什么？\r\n\r\n- 低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的\"View\"上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。\r\n\r\n- 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。\r\n\r\n- 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。\r\n\r\n- 可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。\r\n\r\n## 对于 Vue 是一套渐进式框架的理解\r\n\r\n每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。\r\n\r\n1、使用 vue，你可以在原有大系统的上面，把一两个组件改用它实现，当 jQuery 用；\r\n\r\n2、也可以整个用它全家桶开发，当 Angular 用；\r\n\r\n3、还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用 OO(Object–Oriented )面向对象和设计模式的那套理念。 也可以函数式，都可以。\r\n\r\n它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。\r\n\r\n你不必一开始就用 Vue 所有的全家桶，根据场景，官方提供了方便的框架供你使用。\r\n\r\n场景联想\r\n\r\n- 场景 1： 维护一个老项目管理后台，日常就是提交各种表单了，这时候你可以把 vue 当成一个 js 库来使用，就用来收集 form 表单，和表单验证。\r\n\r\n- 场景 2： 得到 boss 认可， 后面整个页面的 dom 用 Vue 来管理，抽组件，列表用 v-for 来循环，用数据驱动 DOM 的变化\r\n\r\n- 场景 3: 越来越受大家信赖，领导又找你了，让你去做一个移动端 webapp，直接上了 vue 全家桶！\r\n\r\n场景 1-3 从最初的只因多看你一眼而用了前端 js 库，一直到最后的大型项目解决方案。\r\n\r\n## Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？\r\n\r\n在我看来，渐进式代表的含义是：主张最少。\r\n\r\n每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。\r\n\r\n比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：\r\n\r\n- 必须使用它的模块机制\r\n- 必须使用它的依赖注入\r\n- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）\r\n\r\n所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。\r\n\r\n比如React，它也有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。\r\n\r\n你当然可以只用React的视图层，但几乎没有人这么用，为什么呢，因为你用了它，就会觉得其他东西都很别扭，于是你要引入Flux，Redux，Mobx之中的一个，于是你除了Redux，还要看saga，于是你要纠结业务开发过程中每个东西有没有副作用，纯不纯，甚至你连这个都可能不能忍：\r\n\r\n``` js\r\nconst getData = () =\u003e {\r\n  // 如果不存在，就在缓存中创建一个并返回\r\n  // 如果存在，就从缓存中拿\r\n}\r\n```\r\n\r\n因为你要纠结它有外部依赖，同样是不加参数调用，连续两次的结果是不一样的，于是不纯。\r\n\r\n为什么我一直不认同在中后台项目中使用React，原因就在这里，我反对的是整个业务应用的函数式倾向，很多人都是看到有很多好用的React组件，就会倾向于把它引入，然后，你知道怎么把自己的业务映射到函数式的那套理念上吗？\r\n\r\n函数式编程，无副作用，写出来的代码没有bug，这是真理没错，但是有两个问题需要考虑：\r\n\r\n1. JS本身，有太多特性与纯函数式的主张不适配，这一点，题叶能说得更多\r\n2. 业务系统里面的实体关系，如何组织业务逻辑，几十年来积累了无数的基于设计模式的场景经验，有太多的东西可以模仿，但是，没有人给你总结那么多如何把你的厚重业务映射到函数式理念的经验，这个地方很考验综合水平的，真的每个人都有能力去做这种映射吗？\r\n\r\n函数式编程无bug的根本就在于要把业务逻辑完全都依照这套理念搞好，你看看自己公司做中后台的员工，他们熟悉的是什么？是基于传统OO设计模式的这套东西，他们以为拿着你们给的组件库就得到了一切，但是可能还要被灌输函数式编程的一整套东西，而且又没人告诉他们在业务场景下，如何规划业务模型、组织代码，还要求快速开发，怎么能快起来？\r\n\r\n所以我真是心疼这些人，他们要的只是组件库，却不得不把业务逻辑的思考方式也作转换，这个事情没有一两年时间洗脑，根本洗不到能开发业务的程度。\r\n\r\n没有好组件库的时候，大家痛点在视图层，有了基于React的组件化，把原先没那么痛的业务逻辑部分搞得也痛起来了，原先大家按照设计模式教的东西，照猫画虎还能继续开发了，学了一套新理念之后，都不知道怎么写代码了，怎么写都怀疑自己不对，可怕。\r\n\r\n我宁可支持Angular也不支持React的原因也就在此，Angular至少在业务逻辑这块没有软主张，能够跟OO设计模式那套东西配合得很好。我面对过很多商务场景，都是前端很厚重的东西，不仅仅是管理控制台这种，这类东西里面，业务逻辑的占比要比视图大挺多的，如何组织这些东西，目前几个主流技术栈都没有解决方案，要靠业务架构师去摆平。\r\n\r\n如果你的场景不是这么厚重的，只是简单管理控制台，那当我没说好了。\r\n\r\n框架是不能解决业务问题的，只能作为工具，放在合适的人手里，合适的场景下。\r\n\r\n现在我要说说为什么我这么支持Vue了，没什么，可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。\r\n\r\n渐进式的含义，我的理解是：没有多做职责之外的事。\r\n\r\n## Vue computed 实现\r\n\r\n- 建立与其他属性（如：data、 Store）的联系；\r\n- 属性改变后，通知计算属性重新计算\r\n\r\n\u003e 实现时，主要如下\r\n\r\n- 初始化 data， 使用 `Object.defineProperty` 把这些属性全部转为 `getter/setter`。\r\n- 初始化 `computed`, 遍历 `computed` 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。\r\n- `Object.defineProperty getter` 依赖收集。用于依赖发生变化时，触发属性重新计算。\r\n- 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集\r\n\r\n## Vue complier 实现\r\n\r\n- 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。\r\n- 总的来说，Vue complier 是将 template 转化成一个 render 字符串。\r\n\r\n\u003e 可以简单理解成以下步骤：\r\n\r\n- parse 过程，将 template 利用正则转化成 AST 抽象语法树。\r\n- optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。\r\n- generate 过程，生成 render 字符串\r\n\r\n## 如何编译 template 模板？\r\n\r\n1. 首先第一步实例化一个vue项目\r\n2. 模板编译是在vue生命周期的mount阶段进行的\r\n3. 在mount阶段的时候执行了compile方法将template里面的内容转化成真正的html代码\r\n4. parse阶段是将html转化成 AST 抽象语法树，用来表示template代码的数据结构。在 Vue 中我把它理解为嵌套的、携带标签名、属性和父子关系的 JS 对象，以树来表现 DOM 结构。\r\n\r\n``` js\r\nhtml: \"\u003cdiv id=\"test\"\u003etexttext\u003c/div\u003e\"\r\n// html转换成ast\r\nast: {\r\n  // 标签类型\r\n  type: 1,\r\n  // 标签名\r\n  tag: \"div\",\r\n  // 标签行内属性列表\r\n  attrsList: [{name: \"id\", value: \"test\"}],\r\n  // 标签行内属性\r\n  attrsMap: {id: \"test\"},\r\n  // 标签关系 父亲\r\n  parent: undefined,\r\n  // 字标签属性列表\r\n  children: [{\r\n      type: 3,\r\n      text: 'texttext'\r\n    }\r\n  ],\r\n  plain: true,\r\n  attrs: [{name: \"id\", value: \"'test'\"}]\r\n}\r\n```\r\n5. optimize 会对parse阶段生成的 AST 树进行静态资源优化(静态内容指的是和数据没有关系，不需要每次都刷新的内容)\r\n6. generate 函数会将每一个 AST 节点生成一个render字符串方法，其实就是一个内部调用的方法等待后面的调用。\r\n``` vue\r\n\u003ctemplate\u003e\r\n  \u003cdiv id=\"test\"\u003e\r\n    {{val}}\r\n    \u003cimg src=\"http://xx.jpg\"\u003e\r\n  \u003c/div\u003e\r\n\u003c/template\u003e\r\n// 最后输出\r\n// {render: \"with(this){return _c('div',{attrs:{\"id\":\"test\"}},[[_v(_s(val))]),_v(\" \"),_m(0)])}\"}\r\n```\r\n7. 在complie过程结束之后会生成一个render字符串，接下来就是 new watcher这个时候会对绑定的数据执行监听，render 函数就是数据监听的回调所调用的，其结果便是重新生成 Vnode。当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到我们真正的 DOM 上啦\r\n\r\n## vue 中的性能优化\r\n\r\n### 1）编码优化\r\n\r\n- 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher\r\n- v-if和v-for不能连用\r\n- 如果需要使用v-for给每项元素绑定事件时使用事件代理\r\n- SPA 页面采用keep-alive缓存组件\r\n- 在更多的情况下，使用v-if替代v-show\r\n- key保证唯一\r\n- 使用路由懒加载、异步组件\r\n- 防抖、节流\r\n- 第三方模块按需导入\r\n- 长列表滚动到可视区域动态加载\r\n- 图片懒加载\r\n\r\n### 2）用户体验优化\r\n\r\n- 骨架屏\r\n- PWA（渐进式WEB应用）\r\n- 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。\r\n\r\n### 3）SEO优化\r\n\r\n- 预渲染\r\n- 服务端渲染SSR\r\n\r\n### 4）打包优化\r\n\r\n- 压缩代码；\r\n- Tree Shaking/Scope Hoisting；\r\n- 使用cdn加载第三方模块；\r\n- 多线程打包happypack；\r\n- splitChunks抽离公共文件；\r\n- sourceMap优化；\r\n\r\n说明：优化是个大工程，会涉及很多方面\r\n\r\n## Vue 的实例生命周期\r\n\r\n1. beforeCreate 初始化实例后 数据观测和事件配置之前调用\r\n\r\n2. created 实例创建完成后调用\r\n\r\n3. beforeMount 挂载开始前被用\r\n\r\n4. mounted el 被新建 vm. $el 替换并挂在到实例上之后调用\r\n\r\n5. beforeUpdate 数据更新时调用\r\n\r\n6. updated 数据更改导致的 DOM 重新渲染后调用\r\n\r\n7. beforeDestory 实例被销毁前调用\r\n\r\n8. destroyed 实例销毁后调用\r\n\r\nVue2 与Vue3的生命周期对比\r\n\r\n| 变量 | 实例化(次数) |\r\n| ---- | ---- |\r\n| beforeCreate(组件创建之前) | setup(组件创建之前) |\r\n| created(组件创建完成) | setup(组件创建完成) |\r\n| beforeMount(组件挂载之前) | onBeforeMount(组件挂载之前) |\r\n| mounted(组件挂载完成) | onMounted(组件挂载完成) |\r\n| beforeUpdate(数据更新，虚拟DOM打补丁之前) | onBeforeUpdate(数据更新，虚拟DOM打补丁之前) |\r\n| updated(数据更新，虚拟DOM渲染完成) | onUpdated(数据更新，虚拟DOM渲染完成) |\r\n| beforeDestroy(组件销毁之前) | onBeforeUnmount(组件销毁之前) |\r\n| destroyed(组件销毁之后) | onUnmounted(组件销毁之后) |\r\n\r\n## Vue 的双向数据绑定的原理\r\n\r\nVUE 实现双向数据绑定的原理就是利用了 Object. defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。\r\n\r\nVue3. 0 将用原生 Proxy 替换 Object. defineProperty\r\n\r\n## 为什么要替换 Object.defineProperty？（Proxy 相比于 defineProperty 的优势）\r\n\r\n1. 在 Vue 中，Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。\r\n\r\n2. Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x里，是通过 递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。\r\n\r\n而要取代它的Proxy有以下两个优点:\r\n\r\n- 可以劫持整个对象，并返回一个新对象\r\n- 有13种劫持操作\r\n\r\n既然Proxy能解决以上两个问题，而且Proxy作为es6的新属性在vue2.x之前就有了，为什么vue2.x不使用Proxy呢？一个很重要的原因就是：\r\n\r\nProxy是es6提供的新特性，兼容性不好，最主要的是这个属性无法用polyfill来兼容\r\n\r\n## 什么是 Proxy？\r\n\r\n### 含义：\r\nProxy 是 ES6 中新增的一个特性，翻译过来意思是\"代理\"，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。\r\n\r\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。\r\n\r\n使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。\r\n\r\n### 基本用法：\r\n\r\n``` js\r\nlet p = new Proxy(target, handler);\r\n```\r\n\r\n参数：\r\n\r\n- target 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\r\n- handler 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。\r\n- p 是代理后的对象。当外界每次对 p 进行操作时，就会执行 handler 对象上的一些方法。Proxy共有13种劫持操作，\r\n\r\nhandler代理的一些常用的方法有如下几个：\r\n``` txt\r\nget： 读取\r\nset： 修改\r\nhas： 判断对象是否有该属性\r\nconstruct： 构造函数\r\n```\r\n\r\n### 示例：\r\n\r\n下面就用Proxy来定义一个对象的get和set，作为一个基础demo\r\n\r\n``` js\r\nlet obj = {};\r\nlet handler = {\r\n    get(target, property) {\r\n        console.log( `${property} 被读取` );\r\n        return property in target ? target[property] : 3;\r\n    },\r\n    set(target, property, value) {\r\n        console.log( `${property} 被设置为 ${value}` );\r\n        target[property] = value;\r\n    }\r\n}\r\n\r\nlet p = new Proxy(obj, handler);\r\np.name = 'tom' //name 被设置为 tom\r\np.age; //age 被读取 3\r\n```\r\n\r\np 读取属性的值时，实际上执行的是 handler.get() ：在控制台输出信息，并且读取被代理对象 obj 的属性。\r\n\r\np 设置属性值时，实际上执行的是 handler.set() ：在控制台输出信息，并且设置被代理对象 obj 的属性的值。\r\n\r\n以上介绍了Proxy基本用法，实际上这个属性还有许多内容，具体可参考[Proxy文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\r\n\r\n## 为什么避免 v-if 和 v-for 用在一起\r\n\r\n当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过 v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。\r\n\r\n## 组件的设计原则\r\n\r\n1. 页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块)\r\n2. 每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中)\r\n(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑)\r\n3. 页面不过是组件的容器，组件可以嵌套自由组合成完整的页面\r\n\r\n## vue 等单页面应用及其优缺点\r\n\r\n优点：\r\n1. 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。\r\n2. 前后端职责业分离（前端负责view，后端负责model），架构清晰\r\n3. 减轻服务器的压力\r\n\r\n缺点：\r\n\r\n1. SEO（搜索引擎优化）难度高\r\n2. 初次加载页面更耗时\r\n3. 前进、后退、地址栏等，需要程序进行管理，所以会大大提高页面的复杂性和逻辑的难度\r\n\r\n## `$route`和`$router`的区别\r\n\r\n**$route** 是路由信息对象，包括path，params，hash，query，fullPath，matched，name 等路由信息参数。\r\n\r\n**$router** 是路由实例对象，包括了路由的跳转方法，钩子函数等\r\n\r\n## 什么是 vue 的计算属性？\r\n\r\n定义： 当其依赖的属性的值发生变化的时，计算属性会重新计算。反之则使用缓存中的属性值。 计算属性和vue中的其它数据一样，都是响应式的，只不过它必须依赖某一个数据实现，并且只有它依赖的数据的值改变了，它才会更新。\r\n\r\n## watch的作用是什么\r\n\r\nwatch 主要作用是监听某个数据值的变化。和计算属性相比除了没有缓存，作用是一样的。\r\n\r\n借助 watch 还可以做一些特别的事情，例如监听页面路由，当页面跳转时，我们可以做相应的权限控制，拒绝没有权限的用户访问页面。\r\n\r\n## 计算属性的缓存和方法调用的区别\r\n\r\n计算属性是基于数据的依赖缓存，数据发生变化，缓存才会发生变化，如果数据没有发生变化，调用计算属性直接调用的是存储的缓存值；\r\n\r\n而方法每次调用都会重新计算；\r\n\r\n所以可以根据实际需要选择使用，如果需要计算大量数据，性能开销比较大，可以选用计算属性，如果不能使用缓存可以使用方法；\r\n\r\n其实这两个区别还应加一个watch，watch是用来监测数据的变化，和计算属性相比，是watch没有缓存，但是一般想要在数据变化时响应时，或者执行异步操作时，可以选择watch\r\n\r\n## 指令 v-el 的作用是什么?\r\n\r\n通过`v-el`我们可以获取到`DOM`对象，通过`this.$els[elValue]`获得`DOM`对象；通过`v-ref`获取到整个组件（`component`）的对象，通过`this.$refs[refValue]`获得`Component`实例对象。\r\n\r\n## vuex 有哪几种属性？\r\n\r\n有五种，分别是 State、 Getter、Mutation 、Action、 Module\r\n\r\nvuex的State特性\r\n\r\n1. Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data\r\n2. state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新\r\n3. 它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中\r\n\r\nvuex的Getter特性\r\n1. getters 可以对State进行计算操作，它就是Store的计算属性\r\n2. 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用\r\n3. 如果一个状态只在一个组件内使用，是可以不用getters\r\n\r\nvuex的Mutation特性\r\n1. Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。\r\n\r\n## 不用 Vuex 会带来什么问题？\r\n\r\n可维护性会下降，想修改数据要维护三个地方；\r\n\r\n可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；\r\n\r\n增加耦合，大量的上传派发，会让耦合性大大增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。\r\n\r\n## vue-router 有哪几种导航钩子（ 导航守卫 ）？\r\n\r\n答案：三种\r\n\r\n- 第一种: 全局导航钩子, router.beforeEach(to, from, next)，作用：跳转前进行判断拦截；\r\n``` js\r\nrouter.beforeEach((to, from, next) =\u003e {\r\n  // TODO\r\n});\r\n```\r\n\r\n- 第二种：单独路由独享组件；\r\n``` js\r\n{\r\n  path: '/home',\r\n  name: 'home',\r\n  component: Home,\r\n  beforeEnter(to, from, next) {\r\n    // TODO\r\n  }\r\n}\r\n```\r\n\r\n- 第三种：组件内的钩子。\r\n``` js\r\nbeforeRouteEnter(to, from, next) {\r\n  // do someting\r\n  // 在渲染该组件的对应路由被 confirm 前调用\r\n},\r\nbeforeRouteUpdate(to, from, next) {\r\n  // do someting\r\n  // 在当前路由改变，但是依然渲染该组件是调用\r\n},\r\nbeforeRouteLeave(to, from ,next) {\r\n  // do someting\r\n  // 导航离开该组件的对应路由时被调用\r\n}\r\n```\r\n\r\n## vue-router 实现路由懒加载（ 动态加载路由 ）\r\n\r\nvue项目实现按需加载的3种方式：vue异步组件、es提案的import()、webpack的require.ensure()\r\n\r\n### vue异步组件技术\r\n\r\n- vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。\r\n\r\n但是，这种情况下一个组件生成一个js文件。\r\n\r\n举例如下：\r\n\r\n``` vue\r\n{\r\n  path: '/promisedemo',\r\n  name: 'PromiseDemo',\r\n  component: resolve =\u003e require(['../components/PromiseDemo'], resolve)\r\n}\r\n```\r\n\r\n### es提案的import()\r\n\r\n- 推荐使用这种方式(需要webpack \u003e 2.4)\r\n- webpack官方文档：webpack中使用import()\r\n\r\nvue官方文档：[路由懒加载(使用import())](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E6%8A%8A%E7%BB%84%E4%BB%B6%E6%8C%89%E7%BB%84%E5%88%86%E5%9D%97)\r\n\r\n- vue-router配置路由，代码如下：\r\n\r\n``` vue\r\n// 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。\r\nconst ImportFuncDemo1 = () =\u003e import('../components/ImportFuncDemo1')\r\nconst ImportFuncDemo2 = () =\u003e import('../components/ImportFuncDemo2')\r\n// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。\r\n// const ImportFuncDemo = () =\u003e import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo')\r\n// const ImportFuncDemo2 = () =\u003e import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo2')\r\nexport default new Router({\r\n  routes: [\r\n    {\r\n      path: '/importfuncdemo1',\r\n      name: 'ImportFuncDemo1',\r\n      component: ImportFuncDemo1\r\n    },\r\n    {\r\n      path: '/importfuncdemo2',\r\n      name: 'ImportFuncDemo2',\r\n      component: ImportFuncDemo2\r\n    }\r\n  ]\r\n})\r\n```\r\n\r\n### webpack提供的require.ensure()\r\n\r\n- vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。\r\n\r\n这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。\r\n\r\n举例如下：\r\n\r\n``` vue\r\n{\r\n  path: '/promisedemo',\r\n  name: 'PromiseDemo',\r\n  component: resolve =\u003e require.ensure([], () =\u003e resolve(require('../components/PromiseDemo')), 'demo')\r\n},\r\n{\r\n  path: '/hello',\r\n  name: 'Hello',\r\n  // component: Hello\r\n  component: resolve =\u003e require.ensure([], () =\u003e resolve(require('../components/Hello')), 'demo')\r\n}\r\n```\r\n\r\n## 谈一谈 Vue.$nextTick 的原理\r\n\r\n- 在下次 DOM 更新循环结束之后执行延迟回调。\r\n\r\n- nextTick主要使用了宏任务和微任务。\r\n\r\n- 根据执行环境分别尝试采用\r\n  Promise MutationObserver setImmediate\r\n\r\n如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。\r\n\r\n## Vue 的父组件和子组件生命周期钩子执行顺序是什么\r\n\r\n- 加载渲染过程\r\n  - 父beforeCreate-\u003e父created-\u003e父beforeMount-\u003e子beforeCreate-\u003e子created-\u003e子beforeMount-\u003e子mounted-\u003e父mounted\r\n\r\n- 子组件更新过程\r\n  - 父beforeUpdate-\u003e子beforeUpdate-\u003e子updated-\u003e父updated\r\n\r\n- 父组件更新过程\r\n  - 父beforeUpdate-\u003e父updated\r\n\r\n- 销毁过程\r\n  - 父beforeDestroy-\u003e子beforeDestroy-\u003e子destroyed-\u003e父destroyed\r\n\r\n## Vue实现通信方式\r\n\r\n### 方式1: props\r\n1. 通过一般属性实现父向子通信\r\n2. 通过函数属性实现子向父通信\r\n3. 缺点: 隔代组件和兄弟组件间通信比较麻烦\r\n\r\n### 方式2: vue自定义事件\r\n1. vue内置实现, 可以代替函数类型的props\r\n  - 绑定监听: \\\u003cMyComp @eventName=\"callback\"\r\n  - 触发(分发)事件: this.$emit(\"eventName\", data)\r\n2. 缺点: 只适合于子向父通信\r\n\r\n### 方式3: 消息订阅与发布\r\n1. 需要引入消息订阅与发布的实现库, 如: pubsub-js\r\n  - 订阅消息: PubSub.subscribe('msg', (msg, data)=\u003e{})\r\n  - 发布消息: PubSub.publish(‘msg’, data)\r\n2. 优点: 此方式可用于任意关系组件间通信\r\n\r\n### 方式4: vuex\r\n1. 是什么: vuex是vue官方提供的集中式管理vue多组件共享状态数据的vue插件\r\n2. 优点: 对组件间关系没有限制, 且相比于pubsub库管理更集中, 更方便\r\n\r\n### 方式5: slot\r\n1. 是什么: 专门用来实现父向子传递带数据的标签\r\n  - 子组件\r\n  - 父组件\r\n2. 注意: 通信的标签模板是在父组件中解析好后再传递给子组件的\r\n\r\n## 说说Vue的MVVM实现原理\r\n\r\n- 1. Vue作为MVVM模式的实现库的2种技术\r\n  - 模板解析\r\n  - 数据绑定\r\n\r\n- 2. 模板解析: 实现初始化显示\r\n  - 解析大括号表达式\r\n  - 解析指令\r\n\r\n- 3. 数据绑定: 实现更新显示\r\n  - 通过数据劫持实现\r\n\r\n## Vue.use是干什么的？原理是什么？\r\n\r\nvue.use 是用来使用插件的，我们可以在插件中扩展全局组件、指令、原型方法等。\r\n\r\n- 1. 检查插件是否注册，若已注册，则直接跳出；\r\n\r\n- 2. 处理入参，将第一个参数之后的参数归集，并在首部塞入 this 上下文；\r\n\r\n- 3. 执行注册方法，调用定义好的 install 方法，传入处理的参数，若没有 install 方法并且插件本身为 function 则直接进行注册；\r\n\r\n  - 插件不能重复的加载\r\n\r\n    install 方法的第一个参数是vue的构造函数，其他参数是Vue.use中除了第一个参数的其他参数； 代码：args.unshift(this)\r\n\r\n  - 调用插件的install 方法 代码：typeof plugin.install === 'function'\r\n\r\n  - 插件本身是一个函数，直接让函数执行。 代码：plugin.apply(null, args)\r\n\r\n  - 缓存插件。 代码：installedPlugins.push(plugin)\r\n\r\n``` ts\r\nexport function toArray (list: any, start?: number): Array\u003cany\u003e {\r\n  start = start || 0\r\n  let i = list.length - start\r\n  const ret: Array\u003cany\u003e = new Array(i)\r\n  while (i--) {\r\n    ret[i] = list[i + start]\r\n  }\r\n  return ret\r\n}\r\n\r\n\r\nexport function initUse (Vue: GlobalAPI) {\r\n  Vue.use = function (plugin: Function | Object) {\r\n    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\r\n    if (installedPlugins.indexOf(plugin) \u003e -1) {\r\n      return this\r\n    }\r\n\r\n    // additional parameters\r\n    const args = toArray(arguments, 1)\r\n    args.unshift(this)\r\n    if (typeof plugin.install === 'function') {\r\n      plugin.install.apply(plugin, args)\r\n    } else if (typeof plugin === 'function') {\r\n      plugin.apply(null, args)\r\n    }\r\n    installedPlugins.push(plugin)\r\n    return this\r\n  }\r\n}\r\n```\r\n\r\n## new Vue() 发生了什么？\r\n\r\n1. 结论：new Vue()是创建Vue实例，它内部执行了根实例的初始化过程。\r\n\r\n2. 具体包括以下操作：\r\n\r\n选项合并\r\n\r\n`$children`，`$refs`，`$slots`，`$createElement`等实例属性的方法初始化\r\n\r\n自定义事件处理\r\n\r\n数据响应式处理\r\n\r\n生命周期钩子调用 （beforecreate created）\r\n\r\n可能的挂载\r\n\r\n3. 总结：new Vue()创建了根实例并准备好数据和方法，未来执行挂载时，此过程还会递归的应用于它的子组件上，最终形成一个有紧密关系的组件实例树。\r\n\r\n## 请说一下Vue响应式数据的理解？\r\n\r\n根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。\r\n\r\n1. 对象内部通过defineReactive方法，使用Object. defineProperty() 监听数据属性的 get 来进行数据依赖收集，再通过 set 来完成数据更新的派发；\r\n\r\n2. 数组则通过重写数组方法来实现的。扩展它的 7 个变更⽅法，通过监听这些方法可以做到依赖收集和派发更新；( push/pop/shift/unshift/splice/reverse/sort )\r\n\r\n这里在回答时可以带出一些相关知识点 （比如多层对象是通过递归来实现劫持，顺带提出vue3中是使用 proxy来实现响应式数据）\r\n\r\n补充回答：\r\n\r\n内部依赖收集是怎么做到的，每个属性都拥有自己的dep属性，存放他所依赖的 watcher，当属性变化后会通知自己对应的 watcher去更新。\r\n\r\n响应式流程：\r\n\r\n1. defineReactive 把数据定义成响应式的；\r\n\r\n2. 给属性增加一个 dep，用来收集对应的那些watcher；\r\n\r\n3. 等数据变化进行更新\r\n\r\ndep.depend() // get 取值：进行依赖收集\r\n\r\ndep.notify() // set 设置时：通知视图更新\r\n\r\n这里可以引出性能优化相关的内容：\r\n\r\n1. 对象层级过深，性能就会差。\r\n\r\n2. 不需要响应数据的内容不要放在data中。\r\n\r\n3. object.freeze() 可以冻结数据。\r\n\r\n## Vue如何检测数组变化？\r\n\r\n数组考虑性能原因没有用defineProperty对数组的每一项进行拦截，而是选择重写数组方法。当数组调用到这 7 个方法的时候，执行 ob.dep.notify() 进行派发通知 Watcher 更新；\r\n\r\n重写数组方法：push/pop/shift/unshift/splice/reverse/sort\r\n\r\n补充回答：\r\n\r\n在Vue中修改数组的索引和长度是无法监控到的。需要通过以下7种变异方法修改数组才会触发数组对应的wacther进行更新。数组中如果是对象数据类型也会进行递归劫持。\r\n\r\n说明：那如果想要改索引更新数据怎么办？\r\n\r\n可以通过Vue.set()来进行处理 =》 核心内部用的是 splice 方法。\r\n\r\n``` js\r\n// 取出原型方法；\r\n\r\nconst arrayProto = Array.prototype\r\n\r\n// 拷贝原型方法；\r\n\r\nexport const arrayMethods = Object.create(arrayProto)\r\n\r\n// 重写数组方法；\r\n\r\ndef(arrayMethods, method, function mutator (... args) { }\r\n\r\nob.dep.notify() // 调用方法时更新视图；\r\n```\r\n\r\n## Vue.set 方法是如何实现的？\r\n\r\n为什么$set可以触发更新，我们给对象和数组本身都增加了dep属性，当给对象新增不存在的属性则触发对象依赖的watcher去更新，当修改数组索引时我们调用数组本身的splice方法去更新数组。\r\n\r\n补充回答：\r\n\r\n官方定义Vue.set(object, key, value)\r\n\r\n如果是数组，调用重写的splice方法 （这样可以更新视图 ）\r\n代码：target.splice(key, 1, val)\r\n\r\n如果不是响应式的也不需要将其定义成响应式属性。\r\n\r\n如果是对象，将属性定义成响应式的 defineReactive(ob, key, val)\r\n\r\n通知视图更新 ob.dep.notify()\r\n\r\n## Vue3.x响应式数据原理\r\n\r\nVue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。\r\n\r\n## Vue3.x中Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？\r\n\r\n判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。\r\n\r\n## Vue3.x中监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？\r\n\r\n我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。\r\n\r\n## vue2.x中如何监测数组变化\r\n\r\n- 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。\r\n- 这样当调用数组api时，可以通知依赖更新。\r\n- 如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。\r\n\r\n## Vue2.x和Vue3.x渲染器的diff算法分别说一下\r\n\r\n简单来说，diff算法有以下过程\r\n\r\n- 同级比较，再比较子节点\r\n- 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\r\n- 比较都有子节点的情况(核心diff)\r\n- 递归比较子节点\r\n- 正常Diff两个树的时间复杂度是O(n^3) ，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -\u003e O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。\r\n\r\nVue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。\r\n\r\nVue3.x借鉴了 ivi算法和 inferno算法\r\n\r\n在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)\r\n\r\n## Vue SSR了解吗？\r\n\r\n- SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\r\n\r\n- SSR有着更好的SEO、并且首屏加载速度更快等优点。\r\n\r\n- 不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。\r\n\r\n- 还有就是服务器会有更大的负载需求。\r\n\r\n## 组件中写 name选项有哪些好处及作用？\r\n\r\n- 可以通过名字找到对应的组件（ 递归组件 ）\r\n\r\n- 可以通过name属性实现缓存功能 (keep-alive)\r\n\r\n- 可以通过name来识别组件（跨级组件通信时非常重要）\r\n\r\n``` vue\r\nVue.extend = function () {\r\n    if(name) {\r\n        Sub.options.componentd[name] = Sub\r\n    }\r\n}\r\n```\r\n\r\n## vue的diff算法和react的diff算法的区别\r\n\r\nvue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。\r\n\r\n1. vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。\r\n\r\n2. vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。\r\n\r\n## vue3带来的新特性/亮点\r\n\r\n- Performance\r\n  Proxy\r\n- tree sharking\r\n- composition api\r\n  defineComponent, onMounted, onUnmounted, ref, setup 类似react hocks，代替mixin\r\n- Fragment, Teleport, Suspense\r\n  类似ReactFragment，Portal，Suspense\r\n- Typescript\r\n\r\n- Custom Render API\r\n  这个api定义了虚拟DOM的渲染规则，这意味着使用自定义API可以达到跨平台的目的。\r\n\r\n## keep-alive实现原理\r\n\r\nkeep-alive是Vue.js的一个内置组件。它能够不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。\r\n\r\n它提供了include与exclude两个属性，允许组件有条件地进行缓存。\r\n\r\n## 深入keep-alive组件实现\r\n\r\n说完了keep-alive组件的使用，我们从源码角度看一下keep-alive组件究竟是如何实现组件的缓存的呢？\r\n\r\ncreated与destroyed钩子\r\n\r\ncreated钩子会创建一个cache对象，用来作为缓存容器，保存vnode节点。\r\n\r\n``` vue\r\ncreated () {\r\n    /* 缓存对象 */\r\n    this.cache = Object.create(null)\r\n    // 记录缓存组件vnode的个数\r\n    this.keys = []\r\n},\r\n```\r\n\r\ndestroyed钩子则在组件被销毁的时候清除cache缓存中的所有组件实例。\r\n\r\n``` vue\r\n/* destroyed钩子中销毁所有cache中的组件实例 */\r\ndestroyed () {\r\n    for (const key in this.cache) {\r\n      pruneCacheEntry(this.cache, key, this.keys)\r\n    }\r\n},\r\n```\r\n\r\n### render\r\n\r\n``` vue\r\nrender () {\r\n  const vnode: VNode = getFirstComponentChild(this.$slots.default)\r\n  const componentOptions: ?VNodeComponentOptions = vnode \u0026\u0026 vnode.componentOptions\r\n  if (componentOptions) {\r\n    // check pattern\r\n    const name: ?string = getComponentName(componentOptions)\r\n    if (name \u0026\u0026 (\r\n      (this.include \u0026\u0026 !matches(this.include, name)) ||\r\n      (this.exclude \u0026\u0026 matches(this.exclude, name))\r\n    )) {\r\n      return vnode\r\n    }\r\n\r\n    const { cache, keys } = this\r\n    const key: ?string = vnode.key == null\r\n      // same constructor may get registered as different local components\r\n      // so cid alone is not enough (#3269)\r\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')\r\n      : vnode.key\r\n    if (cache[key]) {\r\n      vnode.componentInstance = cache[key].componentInstance\r\n      // make current key freshest\r\n      remove(keys, key)\r\n      keys.push(key)\r\n    } else {\r\n      cache[key] = vnode\r\n      keys.push(key)\r\n      // prune oldest entry\r\n      if (this.max \u0026\u0026 keys.length \u003e parseInt(this.max)) {\r\n        pruneCacheEntry(cache, keys[0], keys, this._vnode)\r\n      }\r\n    }\r\n\r\n    vnode.data.keepAlive = true\r\n  }\r\n  return vnode\r\n}\r\n```\r\n\r\n### watch\r\n\r\n用watch来监听include与exclude这两个属性的改变，在改变的时候修改cache缓存中的缓存数据。\r\n\r\n``` vue\r\nwatch: {\r\n    /* 监视include以及exclude，在被修改的时候对cache进行修正 */\r\n    include (val: string | RegExp) {\r\n        pruneCache(this.cache, this._vnode, name =\u003e matches(val, name))\r\n    },\r\n    exclude (val: string | RegExp) {\r\n        pruneCache(this.cache, this._vnode, name =\u003e !matches(val, name))\r\n    }\r\n},\r\n```\r\n\r\n## vue修饰符\r\n\r\n- .capture\r\n\r\n添加事件监听器时使用事件捕获模式\r\n\r\n- .passive\r\n\r\n默认行为将会立即触发\r\n\r\n修饰符尤其能够提升移动端的性能。\r\n\r\n``` vue\r\n\u003c!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --\u003e\r\n\u003c!-- 而不会等待 `onScroll` 完成  --\u003e\r\n\u003c!-- 这其中包含 `event.preventDefault()` 的情况 --\u003e\r\n\u003cdiv v-on:scroll.passive=\"onScroll\"\u003e...\u003c/div\u003e\r\n```\r\n\r\n- .self\r\n\r\n添加事件监听器时使用事件捕获模式\r\n\r\n## v-model的实现原理\r\n\r\n你可以用 `v-model` 指令在表单 `\u003cinput\u003e`、`\u003ctextarea\u003e` 及 `\u003cselect\u003e` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 `v-model` 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。\r\n\r\n`v-model` 在内部为不同的输入元素使用不同的 `property` 并抛出不同的事件：\r\n\r\n- `text` 和 `textarea` 元素使用 `value` property 和 `input` 事件；\r\n- `checkbox` 和 `radio` 使用 `checked` property 和 `change` 事件；\r\n- `select` 字段将 `value` 作为 property 并将 `change` 作为事件。\r\n\r\n``` vue\r\n\u003cinput v-model=\"msg\" /\u003e\r\n\r\n// 相当于\r\n\r\n\u003cinput v-bind:value=\"msg\" @input=\"msg=$event.target.value\" /\u003e\r\n```\r\n\r\n## vm.$isServer, vm.$attrs 和 vm.$listeners 含义\r\n\r\n### vm.$isServer\r\n\r\n当前 Vue 实例是否运行于服务器。\r\n\r\n### vm.$attrs\r\n\r\n包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。\r\n\r\n### vm.$listeners\r\n\r\n包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用。\r\n\r\n## vue中methods与computed，filters，watch的区别\r\n\r\n### methods\r\n\r\n不是响应式的\r\n\r\nmethods属性里面的方法会在数据发生变化的时候你，只要引用了此里面分方法，方法就会自动执行。这个属性没有依赖缓存。\r\n\r\n### computed\r\n\r\n响应式的\r\n\r\ncomputed属性，是一个计算属性，该属性里面的方法名相当于data属性里面的key，他可以作为key值使用，该属性里面的方法必须要有return返回值，这个返回值就是（value值）。computed属性是有依赖缓存的。\r\n\r\n### filters\r\n\r\nfilters属性，是过滤器属性，在vue2.0以后取消了vue本身自带的过滤器，但是我们可以通过自定义过滤器来实现相应的功能。改属性里面的方法需要有一个参数，这个参数是我们在运用过滤器的时候的数据，通过各过滤器方法的返回值，就是我们在页面上实际渲染的东西。\r\n\r\n### watch\r\n\r\nwatch属性，是监听属性。这个监听的是data属性里面的数据，当这个数据发生变化时，将自动执行这个函数。\r\n\r\n## Vue两个简易代替vuex的方法\r\n\r\n### eventBus\r\n\r\n声明一个全局Vue实例变量 eventBus , 把所有的通信数据，事件监听都存储到这个变量上\r\n\r\n### Vue.observable\r\n\r\n让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。\r\n\r\n返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：\r\n\r\n## 如果让你封装一个通用的弹框组件，你会从哪些方面考虑\r\n\r\n1. 首先写好弹框的样式布局和交互，完成一个基础版本。\r\n\r\n2. 组件API设计：提取出通用的props,event,slot,作为API让使用者使用的时候去传值。\r\n\r\n3. 进一步思考：考虑弹框层级问题，可以通过手动挂载将弹框和#app元素放在同一层级，或者使用Vue3提供的Teleport组件。\r\n\r\n组件封装和组件库的问题，还可以更深入地和面试官聊。比如：\r\n\r\n- 组件库的组件通信问题.\r\n- 组件库文档设计问题。\r\n- render函数在组件封装的应用。\r\n- 作用域插槽在组件封装的应用。\r\n- 组件库动画组件的封装。\r\n- TS在组件库的应用。\r\n- 自动化测试在组件库的应用。\r\n- ...\r\n\r\n关于Vue组件库的方方面面，后续我也将会出专栏详细讲解，感兴趣的小伙伴可以持续关注。\r\n\r\n## Vue组件通信有哪些方式，适用场景分别是什么\r\n\r\n- 父 -\u003e 子：props。\r\n- 子 -\u003e 父：自定义事件。\r\n- provie/inject：父级组件 -\u003e 子孙组件。\r\n- Event Bus：适用于任意组件之间通信，利用$on和$emit通过事件传递数据，也常用于封装组件库时的组件通信。\r\n- 通过组件实例，比如通过$children获取子组件实例，然后就可以在父组件中调用子组件的方法。\r\n- Vuex：适用于复杂应用的全局状态管理。\r\n\r\n## Vue哪个生命周期发送数据请求\r\n\r\n1. created：发送请求时机通常越早越好，beforeCreate最早，但是很多时候我们发送请求需要依赖data和props中的数据或者调用methods里的方法,而这些是在created实例创建之后才有的，所以一般发送请求会放在created。\r\n\r\n2. mounted：除了created之外，mounted也常用来发送请求，其实这两者区别通常不大。因为生命周期是同步的，而请求是异步的。不管在created还是mounted里发请求，都不会阻塞页面渲染，请求都是在下一次事件循环才完成的。\r\n\r\n## Vue的data为什么必须是函数\r\n\r\n组件是用来复用的，且Vue组件和Vue实例之间是通过原型链来继承的。如果data是一个对象，那么在组件复用时，多个组件将共享一个data对象，这样一个组件的状态改变会影响到其他组件。\r\n\r\n将data选项定义为函数，因为函数每次调用返回的都是一个全新的对象，从而避免状态影响。\r\n\r\n## computed和watch使用场景有什么不同，实现原理呢\r\n\r\n### computed\r\n\r\n- computed是值，依赖于其它的状态。比如购物车的总价格，可以根据其它几个价格算得。\r\n- computed有缓存特性，只要依赖的状态没有改变，computed的值就会被缓存起来。当依赖发生变化时，才会重新计算。\r\n\r\n### watch\r\n\r\n- watch用于监听状态的变化，比方说监听路由，一旦监听的状态发生变化，就执行某个函数。\r\n- watch有两个参数也是面试常考点，\r\n  - immediate：当我们希望在组件初始化时执行一次watch函数，就可以开启immediate选项\r\n  - deep：深度监听，开启此选项当监听的对象的某个属性值发生变化，也会触发watch监听函数\r\n\r\n实现原理：\r\n\r\n- computed和watch都是基于Vue响应式原理，首先通过initWatcher和initComputed来解析watch和computed选项，然后遍历，给每个watch和computed添加Watcher对象。\r\n- 不同的是给computed添加的Watcher对象是lazy Watcher，默认不执行，取值的时候才执行。\r\n- computed的缓存特性是通过Watcher对象的dirty属性来实现的。\r\n\r\n## Vue怎么实现数据响应式\r\n\r\n- **数据劫持**：Vue实现数据响应式的核心是使用了Object.defineProperty方法对数据对象进行劫持，实现对数据的监听。\r\n\r\n- **依赖搜集**：Vue之所以可以做到细粒度的更新，不需要像React那样全量diff，核心就在于Vue的依赖搜集。当数据对象的属性被读取时，会触发getter并创建Watcher对象，Watcher对象存储的就是依赖关系，然后将Watcher对象存到依赖收集器（Dep）对象中，这样就完成了依赖收集。\r\n\r\n关于Vue响应式实现原理，此处只是做了一个大略简短的总结，至于其中细节，后续我也会出文章和专栏详细讲解。\r\n\r\n## Vue2中怎么检测数组的变化\r\n\r\n由于Object.defineProperty的限制性，导致Vue2的响应式无法直接监听到对象属性增加或删除的变化以及数组的变化。\r\n\r\nVue2重写了数组的push()、pop()、shift()、unshift()、splice()、sort()和reverse()方法，使用这些方法更改数组，Vue可以监听到。\r\n\r\n对于更改数组索引或者更改数组指定位置元素的操作，可以使用$set这个API。\r\n\r\n## 谈一谈对MVVM的理解？Vue实现双向数据绑定原理是什么\r\n\r\nMVVM，简单来说，就是数据和视图的双向绑定，Model-View和View-Model。\r\n\r\nVue是双向绑定的，数据更改时，视图自动更改。在表单应用中，当用户输入引起页面变更的时候，v-model的数据也会自动发生更新。\r\n\r\nReact是单向绑定的，React只是当数据变更时，视图自动更新。而在用户输入的时候，数据模型不会自动变更。不过在开发表单应用的时候，我们也可以自行给React封装上双向绑定这个功能。\r\n\r\nMVVM是UI开发的一个大趋势，除了前端之外，像Android Jetpack里的Data Binding和IOS的Swift UI，都是摒弃了以往的MVC或者MVP，采用MVVM的方式来组织代码。\r\n\r\nVue双向绑定实现原理：\r\n\r\n- 双向绑定的实现分为两层：数据 -\u003e 视图、视图 -\u003e 数据。\r\n- 从数据到视图的绑定就是Vue实现响应式那一套，利用数据劫持和观察者模式对数据进行监听，当数据变更时，通知视图更新。\r\n- 从视图到数据的绑定实现原理比较简单，是通过监听输入框地input事件，将输入框的值赋给绑定的数据对象属性。\r\n\r\n## 什么是虚拟DOM，有什么作用？有了解过diff算法吗\r\n\r\n所谓虚拟DOM，简单点说就是个JS对象，它是比DOM更轻量级的对UI的描述。在Vue中，就是由VNode节点构成的树形对象。\r\n\r\n### 虚拟DOM的作用\r\n\r\n- 跨平台：因为是纯JS对象，所以可以在任意能运行JS的地方运行，比如SSR和混合开发。\r\n- 相对还不错的渲染性能：虚拟DOM可以将DOM操作转换为JS对象操作，通过对比新旧虚拟DOM树的差异（也就是diff算法），只更新发生变化的部分，从而减少不必要的DOM操作，提高渲染性能。但是这种性能提升只是相对的，因为Svelte已经证明了不用虚拟Dom性能也可以很好。\r\n\r\n### Vue diff算法相关知识点\r\n\r\n- 基于Snabbdom：Vue的diff算法是基于三方库Snabbdom的diff算法基础上优化得来的。\r\n- 采用双端比较：Vue的diff算法采用了双端比较的方式，即同时对新旧两个vnode进行比较。这种方式可以最大限度地复用已有的DOM元素，减少不必要的DOM操作，从而提高更新性能。\r\n- 使用 key 进行原地复用：当 diff 算法比较两个vnode时，会先按照 key 值进行比较，如果 key 值相同，则认为这两个vnode是同一个节点，可以进行复用。否则，Vue会将旧节点从DOM中删除，重新创建新节点并插入到DOM中。\r\n- 静态节点优化：Vue的diff算法对静态节点进行了优化，即对不需要更新的节点进行缓存，减少不必要的比较和更新操作。\r\n- 当比较两个节点时，会首先比较它们的节点类型，如果不同，则直接替换。如果类型相同，则会继续比较节点的key、数据和子节点等属性，找出它们之间的差异，从而更新DOM。\r\n\r\n## Vue模板编译原理了解吗\r\n\r\n模板编译流程：\r\n\r\n模板编译的目标是要把template模板转换成渲染函数，主要分成3个步骤，parse -\u003e optimize -\u003e generate ，记住这三个单词。\r\n\r\n1. parse(解析模板)：首先会用正则等方式将模板解析为 AST（抽象语法树），这个过程包括词法分析和语法分析两个过程。在这个过程中，模板会被分解成一些列的节点，包括普通元素节点、文本节点、注释节点等，同时也会解析出这些节点的标签名、属性、指令等信息。\r\n\r\n2. optimize(静态分析)：静态分析是指分析模板中的所有节点，找出其中的静态节点和静态属性，并将其标记出来。所谓静态节点是指节点的内容不会发生变化的节点，例如纯文本节点、含有静态属性的节点等，而静态属性则是指节点上的属性值不会改变的属性，例如 class 和 style 属性。标记静态节点和静态属性可以帮助 Vue 在后续的更新中跳过这些节点的比对和更新过程，从而提高应用的性能。\r\n\r\n3. generate(代码生成)：将 AST 转换为可执行的渲染函数。\r\n\r\n## 怎么做Vue自动化测试\r\n\r\n### 测试方案\r\n\r\n- 测试框架：Jest或者Mocha，Vue脚手架创建项目的时候会询问，这两个选一个就行。\r\n- 测试工具：@vue/test-utils，专门用于Vue测试的工具包。\r\n\r\n### 测什么\r\n\r\n- 测组件有没有正确渲染。\r\n- 测组件API，包括props,event,slot。\r\n- 测事件函数有没有正常触发。\r\n- 测路由能不能正常触发。\r\n- 测函数逻辑是否正确。\r\n- 测计算属性。\r\n- 测watch。\r\n- 测Vuex。\r\n- 等等，你写的代码几乎都可以测。。。\r\n\r\n举一个简单的测Button按钮组件的例子：\r\n\r\n``` javascript\r\n// 引入需要的测试工具和Button组件\r\nimport { mount } from '@vue/test-utils'\r\nimport Button from '@/components/Button.vue'\r\n\r\ndescribe('Button', () =\u003e {\r\n  it('renders default button', () =\u003e {\r\n    // 渲染组件\r\n    const wrapper = mount(Button)\r\n\r\n    // 断言组件渲染出来的html符合预期\r\n    expect(wrapper.html()).toContain('\u003cbutton class=\"btn\"\u003eButton\u003c/button\u003e')\r\n  })\r\n\r\n  it('renders primary button', () =\u003e {\r\n    // 渲染带有primary属性的Button组件\r\n    const wrapper = mount(Button, {\r\n      propsData: {\r\n        primary: true\r\n      }\r\n    })\r\n\r\n    // 断言组件渲染出来的html符合预期\r\n    expect(wrapper.html()).toContain('\u003cbutton class=\"btn btn-primary\"\u003eButton\u003c/button\u003e')\r\n  })\r\n\r\n  it('triggers click event', () =\u003e {\r\n    // 创建一个mock函数，用于测试点击事件是否被调用\r\n    const mockFn = jest.fn()\r\n\r\n    // 渲染Button组件，并在点击事件中调用mock函数\r\n    const wrapper = mount(Button, {\r\n      propsData: {\r\n        onClick: mockFn\r\n      }\r\n    })\r\n\r\n    // 触发按钮的点击事件\r\n    wrapper.trigger('click')\r\n\r\n    // 断言mock函数被调用\r\n    expect(mockFn).toHaveBeenCalled()\r\n  })\r\n})\r\n```\r\n\r\n## 什么是自定义指令，怎么实现\r\n\r\nVue自定义指令可以用来复用代码，封装常用的DOM操作或行为。常见的自定义指令有监听滚动事件、图片懒加载、设置loading、权限管理等。\r\n\r\n自定义指令可以全局注册或局部注册，注册后可以在模板中使用 v-前缀调用，如 v-mydirective。\r\n\r\n自定义指令的实现需要定义一个对象，其中包含指令名称、生命周期钩子函数和更新函数等属性，具体如下：\r\n\r\n- bind钩子函数：指令第一次绑定到元素时触发，可以用于初始化一些数据或添加事件监听器等操作。\r\n- inserted钩子函数：指令所在元素插入到父节点后触发，常用于添加一些 UI 元素或获取焦点等操作。\r\n- update钩子函数：指令所在元素更新时触发，可以获取新旧值并进行比较后更新UI。\r\n- componentUpdated钩子函数：指令所在元素及其子节点全部更新后触发，常用于需要操作DOM的指令，如监听滚动事件。\r\n- unbind钩子函数：指令与元素解绑时触发，可以清除绑定的事件监听器等操作。\r\n\r\n举个例子：\r\n\r\n``` javascript\r\nVue.directive('focus', {\r\n  inserted: function (el) {\r\n    el.focus()\r\n  }\r\n})\r\n```\r\n该指令实现元素自动获取焦点功能，在模板中使用该指令：\r\n\r\n``` html\r\n\u003cinput v-focus\u003e\r\n```\r\n\r\n## keep-alive适用场景是什么，实现原理是什么\r\n\r\n1. **适用场景**：keep-alive是Vue提供的一个内置组件，用于在组件之间缓存不活动的组件实例，从而提高组件的渲染性能。keep-alive的使用场景主要是那些需要频繁切换的组件，比如tab切换、列表滚动等。\r\n\r\n当一个组件被包裹在keep-alive组件中时，这个组件实例将会被缓存起来。当组件被切换出去时，它的状态会被保存下来，而不是被销毁。当组件被再次渲染时，它的状态将被恢复，从而避免了重新渲染和重新创建组件实例的开销。\r\n\r\n``` html\r\n\u003ctemplate\u003e\r\n  \u003cdiv\u003e\r\n    \u003ckeep-alive\u003e\r\n      \u003crouter-view v-if=\"$route.meta.keepAlive\"\u003e\u003c/router-view\u003e\r\n    \u003c/keep-alive\u003e\r\n    \u003crouter-view v-if=\"!$route.meta.keepAlive\"\u003e\u003c/router-view\u003e\r\n  \u003c/div\u003e\r\n\u003c/template\u003e\r\n```\r\n\r\n2. **实现原理**：\r\n\r\n- 抽象组件：keep-alive组件是一个抽象组件，没有模板，只包含逻辑。\r\n- LRU缓存算法：几乎只要有缓存的地方，就有LRU缓存算法的影子。keep-alive的实现是通过在组件内部维护一个缓存对象来实现的。这个缓存对象是一个类似于LRU缓存的数据结构，它会自动缓存最近使用的组件实例，并根据缓存大小限制自动释放最不常用的组件实例。当keep-alive组件内部渲染时，它会检查缓存对象中是否已经存在对应的组件实例，如果存在则直接取出并渲染，否则就创建一个新的组件实例并添加到缓存中。\r\n\r\n## nextTick有什么作用，实现原理是什么\r\n\r\nnextTick使用场景很简单，一般用来操作dom。\r\n\r\n1. **批量更新**：由于Vue的批量更新策略导致Vue的更新是异步更新，所以改变状态不能立马生效，需要等到下一次事件循环才能获取到更新后的Dom。\r\n\r\n2. **基于事件循环**：nextTick的作用就相当于定时器或者微任务，事实上我们把nextTick换成setTimeout，也能达到一样的效果。\r\n\r\n3. **优雅降级**：Vue在实现nextTick的时候采取了优雅降级的策略，会判断浏览器是否支持Promise，如果支持，就优先采用Promise，然后依次降级成setImeediate -\u003e setTimeout。\r\n\r\n## 讲一下你对SSR的了解\r\n\r\n- 相比于SSR，我们平时开发的基于Vue的单页应用叫CSR。\r\n- SSR的优点：更好的SEO、优化首屏加载。\r\n- SSR缺点：学习开发成本高，运维成本高，需要额外部署，踩坑较多。\r\n- SSR的方案：Vue有Nuxt框架，React有Next框架，当然也可以根据公司项目需求自研。\r\n- SSR的核心概念包括：同构、数据脱水注水、服务端请求、跨平台API、服务端生命周期等等。因为篇幅限制，具体的细节和原理，之后我会出专栏讲解。\r\n至于需不需要使用SSR，具体项目要具体对待，如果是对SEO要求特别高，且交互并不复杂的内容站，可以考虑使用SEO。\r\n\r\n## 有用过Vue3吗，和Vue2有哪些区别\r\n\r\n这是个开放题，不建议背答案，可以结合自己的理解和项目经历展开来讲。如果聊的好的话，没准这一个话题就能帮你获得面试官的青睐。\r\n\r\n### 性能提升方面\r\n\r\n- Proxy替代Object.defineProperty，性能提升，监听更完备。\r\n- 模板编译的优化，基于Block的静态标记。\r\n- 优化slot的生成，优化渲染函数的生成。\r\n- 更好的Tree Shaking，对于没有用到的API，打包时会剔除，减小包体积。\r\n\r\n### 组合API和Reactive API\r\n\r\n- 可以从逻辑复用、自定义组合API展开讲解。\r\n- 可以讲讲ref这个API的故事和争论。\r\n- 可以讲讲Vue3和Vue2响应式原理实现方式的不同。\r\n\r\n### TypeScript支持方面\r\n\r\nVue3源码用TypeScript重写，Vue3的API也提供了更好的TS类型定义。\r\n\r\n### 自定义渲染器\r\n可以讲一讲自定义渲染器能做的一些好玩的事情，比如将Vue用于WebGL或Canvas的渲染。\r\n\r\n### 更好的源码架构：\r\n\r\n- Monorepo把模块拆分开，逻辑更清晰，源码更容易维护。\r\n- 模块划分也使得更多API被解耦出来，比如Reactive API。\r\n- 源码更容易阅读，方便社区维护。\r\n\r\n### 新的功能和组件：\r\n\r\n- Teleport：可以将一个组件的内容渲染到任何地方，而不必受到父组件的限制，一般用于封装弹框组件。\r\n- 更好用的组件递归。\r\n\r\n## 你知道哪些Vue编码规范\r\n\r\n1. if和for不能用在同一个元素。\r\n2. 对于不会发生变化的数据，用Object.freeze()冻结。\r\n3. 给for设置合适的key，尽量不要使用数组的索引作为key。\r\n4. 组件命名：驼峰命名，首字母大写，组件名应该为多个单词组成。\r\n5. props要指定类型。\r\n6. 使用策略模式替代满屏的if/else。\r\n7. 不要写死字符串，多个状态时要使用枚举。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/614/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/614/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## Vue.js虚拟DOM的优缺点","### 1）优点","### 2）缺点","## vue的优点是什么？","## 对于 Vue 是一套渐进式框架的理解","## Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？","## Vue computed 实现","## Vue complier 实现","## 如何编译 template 模板？","## vue 中的性能优化","### 1）编码优化","### 2）用户体验优化","### 3）SEO优化","### 4）打包优化","## Vue 的实例生命周期","## Vue 的双向数据绑定的原理","## 为什么要替换 Object.defineProperty？（Proxy 相比于 defineProperty 的优势）","## 什么是 Proxy？","### 含义：","### 基本用法：","### 示例：","## 为什么避免 v-if 和 v-for 用在一起","## 组件的设计原则","## vue 等单页面应用及其优缺点","## `$route`和`$router`的区别","## 什么是 vue 的计算属性？","## watch的作用是什么","## 计算属性的缓存和方法调用的区别","## 指令 v-el 的作用是什么?","## vuex 有哪几种属性？","## 不用 Vuex 会带来什么问题？","## vue-router 有哪几种导航钩子（ 导航守卫 ）？","## vue-router 实现路由懒加载（ 动态加载路由 ）","### vue异步组件技术","### es提案的import()","### webpack提供的require.ensure()","## 谈一谈 Vue.$nextTick 的原理","## Vue 的父组件和子组件生命周期钩子执行顺序是什么","## Vue实现通信方式","### 方式1: props","### 方式2: vue自定义事件","### 方式3: 消息订阅与发布","### 方式4: vuex","### 方式5: slot","## 说说Vue的MVVM实现原理","## Vue.use是干什么的？原理是什么？","## new Vue() 发生了什么？","## 请说一下Vue响应式数据的理解？","## Vue如何检测数组变化？","## Vue.set 方法是如何实现的？","## Vue3.x响应式数据原理","## Vue3.x中Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？","## Vue3.x中监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？","## vue2.x中如何监测数组变化","## Vue2.x和Vue3.x渲染器的diff算法分别说一下","## Vue SSR了解吗？","## 组件中写 name选项有哪些好处及作用？","## vue的diff算法和react的diff算法的区别","## vue3带来的新特性/亮点","## keep-alive实现原理","## 深入keep-alive组件实现","### render","### watch","## vue修饰符","## v-model的实现原理","## vm.$isServer, vm.$attrs 和 vm.$listeners 含义","### vm.$isServer","### vm.$attrs","### vm.$listeners","## vue中methods与computed，filters，watch的区别","### methods","### computed","### filters","### watch","## Vue两个简易代替vuex的方法","### eventBus","### Vue.observable","## 如果让你封装一个通用的弹框组件，你会从哪些方面考虑","## Vue组件通信有哪些方式，适用场景分别是什么","## Vue哪个生命周期发送数据请求","## Vue的data为什么必须是函数","## computed和watch使用场景有什么不同，实现原理呢","### computed","### watch","## Vue怎么实现数据响应式","## Vue2中怎么检测数组的变化","## 谈一谈对MVVM的理解？Vue实现双向数据绑定原理是什么","## 什么是虚拟DOM，有什么作用？有了解过diff算法吗","### 虚拟DOM的作用","### Vue diff算法相关知识点","## Vue模板编译原理了解吗","## 怎么做Vue自动化测试","### 测试方案","### 测什么","## 什么是自定义指令，怎么实现","## keep-alive适用场景是什么，实现原理是什么","## nextTick有什么作用，实现原理是什么","## 讲一下你对SSR的了解","## 有用过Vue3吗，和Vue2有哪些区别","### 性能提升方面","### 组合API和Reactive API","### TypeScript支持方面","### 自定义渲染器","### 更好的源码架构：","### 新的功能和组件：","## 你知道哪些Vue编码规范"]},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"614"},"buildId":"eqHLrJmKCmctBZmrJMyBT","assetPrefix":"/toolbox-frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>