<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具</title><link rel="icon" href="/toolkit/favicon.ico"/><meta name="description" content="卡鲁秋的前端工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋,Hank,HankLiu"/><meta name="author" content="Hank.Liu"/><meta name="next-head-count" content="7"/><link rel="stylesheet" href="/toolkit/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/toolkit/_next/static/css/f5460a021fc371e8.css" as="style"/><link rel="stylesheet" href="/toolkit/_next/static/css/f5460a021fc371e8.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/toolkit/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/toolkit/_next/static/chunks/webpack-ce7c55ca7efa7362.js" defer=""></script><script src="/toolkit/_next/static/chunks/framework-aec4381329cec0e4.js" defer=""></script><script src="/toolkit/_next/static/chunks/main-65c03d41a91f9ca8.js" defer=""></script><script src="/toolkit/_next/static/chunks/pages/_app-663e05d45e239ea8.js" defer=""></script><script src="/toolkit/_next/static/chunks/9691-52831ba1a45a37ee.js" defer=""></script><script src="/toolkit/_next/static/chunks/8490-9c9cad1e305c687c.js" defer=""></script><script src="/toolkit/_next/static/chunks/1664-f865873e77459860.js" defer=""></script><script src="/toolkit/_next/static/chunks/pages/articles/%5Bid%5D-b6bd1d5b4743d958.js" defer=""></script><script src="/toolkit/_next/static/01n3oM-TaM2WlnAyxyv2V/_buildManifest.js" defer=""></script><script src="/toolkit/_next/static/01n3oM-TaM2WlnAyxyv2V/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1 overflow-x-hidden"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-12jzuas"><div class="ant-card-body"><article><div class="mx-auto mb-[36px] max-w-[1045px] px-[30px] lg:mb-[52px] lg:flex lg:px-0"><div id="banner" class="media-wrapper image-media-wrapper w-full overflow-hidden rounded-[8px] border-[1px] border-solid border-[#1D2129] lg:ml-0 lg:h-[320px] lg:w-[500px]"><div class="hidden before"></div><div class="hidden after"></div><div class="scale-103 h-full w-full border-[8px] border-solid border-white lg:scale-100 cover-wrapper"><img class="h-full w-full rounded-md object-cover cover" src="/toolkit/dashboard/images/banner.png" alt=""/></div></div><div class="mt-[60px] overflow-hidden lg:ml-[32px] lg:mt-0 lg:flex-1"><h1 class="leading-130 montserrat-bold mb-[9px] text-[36px] font-medium text-[#1D2129] lg:mb-[8px]">工程化相关的面试题</h1><div class="mb-[9px] flex whitespace-nowrap lg:mb-[10px]"><div class="leading-120 cursor-pointer truncate text-[24px] font-normal text-[#1D2129] underline-offset-2 hover:underline lg:text-[20px]" aria-hidden="true"># VOL.<!-- -->603</div><div class="leading-120 ml-[48px] text-[24px] font-normal text-[#1D2129] lg:ml-[32px] lg:text-[20px]">2024/02/13</div></div><div class="mb-[12px] flex flex-wrap lg:mb-0"><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">blog</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">engine</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">interview</div></div><div class="my-[30px] hidden w-[213px] border border-[#1D2129] lg:mb-[20px] lg:mt-[8px] lg:block"></div><div class="lg:rounded-0 rounded-[12px] bg-white/30 p-[36px] lg:flex lg:bg-transparent lg:p-0"><div class="float-left h-[118px] w-[118px] lg:float-none lg:h-[112px] lg:w-[112px]"><img src="https://avatars.githubusercontent.com/u/8088864?v=4" class="h-full w-full rounded-[8px] object-cover lg:rounded-[12px]" alt=""/></div><div class="lg:ml-[32px] lg:flex-1 lg:overflow-hidden"><div class="mb-[10px] flex h-[118px] flex-col justify-center pl-[36px] lg:h-auto lg:flex-row lg:items-center lg:justify-between lg:pl-0"><div class="leading-130 montserrat-bold mb-[12px] w-full truncate text-[30px] font-medium text-[#1D2129] lg:mb-0 lg:flex-1 lg:text-[24px]">hankliu62</div><a class="leading-170 ml-0 whitespace-pre-wrap text-[20px] font-normal !text-[#1D2129] !underline hover:!text-[#1D2129] hover:!underline focus:!text-[#1D2129] lg:ml-[5px] lg:text-[14px]" href="https://github.com/hankliu62" target="_blank" rel="noreferrer">TA的个人名片</a></div><div class="leading-170 text-[20px] font-normal text-[#4E5969] lg:text-[14px]">HankLiu前端开发工程师，精通前端，涉猎后端，对前端有着浓厚的兴趣，希望能够在前端这条路上一直走下去。努力去听风的声音，不必在意风的方向。</div></div></div></div></div><div class="ant-divider css-12jzuas ant-divider-horizontal !mt-0 !border-[#bfc3c7]" role="separator"></div><section><div><div class="ant-skeleton ant-skeleton-active css-12jzuas"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-12jzuas"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="## 前端性能优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/toolkit/articles/603#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:16px">前端性能优化</div></a></li><li id="### 1. 减少 HTTP 请求" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#1.-%E5%87%8F%E5%B0%91-http-%E8%AF%B7%E6%B1%82"><div class="truncate" style="padding-left:32px">1. 减少 HTTP 请求</div></a></li><li id="### 2. 使用 HTTP2" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#2.-%E4%BD%BF%E7%94%A8-http2"><div class="truncate" style="padding-left:32px">2. 使用 HTTP2</div></a></li><li id="#### 解析速度快" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E8%A7%A3%E6%9E%90%E9%80%9F%E5%BA%A6%E5%BF%AB"><div class="truncate" style="padding-left:48px">解析速度快</div></a></li><li id="#### 多路复用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><div class="truncate" style="padding-left:48px">多路复用</div></a></li><li id="#### 首部压缩" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9"><div class="truncate" style="padding-left:48px">首部压缩</div></a></li><li id="#### 优先级" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E4%BC%98%E5%85%88%E7%BA%A7"><div class="truncate" style="padding-left:48px">优先级</div></a></li><li id="#### 流量控制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><div class="truncate" style="padding-left:48px">流量控制</div></a></li><li id="#### 服务器推送" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><div class="truncate" style="padding-left:48px">服务器推送</div></a></li><li id="### 3. 使用服务端渲染" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#3.-%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><div class="truncate" style="padding-left:32px">3. 使用服务端渲染</div></a></li><li id="#### 客户端渲染过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:48px">客户端渲染过程</div></a></li><li id="#### 服务端渲染过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:48px">服务端渲染过程</div></a></li><li id="### 4. 静态资源使用 CDN" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#4.-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8-cdn"><div class="truncate" style="padding-left:32px">4. 静态资源使用 CDN</div></a></li><li id="#### CDN 原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#cdn-%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:48px">CDN 原理</div></a></li><li id="### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#5.-%E5%B0%86-css-%E6%94%BE%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8javascript-%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%E5%BA%95%E9%83%A8"><div class="truncate" style="padding-left:32px">5. 将 CSS 放在文件头部，JavaScript 文件放在底部</div></a></li><li id="### 6. 使用字体图标 iconfont 代替图片图标" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#6.-%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87-iconfont-%E4%BB%A3%E6%9B%BF%E5%9B%BE%E7%89%87%E5%9B%BE%E6%A0%87"><div class="truncate" style="padding-left:32px">6. 使用字体图标 iconfont 代替图片图标</div></a></li><li id="#### 压缩字体文件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%8E%8B%E7%BC%A9%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6"><div class="truncate" style="padding-left:48px">压缩字体文件</div></a></li><li id="### 7. 善用缓存，不重复加载相同的资源" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#7.-%E5%96%84%E7%94%A8%E7%BC%93%E5%AD%98%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD%E7%9B%B8%E5%90%8C%E7%9A%84%E8%B5%84%E6%BA%90"><div class="truncate" style="padding-left:32px">7. 善用缓存，不重复加载相同的资源</div></a></li><li id="### 8. 压缩文件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#8.-%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><div class="truncate" style="padding-left:32px">8. 压缩文件</div></a></li><li id="### 9. 图片优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#9.-%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">9. 图片优化</div></a></li><li id="#### (1). 图片延迟加载" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#(1).-%E5%9B%BE%E7%89%87%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><div class="truncate" style="padding-left:48px">(1). 图片延迟加载</div></a></li><li id="#### (2). 响应式图片" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#(2).-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E7%89%87"><div class="truncate" style="padding-left:48px">(2). 响应式图片</div></a></li><li id="#### (3). 调整图片大小" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#(3).-%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F"><div class="truncate" style="padding-left:48px">(3). 调整图片大小</div></a></li><li id="#### (4). 降低图片质量" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#(4).-%E9%99%8D%E4%BD%8E%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F"><div class="truncate" style="padding-left:48px">(4). 降低图片质量</div></a></li><li id="#### (5). 尽可能利用 CSS3 效果代替图片" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#(5).-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%88%A9%E7%94%A8-css3-%E6%95%88%E6%9E%9C%E4%BB%A3%E6%9B%BF%E5%9B%BE%E7%89%87"><div class="truncate" style="padding-left:48px">(5). 尽可能利用 CSS3 效果代替图片</div></a></li><li id="#### (6). 使用 webp 格式的图片" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#(6).-%E4%BD%BF%E7%94%A8-webp-%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%9B%BE%E7%89%87"><div class="truncate" style="padding-left:48px">(6). 使用 webp 格式的图片</div></a></li><li id="### 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#10.-%E9%80%9A%E8%BF%87-webpack-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%A0%81%E6%8F%90%E5%8F%96%E7%AC%AC%E4%B8%89%E5%BA%93%E4%BB%A3%E7%A0%81%E5%87%8F%E5%B0%91-es6-%E8%BD%AC%E4%B8%BA-es5-%E7%9A%84%E5%86%97%E4%BD%99%E4%BB%A3%E7%A0%81"><div class="truncate" style="padding-left:32px">10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码</div></a></li><li id="#### 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E5%90%8D%E7%BB%93%E5%90%88-import-%E5%8A%A8%E6%80%81%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><div class="truncate" style="padding-left:48px">根据文件内容生成文件名，结合 import 动态引入组件实现按需加载</div></a></li><li id="#### 提取第三方库" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%8F%90%E5%8F%96%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><div class="truncate" style="padding-left:48px">提取第三方库</div></a></li><li id="#### 减少 ES6 转为 ES5 的冗余代码" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%87%8F%E5%B0%91-es6-%E8%BD%AC%E4%B8%BA-es5-%E7%9A%84%E5%86%97%E4%BD%99%E4%BB%A3%E7%A0%81"><div class="truncate" style="padding-left:48px">减少 ES6 转为 ES5 的冗余代码</div></a></li><li id="### 11. 减少重绘重排" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#11.-%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92"><div class="truncate" style="padding-left:32px">11. 减少重绘重排</div></a></li><li id="#### 重排" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E9%87%8D%E6%8E%92"><div class="truncate" style="padding-left:48px">重排</div></a></li><li id="#### 重绘" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E9%87%8D%E7%BB%98"><div class="truncate" style="padding-left:48px">重绘</div></a></li><li id="### 12. 使用事件委托" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#12.-%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><div class="truncate" style="padding-left:32px">12. 使用事件委托</div></a></li><li id="### 13. 注意程序的局部性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#13.-%E6%B3%A8%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><div class="truncate" style="padding-left:32px">13. 注意程序的局部性</div></a></li><li id="### 14. if-else 对比 switch" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#14.-if-else-%E5%AF%B9%E6%AF%94-switch"><div class="truncate" style="padding-left:32px">14. if-else 对比 switch</div></a></li><li id="### 15. 查找表" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#15.-%E6%9F%A5%E6%89%BE%E8%A1%A8"><div class="truncate" style="padding-left:32px">15. 查找表</div></a></li><li id="### 16. 避免页面卡顿" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#16.-%E9%81%BF%E5%85%8D%E9%A1%B5%E9%9D%A2%E5%8D%A1%E9%A1%BF"><div class="truncate" style="padding-left:32px">16. 避免页面卡顿</div></a></li><li id="### 17. 使用 requestAnimationFrame 来实现视觉变化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#17.-%E4%BD%BF%E7%94%A8-requestanimationframe-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%86%E8%A7%89%E5%8F%98%E5%8C%96"><div class="truncate" style="padding-left:32px">17. 使用 requestAnimationFrame 来实现视觉变化</div></a></li><li id="### 18. 使用 Web Workers" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#18.-%E4%BD%BF%E7%94%A8-web-workers"><div class="truncate" style="padding-left:32px">18. 使用 Web Workers</div></a></li><li id="### 19. 使用位操作" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#19.-%E4%BD%BF%E7%94%A8%E4%BD%8D%E6%93%8D%E4%BD%9C"><div class="truncate" style="padding-left:32px">19. 使用位操作</div></a></li><li id="#### 取模" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%8F%96%E6%A8%A1"><div class="truncate" style="padding-left:48px">取模</div></a></li><li id="#### 取整" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%8F%96%E6%95%B4"><div class="truncate" style="padding-left:48px">取整</div></a></li><li id="#### 位掩码" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E4%BD%8D%E6%8E%A9%E7%A0%81"><div class="truncate" style="padding-left:48px">位掩码</div></a></li><li id="### 20. 不要覆盖原生方法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#20.-%E4%B8%8D%E8%A6%81%E8%A6%86%E7%9B%96%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><div class="truncate" style="padding-left:32px">20. 不要覆盖原生方法</div></a></li><li id="### 21. 降低 CSS 选择器的复杂性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#21.-%E9%99%8D%E4%BD%8E-css-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><div class="truncate" style="padding-left:32px">21. 降低 CSS 选择器的复杂性</div></a></li><li id="#### (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#(1).-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E9%80%89%E6%8B%A9%E5%99%A8%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%8E%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%8F%B3%E8%BE%B9%E5%88%B0%E5%B7%A6%E8%BE%B9%E8%AF%BB%E5%8F%96"><div class="truncate" style="padding-left:48px">(1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取</div></a></li><li id="#### (2). CSS 选择器优先级" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#(2).-css-%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><div class="truncate" style="padding-left:48px">(2). CSS 选择器优先级</div></a></li><li id="### 22. 使用 flexbox 而不是较早的布局模型" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#22.-%E4%BD%BF%E7%94%A8-flexbox-%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BE%83%E6%97%A9%E7%9A%84%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B"><div class="truncate" style="padding-left:32px">22. 使用 flexbox 而不是较早的布局模型</div></a></li><li id="### 23. 使用 transform 和 opacity 属性更改来实现动画" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#23.-%E4%BD%BF%E7%94%A8-transform-%E5%92%8C-opacity-%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%94%B9%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB"><div class="truncate" style="padding-left:32px">23. 使用 transform 和 opacity 属性更改来实现动画</div></a></li><li id="### 24. 合理使用规则，避免过度优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#24.-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">24. 合理使用规则，避免过度优化</div></a></li><li id="#### 检查加载性能" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%A3%80%E6%9F%A5%E5%8A%A0%E8%BD%BD%E6%80%A7%E8%83%BD"><div class="truncate" style="padding-left:48px">检查加载性能</div></a></li><li id="#### 检查运行性能" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%A3%80%E6%9F%A5%E8%BF%90%E8%A1%8C%E6%80%A7%E8%83%BD"><div class="truncate" style="padding-left:48px">检查运行性能</div></a></li><li id="## 如何进行网站性能优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:16px">如何进行网站性能优化</div></a></li><li id="## PNG,GIF,JPG 的区别及如何选" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#png,gif,jpg-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%A6%82%E4%BD%95%E9%80%89"><div class="truncate" style="padding-left:16px">PNG,GIF,JPG 的区别及如何选</div></a></li><li id="## AMD和CMD规范区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#amd%E5%92%8Ccmd%E8%A7%84%E8%8C%83%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">AMD和CMD规范区别</div></a></li><li id="## SPA单页页面" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#spa%E5%8D%95%E9%A1%B5%E9%A1%B5%E9%9D%A2"><div class="truncate" style="padding-left:16px">SPA单页页面</div></a></li><li id="### SPA优点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#spa%E4%BC%98%E7%82%B9"><div class="truncate" style="padding-left:32px">SPA优点</div></a></li><li id="### SPA缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#spa%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:32px">SPA缺点</div></a></li><li id="## 什么是 Jest?" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E4%BB%80%E4%B9%88%E6%98%AF-jest?"><div class="truncate" style="padding-left:16px">什么是 Jest?</div></a></li><li id="## Jest 对比 Jasmine 有什么优势?" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#jest-%E5%AF%B9%E6%AF%94-jasmine-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF?"><div class="truncate" style="padding-left:16px">Jest 对比 Jasmine 有什么优势?</div></a></li><li id="## 前端错误监控" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7"><div class="truncate" style="padding-left:16px">前端错误监控</div></a></li><li id="### 1 前言" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#1-%E5%89%8D%E8%A8%80"><div class="truncate" style="padding-left:32px">1 前言</div></a></li><li id="### 2 前端错误的分类" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#2-%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%86%E7%B1%BB"><div class="truncate" style="padding-left:32px">2 前端错误的分类</div></a></li><li id="### 3 每种错误的捕获方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#3-%E6%AF%8F%E7%A7%8D%E9%94%99%E8%AF%AF%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:32px">3 每种错误的捕获方式</div></a></li><li id="#### 3.1 即时运行错误的捕获方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#3.1-%E5%8D%B3%E6%97%B6%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:48px">3.1 即时运行错误的捕获方式</div></a></li><li id="#### 3.2 资源加载错误的捕获方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#3.2-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%94%99%E8%AF%AF%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:48px">3.2 资源加载错误的捕获方式</div></a></li><li id="### 4 错误上报的两种方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#4-%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:32px">4 错误上报的两种方式</div></a></li><li id="## 前端工程化相关" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9B%B8%E5%85%B3"><div class="truncate" style="padding-left:16px">前端工程化相关</div></a></li><li id="## 前端模块化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><div class="truncate" style="padding-left:16px">前端模块化</div></a></li><li id="## 性能优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:16px">性能优化</div></a></li><li id="## 图片相关" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3"><div class="truncate" style="padding-left:16px">图片相关</div></a></li><li id="## SEO" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#seo"><div class="truncate" style="padding-left:16px">SEO</div></a></li><li id="### 前端需要注意哪些SEO" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9Bseo"><div class="truncate" style="padding-left:32px">前端需要注意哪些SEO</div></a></li><li id="## Git" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#git"><div class="truncate" style="padding-left:16px">Git</div></a></li><li id="## 前端工程化的理解" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3"><div class="truncate" style="padding-left:16px">前端工程化的理解</div></a></li><li id="## JSBridge" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#jsbridge"><div class="truncate" style="padding-left:16px">JSBridge</div></a></li><li id="### 注册监听事件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6"><div class="truncate" style="padding-left:32px">注册监听事件</div></a></li><li id="### 原生调用js" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%8E%9F%E7%94%9F%E8%B0%83%E7%94%A8js"><div class="truncate" style="padding-left:32px">原生调用js</div></a></li><li id="### js 调用原生方法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#js-%E8%B0%83%E7%94%A8%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><div class="truncate" style="padding-left:32px">js 调用原生方法</div></a></li><li id="## babel原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#babel%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">babel原理</div></a></li><li id="### 核心成员" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%A0%B8%E5%BF%83%E6%88%90%E5%91%98"><div class="truncate" style="padding-left:32px">核心成员</div></a></li><li id="## git rebase 和 git merge 有啥区别？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#git-rebase-%E5%92%8C-git-merge-%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">git rebase 和 git merge 有啥区别？</div></a></li><li id="## E2E" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#e2e"><div class="truncate" style="padding-left:16px">E2E</div></a></li><li id="## 如何选择图片格式，例如 png, webp" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E4%BE%8B%E5%A6%82-png,-webp"><div class="truncate" style="padding-left:16px">如何选择图片格式，例如 png, webp</div></a></li><li id="## common.js 和 es6 中模块引入的区别？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#common.js-%E5%92%8C-es6-%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">common.js 和 es6 中模块引入的区别？</div></a></li><li id="## 设计WebSDK站在什么样的角度思考问题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E8%AE%BE%E8%AE%A1websdk%E7%AB%99%E5%9C%A8%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:16px">设计WebSDK站在什么样的角度思考问题</div></a></li><li id="## webpack和gulp的优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#webpack%E5%92%8Cgulp%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:16px">webpack和gulp的优缺点</div></a></li><li id="## 什么是前端工程化？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96"><div class="truncate" style="padding-left:16px">什么是前端工程化？</div></a></li><li id="## 包管理器用的哪个？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%94%A8%E7%9A%84%E5%93%AA%E4%B8%AA"><div class="truncate" style="padding-left:16px">包管理器用的哪个？</div></a></li><li id="## 有没有写过自动化测试，怎么做前端自动化测试？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%9C%89%E6%B2%A1%E6%9C%89%E5%86%99%E8%BF%87%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%80%8E%E4%B9%88%E5%81%9A%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><div class="truncate" style="padding-left:16px">有没有写过自动化测试，怎么做前端自动化测试？</div></a></li><li id="### 测试的优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:32px">测试的优缺点</div></a></li><li id="### 测试的分类" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB"><div class="truncate" style="padding-left:32px">测试的分类</div></a></li><li id="### 测试常用框架" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6"><div class="truncate" style="padding-left:32px">测试常用框架</div></a></li><li id="### 测试检验结果" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%B5%8B%E8%AF%95%E6%A3%80%E9%AA%8C%E7%BB%93%E6%9E%9C"><div class="truncate" style="padding-left:32px">测试检验结果</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## 什么是持续集成？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><div class="truncate" style="padding-left:16px">什么是持续集成？</div></a></li><li id="## 用过Babel吗？讲一下你对Babel的了解？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E7%94%A8%E8%BF%87babel%E5%90%97%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9babel%E7%9A%84%E4%BA%86%E8%A7%A3"><div class="truncate" style="padding-left:16px">用过Babel吗？讲一下你对Babel的了解？</div></a></li><li id="## ESLint有什么用？你有用它来规范过团队代码吗？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#eslint%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E4%BD%A0%E6%9C%89%E7%94%A8%E5%AE%83%E6%9D%A5%E8%A7%84%E8%8C%83%E8%BF%87%E5%9B%A2%E9%98%9F%E4%BB%A3%E7%A0%81%E5%90%97"><div class="truncate" style="padding-left:16px">ESLint有什么用？你有用它来规范过团队代码吗？</div></a></li><li id="## 讲一下你了解哪些前端模块化规范？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><div class="truncate" style="padding-left:16px">讲一下你了解哪些前端模块化规范？</div></a></li><li id="## 讲一下你最常用的git命令，你们团队的git提交规范是什么？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E4%BD%A0%E4%BB%AC%E5%9B%A2%E9%98%9F%E7%9A%84git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">讲一下你最常用的git命令，你们团队的git提交规范是什么？</div></a></li><li id="### 常用命令" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><div class="truncate" style="padding-left:32px">常用命令</div></a></li><li id="### 提交规范" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83"><div class="truncate" style="padding-left:32px">提交规范</div></a></li><li id="## 打包工具了解哪些，Webpack、Rollup、Parcel有什么区别？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9Bwebpackrollupparcel%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">打包工具了解哪些，Webpack、Rollup、Parcel有什么区别？</div></a></li><li id="## 有用过Vite吗，为什么Vite会那么快？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%9C%89%E7%94%A8%E8%BF%87vite%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88vite%E4%BC%9A%E9%82%A3%E4%B9%88%E5%BF%AB"><div class="truncate" style="padding-left:16px">有用过Vite吗，为什么Vite会那么快？</div></a></li><li id="## 你怎么理解前端基建？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E4%BD%A0%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E5%9F%BA%E5%BB%BA"><div class="truncate" style="padding-left:16px">你怎么理解前端基建？</div></a></li><li id="## 有了解过Rust吗？在前端有哪些应用？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87rust%E5%90%97%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8"><div class="truncate" style="padding-left:16px">有了解过Rust吗？在前端有哪些应用？</div></a></li><li id="## 微前端适用于什么场景？设计一个微前端框架要怎么考虑？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolkit/articles/603#%E5%BE%AE%E5%89%8D%E7%AB%AF%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%A6%81%E6%80%8E%E4%B9%88%E8%80%83%E8%99%91"><div class="truncate" style="padding-left:16px">微前端适用于什么场景？设计一个微前端框架要怎么考虑？</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/603","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/603/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/603/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/603/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/603","id":2131538261,"node_id":"I_kwDOBiJZIc5_DLFV","number":603,"title":"工程化相关的面试题","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536681139,"node_id":"LA_kwDOBiJZIc8AAAABhZ3Wsw","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/engine","name":"engine","color":"1d76db","default":false,"description":"分类-工程化相关"},{"id":6552343574,"node_id":"LA_kwDOBiJZIc8AAAABhozUFg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview","name":"interview","color":"79D677","default":false,"description":"分类-面试题相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-13T06:14:54Z","updated_at":"2024-02-13T08:50:48Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"---\r\n\r\ntitle: 工程化相关的面试题\r\n\r\ndate: 2024-02-13 16:50:46\r\n\r\ntag: [blog, interview, engine]\r\n\r\n---\r\n\r\n## 前端性能优化\r\n\r\n性能优化是把双刃剑，有好的一面也有坏的一面。好的一面就是能提升网站性能，坏的一面就是配置麻烦，或者要遵守的规则太多。并且某些性能优化规则并不适用所有场景，需要谨慎使用。\r\n\r\n下面列出来了前端性能的24条建议:\r\n\r\n### 1. 减少 HTTP 请求\r\n\r\n一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。\r\n\r\n接下来看一个具体的例子帮助理解 HTTP ：\r\n\r\n![http请求瀑布图](https://user-images.githubusercontent.com/8088864/125281253-957bc880-e348-11eb-97bf-464d4531ce8e.png)\r\n\r\n这是一个 HTTP 请求，请求的文件大小为 28.4KB。\r\n\r\n名词解释：\r\n\r\n- Queueing: 在请求队列中的时间。\r\n- Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。\r\n- Proxy negotiation: 与代理服务器连接进行协商所花费的时间。\r\n- DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。\r\n- Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手，重试和协商SSL。\r\n- SSL: 完成SSL握手所花费的时间。\r\n- Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。\r\n- Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。\r\n- Content Download: 接收响应数据所花费的时间。\r\n\r\n从这个例子可以看出，真正下载数据的时间占比为 13.05 / 204.16 = 6.39%，文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。\r\n\r\n### 2. 使用 HTTP2\r\n\r\nHTTP2 相比 HTTP1.1 有如下几个优点：\r\n\r\n#### 解析速度快\r\n\r\n服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。\r\n\r\n#### 多路复用\r\n\r\nHTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。\r\n\r\n在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。\r\n\r\n#### 首部压缩\r\n\r\nHTTP2 提供了首部压缩功能。\r\n\r\n例如有如下两个请求：\r\n\r\n```\r\n// 请求1\r\n:authority: unpkg.zhimg.com\r\n:method: GET\r\n:path: /za-js-sdk@2.16.0/dist/zap.js\r\n:scheme: https\r\naccept: */*\r\naccept-encoding: gzip, deflate, br\r\naccept-language: zh-CN,zh;q=0.9\r\ncache-control: no-cache\r\npragma: no-cache\r\nreferer: https://www.zhihu.com/\r\nsec-fetch-dest: script\r\nsec-fetch-mode: no-cors\r\nsec-fetch-site: cross-site\r\nuser-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\r\n\r\n// 请求2\r\n:authority: zz.bdstatic.com\r\n:method: GET\r\n:path: /linksubmit/push.js\r\n:scheme: https\r\naccept: */*\r\naccept-encoding: gzip, deflate, br\r\naccept-language: zh-CN,zh;q=0.9\r\ncache-control: no-cache\r\npragma: no-cache\r\nreferer: https://www.zhihu.com/\r\nsec-fetch-dest: script\r\nsec-fetch-mode: no-cors\r\nsec-fetch-site: cross-site\r\nuser-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\r\n```\r\n\r\n从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。\r\n\r\nHTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。\r\n\r\n下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：\r\n\r\n```\r\nHeader1:foo\r\nHeader2:bar\r\nHeader3:bat\r\n```\r\n\r\n当客户端发送请求时，它会根据首部值创建一张表：\r\n\r\n| 索引 | 首部名称 | 值 |\r\n| ---- | ---- | ---- |\r\n| 62 | Header1 | foo |\r\n| 63 | Header2 | bar |\r\n| 64 | Header3 | bar |\r\n\r\n如果服务器收到了请求，它会照样创建一张表。 当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块：\r\n\r\n```\r\n62 63 64\r\n```\r\n\r\n服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。\r\n\r\n#### 优先级\r\n\r\nHTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。\r\n\r\n#### 流量控制\r\n\r\n由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。\r\n\r\n#### 服务器推送\r\n\r\nHTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。\r\n\r\n例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。\r\n\r\n现在有很多网站已经开始使用 HTTP2 了，例如知乎：\r\n\r\n![服务器推送](https://user-images.githubusercontent.com/8088864/125283274-d83ea000-e34a-11eb-95d5-7881c4af0403.jpg)\r\n\r\n其中 h2 是指 HTTP2 协议，http/1.1 则是指 HTTP1.1 协议。\r\n\r\n参考资料：\r\n\r\n- [半小时搞懂 HTTP、HTTPS和HTTP2](https://github.com/woai3c/Front-end-articles/blob/master/http-https-http2.md)\r\n\r\n### 3. 使用服务端渲染\r\n\r\n客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\r\n\r\n服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\r\n\r\n- 优点：首屏渲染快，SEO 好。\r\n- 缺点：配置麻烦，增加了服务器的计算压力。\r\n\r\n下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。\r\n\r\n#### 客户端渲染过程\r\n\r\n1. 访问客户端渲染的网站。\r\n2. 服务器返回一个包含了引入资源语句和 \\\u003cdiv id=\"app\"\u003e\\\u003c/div\u003e 的 HTML 文件。\r\n3. 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。\r\n\r\n#### 服务端渲染过程\r\n\r\n1. 访问服务端渲染的网站。\r\n2. 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。\r\n3. 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面。\r\n\r\n从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。\r\n\r\n这样做的好处是什么？是更快的内容到达时间 (time-to-content)。\r\n\r\n假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。\r\n\r\n这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。这就是服务端渲染更快的原因。\r\n\r\n参考资料：\r\n\r\n- [vue-ssr-demo](https://github.com/woai3c/vue-ssr-demo)\r\n- [Vue.js 服务器端渲染指南](https://ssr.vuejs.org/zh/)\r\n\r\n### 4. 静态资源使用 CDN\r\n\r\n内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。\r\n\r\n#### CDN 原理\r\n\r\n当用户访问一个网站时，如果没有 CDN，过程是这样的：\r\n\r\n1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。\r\n2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。\r\n3. 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。\r\n\r\n![没有CDN的资源请求](https://user-images.githubusercontent.com/8088864/125375921-8171ae80-e3bc-11eb-9d66-adb57433b67a.jpg)\r\n\r\n如果用户访问的网站部署了 CDN，过程是这样的：\r\n\r\n1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。\r\n2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。\r\n3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。\r\n4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。\r\n5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。\r\n6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。\r\n7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。\r\n\r\n![有CDN的资源请求](https://user-images.githubusercontent.com/8088864/125376046-baaa1e80-e3bc-11eb-84ba-c86cd8d63a7f.jpg)\r\n\r\n参考资料：\r\n\r\n- [CDN是什么？使用CDN有什么优势？](https://www.zhihu.com/question/36514327/answer/193768864)\r\n- [CDN原理简析](https://juejin.cn/post/6844903873518239752)\r\n\r\n### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部\r\n\r\n所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。\r\n\r\n那为什么 CSS 文件还要放在头部呢？\r\n\r\n因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。\r\n\r\n另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。\r\n\r\n### 6. 使用字体图标 iconfont 代替图片图标\r\n\r\n字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。\r\n\r\n#### 压缩字体文件\r\n\r\n使用 [fontmin-webpack](https://github.com/patrickhulce/fontmin-webpack) 插件对字体文件进行压缩。\r\n\r\n![fontmin-webpack](https://user-images.githubusercontent.com/8088864/125377089-efb77080-e3be-11eb-845b-d8992de47838.png)\r\n\r\n参考资料：\r\n\r\n- [fontmin-webpack](https://github.com/patrickhulce/fontmin-webpack)\r\n- [Iconfont-阿里巴巴矢量图标库](https://www.iconfont.cn/)\r\n\r\n### 7. 善用缓存，不重复加载相同的资源\r\n\r\n为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。\r\n\r\n不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？\r\n\r\n可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。\r\n\r\n具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用[数据摘要要算法](https://cloud.tencent.com/developer/article/1584742)对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。\r\n\r\n参考资料：\r\n\r\n- [webpack + express 实现文件精确缓存](https://github.com/woai3c/node-blog/blob/master/doc/node-blog7.md)\r\n- [webpack-缓存](https://www.webpackjs.com/guides/caching/)\r\n- [张云龙--大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576/answer/32602154)\r\n\r\n### 8. 压缩文件\r\n\r\n压缩文件可以减少文件下载时间，让用户体验性更好。\r\n\r\n得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。\r\n\r\n在 webpack 可以使用如下插件进行压缩：\r\n\r\n- JavaScript：UglifyPlugin\r\n- CSS ：MiniCssExtractPlugin\r\n- HTML：HtmlWebpackPlugin\r\n\r\n其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。\r\n\r\ngzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。\r\n\r\n附上 webpack 和 node 配置 gzip 的使用方法。\r\n\r\n下载插件\r\n\r\n``` shell\r\nnpm install compression-webpack-plugin --save-dev\r\nnpm install compression\r\n```\r\n\r\nwebpack 配置\r\n\r\n``` js\r\nconst CompressionPlugin = require('compression-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  plugins: [new CompressionPlugin()],\r\n}\r\n```\r\n\r\nnode 配置\r\n\r\n``` js\r\nconst compression = require('compression')\r\n// 在其他中间件前使用\r\napp.use(compression())\r\n```\r\n\r\n### 9. 图片优化\r\n\r\n#### (1). 图片延迟加载\r\n\r\n在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。\r\n\r\n首先可以将图片这样设置，在页面不可见时图片不会加载：\r\n\r\n``` html\r\n\u003cimg data-src=\"https://avatars0.githubusercontent.com/u/22117876?s=460\u0026u=7bd8f32788df6988833da6bd155c3cfbebc68006\u0026v=4\"\u003e\r\n```\r\n\r\n等页面可见时，使用 JS 加载图片：\r\n\r\n``` js\r\nconst img = document.querySelector('img')\r\nimg.src = img.dataset.src\r\n```\r\n\r\n这样图片就加载出来了，完整的代码可以看一下参考资料。\r\n\r\n参考资料：\r\n\r\n- [web 前端图片懒加载实现原理](https://juejin.cn/post/6844903482164510734)\r\n\r\n#### (2). 响应式图片\r\n\r\n响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。\r\n\r\n通过 picture 实现\r\n\r\n``` html\r\n\u003cpicture\u003e\r\n  \u003csource srcset=\"banner_w1000.jpg\" media=\"(min-width: 801px)\"\u003e\r\n  \u003csource srcset=\"banner_w800.jpg\" media=\"(max-width: 800px)\"\u003e\r\n  \u003cimg src=\"banner_w800.jpg\" alt=\"\"\u003e\r\n\u003c/picture\u003e\r\n```\r\n\r\n通过 @media 实现\r\n\r\n``` css\r\n@media (min-width: 769px) {\r\n  .bg {\r\n    background-image: url(bg1080.jpg);\r\n  }\r\n}\r\n@media (max-width: 768px) {\r\n  .bg {\r\n    background-image: url(bg768.jpg);\r\n  }\r\n}\r\n```\r\n\r\n#### (3). 调整图片大小\r\n\r\n例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。\r\n\r\n所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。\r\n\r\n#### (4). 降低图片质量\r\n\r\n例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。\r\n\r\n压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。\r\n\r\n以下附上 webpack 插件 image-webpack-loader 的用法。\r\n\r\n``` shell\r\nnpm install --save-dev image-webpack-loader\r\n```\r\n\r\nwebpack 配置\r\n\r\n``` js\r\n{\r\n  test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\r\n  use:[\r\n    {\r\n    loader: 'url-loader',\r\n    options: {\r\n      limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/\r\n      name: utils.assetsPath('img/[name].[hash:7].[ext]')\r\n      }\r\n    },\r\n    /*对图片进行压缩*/\r\n    {\r\n      loader: 'image-webpack-loader',\r\n      options: {\r\n        bypassOnDebug: true,\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n参考资料：\r\n\r\n- [img图片在webpack中使用](https://juejin.cn/post/6844903816081457159)\r\n\r\n#### (5). 尽可能利用 CSS3 效果代替图片\r\n\r\n有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。\r\n\r\n#### (6). 使用 webp 格式的图片\r\n\r\nWebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。\r\n\r\n参考资料：\r\n\r\n- [WebP 相对于 PNG、JPG 有什么优势？](https://www.zhihu.com/question/27201061)\r\n\r\n### 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码\r\n\r\n懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。\r\n\r\n#### 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载\r\n\r\n通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。\r\n\r\n``` js\r\n{\r\n  output: {\r\n    filename: '[name].[contenthash].js',\r\n    chunkFilename: '[name].[contenthash].js',\r\n    path: path.resolve(__dirname, '../dist'),\r\n  },\r\n}\r\n```\r\n\r\n#### 提取第三方库\r\n\r\n由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。 这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。\r\n\r\n``` js\r\noptimization: {\r\n  runtimeChunk: {\r\n    name: 'manifest' // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。\r\n  },\r\n  splitChunks: {\r\n    cacheGroups: {\r\n      vendor: {\r\n        name: 'chunk-vendors',\r\n        test: /[\\\\/]node_modules[\\\\/]/,\r\n        priority: -10,\r\n        chunks: 'initial'\r\n      },\r\n      common: {\r\n        name: 'chunk-common',\r\n        minChunks: 2,\r\n        priority: -20,\r\n        chunks: 'initial',\r\n        reuseExistingChunk: true\r\n      }\r\n    },\r\n  }\r\n},\r\n```\r\n\r\n- **test**: 过滤 modules，默认为所有的 modules，可匹配模块路径或 chunk 名字，当匹配到某个 chunk 的名字时，这个 chunk 里面引入的所有 module 都会选中。可以传递的值类型：RegExp、String和Function。\r\n- **priority**: 权重，数字越大表示优先级越高。一个 module 可能会满足多个 cacheGroups 的正则匹配，到底将哪个缓存组应用于这个 module，取决于优先级。\r\n- **reuseExistingChunk**: 表示是否使用已有的 chunk，true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的，即几个 chunk 复用被拆分出去的一个 module。\r\n- **minChunks**(默认是1): 在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）\r\n- **chunks**(默认是async): initial、async和all。chunks改为all，表示同时对静态加载(initial)和动态加载(async)起作用。\r\n- **name**(打包的chunks的名字): 字符串或者函数(函数可以根据条件自定义名字)\r\n\r\n#### 减少 ES6 转为 ES5 的冗余代码\r\n\r\nBabel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数，比如\r\n\r\n``` js\r\nclass Person {}\r\n```\r\n\r\n会被转换为：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n}\r\n\r\nvar Person = function Person() {\r\n  _classCallCheck(this, Person);\r\n};\r\n```\r\n\r\n这里 `_classCallCheck` 就是一个 `helper` 函数，如果在很多文件里都声明了类，那么就会产生很多个这样的 `helper` 函数。\r\n\r\n这里的 `@babel/runtime` 包就声明了所有需要用到的帮助函数，而 `@babel/plugin-transform-runtime` 的作用就是将所有需要 `helper` 函数的文件，从 `@babel/runtime`包引进来：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nvar _classCallCheck2 = require(\"@babel/runtime/helpers/classCallCheck\");\r\n\r\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\r\n\r\nfunction _interopRequireDefault(obj) {\r\n  return obj \u0026\u0026 obj.__esModule ? obj : { default: obj };\r\n}\r\n\r\nvar Person = function Person() {\r\n  (0, _classCallCheck3.default)(this, Person);\r\n};\r\n```\r\n\r\n这里就没有再编译出 helper 函数 classCallCheck 了，而是直接引用了 @babel/runtime 中的 helpers/classCallCheck。\r\n\r\n**安装**\r\n\r\n``` shell\r\nnpm install --save-dev @babel/plugin-transform-runtime @babel/runtime\r\n```\r\n\r\n**使用** 在 .babelrc 文件中\r\n\r\n``` json\r\n{\r\n  \"plugins\": [\r\n    \"@babel/plugin-transform-runtime\"\r\n  ]\r\n}\r\n```\r\n\r\n参考资料：\r\n\r\n- [Babel 7.1介绍 transform-runtime polyfill env](https://www.jianshu.com/p/d078b5f3036a)\r\n- [webpack 懒加载](https://webpack.docschina.org/guides/lazy-loading/)\r\n- [Vue 路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD)\r\n- [webpack 缓存](https://webpack.docschina.org/guides/caching/)\r\n- [一步一步的了解webpack4的splitChunk插件](https://juejin.cn/post/6844903614759043079)\r\n\r\n### 11. 减少重绘重排\r\n\r\n浏览器渲染过程\r\n\r\n1. 解析HTML生成DOM树。\r\n2. 解析CSS生成CSSOM规则树。\r\n3. 将DOM树与CSSOM规则树合并在一起生成渲染树。\r\n4. 遍历渲染树开始布局，计算每个节点的位置大小信息。\r\n5. 将渲染树每个节点绘制到屏幕。\r\n\r\n![渲染树生成](https://user-images.githubusercontent.com/8088864/125440124-9cc83d52-c342-4959-af1e-dc67cfe7d312.png)\r\n\r\n#### 重排\r\n\r\n当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。\r\n\r\n#### 重绘\r\n\r\n当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排。\r\n\r\n重排和重绘这两个操作都是非常昂贵的，因为 **JavaScript** 引擎线程与 **GUI** 渲染线程是互斥，它们同时只能一个在工作。\r\n\r\n什么操作会导致重排？\r\n\r\n- 添加或删除可见的 **DOM** 元素\r\n- 元素位置改变\r\n- 元素尺寸改变\r\n- 内容改变\r\n- 浏览器窗口尺寸改变\r\n\r\n如何减少重排重绘？\r\n\r\n- 用 **JavaScript** 修改样式时，最好不要直接写样式，而是替换 **class** 来改变样式。\r\n- 如果要对 **DOM** 元素执行一系列操作，可以将 **DOM** 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（**display:none**）或文档碎片（**DocumentFragment**），都能很好的实现这个方案。\r\n\r\n### 12. 使用事件委托\r\n\r\n事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。\r\n\r\n``` html\r\n\u003cul\u003e\r\n  \u003cli\u003e苹果\u003c/li\u003e\r\n  \u003cli\u003e香蕉\u003c/li\u003e\r\n  \u003cli\u003e凤梨\u003c/li\u003e\r\n\u003c/ul\u003e\r\n```\r\n\r\n``` js\r\n// good\r\ndocument.querySelector('ul').onclick = (event) =\u003e {\r\n  const target = event.target;\r\n  if (target.nodeName === 'LI') {\r\n    console.log(target.innerHTML);\r\n  }\r\n}\r\n\r\n// bad\r\ndocument.querySelectorAll('li').forEach((e) =\u003e {\r\n  e.onclick = function() {\r\n    console.log(this.innerHTML);\r\n  }\r\n})\r\n```\r\n\r\n### 13. 注意程序的局部性\r\n\r\n一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用最近引用过的数据项附近的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。有良好局部性的程序比局部性差的程序运行得更快。\r\n\r\n**局部性通常有两种不同的形式：**\r\n\r\n- 时间局部性: 在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。\r\n- 空间局部性: 在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。\r\n\r\n时间局部性示例\r\n\r\n``` js\r\nfunction sum(arry) {\r\n  let i, sum = 0;\r\n  let len = arry.length;\r\n\r\n  for (i = 0; i \u003c len; i++) {\r\n    sum += arry[i];\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n在这个例子中，变量sum在每次循环迭代中被引用一次，因此，对于sum来说，具有良好的时间局部性\r\n\r\n空间局部性示例\r\n\r\n**具有良好空间局部性的程序**\r\n\r\n``` js\r\n// 二维数组\r\nfunction sum1(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (i = 0; i \u003c rows; i++) {\r\n    for (j = 0; j \u003c cols; j++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n**空间局部性差的程序**\r\n\r\n``` js\r\n// 二维数组\r\nfunction sum2(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (j = 0; j \u003c cols; j++) {\r\n    for (i = 0; i \u003c rows; i++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n看一下上面的两个空间局部性示例，像示例中从每行开始按顺序访问数组每个元素的方式，称为具有步长为1的引用模式。 如果在数组中，每隔k个元素进行访问，就称为步长为k的引用模式。 一般而言，随着步长的增加，空间局部性下降。\r\n\r\n这两个例子有什么区别？区别在于第一个示例是按行扫描数组，每扫描完一行再去扫下一行；第二个示例是按列来扫描数组，扫完一行中的一个元素，马上就去扫下一行中的同一列元素。\r\n\r\n数组在内存中是按照行顺序来存放的，结果就是逐行扫描数组的示例得到了步长为 1 引用模式，具有良好的空间局部性；而另一个示例步长为 rows，空间局部性极差。\r\n\r\n**性能测试**\r\n\r\n运行环境：\r\n\r\n- cpu: i7-10510U\r\n- 浏览器: 83.0.4103.61\r\n\r\n对一个长度为9000的二维数组（子数组长度也为9000）进行10次空间局部性测试，时间（毫秒）取平均值，结果如下：\r\n\r\n``` js\r\nfunction sum2(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (j = 0; j \u003c cols; j++) {\r\n    for (i = 0; i \u003c rows; i++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n\r\n// 二维数组\r\nfunction sum1(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (i = 0; i \u003c rows; i++) {\r\n    for (j = 0; j \u003c cols; j++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n\r\nvar arry = new Array(9000).fill(new Array(9000).fill(1));\r\n\r\nlet ts = 0;\r\nfor (let i = 0; i \u003c 10; i++) {\r\n  const startTime = new Date().valueOf();\r\n  sum1(arry, 9000, 9000);\r\n  ts += (new Date().valueOf() - startTime);\r\n}\r\n\r\nconsole.log('sum1: ' + (ts / 10)); // 81.5ms\r\n\r\nlet ts2 = 0;\r\nfor (let i = 0; i \u003c 10; i++) {\r\n  const startTime = new Date().valueOf();\r\n  sum2(arry, 9000, 9000);\r\n  ts2 += (new Date().valueOf() - startTime);\r\n}\r\n\r\nconsole.log('sum2: ' + (ts2 / 10)); // 167.3ms\r\n```\r\n\r\n所用示例为上述两个空间局部性示例\r\n\r\n| 步长为1(sum1) | 步长为9000(sum2) |\r\n| ---- | ---- |\r\n| 81.5ms | 167.3ms |\r\n\r\n从以上测试结果来看，步长为 1 的数组执行时间比步长为 9000 的数组快了一个数量级。\r\n\r\n总结：\r\n\r\n- 重复引用相同变量的程序具有良好的时间局部性\r\n- 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好；而在内存中以大步长跳来跳去的程序空间局部性会很差\r\n\r\n参考资料：\r\n\r\n- [深入理解计算机系统](https://book.douban.com/subject/26912767/)\r\n\r\n### 14. if-else 对比 switch\r\n\r\n当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\r\n\r\n``` js\r\nif (color == 'blue') {\r\n\r\n} else if (color == 'yellow') {\r\n\r\n} else if (color == 'white') {\r\n\r\n} else if (color == 'black') {\r\n\r\n} else if (color == 'green') {\r\n\r\n} else if (color == 'orange') {\r\n\r\n} else if (color == 'pink') {\r\n\r\n}\r\n\r\nswitch (color) {\r\n  case 'blue':\r\n\r\n    break;\r\n  case 'yellow':\r\n\r\n    break;\r\n  case 'white':\r\n\r\n    break;\r\n  case 'black':\r\n\r\n    break;\r\n  case 'green':\r\n\r\n    break;\r\n  case 'orange':\r\n\r\n    break;\r\n  case 'pink':\r\n\r\n    break;\r\n}\r\n```\r\n\r\n像以上这种情况，使用 switch 是最好的。假设 color 的值为 pink，则 if-else 语句要进行 7 次判断，switch 只需要进行一次判断。 从可读性来说，switch 语句也更好。\r\n\r\n从使用时机来说，当条件值大于两个的时候，使用 switch 更好。不过 if-else 也有 switch 无法做到的事情，例如有多个判断条件的情况下，无法使用 switch。\r\n\r\n### 15. 查找表\r\n\r\n当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。\r\n\r\n``` js\r\nswitch (index) {\r\n  case '0':\r\n    return result0;\r\n  case '1':\r\n    return result1;\r\n  case '2':\r\n    return result2;\r\n  case '3':\r\n    return result3;\r\n  case '4':\r\n    return result4;\r\n  case '5':\r\n    return result5;\r\n  case '6':\r\n    return result6;\r\n  case '7':\r\n    return result7;\r\n  case '8':\r\n    return result8;\r\n  case '9':\r\n    return result9;\r\n  case '10':\r\n    return result10;\r\n  case '11':\r\n    return result11;\r\n}\r\n```\r\n\r\n可以将这个 switch 语句转换为查找表\r\n\r\n``` js\r\nconst results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11];\r\n\r\nreturn results[index];\r\n```\r\n\r\n如果条件语句不是数值而是字符串，可以用对象来建立查找表\r\n\r\n``` js\r\nconst map = {\r\n  red: result0,\r\n  green: result1,\r\n};\r\n\r\nreturn map[color];\r\n```\r\n\r\n### 16. 避免页面卡顿\r\n\r\n**60fps 与设备刷新率**\r\n\r\n目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\r\n\r\n![网页渲染流程](https://user-images.githubusercontent.com/8088864/125445172-29d132ea-e485-49c7-b32d-172956c4349b.jpeg)\r\n\r\n假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。\r\n\r\n对于一些长时间运行的 JavaScript，我们可以使用定时器进行切分，延迟执行。\r\n\r\n``` js\r\nfor (let i = 0, len = arry.length; i \u003c len; i++) {\r\n  process(arry[i]);\r\n}\r\n```\r\n\r\n假设上面的循环结构由于 process() 复杂度过高或数组元素太多，甚至两者都有，可以尝试一下切分。\r\n\r\n``` js\r\nconst todo = arry.concat();\r\nsetTimeout(function(){\r\n  process(todo.shift());\r\n  if (todo.length) {\r\n    setTimeout(arguments.callee, 25);\r\n  } else {\r\n    callback(arry);\r\n  }\r\n}, 25);\r\n```\r\n\r\n如果有兴趣了解更多，可以查看一下高性能JavaScript第 6 章和[高效前端：Web高效编程与优化实践](https://book.douban.com/subject/30170670/)第 3 章。\r\n\r\n### 17. 使用 requestAnimationFrame 来实现视觉变化\r\n\r\n从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 `requestAnimationFrame`。\r\n\r\n``` js\r\n/**\r\n * If run as a requestAnimationFrame callback, this\r\n * will be run at the start of the frame.\r\n */\r\nfunction updateScreen(time) {\r\n  // Make visual updates here.\r\n}\r\n\r\nrequestAnimationFrame(updateScreen);\r\n```\r\n\r\n如果采取 setTimeout 或 setInterval 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。\r\n\r\n![requestAnimationFrame执行点](https://user-images.githubusercontent.com/8088864/125448006-c889aac7-f5d6-4a21-a4fe-b4c6c0cdf197.jpg)\r\n\r\n### 18. 使用 Web Workers\r\n\r\nWeb Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。\r\n\r\nWeb Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。\r\n\r\n创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）：\r\n\r\n``` js\r\nvar myWorker = new Worker('worker.js');\r\n// 你可以通过postMessage() 方法和onmessage事件向worker发送消息。\r\nfirst.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n\r\nsecond.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n```\r\n\r\n在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）：\r\n\r\n``` js\r\nonmessage = function(e) {\r\n  console.log('Message received from main script');\r\n  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);\r\n  console.log('Posting message back to main script');\r\n  postMessage(workerResult);\r\n}\r\n```\r\n\r\nonmessage处理函数在接收到消息后马上执行，代码中消息本身作为事件的data属性进行使用。这里我们简单的对这2个数字作乘法处理并再次使用postMessage()方法，将结果回传给主线程。\r\n\r\n回到主线程，我们再次使用onmessage以响应worker回传的消息：\r\n\r\n``` js\r\nmyWorker.onmessage = function(e) {\r\n  result.textContent = e.data;\r\n  console.log('Message received from worker');\r\n}\r\n```\r\n\r\n在这里我们获取消息事件的data，并且将它设置为result的textContent，所以用户可以直接看到运算的结果。\r\n\r\n不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。\r\n\r\n参考资料：\r\n\r\n- [Web Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)\r\n\r\n### 19. 使用位操作\r\n\r\nJavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。\r\n\r\n#### 取模\r\n\r\n由于偶数的最低位为 0，奇数为 1，所以取模运算可以用位操作来代替。\r\n\r\n``` js\r\nif (value % 2) {\r\n    // 奇数\r\n} else {\r\n    // 偶数\r\n}\r\n// 位操作\r\nif (value \u0026 1) {\r\n    // 奇数\r\n} else {\r\n    // 偶数\r\n}\r\n```\r\n\r\n#### 取整\r\n\r\n``` js\r\n~~10.12 // 10\r\n~~10 // 10\r\n~~'1.5' // 1\r\n~~undefined // 0\r\n~~null // 0\r\n```\r\n\r\n#### 位掩码\r\n\r\n``` js\r\nconst a = 1\r\nconst b = 2\r\nconst c = 4\r\nconst options = a | b | c\r\n```\r\n\r\n通过定义这些选项，可以用按位与操作来判断 a/b/c 是否在 options 中。\r\n\r\n``` js\r\n// 选项 b 是否在选项中\r\nif (b \u0026 options) {\r\n  // ...\r\n}\r\n```\r\n\r\n### 20. 不要覆盖原生方法\r\n\r\n无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。\r\n\r\n### 21. 降低 CSS 选择器的复杂性\r\n\r\n#### (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取\r\n\r\n看个示例\r\n\r\n``` css\r\n#block .text p {\r\n    color: red;\r\n}\r\n```\r\n\r\n1. 查找所有 P 元素。\r\n2. 查找结果 1 中的元素是否有类名为 text 的父元素\r\n3. 查找结果 2 中的元素是否有 id 为 block 的父元素\r\n\r\n#### (2). CSS 选择器优先级\r\n\r\n```\r\n内联 \u003e ID选择器 \u003e 类选择器 \u003e 标签选择器\r\n```\r\n\r\n根据以上两个信息可以得出结论。\r\n\r\n1. 选择器越短越好。\r\n2. 尽量使用高优先级的选择器，例如 ID 和类选择器。\r\n3. 避免使用通配符 *。\r\n\r\n最后要说一句，据我查找的资料所得，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小。\r\n\r\n### 22. 使用 flexbox 而不是较早的布局模型\r\n\r\n在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 [flexbox](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)，它比起早期的布局方式来说有个优势，那就是性能比较好。\r\n\r\n下面的截图显示了在 1300 个框上使用浮动的布局开销：\r\n\r\n![float布局的元素](https://user-images.githubusercontent.com/8088864/125547454-c911b26b-4a1c-44d8-9044-e83a09dc618d.jpg)\r\n\r\n然后我们用 flexbox 来重现这个例子：\r\n\r\n![flexbox布局的元素](https://user-images.githubusercontent.com/8088864/125547509-ecf25fd0-a9ef-438c-827a-987ea0bb9ae5.jpg)\r\n\r\n现在，对于相同数量的元素和相同的视觉外观，布局的时间要少得多（本例中为分别 3.5 毫秒和 14 毫秒）。\r\n\r\n不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。\r\n\r\n各浏览器兼容性：\r\n\r\n- Chrome 29+\r\n- Firefox 28+\r\n- Internet Explorer 11\r\n- Opera 17+\r\n- Safari 6.1+ (prefixed with -webkit-)\r\n- Android 4.4+\r\n- iOS 7.1+ (prefixed with -webkit-)\r\n\r\n但是在可能的情况下，至少应研究布局模型对网站性能的影响，并且采用最大程度减少网页执行开销的模型。\r\n\r\n在任何情况下，不管是否选择 Flexbox，都应当在应用的高压力点期间尝试完全避免触发布局！\r\n\r\n### 23. 使用 transform 和 opacity 属性更改来实现动画\r\n\r\n在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。\r\n\r\n![使用 transform 和 opacity 属性更改来实现动画](https://user-images.githubusercontent.com/8088864/125547800-ab61c27b-23fb-45bd-9d6a-2585df8d804e.jpeg)\r\n\r\n### 24. 合理使用规则，避免过度优化\r\n\r\n性能优化主要分为两类：\r\n\r\n1. 加载时优化\r\n2. 运行时优化\r\n\r\n上述 23 条建议中，属于加载时优化的是前面 10 条建议，属于运行时优化的是后面 13 条建议。通常来说，没有必要 23 条性能优化规则都用上，根据网站用户群体来做针对性的调整是最好的，节省精力，节省时间。\r\n\r\n在解决问题之前，得先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。\r\n\r\n#### 检查加载性能\r\n\r\n一个网站加载性能如何主要看白屏时间和首屏时间。\r\n\r\n- 白屏时间：指从输入网址，到页面开始显示内容的时间。\r\n- 首屏时间：指从输入网址，到页面完全渲染的时间。\r\n\r\n将以下脚本放在 \\\u003c/head\u003e 前面就能获取白屏时间。\r\n\r\n``` html\r\n\u003cscript\u003e\r\n  new Date() - performance.timing.navigationStart\r\n\u003c/script\u003e\r\n```\r\n\r\n在 `window.onload` 事件里执行 `new Date() - performance.timing.navigationStart` 即可获取首屏时间。\r\n\r\n#### 检查运行性能\r\n\r\n配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。\r\n\r\n打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。performance 的具体使用方法请用搜索引擎搜索一下，毕竟篇幅有限。\r\n\r\n通过检查加载和运行性能，相信你对网站性能已经有了大概了解。所以这时候要做的事情，就是使用上述 23 条建议尽情地去优化你的网站，加油！\r\n\r\n参考资料：\r\n\r\n- [performance.timing.navigationStart](https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/navigationStart)\r\n\r\n其他参考资料\r\n\r\n- 高性能网站建设指南\r\n- Web性能权威指南\r\n- 高性能JavaScript\r\n- [高效前端：Web高效编程与优化实践](https://book.douban.com/subject/30170670/)\r\n\r\n## 如何进行网站性能优化\r\n\r\n[雅虎 Best Practices for Speeding Up Your Web Site](https://developer.yahoo.com/performance/rules.html)：\r\n\r\n- content 方面\r\n\r\n  1. 减少 HTTP 请求：合并文件、CSS 精灵、inline Image\r\n  2. 减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询\r\n  3. 避免重定向：多余的中间访问\r\n  4. 使 Ajax 可缓存\r\n  5. 非必须组件延迟加载\r\n  6. 未来所需组件预加载\r\n  7. 减少 DOM 元素数量\r\n  8. 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量\r\n  9. 减少 iframe 数量\r\n  10. 不要 404\r\n\r\n- Server 方面\r\n  1. 使用 CDN\r\n  2. 添加 Expires 或者 Cache-Control 响应头\r\n  3. 对组件使用 Gzip 压缩\r\n  4. 配置 ETag\r\n  5. Flush Buffer Early\r\n  6. Ajax 使用 GET 进行请求\r\n  7. 避免空 src 的 img 标签\r\n- Cookie 方面\r\n  1. 减小 cookie 大小\r\n  2. 引入资源的域名不要包含 cookie\r\n- css 方面\r\n  1. 将样式表放到页面顶部\r\n  2. 不使用 CSS 表达式\r\n  3. 使用`\u003clink\u003e`不使用@import\r\n  4. 不使用 IE 的 Filter\r\n- Javascript 方面\r\n  1. 将脚本放到页面底部\r\n  2. 将 javascript 和 css 从外部引入\r\n  3. 压缩 javascript 和 css\r\n  4. 删除不需要的脚本\r\n  5. 减少 DOM 访问\r\n  6. 合理设计事件监听器\r\n- 图片方面\r\n  1. 优化图片：根据实际颜色需要选择色深、压缩\r\n  2. 优化 css 精灵\r\n  3. 不要在 HTML 中拉伸图片\r\n  4. 保证 favicon.ico 小并且可缓存\r\n- 移动方面\r\n  1. 保证组件小于 25k\r\n  2. Pack Components into a Multipart Document\r\n\r\n## PNG,GIF,JPG 的区别及如何选\r\n\r\n参考资料： [选择正确的图片格式](http://www.yuiblog.com/blog/2008/11/04/imageopt-2/)\r\n**GIF**:\r\n\r\n1. 8 位像素，256 色\r\n2. 无损压缩\r\n3. 支持简单动画\r\n4. 支持 boolean 透明\r\n5. 适合简单动画\r\n\r\n**JPEG**：\r\n\r\n1. 颜色限于 256\r\n2. 有损压缩\r\n3. 可控制压缩质量\r\n4. 不支持透明\r\n5. 适合照片\r\n\r\n**PNG**：\r\n\r\n1. 有 PNG8 和 truecolor PNG\r\n2. PNG8 类似 GIF 颜色上限为 256，文件小，支持 alpha 透明度，无动画\r\n3. 适合图标、背景、按钮\r\n\r\n## AMD和CMD规范区别\r\n\r\n- AMD规范：是 RequireJS在推广过程中对模块定义的规范化产出的\r\n- CMD规范：是SeaJS 在推广过程中对模块定义的规范化产出的\r\n- CMD 推崇依赖就近；AMD 推崇依赖前置\r\n- CMD 是延迟执行；AMD 是提前执行\r\n- CMD性能好，因为只有用户需要的时候才执行；AMD用户体验好，因为没有延迟，依赖模块提前执行了\r\n\r\n## SPA单页页面\r\n\r\nSPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\r\n\r\n### SPA优点\r\n\r\n- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\r\n- 基于上面一点，SPA 相对对服务器压力小；\r\n- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\r\n\r\n### SPA缺点\r\n\r\n- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\r\n- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\r\n- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。\r\n\r\n## 什么是 Jest?\r\n\r\nJest是一个由 Facebook 基于 Jasmine 创建的 JavaScript 单元测试框架，提供自动模拟依赖项和jsdom环境。它通常用于测试组件。\r\n\r\n## Jest 对比 Jasmine 有什么优势?\r\n\r\n与 Jasmine 相比，有几个优点：\r\n\r\n- 自动查找在源代码中要执行的测试。\r\n- 在运行测试时自动模拟依赖项。\r\n- 允许您同步测试异步代码。\r\n- 通过 jsdom 使用假的 DOM 实现运行测试，以便可以在命令行上运行测试。\r\n- 在并行流程中运行测试，以便更快完成。\r\n\r\n## 前端错误监控\r\n\r\n### 1 前言\r\n\r\n\u003e 错误监控包含的内容是：\r\n\r\n- 前端错误的分类\r\n- 每种错误的捕获方式\r\n- 上报错误的基本原理\r\n\r\n\u003e 面试时，可能有两种问法：\r\n\r\n- 如何监测 `js` 错误？（开门见山的方式）\r\n- 如何保证**产品质量**？（其实问的也是错误监控）\r\n\r\n\r\n### 2 前端错误的分类\r\n\r\n包括两种：\r\n\r\n- 即时运行错误（代码错误）\r\n- 资源加载错误\r\n\r\n\r\n### 3 每种错误的捕获方式\r\n\r\n\r\n#### 3.1 即时运行错误的捕获方式\r\n\r\n**方式1**：`try ... catch`。\r\n\r\n\u003e 这种方式要部署在代码中。\r\n\r\n**方式2：**`window.onerror`函数。这个函数是全局的。\r\n\r\n```js\r\n\twindow.onerror = function(msg, url, row, col, error) { ... }\r\n```\r\n\r\n\u003e 参数解释：\r\n\r\n- `msg`为异常基本信息\r\n- `source`为发生异常`Javascript`文件的`url`\r\n- `row`为发生错误的行号\r\n\r\n\u003e 方式二中的`window.onerror`是属于DOM0的写法，我们也可以用DOM2的写法：`window.addEventListener(\"error\", fn);`也可以。\r\n\r\n**问题延伸1：**\r\n\r\n`window.onerror`默认无法捕获**跨域**的`js`运行错误。捕获出来的信息如下：（基本属于无效信息）\r\n\r\n\u003e 比如说，我们的代码想引入`B`网站的`b.js`文件，怎么捕获它的异常呢？\r\n\r\n**解决办法**：在方法二的基础之上，做如下操作：\r\n\r\n1. 在`b.js`文件里，加入如下 `response` `header`，表示允许跨域：（或者世界给静态资源`b.js`加这个 response header）\r\n\r\n```js\r\n\tAccess-Control-Allow-Origin: *\r\n```\r\n\r\n2. 引入第三方的文件`b.js`时，在`\u003cscript\u003e`标签中增加`crossorigin`属性；\r\n\r\n\r\n\r\n**问题延伸2：**\r\n\r\n\u003e 只靠方式二中的`window.onerror`是不够的，因为我们无法获取文件名是什么，不知道哪里出了错误。解决办法：把**堆栈**信息作为msg打印出来，堆栈里很详细。\r\n\r\n\r\n\r\n#### 3.2 资源加载错误的捕获方式\r\n\r\n\u003e 上面的`window.onerror`只能捕获即时运行错误，无法捕获资源加载错误。原理是：资源加载错误，并不会向上冒泡，`object.onerror`捕获后就会终止（不会冒泡给`window`），所以`window.onerror`并不能捕获资源加载错误。\r\n\r\n- **方式1**：`object.onerror`。`img`标签、`script`标签等节点都可以添加`onerror`事件，用来捕获资源加载的错误。\r\n- **方式2**：performance.getEntries。可以获取所有已加载资源的加载时长，通过这种方式，可以间接的拿到没有加载的资源错误。\r\n\r\n举例：\r\n\r\n\u003e 浏览器打开一个网站，在`Console`控制台下，输入：\r\n\r\n```js\r\n\tperformance.getEntries().forEach(function(item){console.log(item.name)})\r\n```\r\n\r\n或者输入：\r\n\r\n```js\r\n\tperformance.getEntries().forEach(item=\u003e{console.log(item.name)})\r\n```\r\n\r\n\r\n\u003e 上面这个`api`，返回的是数组，既然是数组，就可以用`forEach`遍历。打印出来的资源就是**已经成功加载**的资源。；\r\n\r\n![](http://img.smyhvae.com/20180311_2030.png)\r\n\r\n\u003e 再入`document.getElementsByTagName('img')`，就会显示出所有**需要加载**的的img集合。\r\n\r\n\u003e 于是，`document.getElementsByTagName('img')`获取的资源数组减去通过`performance.getEntries()`获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接捕获到资源加载错误。\r\n\r\n这种方式非常有用，一定要记住。\r\n\r\n\r\n**方式3；**Error事件捕获。\r\n\r\n\u003e 源加载错误，虽然会阻止冒泡，但是不会阻止捕获。我们可以在捕获阶段绑定error事件。例如：\r\n\r\n![](http://img.smyhvae.com/20180311_2040.png)\r\n\r\n\r\n\r\n\u003e **总结：**如果我们能回答出后面的两种方式，面试官对我们的印象会大大增加。既可以体现出我们对错误监控的了解，还可以体现出我们对事件模型的掌握。\r\n\r\n\r\n### 4 错误上报的两种方式\r\n\r\n- **方式一**：采用Ajax通信的方式上报（此方式虽然可以上报错误，但是我们并不采用这种方式）\r\n- **方式二：**利用Image对象上报（推荐。网站的监控体系都是采用的这种方式）\r\n\r\n\u003e 方式二的实现方式如下：\r\n\r\n```html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eTitle\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n\r\n\u003cscript\u003e\r\n\t//通过Image对象进行错误上报\r\n    (new Image()).src = 'http://smyhvae.com/myPath?badjs=msg';   // myPath表示上报的路径（我要上报到哪里去）。后面的内容是自己加的参数。\r\n\u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n\r\n```\r\n\r\n\r\n\u003e 打开浏览器，效果如下：\r\n\r\n![](http://img.smyhvae.com/20180311_2055.png)\r\n\r\n上图中，红色那一栏表明，我的请求已经发出去了。点进去看看：\r\n\r\n![](http://img.smyhvae.com/20180311_2057.png)\r\n\r\n\u003e 这种方式，不需要借助第三方的库，一行代码即可搞定。\r\n\r\n## 前端工程化相关\r\n\r\n**什么是单页面应用(SPA)？**\r\n\r\n* 单页面应用(SPA)是指用户在浏览器加载单一的HTML页面，后续请求都无需再离开此页\r\n* 目标：旨在用为用户提供了更接近本地移动APP或桌面应用程序的体验。\r\n\r\n* 流程：第一次请求时，将导航页传输到客户端，其余请求通过 REST API 获取 JSON 数据\r\n* 实现：数据的传输通过 Web Socket API 或 RPC(远程过程调用)。\r\n\r\n* 优点：用户体验流畅，服务器压力小，前后端职责分离\r\n* 缺点：关键词布局难度加大，不利于 SEO\r\n\r\n**什么是“前端路由”? 什么时候适用“前端路由”? 有哪些优点和缺点?**\r\n\r\n* 前端路由通过 URL 和 History 来实现页面切换\r\n* 应用：前端路由主要适用于“前后端分离”的单页面应用(SPA)项目\r\n* 优点：用户体验好，交互流畅\r\n* 缺点：浏览器“前进”、“后退”会重新请求，无法合理利用缓存\r\n\r\n**模块化开发怎么做？**\r\n\r\n* 封装对象作为命名空间 -- 内部状态可以被外部改写\r\n* 立即执行函数(IIFE) -- 需要依赖多个JS文件，并且严格按顺序加载\r\n* 使用模块加载器 -- require.js, sea.js, EC6 模块\r\n\r\n**通行的 Javascript 模块的规范有哪些？**\r\n\r\n* CommonJS -- 主要用在服务器端 node.js\r\n\r\n```javascript\r\nvar math = require('./math');\r\nmath.add(2,3);\r\n```\r\n\r\n* AMD(异步模块定义) -- require.js\r\n\r\n```javascript\r\nrequire(['./math'], function (math) {\r\n    math.add(2, 3);\r\n});\r\n```\r\n\r\n* CMD(通用模块定义) -- sea.js\r\n```javascript\r\nvar math = require('./math');\r\nmath.add(2,3);\r\n```\r\n\r\n* ES6 模块\r\n\r\n\r\n```javascript\r\nimport {math} from './math';\r\nmath.add(2, 3);\r\n```\r\n\r\n**AMD 与 CMD 规范的区别？**\r\n\r\n\r\n* 规范化产出：\r\n  - AMD 由 RequireJS 推广产出\r\n  - CMD 由 SeaJS 推广产出\r\n\r\n* 模块的依赖:\r\n  - AMD 提前执行，推崇依赖前置\r\n  - CMD 延迟执行，推崇依赖就近\r\n\r\n* API 功能:\r\n  - AMD 的 API 默认多功能（分全局 require 和局部 require）\r\n  - CMD 的 API 推崇职责单一纯粹（没有全局 require）\r\n\r\n * 模块定义规则：\r\n   - AMD 默认一开始就载入全部依赖模块\r\n\r\n\r\n```javascript\r\n  define(['./a', './b'], function(a, b) {\r\n      a.doSomething();\r\n      b.doSomething();\r\n  });\r\n```\r\n\r\n- CMD 依赖模块在用到时才就近载入\r\n\r\n```javascript\r\n  define(function(require, exports, module) {\r\n      var a = require('./a');\r\n      a.doSomething();\r\n      var b = require('./b');\r\n      b.doSomething();\r\n  })\r\n```\r\n\r\n**requireJS的核心原理是什么？**\r\n\r\n- 每个模块所依赖模块都会比本模块预先加载\r\n\r\n**对 Node.js 的优点、缺点提出了自己的看法？ Node.js的特点和适用场景？**\r\n\r\n* Node.js的特点：单线程，非阻塞I/O，事件驱动\r\n* Node.js的优点：擅长处理高并发；适合I/O密集型应用\r\n\r\n- Node.js的缺点：不适合CPU密集运算；不能充分利用多核CPU；可靠性低，某个环节出错会导致整个系统崩溃\r\n\r\n - Node.js的适用场景：\r\n    - RESTful API\r\n    - 实时应用：在线聊天、图文直播\r\n    - 工具类应用：前端部署(npm, gulp)\r\n    - 表单收集：问卷系统\r\n\r\n**如何判断当前脚本运行在浏览器还是node环境中？**\r\n\r\n- 判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中\r\n\r\n**什么是 npm ？**\r\n\r\n- npm 是 Node.js 的模块管理和发布工具\r\n\r\n**什么是 WebKit ？**\r\n\r\n* WebKit 是一个开源的浏览器内核，由渲染引擎(WebCore)和JS解释引擎(JSCore)组成\r\n* 通常所说的 WebKit 指的是 WebKit(WebCore)，主要工作是进行 HTML/CSS 渲染\r\n* WebKit 一直是 Safari 和 Chrome(之前) 使用的浏览器内核，后来 Chrome 改用Blink 内核\r\n\r\n**如何测试前端代码? 知道 Unit Test，BDD, TDD 么? 怎么测试你的前端工程(mocha, jasmin..)?**\r\n\r\n* 通过为前端代码编写单元测试(Unit Test)来测试前端代码\r\n* Unit Test：一段用于测试一个模块或接口是否能达到预期结果的代码\r\n* BDD：行为驱动开发 -- 业务需求描述产出产品代码的开发方法\r\n* TDD：测试驱动开发 -- 单元测试用例代码产出产品代码的开发方法\r\n* 单元测试框架：\r\n\r\n\r\n```javascript\r\n// mocha 示例\r\ndescribe('Test add', function() {\r\n  it('1 + 2 = 3', function() {\r\n      expect(add(1, 2)).to.be.equal(3);\r\n  });\r\n});\r\n\r\n// jasmin 示例\r\ndescribe('Test add', function () {\r\n    it('1 + 2 = 3', function () {\r\n        expect(add(1, 2)).toEqual(3);\r\n    });\r\n});\r\n```\r\n\r\n**介绍你知道的前端模板引擎？**\r\n\r\n-  artTemplate, underscore, handlebars\r\n\r\n**什么是 Modernizr？ Modernizr 工作原理？**\r\n\r\n* Modernizr 是一个开源的 JavaScript 库，用于检测用户浏览器对 HTML5 与 CSS3 的支持情况\r\n\r\n**移动端最小触控区域是多大？**\r\n\r\n- 44 * 44 px\r\n\r\n**移动端的点击事件的延迟时间是多长，为什么会有延迟？ 如何解决这个延时？**\r\n\r\n* 移动端 click 有 300ms 延迟，浏览器为了区分“双击”（放大页面）还是“单击”而设计\r\n* 解决方案：\r\n  - 禁用缩放(对safari无效)\r\n  - 使用指针事件(IE私有特性，且仅IE10+)\r\n  - 使用 Zepto 的 tap 事件(有点透BUG)\r\n  - 使用 FastClick 插件(体积大[压缩后8k])\r\n\r\n**什么是函数式编程？**\r\n\r\n* 函数式编程是一种\"编程范式\"，主要思想是把运算过程尽量写成一系列嵌套的函数调用\r\n* 例如：var result = subtract(multiply(add(1,2), 3), 4);\r\n\r\n* 函数式编程的特点：\r\n    - 函数核心化：函数可以作为变量的赋值、另一函数的参数、另一函数的返回值\r\n    - 只用“表达式”，不用“语句”：要求每一步都是单纯的运算，都必须有返回值\r\n    - 没有\"副作用\"：所有功能只为返回一个新的值，不修改外部变量\r\n    - 引用透明：运行不依赖于外部变量，只依赖于输入的参数\r\n\r\n* 函数式编程的优点：\r\n    - 代码简洁，接近自然语言，易于理解\r\n    - 便于维护，利于测试、除错、组合\r\n    - 易于“并发编程“，不用担心一个线程的数据，被另一个线程修改\r\n    - 可“热升级”代码，在运行状态下直接升级代码，不需要重启，也不需要停机\r\n\r\n**什么是函数柯里化Currying)？**\r\n\r\n* 柯里化：\r\n  - 通常也称部分求值，含义是给函数分步传递参数，每次递参部分应用参数，并返回一个更具体的函数，继续接受剩余参数\r\n  - 期间会连续返回具体函数，直至返回最后结果。因此，函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程\r\n  - 柯里化的作用：延迟计算；参数复用；动态创建函数\r\n\r\n* 柯里化的缺点：\r\n  - 函数柯里化会产生开销（函数嵌套，比普通函数占更多内存），但性能瓶颈首先来自其它原因（DOM 操作等）\r\n\r\n**什么是依赖注入？**\r\n\r\n- 当一个类的实例依赖另一个类的实例时，自己不创建该实例，由IOC容器创建并注入给自己，因此称为依赖注入。\r\n- 依赖注入解决的就是如何有效组织代码依赖模块的问题\r\n\r\n**设计模式：什么是 singleton, factory, strategy, decorator？**\r\n\r\n* Singleton(单例)   一个类只有唯一实例，这个实例在整个程序中有一个全局的访问点\r\n* Factory (工厂)    解决实列化对象产生重复的问题\r\n* Strategy(策略)    将每一个算法封装起来，使它们还可以相互替换，让算法独立于使用\r\n* Observer(观察者)  多个观察者同时监听一个主体，当主体对象发生改变时，所有观察者都将得到通知\r\n* Prototype(原型)   一个完全初始化的实例，用于拷贝或者克隆\r\n* Adapter(适配器)   将不同类的接口进行匹配调整，尽管内部接口不兼容，不同的类还是可以协同工作\r\n* Proxy(代理模式)   一个充当过滤转发的对象用来代表一个真实的对象\r\n* Iterator(迭代器)  在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素\r\n* Chain of Responsibility(职责连)  处理请求组成的对象一条链，请求链中传递，直到有对象可以处理\r\n\r\n**什么是前端工程化？**\r\n\r\n* 前端工程化就是把一整套前端工作流程使用工具自动化完成\r\n\r\n\r\n* 前端开发基本流程：\r\n  - 项目初始化：yeoman, FIS\r\n  - 引入依赖包：bower, npm\r\n  - 模块化管理：npm, browserify, Webpack\r\n  - 代码编译：babel, sass, less\r\n  - 代码优化(压缩/合并)：Gulp, Grunt\r\n  - 代码检查：JSHint, ESLint\r\n  - 代码测试：Mocha\r\n* 目前最知名的构建工具：Gulp, Grunt, npm + Webpack\r\n\r\n**介绍 Yeoman 是什么？**\r\n\r\n* Yeoman --前端开发脚手架工具，自动将最佳实践和工具整合起来构建项目骨架\r\n* Yeoman 其实是三类工具的合体，三类工具各自独立：\r\n  - yo --- 脚手架，自动生成工具（相当于一个粘合剂，把 Yeoman 工具粘合在一起）\r\n  - Grunt、gulp --- 自动化构建工具 （最初只有grunt，之后加入了gulp）\r\n  - Bower、npm --- 包管理工具 （原来是bower，之后加入了npm）\r\n\r\n**介绍 WebPack 是什么？ 有什么优势？**\r\n\r\n* WebPack 是一款[模块加载器]兼[打包工具]，用于把各种静态资源（js/css/image等）作为模块来使用\r\n* WebPack 的优势：\r\n  - WebPack 同时支持 commonJS 和 AMD/CMD，方便代码迁移\r\n  - 不仅仅能被模块化 JS ，还包括 CSS、Image 等\r\n  - 能替代部分 grunt/gulp 的工作，如打包、压缩混淆、图片base64\r\n  - 扩展性强，插件机制完善，特别是支持 React 热插拔的功能\r\n\r\n**介绍类库和框架的区别？**\r\n\r\n* 类库是一些函数的集合，帮助开发者写WEB应用，起主导作用的是开发者的代码\r\n* 框架是已实现的特殊WEB应用，开发者只需对它填充具体的业务逻辑，起主导作用是框架\r\n\r\n\r\n**什么是 MVC/MVP/MVVM/Flux？**\r\n\r\n* MVC(Model-View-Controller)\r\n  - V-\u003eC, C-\u003eM, M-\u003eV\r\n  - 通信都是单向的；C只起路由作用，业务逻辑都部署在V\r\n  - Backbone\r\n\r\n\r\n* MVP(Model-View-Presenter)\r\n  - V\u003c-\u003eP, P\u003c-\u003eM\r\n  - 通信都是双向的；V和M不发生联系(通过P传)；V非常薄，逻辑都部署在P\r\n  - Riot.js\r\n\r\n* MVVM(Model-View-ViewModel)\r\n  - V-\u003eVM, VM\u003c-\u003eM\r\n  - 采用双向数据绑定：View 和 ViewModel 的变动都会相互映射到对象上面\r\n  - Angular\r\n\r\n* Flux(Dispatcher-Store-View)\r\n  - Action-\u003eDispatcher-\u003eStore-\u003eView, View-\u003eAction\r\n  - Facebook 为了解决在 MVC 应用中碰到的工程性问题提出一个架构思想\r\n  - 基于一个简单的原则：数据在应用中单向流动（单向数据流）\r\n  - React(Flux 中 View，只关注表现层)\r\n\r\n**Backbone 是什么？**\r\n\r\n- Backbone 是一个基于 jquery 和 underscore 的前端(MVC)框架\r\n\r\n**AngularJS 是什么？**\r\n\r\n- AngularJS 是一个完善的前端 MVVM 框架，包含模板、数据双向绑定、路由、模块化、服务、依赖注入等\r\n- AngularJS 由 Google 维护，用来协助大型单一页面应用开发。\r\n\r\n\r\n**React 是什么？**\r\n\r\n* React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层\r\n* React 主要的原理：\r\n  - 虚拟 DOM + diff 算法 -\u003e 不直接操作 DOM 对象\r\n  - Components 组件 -\u003e Virtual DOM 的节点\r\n  - State 触发视图的渲染 -\u003e 单向数据绑定\r\n  - React 解决方案：React + Redux + react-router + Fetch + webpack\r\n\r\n**react-router 路由系统的实现原理？**\r\n\r\n- 实现原理：location 与 components 之间的同步\r\n\r\n* 路由的职责是保证 UI 和 URL 的同步\r\n* 在 react-router 中，URL 对应 Location 对象，UI 由 react components 决定\r\n* 因此，路由在 react-router 中就转变成 location 与 components 之间的同步\r\n\r\n**Meteor 是什么**\r\n\r\n- Meteor 是一个全栈开发框架，基础构架是 Node.JS + MongoDB，并把延伸到了浏览器端。\r\n- Meteor 统一了服务器端和客户端的数据访问，使开发者可以轻松完成全栈式开发工作。\r\n\r\n## 前端模块化\r\n\r\n**说说你对AMD和Commonjs的理解**\r\n\r\n- CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数\r\n- AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的\r\n\r\n**模块化开发怎么做？**\r\n\r\n- 立即执行函数,不暴露私有成员\r\n\r\n```\r\nvar module1 = (function(){\r\n　　　　var _count = 0;\r\n　　　　var m1 = function(){\r\n　　　　　　//...\r\n　　　　};\r\n　　　　var m2 = function(){\r\n　　　　　　//...\r\n　　　　};\r\n　　　　return {\r\n　　　　　　m1 : m1,\r\n　　　　　　m2 : m2\r\n　　　　};\r\n　　})();\r\n```\r\n\r\n**AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？**\r\n\r\n- Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中\r\n\r\n```\r\n// CMD\r\ndefine(function(require, exports, module) {\r\n    var a = require('./a')\r\n    a.doSomething()\r\n    // 此处略去 100 行\r\n    var b = require('./b') // 依赖可以就近书写\r\n    b.doSomething()\r\n    // ...\r\n})\r\n\r\n// AMD 默认推荐\r\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\r\n    a.doSomething()\r\n    // 此处略去 100 行\r\n    b.doSomething()\r\n    // ...\r\n})\r\n```\r\n\r\n**对前端模块化的认识**\r\n\r\n- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出\r\n- CMD 是 SeaJS 在推广过程中对模块定义的规范化产出\r\n- AMD 是提前执行，CMD 是延迟执行\r\n- AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的\r\n\r\n## 性能优化\r\n\r\n**如何进行网站性能优化**\r\n\r\n- content方面\r\n  - 减少HTTP请求：合并文件、CSS精灵、inline Image\r\n  - 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询\r\n  - 避免重定向：多余的中间访问\r\n  - 使Ajax可缓存\r\n  - 非必须组件延迟加载\r\n  - 未来所需组件预加载\r\n  - 减少DOM元素数量\r\n  - 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量\r\n  - 减少iframe数量\r\n  - 不要404\r\n\r\n- Server方面\r\n  - 使用CDN\r\n  - 添加Expires或者Cache-Control响应头\r\n  - 对组件使用Gzip压缩\r\n  - 配置ETag\r\n  - Flush Buffer Early\r\n  - Ajax使用GET进行请求\r\n  - 避免空src的img标签\r\n- Cookie方面\r\n  - 减小cookie大小\r\n  - 引入资源的域名不要包含cookie\r\n\r\n- css方面\r\n  - 将样式表放到页面顶部\r\n  - 不使用CSS表达式\r\n  - 不使用IE的Filter\r\n\r\n- Javascript方面\r\n  - 将脚本放到页面底部\r\n  - 将javascript和css从外部引入\r\n  - 压缩javascript和css\r\n  - 删除不需要的脚本\r\n  - 减少DOM访问\r\n  - 合理设计事件监听器\r\n\r\n- 图片方面\r\n  - 优化图片：根据实际颜色需要选择色深、压缩\r\n  - 优化css精灵\r\n  - 不要在HTML中拉伸图片\r\n  - 保证favicon.ico小并且可缓存\r\n\r\n- 移动方面\r\n  - 保证组件小于25k\r\n  - `Pack Components into a Multipart Document`\r\n\r\n**你有用过哪些前端性能优化的方法？**\r\n\r\n- 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\r\n-  前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\r\n-  用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\r\n-  当需要设置的样式很多时设置className而不是直接操作style\r\n-  少用全局变量、缓存DOM节点查找的结果。减少IO读取操作\r\n-  避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)\r\n-  图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳\r\n-  避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢\r\n\r\n**谈谈性能优化问题**\r\n\r\n- 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器\r\n- 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等\r\n- 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载\r\n- 请求带宽：压缩文件，开启GZIP\r\n\r\n**代码层面的优化**\r\n- 用hash-table来优化查找\r\n\r\n- 少用全局变量\r\n\r\n- 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能\r\n\r\n- 用setTimeout来避免页面失去响应\r\n\r\n- 缓存DOM节点查找的结果\r\n\r\n- 避免使用CSS Expression\r\n\r\n- 避免全局查询\r\n\r\n- 避免使用with(with会创建自己的作用域，会增加作用域链长度)\r\n\r\n- 多个变量声明合并\r\n\r\n- 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率\r\n\r\n- 尽量避免写在HTML标签中写Style属性\r\n\r\n**前端性能优化最佳实践？**\r\n\r\n* 性能评级工具（PageSpeed 或 YSlow）\r\n* 合理设置 HTTP 缓存：Expires 与 Cache-control\r\n* 静态资源打包，开启 Gzip 压缩（节省响应流量）\r\n* CSS3 模拟图像，图标base64（降低请求数）\r\n* 模块延迟(defer)加载/异步(async)加载\r\n* Cookie 隔离（节省请求流量）\r\n* localStorage（本地存储）\r\n* 使用 CDN 加速（访问最近服务器）\r\n* 启用 HTTP/2（多路复用，并行加载）\r\n* 前端自动化（gulp/webpack）\r\n\r\n## 图片相关\r\n\r\n**PNG,GIF,JPG的区别及如何选**\r\n\r\n- GIF：\r\n  - 8位像素，256色\r\n  - 无损压缩\r\n  - 支持简单动画\r\n  - 支持boolean透明\r\n  - 适合简单动画\r\n\r\n- JPEG：\r\n  - 颜色限于256\r\n  - 有损压缩\r\n  - 可控制压缩质量\r\n  - 不支持透明\r\n  - 适合照片\r\n\r\n- PNG：\r\n  - 有PNG8和truecolor PNG\r\n  - PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画\r\n  - 适合图标、背景、按钮\r\n\r\n## SEO\r\n\r\n### 前端需要注意哪些SEO\r\n\r\n- 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可\r\n- 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页\r\n- 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\r\n- 重要内容不要用js输出：爬虫不会执行js获取内容\r\n- 少用iframe：搜索引擎不会抓取iframe中的内容\r\n- 非装饰性图片必须加alt\r\n- 提高网站速度：网站速度是搜索引擎排序的一个重要指标\r\n\r\n**如何做SEO优化?**\r\n\r\n* 标题与关键词\r\n  - 设置有吸引力切合实际的标题，标题中要包含所做的关键词\r\n\r\n* 网站结构目录\r\n  - 最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布\r\n\r\n* 页面元素\r\n  - 给图片标注\"Alt\"可以让搜索引擎更友好的收录\r\n\r\n* 网站内容\r\n  - 每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢\r\n\r\n* 友情链接\r\n  - 对方一定要是正规网站，每天有专业的团队或者个人维护更新\r\n\r\n* 内链的布置\r\n  - 使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接\r\n\r\n* 流量分析\r\n  - 通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO\r\n\r\n## Git\r\n\r\n**git fetch和git pull的区别**\r\n\r\n- git pull：相当于是从远程获取最新版本并merge到本地\r\n- git fetch：相当于是从远程获取最新版本到本地，不会自动merge\r\n\r\n## 前端工程化的理解\r\n\r\n**如何评价AngularJS和BackboneJS**\r\n\r\n- backbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto)就比一个AngularJS 多出了2 次HTTP请求.\r\n\r\n- Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新\r\n- AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令\r\n\r\n**谈谈你对重构的理解**\r\n\r\n- 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI\r\n\r\n- 对于传统的网站来说重构通常是：\r\n\r\n  - 表格(table)布局改为DIV+CSS\r\n\r\n  - 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)\r\n\r\n  - 对于移动平台的优化\r\n\r\n  - 针对于SEO进行优化\r\n\r\n  - 深层次的网站重构应该考虑的方面\r\n\r\n**说说你对前端架构师的理解**\r\n\r\n- 负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护； 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训\r\n\r\n**什么样的前端代码是好的**\r\n\r\n- 高复用低耦合，这样文件小，好维护，而且好扩展。\r\n\r\n**谈谈你对webpack的看法**\r\n\r\n\u003e WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源\r\n\r\n**页面重构怎么操作？**\r\n\r\n* 网站重构：不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。\r\n\r\n* 页面重构可以考虑的方面：\r\n    - 升级第三方依赖\r\n    - 使用HTML5、CSS3、ES6 新特性\r\n    - 加入响应式布局\r\n    - 统一代码风格规范\r\n    - 减少代码间的耦合\r\n    - 压缩/合并静态资源\r\n    - 程序的性能优化\r\n    - 采用CDN来加速资源加载\r\n    - 对于JS DOM的优化\r\n    - HTTP服务器的文件缓存\r\n\r\n**列举IE与其他浏览器不一样的特性？**\r\n\r\n* IE 的渲染引擎是 Trident 与 W3C 标准差异较大：例如盒子模型的怪异模式\r\n* JS 方面有很多独立的方法，例如事件处理不同：绑定/删除事件，阻止冒泡，阻止默认事件等\r\n* CSS 方面也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式\r\n\r\n**是否了解公钥加密和私钥加密？**\r\n\r\n\r\n* 私钥用于对数据进行签名，公钥用于对签名进行验证\r\n* 网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密\r\n\r\n**WEB应用从服务器主动推送Data到客户端有那些方式？**\r\n* AJAX 轮询\r\n* html5 服务器推送事件\r\n`(new EventSource(SERVER_URL)).addEventListener(\"message\", func);`\r\n* html5 Websocket\r\n - `(new WebSocket(SERVER_URL)).addEventListener(\"message\", func);`\r\n\r\n**你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？）**\r\n\r\n* Web App(HTML5)：采用HTML5生存在浏览器中的应用，不需要下载安装\r\n  - 优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端\r\n  - 缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、GPS等）\r\n\r\n * Hybrid App(混合开发)：UI WebView，需要下载安装\r\n   - 优点：接近 Native App 的体验，部分支持离线功能\r\n   - 缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟\r\n\r\n* Native App(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用\r\n\r\n  - 优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册）\r\n  - 缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核\r\n\r\n**Web 前端开发的注意事项？**\r\n\r\n* 特别设置 meta 标签 viewport\r\n* 百分比布局宽度，结合 box-sizing: border-box;\r\n* 使用 rem 作为计算单位。rem 只参照跟节点 html 的字体大小计算\r\n* 使用 css3 新特性。弹性盒模型、多列布局、媒体查询等\r\n* 多机型、多尺寸、多系统覆盖测试\r\n\r\n**在设计 Web APP 时，应当遵循以下几点**\r\n\r\n* 简化不重要的动画/动效/图形文字样式\r\n* 少用手势，避免与浏览器手势冲突\r\n* 减少页面内容，页面跳转次数，尽量在当前页面显示\r\n* 增强 Loading 趣味性，增强页面主次关系\r\n\r\n**平时如何管理你的项目？**\r\n\r\n* 规定全局样式、公共脚本\r\n* 严格要求代码注释(html/js/css)\r\n* 严格要求静态资源存放路径\r\n* Git 提交必须填写说明\r\n\r\n**如何设计突发大规模并发架构？**\r\n\r\n* 及时响应(NoSQL缓存)\r\n* 数据安全(数据备份)\r\n* 负载均衡\r\n\r\n**说说最近最流行的一些东西吧？**\r\n\r\n- ES6、Node、React、Webpack\r\n\r\n## JSBridge\r\n\r\n// WebViewJavascriptBridge是提前注入的一个全局变量用于javascript调用native提供的函数\r\n\r\nThis lib will inject a WebViewJavascriptBridge Object to window object. You can listen to WebViewJavascriptBridgeReady event to ensure window.WebViewJavascriptBridge is exist, as the blow code shows:\r\n\r\n``` js\r\n    if (window.WebViewJavascriptBridge) {\r\n        //do your work here\r\n    } else {\r\n        document.addEventListener(\r\n            'WebViewJavascriptBridgeReady'\r\n            , function() {\r\n                //do your work here\r\n            },\r\n            false\r\n        );\r\n    }\r\n```\r\nOr put all JsBridge function call into window.WVJBCallbacks array if window.WebViewJavascriptBridge is undefined, this taks queue will be flushed when WebViewJavascriptBridgeReady event triggered.\r\n\r\nCopy and paste setupWebViewJavascriptBridge into your JS:\r\n\r\n``` js\r\nfunction setupWebViewJavascriptBridge(callback) {\r\n\tif (window.WebViewJavascriptBridge) {\r\n        return callback(WebViewJavascriptBridge);\r\n    }\r\n\tif (window.WVJBCallbacks) {\r\n        return window.WVJBCallbacks.push(callback);\r\n    }\r\n\twindow.WVJBCallbacks = [callback];\r\n}\r\n```\r\nCall setupWebViewJavascriptBridge and then use the bridge to register handlers or call Java handlers:\r\n\r\n``` js\r\nsetupWebViewJavascriptBridge(function(bridge) {\r\n\tbridge.registerHandler('JS Echo', function(data, responseCallback) {\r\n\t\tconsole.log(\"JS Echo called with:\", data);\r\n\t\tresponseCallback(data);\r\n    });\r\n\tbridge.callHandler('ObjC Echo', {'key':'value'}, function(responseData) {\r\n\t\tconsole.log(\"JS received response:\", responseData);\r\n\t});\r\n});\r\n```\r\n\r\nIt same with https://github.com/marcuswestin/WebViewJavascriptBridge, that would be easier for you to define same behavior in different platform between Android and iOS. Meanwhile, writing concise code.\r\n\r\n### 注册监听事件\r\n\r\n这段代码是固定的，必须要放到js中\r\n\r\n``` js\r\n/*这段代码是固定的，必须要放到js中*/\r\nfunction setupWebViewJavascriptBridge(callback) {\r\n  // Android使用\r\n  if (window.WebViewJavascriptBridge) {\r\n    callback(WebViewJavascriptBridge)\r\n  } else {\r\n    document.addEventListener(\r\n      'WebViewJavascriptBridgeReady',\r\n      function() {\r\n        callback(WebViewJavascriptBridge)\r\n      },\r\n      false\r\n    );\r\n  }\r\n  //iOS使用\r\n  if (window.WebViewJavascriptBridge) {\r\n    return callback(WebViewJavascriptBridge);\r\n  } if (window.WVJBCallbacks) {\r\n    return window.WVJBCallbacks.push(callback);\r\n  }\r\n\r\n  window.WVJBCallbacks = [callback];\r\n  var WVJBIframe = document.createElement('iframe');\r\n  WVJBIframe.style.display = 'none';\r\n  WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__';\r\n  document.documentElement.appendChild(WVJBIframe);\r\n  setTimeout(function() {\r\n    document.documentElement.removeChild(WVJBIframe)\r\n  }, 0);\r\n}\r\n```\r\n\r\n### 原生调用js\r\n在 setupWebViewJavascriptBridge 中注册原生调用的js\r\n\r\n``` js\r\n//在改function 中添加原生调起js方法\r\nsetupWebViewJavascriptBridge(function(bridge) {\r\n  //注册原生调起方法\r\n  //参数1： buttonjs 注册flag 供原生使用，要和原生统一\r\n  //参数2： data  是原生传给js 的数据\r\n  //参数3： responseCallback 是js 的回调，可以通过该方法给原生传数据\r\n  bridge.registerHandler(\"buttonjs\", function(data, responseCallback) {\r\n    document.getElementById(\"show\").innerHTML = \"buuton js\" + data;\r\n    responseCallback(\"button js callback\");\r\n  });\r\n});\r\n```\r\n\r\n### js 调用原生方法\r\n``` js\r\nsetupWebViewJavascriptBridge(function(bridge) {\r\n  document.getElementById('enter3').onclick = function (e) {\r\n  var data = \"good hello\"\r\n  //参数1： pay 注册flag 供原生使用，要和原生统一\r\n  //参数2： 是调起原生时向原生传递的参数\r\n  //参数3： 原生调用回调返回的数据\r\n  bridge.callHandler('getBlogNameFromObjC', data, function(resp) {\r\n    document.getElementById(\"show\").innerHTML = \"payInterface\" + resp;\r\n  });\r\n});\r\n```\r\n\r\n## babel原理\r\n\r\n### 核心成员\r\n\r\n- babel-core：babel转译器本身，提供了babel的转译API，如babel.transform等，用于对代码进行转译。像webpack的babel-loader 就是调用这些API来完成转译过程的。\r\n- babylon：js的词法解析器\r\n- babel-traverse：用于对AST（抽象语法树，想了解的请自行查询编译原理）的遍历，主要给plugin用\r\n- babel-generator：根据AST生成代码\r\n\r\n（1）babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：\r\n\r\n- ES6代码输入\r\n\r\n- babylon进行解析得到AST\r\n\r\n- plugin用babel-traverse对AST树进行遍历转译,得到新的AST树\r\n\r\n- 用babel-generator通过AST树生成ES5代码\r\n\r\nES6代码输入 ==》 babylon进行解析 ==》 得到AST\r\n==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树\r\n==》 用babel-generator通过AST树生成ES5代码\r\n\r\n注：\r\n\r\nbabel只是转译新标准引入的语法，比如ES6的箭头函数转译成ES5的函数；而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的API等（如Proxy、Set等），这些babel是不会转译的。需要用户自行引入polyfill来解决\r\n\r\n## git rebase 和 git merge 有啥区别？\r\n\r\nrebase会把你当前分支的 commit 放到公共分支的最后面,所以叫变基。\r\n\r\nmerge 会把公共分支和你当前的commit 合并在一起，形成一个新的 commit 提交\r\n\r\n## E2E\r\n\r\nE2E（End To End）即端对端测试，属于黑盒测试，通过编写测试用例，自动化模拟用户操作，确保组件间通信正常，程序流数据传递如预期。\r\n\r\n典型E2E测试框架对比\r\n\r\n| 名称 | 断言 | 是否跨浏览器支持 | 实现 | 官网 | 是否开源 |\r\n| ---- | ---- | ---- | ---- | ---- |\r\n| nightwatch | assert 和 Chai Expect | 是 | selenium | http://nightwatchjs.org/ | 是 |\r\n| cypress | Chai、Chai-jQuery 等 | 否 | Chrome | https://www.cypress.io/ | 是 |\r\n| testcafe | 自定义的断言 | 是 | 不是基于 selenium 实现 | https://devexpress.github.io/testcafe/ | 是 |\r\n| katalon | TDD/BDD | 是 | 未知 | https://www.katalon.com/katalon-studio/ | 否 |\r\n\r\n## 如何选择图片格式，例如 png, webp\r\n\r\n| 图片格式 | 压缩方式 | 透明度 | 动画 | 浏览器兼容 | 适应场景 |\r\n| ---- | ---- | ---- | ---- | ---- | ---- |\r\n\r\n| JPEG | 有损压缩 | 不支持 | 不支持 | 所有 | 复杂颜色及形状、尤其是照片 |\r\n| GIF | 无损压缩 | 支持 | 支持 | 所有 | 简单颜色，动画 |\r\n| PNG | 无损压缩 | 支持 | 不支持 | 所有 | 需要透明时 |\r\n| APNG | 无损压缩 | 支持 | 支持 | Firefox SafariIOS Safari | 需要半透明效果的动画 |\r\n| WebP | 有损压缩 | 支持 | 支持 | Chrome OperaAndroid ChromeAndroid Browser | 复杂颜色及形状浏览器平台可预知 |\r\n| SVG | 无损压缩 | 支持 | 支持 | 所有（IE8以上）||\r\n\r\n## common.js 和 es6 中模块引入的区别？\r\n\r\nCommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有：\r\n\r\n1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\r\n2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\r\n3. CommonJs 是单个值导出，ES6 Module可以导出多个\r\n4. CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层\r\n5. CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined\r\n\r\n## 设计WebSDK站在什么样的角度思考问题\r\n\r\n- 使用者方便的角度，接口尽可能的简单\r\n  - 多通道API接口兼容性的抹平\r\n  - 形成场景模式的使用线，根据不同的场景将多个API调用合并成一个，尽可能的简化API的调用。\r\n\r\n- 事件监听回调函数的链式操作和设置属性同步方法的链式操作\r\n\r\n- 工厂方法的模式创建多通道的实例\r\n\r\n- 单实例埋点添加，保证出现问题后方便定位问题\r\n\r\n- 说明文档\r\n  - 保持简单清晰，在线版和SDK包（如果有）离线版共存\r\n  - 跟随SDK及时更新，注明更新时间及对应版本号，若新版改动较大，需要保持老版文档及入口\r\n  - 如果使用了第三方库，需要包含详尽的使用步骤、注意事项以及问题解决方法\r\n\r\n- 提供Demo\r\n  - 保证Demo可用并随SDK或开发工具的更新保持同步更新\r\n  - Demo中应包含完整的SDK功能示例\r\n\r\n## webpack和gulp的优缺点\r\n\r\n| | gulp | webpack |\r\n| ---- | ---- | ---- |\r\n| 定位 | 基于任务流的自动化打包工具 | 模块化打包工具 |\r\n| 优点 | 易于学习和理解, 适合多页面应用开发 | 可以模块化的打包任何资源,适配任何模块系统,适合SPA单页应用的开发 |\r\n| 缺点 | 不太适合单页或者自定义模块的开发 | 学习成本低,配置复杂,通过babel编译后的js代码打包后体积过 |\r\n\r\n## 什么是前端工程化？\r\n\r\n- 模块化：AMD、CMD、commonjs、ESM。\r\n- 自动化：自动化测试、自动化构建、自动化部署。\r\n- 规范化：Vue编码规范、React编码规范、Git提交规范、文档规范。\r\n- 各种工具：Webpack、Rollup、Vite、Babel、PostCSS。\r\n\r\n## 包管理器用的哪个？\r\n\r\nnpm、cnpm、yarn、pnpm，或者有些大公司会自建包管理器。\r\n\r\nnpm和yarn的原理类似，但是yarn相对来说速度更快。\r\n\r\npnpm与npm、yarn不同，pnpm不会将每个包都复制到项目的node_modules文件夹中，而是将所有包放在一个公共存储库中，并且在需要使用包时将其链接到项目中。这种方法可以减少磁盘使用量，并提高安装和更新速度。\r\n\r\n推荐使用yarn和pnpm，速度更快，更稳定。\r\n\r\n## 有没有写过自动化测试，怎么做前端自动化测试？\r\n\r\n### 测试的优缺点\r\n\r\n- 优点：提高测试效率、确保代码质量，重构舒服\r\n- 缺点：学习成本高，需要额外的时间来思考和编写测试代码\r\n\r\n### 测试的分类\r\n\r\n- 单元测试：针对代码的最小单元进行测试，例如测试函数或模块等。\r\n- 集成测试：将多个模块组合在一起进行测试，确保它们在一起能够正确地工作。\r\n- 端到端测试：模拟用户在应用程序中执行操作的场景，例如点击按钮、输入文本等。\r\n\r\n### 测试常用框架\r\n\r\n- **Jest**：基础测试框架，一般测试就是选个基础框架，然后再选一些测试工具。\r\n\r\n- **vue-test-utils**：vue-test-utils 是一个 Vue.js 官方的单元测试实用工具库，提供了许多 API 来方便地测试 Vue 组件。在单元测试中，可以通过模拟组件的 props、methods、data 等属性和方法，以及通过创建 wrapper 对象来访问组件实例的生命周期钩子函数，来进行组件的测试。此外，还可以使用 snapshot 测试来测试组件的渲染输出是否符合预期。\r\n\r\n- **Cypress**：Cypress是一个用于 Web 应用程序的端到端测试工具，它可以模拟用户操作和行为，以及监控页面状态和 DOM 变化等。\r\n\r\n- **Enzyme**：Enzyme 是一个 React 组件测试实用工具库，提供了许多 API 来方便地测试 React 组件。在单元测试中，可以通过模拟组件的 props、state、函数和生命周期钩子等属性和方法，以及通过创建 wrapper 对象来访问组件实例的 DOM 节点和事件，来进行组件的测试。\r\n\r\n### 测试检验结果\r\n\r\n通过测试覆盖率当成测试的检验结果，测试覆盖率是衡量测试用例覆盖源代码的程度的指标，包括行覆盖率、分支覆盖率、函数覆盖率和语句覆盖率。测试覆盖率可以评估测试用例的质量和完整性，帮助开发人员确定需要更多测试的部分，并作为一种度量软件质量的指标。覆盖率越高，说明被测试的代码被验证的越充分，软件更加稳定和可靠。\r\n\r\n### 总结\r\n\r\n一般在项目里如果只是做UI开发，大多数情况下不用写自动化测试，但是一些封装的工具，组件库，插件之类的，可以写测试提高代码健壮性。\r\n\r\n## 什么是持续集成？\r\n\r\n持续集成，简称CI。CI有以下好处：\r\n\r\n- CI作为敏捷开发重要的一步，其目的在于让产品快速迭代的同时，尽可能保持高质量.\r\n- CI可以增加项目可见性，降低项目失败风险的开发实践。其每一次代码更新，都要通过自动化测试来检测代码和功能的正确性，只有通过自动测试的代码才能进行后续的交付和部署.\r\n- CI 是团队成员间（产研测）更好地协调工作，更好的适应敏捷迭代开发，自动完成减少人工干预，保证每个时间点上团队成员提交的代码都能成功集成的，可以很好的用于对各种WEB、APP项目的打包.\r\n\r\n一般是借助Jenkins、Docker、Travis、GitLab等工具来实现，大多数时候是由后端或者运维来做这个事的，但是在公司没有专业运维的情况下，前端负责人也可以考虑给项目上持续集成。\r\n\r\n## 用过Babel吗？讲一下你对Babel的了解？\r\n\r\nBabel是一个JS编译器，用通俗的话解释就是它主要用于将高版本的JavaScript代码转为向后兼容的JS代码，从而能让我们的代码运行在更低版本的浏览器或者其他的环境中。\r\n\r\nBabel的核心就是plugin、preset。\r\n\r\n1. **plugin**：Babel功能的实现就是靠着各种plugin，Babel插件包括语法插件和转换插件。\r\n\r\n2. **preset**：预设，一组plugin的组合，共同完成一个大功能。\r\n\r\nBabel执行原理:\r\n\r\n1. 解析: 将代码字符串转换成 AST抽象语法树\r\n2. 转换: 访问AST的节点进行变换操作生成新的 AST\r\n3. 生成: 以新的AST为基础生成代码\r\n\r\n## ESLint有什么用？你有用它来规范过团队代码吗？\r\n\r\nESLint是JS代码检查工具，可以用来规范前端代码风格和发现潜在的代码错误。\r\n\r\n很多初学者不愿意用这样的代码检查工具，因为总会报错。但是对于有经验的开发者或者说团队管理者来说，它可以规范团队小伙伴的编码风格。\r\n\r\nESLint常用的配置有：\r\n\r\n- rules：指定规则，包括警告和错误规则，可以覆盖继承规则集中的规则或自定义规则。\r\n- plugins：指定插件，可以使用已有的插件如eslint-plugin-react或自定义插件。\r\n\r\n## 讲一下你了解哪些前端模块化规范？\r\n\r\n1. ES6 模块化：ES6 模块化是一种 JavaScript 模块化规范，是 ES6 中新增的语言特性。在 ES6 中，每个模块都是一个独立的文件，并通过 export 导出模块，通过 import 导入模块。例如：\r\n\r\n``` javascript\r\n// 导出模块\r\nexport var foo = 'bar';\r\nexport function add(x, y) {\r\n  return x + y;\r\n}\r\n\r\n// 导入模块\r\nimport {foo, add} from 'module';\r\nconsole.log(foo); // 'bar'\r\nconsole.log(add(1, 2)); // 3\r\n```\r\n\r\n2. CommonJS：Node.js的模块化规范。在CommonJS中，每个模块都是一个单独的文件，并通过module.exports导出模块，通过require()导入模块。例如：\r\n\r\n``` javascript\r\n// 导出模块\r\nmodule.exports = {\r\n  foo: 'bar',\r\n  add: function(x, y) {\r\n    return x + y;\r\n  }\r\n};\r\n\r\n// 导入模块\r\nvar module = require('module');\r\nconsole.log(module.foo); // 'bar'\r\nconsole.log(module.add(1, 2)); // 3\r\n```\r\n\r\n3. AMD和CMD：以前老的模块化规范，现在很少用了。\r\n\r\n## 讲一下你最常用的git命令，你们团队的git提交规范是什么？\r\n\r\n### 常用命令\r\n\r\n- git init: 初始化Git仓库。\r\n- git clone：克隆远程仓库到本地。\r\n- git add：保存修改。\r\n- git commit：提交修改。\r\n- git push：将本地仓库的修改推送到远程仓库。\r\n- git pull：从远程仓库拉取最新的修改到本地仓库。\r\n- git stash：暂存当前工作区，以便后续恢复。\r\n- git reset: 恢复到指定的提交。\r\n- git revert: 撤销指定的提交。\r\n- git branch: 列出当前所有分支。\r\n- git checkout: 切换到指定分支或提交。\r\n- git merge: 将指定分支合并到当前分支。\r\n\r\n### 提交规范\r\n\r\n一般采用 Angular 团队提出的 Commit Message Conventions。\r\n\r\n1. 每次提交都应该包含一个 Header，格式为 `\u003ctype\u003e(\u003cscope\u003e): \u003csubject\u003e`，其中 `\u003ctype\u003e` 表示提交的类型，包括以下几种：feat（新功能）、fix（修复 bug）、docs（文档修改）、style（代码样式修改）、refactor（重构代码）、test（增加测试代码）、chore（构建过程或辅助工具的修改）；`\u003cscope\u003e` 表示影响的范围；`\u003csubject\u003e` 表示简要说明。\r\n2. Header 应该在 50 个字符以内。\r\n3. Header 应该使用英文。\r\n4. Body 是可选的，用于更详细地说明修改内容，可以分成多行，每行不超过 72 个字符。\r\n5. Footer 也是可选的，用于关闭 Issue 或者列举重大变化等。 这种提交规范可以帮助团队更好地管理代码，方便追踪历史修改记录，提高代码质量。\r\n\r\n## 打包工具了解哪些，Webpack、Rollup、Parcel有什么区别？\r\n\r\nWebpack适合打包大型项目，可以处理多种文件类型，包括 JS、CSS、图片、字体等,另外通过Loader和Plugin机制提供了丰富的扩展功能。\r\n\r\nRollup适合JS库打包。Rollup的特点是生成的代码简洁，不会出现冗余的代码，因此适合用于构建库或插件等独立的组件。\r\n\r\nParcel使用简单，适用于小型项目和个人项目打包。\r\n\r\n## 有用过Vite吗，为什么Vite会那么快？\r\n\r\n1. 在开发环境下利用Chrome原生支持ESM的新特性，减少了处理import的消耗。\r\n\r\n2. 静态分析和模块预构建：Vite 在启动时，会分析项目中的所有模块，并提前编译和缓存这些模块，以便在需要时能够快速地提供给浏览器。这样可以避免了每次修改代码时重新构建的时间浪费。\r\n\r\n3. Vite内部使用ESBuild来处理TS，比TSC性能要好很多。\r\n\r\n## 你怎么理解前端基建？\r\n\r\n包括但不限于：\r\n\r\n- 规范建设，给团队指定编码和提交规范。\r\n- 文档建设，包括组件文档、业务文档、接口文档、跨端跨部门文档。\r\n- 安全建设。\r\n- 性能体系、埋点体系。\r\n- 组件库和类库建设。\r\n- BFF方案，包括SSR和GraphQL.\r\n- 微前端方案。\r\n- 脚手架。\r\n- 低代码。\r\n\r\n## 有了解过Rust吗？在前端有哪些应用？\r\n\r\nRust特点：简单概括就是高性能、语法多、学习难。(鉴于此，后续我会出一个教前端同学入门Rust的专栏。)\r\n\r\nRust的语法特性包括：所有权、借用、trait、泛型、模式匹配、宏等。\r\n\r\nRust在前端领域主要应用有WASM和前端基建，并且已经有了不少实战。比如：\r\n\r\n1. Yew：一个用Rust开发WASM应用的框架，开发体验类似于React，甚至也有Yew Hooks。\r\n2. Deno：JS和TS运行时，相当于更安全，性能更好的Nodejs。\r\n3. SWC：相当于Rust版的Babel。\r\n4. Turbopack、RSpack：相当于Rust版的Webpack。\r\n\r\n## 微前端适用于什么场景？设计一个微前端框架要怎么考虑？\r\n\r\n微前端适用于以下场景：\r\n\r\n1. 随着项目规模逐渐扩大，团队协作效率降低，可以考虑将大项目拆分成多个小项目，每个小项目都由独立的小型团队独立开发独立部署，\r\n2. 团队技术栈不同，可以将项目拆分，每个子项目采用不同技术栈开发，然后用微前端框架把项目组合在一块。\r\n\r\n设计一个微前端框架，需要考虑：\r\n\r\n1. 样式隔离：样式隔离可以采用的方案有CSS Modules、Shadow DOM、CSS-in-JS或者命名约定的方式。\r\n2. JS隔离：JS隔离需要创建沙箱环境，JS里可以通过Web Worker或者iframe来创建沙箱，还可以通过IIFE(立即调用表达式)来创建沙箱。\r\n3. 应用通信：应用之间可以采取URL参数传递信息、事件总线或者全局变量(会造成命名冲突和状态污染、，不够优雅)来实现通信。\r\n4. 路由管理：微前端中的路由管理，主要包括两个方面的内容：一是在宿主应用中对微前端应用的路由进行管理，二是在微前端应用内部实现自身的路由管理。\r\n5. 代码共享：可以通过将公用代码提取成三方库的形式来共享代码，还可以采用Webpack5的模块联邦来实现代码共享。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/603/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/603/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 前端性能优化","### 1. 减少 HTTP 请求","### 2. 使用 HTTP2","#### 解析速度快","#### 多路复用","#### 首部压缩","#### 优先级","#### 流量控制","#### 服务器推送","### 3. 使用服务端渲染","#### 客户端渲染过程","#### 服务端渲染过程","### 4. 静态资源使用 CDN","#### CDN 原理","### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部","### 6. 使用字体图标 iconfont 代替图片图标","#### 压缩字体文件","### 7. 善用缓存，不重复加载相同的资源","### 8. 压缩文件","### 9. 图片优化","#### (1). 图片延迟加载","#### (2). 响应式图片","#### (3). 调整图片大小","#### (4). 降低图片质量","#### (5). 尽可能利用 CSS3 效果代替图片","#### (6). 使用 webp 格式的图片","### 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码","#### 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载","#### 提取第三方库","#### 减少 ES6 转为 ES5 的冗余代码","### 11. 减少重绘重排","#### 重排","#### 重绘","### 12. 使用事件委托","### 13. 注意程序的局部性","### 14. if-else 对比 switch","### 15. 查找表","### 16. 避免页面卡顿","### 17. 使用 requestAnimationFrame 来实现视觉变化","### 18. 使用 Web Workers","### 19. 使用位操作","#### 取模","#### 取整","#### 位掩码","### 20. 不要覆盖原生方法","### 21. 降低 CSS 选择器的复杂性","#### (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取","#### (2). CSS 选择器优先级","### 22. 使用 flexbox 而不是较早的布局模型","### 23. 使用 transform 和 opacity 属性更改来实现动画","### 24. 合理使用规则，避免过度优化","#### 检查加载性能","#### 检查运行性能","## 如何进行网站性能优化","## PNG,GIF,JPG 的区别及如何选","## AMD和CMD规范区别","## SPA单页页面","### SPA优点","### SPA缺点","## 什么是 Jest?","## Jest 对比 Jasmine 有什么优势?","## 前端错误监控","### 1 前言","### 2 前端错误的分类","### 3 每种错误的捕获方式","#### 3.1 即时运行错误的捕获方式","#### 3.2 资源加载错误的捕获方式","### 4 错误上报的两种方式","## 前端工程化相关","## 前端模块化","## 性能优化","## 图片相关","## SEO","### 前端需要注意哪些SEO","## Git","## 前端工程化的理解","## JSBridge","### 注册监听事件","### 原生调用js","### js 调用原生方法","## babel原理","### 核心成员","## git rebase 和 git merge 有啥区别？","## E2E","## 如何选择图片格式，例如 png, webp","## common.js 和 es6 中模块引入的区别？","## 设计WebSDK站在什么样的角度思考问题","## webpack和gulp的优缺点","## 什么是前端工程化？","## 包管理器用的哪个？","## 有没有写过自动化测试，怎么做前端自动化测试？","### 测试的优缺点","### 测试的分类","### 测试常用框架","### 测试检验结果","### 总结","## 什么是持续集成？","## 用过Babel吗？讲一下你对Babel的了解？","## ESLint有什么用？你有用它来规范过团队代码吗？","## 讲一下你了解哪些前端模块化规范？","## 讲一下你最常用的git命令，你们团队的git提交规范是什么？","### 常用命令","### 提交规范","## 打包工具了解哪些，Webpack、Rollup、Parcel有什么区别？","## 有用过Vite吗，为什么Vite会那么快？","## 你怎么理解前端基建？","## 有了解过Rust吗？在前端有哪些应用？","## 微前端适用于什么场景？设计一个微前端框架要怎么考虑？"]},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"603"},"buildId":"01n3oM-TaM2WlnAyxyv2V","assetPrefix":"/toolkit","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>