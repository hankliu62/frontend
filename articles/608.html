<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具集合</title><link rel="icon" href="/toolbox-frontend/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="stylesheet" href="/toolbox-frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/toolbox-frontend/_next/static/css/e443953a41d4ccca.css" as="style"/><link rel="stylesheet" href="/toolbox-frontend/_next/static/css/e443953a41d4ccca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/toolbox-frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/toolbox-frontend/_next/static/chunks/webpack-c5f674d417b86779.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/framework-aec4381329cec0e4.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/main-82d23b26b43cd32b.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/_app-f3d697fda40e8318.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/6396-e9161609a76be07a.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/8490-2f2be535c5ee8413.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/1664-f865873e77459860.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/articles/%5Bid%5D-64dad036164a7646.js" defer=""></script><script src="/toolbox-frontend/_next/static/0Vvb4_ySYrEYJ5MFNauen/_buildManifest.js" defer=""></script><script src="/toolbox-frontend/_next/static/0Vvb4_ySYrEYJ5MFNauen/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1 overflow-x-hidden"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-12jzuas"><div class="ant-card-body"><article><div class="mx-auto mb-[36px] max-w-[1045px] px-[30px] lg:mb-[52px] lg:flex lg:px-0"><div id="banner" class="media-wrapper image-media-wrapper w-full rounded-[8px] border-[1px] border-solid border-[#1D2129] lg:ml-0 lg:h-[320px] lg:w-[500px]"><div class="hidden before"></div><div class="hidden after"></div><div class="scale-103 h-full w-full border-[8px] border-solid border-white lg:scale-100 cover-wrapper"><img class="h-full w-full rounded-md object-cover cover" src="/toolbox-frontend/dashboard/images/banner.png" alt=""/></div></div><div class="mt-[60px] overflow-hidden lg:ml-[32px] lg:mt-0 lg:flex-1"><h1 class="leading-130 montserrat-bold mb-[9px] text-[36px] font-medium text-[#1D2129] lg:mb-[8px]">网络相关的面试题</h1><div class="mb-[9px] flex whitespace-nowrap lg:mb-[10px]"><div class="leading-120 cursor-pointer truncate text-[24px] font-normal text-[#1D2129] underline-offset-2 hover:underline lg:text-[20px]" aria-hidden="true"># VOL.<!-- -->608</div><div class="leading-120 ml-[48px] text-[24px] font-normal text-[#1D2129] lg:ml-[32px] lg:text-[20px]">2024/02/13</div></div><div class="mb-[12px] flex flex-wrap lg:mb-0"><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">blog</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">network</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">interview</div></div><div class="my-[30px] hidden w-[213px] border border-[#1D2129] lg:mb-[20px] lg:mt-[8px] lg:block"></div><div class="lg:rounded-0 rounded-[12px] bg-white/30 p-[36px] lg:flex lg:bg-transparent lg:p-0"><div class="float-left h-[118px] w-[118px] lg:float-none lg:h-[112px] lg:w-[112px]"><img src="https://avatars.githubusercontent.com/u/8088864?v=4" class="h-full w-full rounded-[8px] object-cover lg:rounded-[12px]" alt=""/></div><div class="lg:ml-[32px] lg:flex-1 lg:overflow-hidden"><div class="mb-[10px] flex h-[118px] flex-col justify-center pl-[36px] lg:h-auto lg:flex-row lg:items-center lg:justify-between lg:pl-0"><div class="leading-130 montserrat-bold mb-[12px] w-full truncate text-[30px] font-medium text-[#1D2129] lg:mb-0 lg:flex-1 lg:text-[24px]">hankliu62</div><a class="leading-170 ml-0 whitespace-pre-wrap text-[20px] font-normal !text-[#1D2129] !underline hover:!text-[#1D2129] hover:!underline focus:!text-[#1D2129] lg:ml-[5px] lg:text-[14px]" href="https://github.com/hankliu62" target="_blank" rel="noreferrer">TA的个人名片</a></div><div class="leading-170 text-[20px] font-normal text-[#4E5969] lg:text-[14px]">HankLiu前端开发工程师，精通前端，涉猎后端，对前端有着浓厚的兴趣，希望能够在前端这条路上一直走下去。努力去听风的声音，不必在意风的方向。</div></div></div></div></div><div class="ant-divider css-12jzuas ant-divider-horizontal !mt-0 !border-[#bfc3c7]" role="separator"></div><section><div><div class="ant-skeleton ant-skeleton-active css-12jzuas"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-12jzuas"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="## 强缓存与协商缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/toolbox-frontend/articles/608#%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:16px">强缓存与协商缓存</div></a></li><li id="### 浏览器缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:32px">浏览器缓存</div></a></li><li id="#### 缓存优点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%BC%93%E5%AD%98%E4%BC%98%E7%82%B9"><div class="truncate" style="padding-left:48px">缓存优点</div></a></li><li id="#### 缓存缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%BC%93%E5%AD%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:48px">缓存缺点</div></a></li><li id="#### 缓存流程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B"><div class="truncate" style="padding-left:48px">缓存流程</div></a></li><li id="### 强缓存相关的header字段" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%BC%BA%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84header%E5%AD%97%E6%AE%B5"><div class="truncate" style="padding-left:32px">强缓存相关的header字段</div></a></li><li id="### 协商缓存相关的header字段" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84header%E5%AD%97%E6%AE%B5"><div class="truncate" style="padding-left:32px">协商缓存相关的header字段</div></a></li><li id="#### 1. Last-Modified/If-Modified-Since" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1.-last-modified/if-modified-since"><div class="truncate" style="padding-left:48px">1. Last-Modified/If-Modified-Since</div></a></li><li id="#### 2. Etag/If-None-Match" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.-etag/if-none-match"><div class="truncate" style="padding-left:48px">2. Etag/If-None-Match</div></a></li><li id="### 既生Last-Modified何生Etag" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%97%A2%E7%94%9Flast-modified%E4%BD%95%E7%94%9Fetag"><div class="truncate" style="padding-left:32px">既生Last-Modified何生Etag</div></a></li><li id="### 用户的行为对缓存的影响" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%94%A8%E6%88%B7%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%AF%B9%E7%BC%93%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D"><div class="truncate" style="padding-left:32px">用户的行为对缓存的影响</div></a></li><li id="### 强缓存如何重新加载缓存缓存过的资源" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%BC%BA%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E7%BC%93%E5%AD%98%E7%BC%93%E5%AD%98%E8%BF%87%E7%9A%84%E8%B5%84%E6%BA%90"><div class="truncate" style="padding-left:32px">强缓存如何重新加载缓存缓存过的资源</div></a></li><li id="## HTTP 各版本特点与区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http-%E5%90%84%E7%89%88%E6%9C%AC%E7%89%B9%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">HTTP 各版本特点与区别</div></a></li><li id="### 1、HTTP 0.9" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1http-0.9"><div class="truncate" style="padding-left:32px">1、HTTP 0.9</div></a></li><li id="### 2、HTTP 1.0" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2http-1.0"><div class="truncate" style="padding-left:32px">2、HTTP 1.0</div></a></li><li id="### 3、HTTP 1.1" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#3http-1.1"><div class="truncate" style="padding-left:32px">3、HTTP 1.1</div></a></li><li id="#### Persistent Connection（keepalive连接）" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#persistent-connectionkeepalive%E8%BF%9E%E6%8E%A5"><div class="truncate" style="padding-left:48px">Persistent Connection（keepalive连接）</div></a></li><li id="#### chunked编码传输" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#chunked%E7%BC%96%E7%A0%81%E4%BC%A0%E8%BE%93"><div class="truncate" style="padding-left:48px">chunked编码传输</div></a></li><li id="#### 字节范围请求" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%AD%97%E8%8A%82%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82"><div class="truncate" style="padding-left:48px">字节范围请求</div></a></li><li id="#### 断点续传" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><div class="truncate" style="padding-left:48px">断点续传</div></a></li><li id="#### Pipelining（请求流水线）" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#pipelining%E8%AF%B7%E6%B1%82%E6%B5%81%E6%B0%B4%E7%BA%BF"><div class="truncate" style="padding-left:48px">Pipelining（请求流水线）</div></a></li><li id="#### 其他特性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><div class="truncate" style="padding-left:48px">其他特性</div></a></li><li id="### 4、HTTP 2.0" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#4http-2.0"><div class="truncate" style="padding-left:32px">4、HTTP 2.0</div></a></li><li id="#### 二进制分帧" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7"><div class="truncate" style="padding-left:48px">二进制分帧</div></a></li><li id="#### 多路复用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><div class="truncate" style="padding-left:48px">多路复用</div></a></li><li id="#### 头部压缩" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><div class="truncate" style="padding-left:48px">头部压缩</div></a></li><li id="#### 随时复位" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%9A%8F%E6%97%B6%E5%A4%8D%E4%BD%8D"><div class="truncate" style="padding-left:48px">随时复位</div></a></li><li id="#### 服务器端推流" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%8E%A8%E6%B5%81"><div class="truncate" style="padding-left:48px">服务器端推流</div></a></li><li id="#### 优先权和依赖" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E4%BC%98%E5%85%88%E6%9D%83%E5%92%8C%E4%BE%9D%E8%B5%96"><div class="truncate" style="padding-left:48px">优先权和依赖</div></a></li><li id="## 队头阻塞以及解决办法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><div class="truncate" style="padding-left:16px">队头阻塞以及解决办法</div></a></li><li id="### 前言" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%89%8D%E8%A8%80"><div class="truncate" style="padding-left:32px">前言</div></a></li><li id="### TCP队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:32px">TCP队头阻塞</div></a></li><li id="### HTTP队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:32px">HTTP队头阻塞</div></a></li><li id="#### HTTP管道化是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http%E7%AE%A1%E9%81%93%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:48px">HTTP管道化是什么</div></a></li><li id="#### HTTP管道化产生的背景" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http%E7%AE%A1%E9%81%93%E5%8C%96%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF"><div class="truncate" style="padding-left:48px">HTTP管道化产生的背景</div></a></li><li id="#### HTTP管道化的限制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http%E7%AE%A1%E9%81%93%E5%8C%96%E7%9A%84%E9%99%90%E5%88%B6"><div class="truncate" style="padding-left:48px">HTTP管道化的限制</div></a></li><li id="#### HTTP管道化引起的请求队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http%E7%AE%A1%E9%81%93%E5%8C%96%E5%BC%95%E8%B5%B7%E7%9A%84%E8%AF%B7%E6%B1%82%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:48px">HTTP管道化引起的请求队头阻塞</div></a></li><li id="### 如何解决队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:32px">如何解决队头阻塞</div></a></li><li id="#### 如何解决HTTP队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3http%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:48px">如何解决HTTP队头阻塞</div></a></li><li id="#### 如何解决TCP队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:48px">如何解决TCP队头阻塞</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## QUIC" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#quic"><div class="truncate" style="padding-left:16px">QUIC</div></a></li><li id="### QUIC的由来：为什么是UDP而非TCP？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#quic%E7%9A%84%E7%94%B1%E6%9D%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFudp%E8%80%8C%E9%9D%9Etcp"><div class="truncate" style="padding-left:32px">QUIC的由来：为什么是UDP而非TCP？</div></a></li><li id="### 为什么要用QUIC？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8quic"><div class="truncate" style="padding-left:32px">为什么要用QUIC？</div></a></li><li id="#### 1. 建连延迟低" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1.-%E5%BB%BA%E8%BF%9E%E5%BB%B6%E8%BF%9F%E4%BD%8E"><div class="truncate" style="padding-left:48px">1. 建连延迟低</div></a></li><li id="#### 2. 安全又可靠" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.-%E5%AE%89%E5%85%A8%E5%8F%88%E5%8F%AF%E9%9D%A0"><div class="truncate" style="padding-left:48px">2. 安全又可靠</div></a></li><li id="#### 3. 改造灵活" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#3.-%E6%94%B9%E9%80%A0%E7%81%B5%E6%B4%BB"><div class="truncate" style="padding-left:48px">3. 改造灵活</div></a></li><li id="#### 4. 改进的拥塞控制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#4.-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><div class="truncate" style="padding-left:48px">4. 改进的拥塞控制</div></a></li><li id="#### 5. 无队头阻塞的多路复用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#5.-%E6%97%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><div class="truncate" style="padding-left:48px">5. 无队头阻塞的多路复用</div></a></li><li id="### QUIC对客户端的要求" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#quic%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%A6%81%E6%B1%82"><div class="truncate" style="padding-left:32px">QUIC对客户端的要求</div></a></li><li id="### QUIC应用场景" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#quic%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><div class="truncate" style="padding-left:32px">QUIC应用场景</div></a></li><li id="## HTTP协议" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http%E5%8D%8F%E8%AE%AE"><div class="truncate" style="padding-left:16px">HTTP协议</div></a></li><li id="### 1. 前言" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1.-%E5%89%8D%E8%A8%80"><div class="truncate" style="padding-left:32px">1. 前言</div></a></li><li id="### 2. HTTP协议的主要特点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.-http%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><div class="truncate" style="padding-left:32px">2. HTTP协议的主要特点</div></a></li><li id="#### 2.1 简单快速" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.1-%E7%AE%80%E5%8D%95%E5%BF%AB%E9%80%9F"><div class="truncate" style="padding-left:48px">2.1 简单快速</div></a></li><li id="#### 2.2 灵活" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.2-%E7%81%B5%E6%B4%BB"><div class="truncate" style="padding-left:48px">2.2 灵活</div></a></li><li id="#### 2.3 无连接" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.3-%E6%97%A0%E8%BF%9E%E6%8E%A5"><div class="truncate" style="padding-left:48px">2.3 无连接</div></a></li><li id="#### 2.4 无状态" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.4-%E6%97%A0%E7%8A%B6%E6%80%81"><div class="truncate" style="padding-left:48px">2.4 无状态</div></a></li><li id="### 3 HTTP报文的组成部分" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#3-http%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><div class="truncate" style="padding-left:32px">3 HTTP报文的组成部分</div></a></li><li id="#### 3.1 请求报文包括：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#3.1-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%8C%85%E6%8B%AC"><div class="truncate" style="padding-left:48px">3.1 请求报文包括：</div></a></li><li id="#### 3.2 响应报文包括：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#3.2-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%8C%85%E6%8B%AC"><div class="truncate" style="padding-left:48px">3.2 响应报文包括：</div></a></li><li id="### 4 HTTP方法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#4-http%E6%96%B9%E6%B3%95"><div class="truncate" style="padding-left:32px">4 HTTP方法</div></a></li><li id="### 5 get 和 post的区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#5-get-%E5%92%8C-post%E7%9A%84%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:32px">5 get 和 post的区别</div></a></li><li id="### 6 http状态码" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#6-http%E7%8A%B6%E6%80%81%E7%A0%81"><div class="truncate" style="padding-left:32px">6 http状态码</div></a></li><li id="### 7 持久链接/http长连接" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#7-%E6%8C%81%E4%B9%85%E9%93%BE%E6%8E%A5/http%E9%95%BF%E8%BF%9E%E6%8E%A5"><div class="truncate" style="padding-left:32px">7 持久链接/http长连接</div></a></li><li id="### 8 长连接中的管线化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#8-%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%BA%BF%E5%8C%96"><div class="truncate" style="padding-left:32px">8 长连接中的管线化</div></a></li><li id="#### 8.1 管线化的原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#8.1-%E7%AE%A1%E7%BA%BF%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:48px">8.1 管线化的原理</div></a></li><li id="#### 8.2 管线化的注意事项" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#8.2-%E7%AE%A1%E7%BA%BF%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><div class="truncate" style="padding-left:48px">8.2 管线化的注意事项</div></a></li><li id="### 9 TLS 协商" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#9-tls-%E5%8D%8F%E5%95%86"><div class="truncate" style="padding-left:32px">9 TLS 协商</div></a></li><li id="## EventSource和轮询的优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#eventsource%E5%92%8C%E8%BD%AE%E8%AF%A2%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:16px">EventSource和轮询的优缺点</div></a></li><li id="### EventSource" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#eventsource"><div class="truncate" style="padding-left:32px">EventSource</div></a></li><li id="#### 简介" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%AE%80%E4%BB%8B"><div class="truncate" style="padding-left:48px">简介</div></a></li><li id="#### EventSource规范字段" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#eventsource%E8%A7%84%E8%8C%83%E5%AD%97%E6%AE%B5"><div class="truncate" style="padding-left:48px">EventSource规范字段</div></a></li><li id="#### EventSource属性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#eventsource%E5%B1%9E%E6%80%A7"><div class="truncate" style="padding-left:48px">EventSource属性</div></a></li><li id="#### EventSource 通讯过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#eventsource-%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:48px">EventSource 通讯过程</div></a></li><li id="#### 缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:48px">缺点</div></a></li><li id="### 轮询" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E8%BD%AE%E8%AF%A2"><div class="truncate" style="padding-left:32px">轮询</div></a></li><li id="#### 短轮询(Polling)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%9F%AD%E8%BD%AE%E8%AF%A2(polling)"><div class="truncate" style="padding-left:48px">短轮询(Polling)</div></a></li><li id="#### 长轮询(Long Polling)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%95%BF%E8%BD%AE%E8%AF%A2(long-polling)"><div class="truncate" style="padding-left:48px">长轮询(Long Polling)</div></a></li><li id="### EventSource VS 轮询" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#eventsource-vs-%E8%BD%AE%E8%AF%A2"><div class="truncate" style="padding-left:32px">EventSource VS 轮询</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## WebSocket 是什么原理？为什么可以实现持久连接？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#websocket-%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><div class="truncate" style="padding-left:16px">WebSocket 是什么原理？为什么可以实现持久连接？</div></a></li><li id="### WebSocket 机制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#websocket-%E6%9C%BA%E5%88%B6"><div class="truncate" style="padding-left:32px">WebSocket 机制</div></a></li><li id="### WebSocket协议的原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#websocket%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:32px">WebSocket协议的原理</div></a></li><li id="### WebSocket协议的优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#websocket%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:32px">WebSocket协议的优缺点</div></a></li><li id="## 网络相关" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><div class="truncate" style="padding-left:16px">网络相关</div></a></li><li id="### 1.1 DNS 预解析" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1.1-dns-%E9%A2%84%E8%A7%A3%E6%9E%90"><div class="truncate" style="padding-left:32px">1.1 DNS 预解析</div></a></li><li id="### 1.2 缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1.2-%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:32px">1.2 缓存</div></a></li><li id="### 1.3 使用 HTTP / 2.0" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1.3-%E4%BD%BF%E7%94%A8-http-/-2.0"><div class="truncate" style="padding-left:32px">1.3 使用 HTTP / 2.0</div></a></li><li id="### 1.4 预加载" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1.4-%E9%A2%84%E5%8A%A0%E8%BD%BD"><div class="truncate" style="padding-left:32px">1.4 预加载</div></a></li><li id="### 1.5 预渲染" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1.5-%E9%A2%84%E6%B8%B2%E6%9F%93"><div class="truncate" style="padding-left:32px">1.5 预渲染</div></a></li><li id="## 优化渲染过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E4%BC%98%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:16px">优化渲染过程</div></a></li><li id="### 2.1 懒执行" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.1-%E6%87%92%E6%89%A7%E8%A1%8C"><div class="truncate" style="padding-left:32px">2.1 懒执行</div></a></li><li id="### 2.2 懒加载" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2.2-%E6%87%92%E5%8A%A0%E8%BD%BD"><div class="truncate" style="padding-left:32px">2.2 懒加载</div></a></li><li id="## HTTP method" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http-method"><div class="truncate" style="padding-left:16px">HTTP method</div></a></li><li id="## 从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5-url-%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4(%E4%BB%A5-http-%E4%B8%BA%E4%BE%8B)"><div class="truncate" style="padding-left:16px">从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)</div></a></li><li id="## HTTP request 报文结构是怎样的" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http-request-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><div class="truncate" style="padding-left:16px">HTTP request 报文结构是怎样的</div></a></li><li id="## HTTP response 报文结构是怎样的" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http-response-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><div class="truncate" style="padding-left:16px">HTTP response 报文结构是怎样的</div></a></li><li id="## HTTP 状态码及其含义" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http-%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89"><div class="truncate" style="padding-left:16px">HTTP 状态码及其含义</div></a></li><li id="## 说一下 Http 缓存策略，有什么区别，分别解决了什么问题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E8%AF%B4%E4%B8%80%E4%B8%8B-http-%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%88%86%E5%88%AB%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:16px">说一下 Http 缓存策略，有什么区别，分别解决了什么问题</div></a></li><li id="### 1）浏览器缓存策略" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><div class="truncate" style="padding-left:32px">1）浏览器缓存策略</div></a></li><li id="### 2）强缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#2%E5%BC%BA%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:32px">2）强缓存</div></a></li><li id="### 3）强缓存(expires)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#3%E5%BC%BA%E7%BC%93%E5%AD%98(expires)"><div class="truncate" style="padding-left:32px">3）强缓存(expires)</div></a></li><li id="### 4）强缓存(cache-control)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#4%E5%BC%BA%E7%BC%93%E5%AD%98(cache-control)"><div class="truncate" style="padding-left:32px">4）强缓存(cache-control)</div></a></li><li id="### 5）协商缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#5%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:32px">5）协商缓存</div></a></li><li id="### 协商缓存(Last-Modified/If-Modified-since)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98(last-modified/if-modified-since)"><div class="truncate" style="padding-left:32px">协商缓存(Last-Modified/If-Modified-since)</div></a></li><li id="### 协商缓存(Etag/If-None-match)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98(etag/if-none-match)"><div class="truncate" style="padding-left:32px">协商缓存(Etag/If-None-match)</div></a></li><li id="## 前端安全、中间人攻击" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><div class="truncate" style="padding-left:16px">前端安全、中间人攻击</div></a></li><li id="### 1）XSS：跨站脚本攻击" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#1xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"><div class="truncate" style="padding-left:32px">1）XSS：跨站脚本攻击</div></a></li><li id="#### 存储型(server端)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%AD%98%E5%82%A8%E5%9E%8B(server%E7%AB%AF)"><div class="truncate" style="padding-left:48px">存储型(server端)</div></a></li><li id="#### 反射型(Server端)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%8F%8D%E5%B0%84%E5%9E%8B(server%E7%AB%AF)"><div class="truncate" style="padding-left:48px">反射型(Server端)</div></a></li><li id="#### Dom 型(浏览器端)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#dom-%E5%9E%8B(%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF)"><div class="truncate" style="padding-left:48px">Dom 型(浏览器端)</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### CSRF：跨站请求伪造" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#csrf%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0"><div class="truncate" style="padding-left:32px">CSRF：跨站请求伪造</div></a></li><li id="#### 攻击流程举例" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%E4%B8%BE%E4%BE%8B"><div class="truncate" style="padding-left:48px">攻击流程举例</div></a></li><li id="#### 攻击类型" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B"><div class="truncate" style="padding-left:48px">攻击类型</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 3）iframe 安全" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#3iframe-%E5%AE%89%E5%85%A8"><div class="truncate" style="padding-left:32px">3）iframe 安全</div></a></li><li id="#### 说明" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E8%AF%B4%E6%98%8E"><div class="truncate" style="padding-left:48px">说明</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 4）错误的内容推断" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#4%E9%94%99%E8%AF%AF%E7%9A%84%E5%86%85%E5%AE%B9%E6%8E%A8%E6%96%AD"><div class="truncate" style="padding-left:32px">4）错误的内容推断</div></a></li><li id="#### 说明" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E8%AF%B4%E6%98%8E"><div class="truncate" style="padding-left:48px">说明</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 5）第三方依赖包" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#5%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E5%8C%85"><div class="truncate" style="padding-left:32px">5）第三方依赖包</div></a></li><li id="### 6）HTTPS" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#6https"><div class="truncate" style="padding-left:32px">6）HTTPS</div></a></li><li id="#### 描述" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%8F%8F%E8%BF%B0"><div class="truncate" style="padding-left:48px">描述</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 7）本地存储数据" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#7%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><div class="truncate" style="padding-left:32px">7）本地存储数据</div></a></li><li id="### 8）静态资源完整性校验" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%AA%8C"><div class="truncate" style="padding-left:32px">8）静态资源完整性校验</div></a></li><li id="#### 描述" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%8F%8F%E8%BF%B0"><div class="truncate" style="padding-left:48px">描述</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 9）网络劫持" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#9%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81"><div class="truncate" style="padding-left:32px">9）网络劫持</div></a></li><li id="#### 描述" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%8F%8F%E8%BF%B0"><div class="truncate" style="padding-left:48px">描述</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 10）中间人攻击" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#10%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><div class="truncate" style="padding-left:32px">10）中间人攻击</div></a></li><li id="#### 场景" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%9C%BA%E6%99%AF"><div class="truncate" style="padding-left:48px">场景</div></a></li><li id="#### 过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:48px">过程</div></a></li><li id="#### 使用抓包工具fiddle来进行举例说明" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E4%BD%BF%E7%94%A8%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7fiddle%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><div class="truncate" style="padding-left:48px">使用抓包工具fiddle来进行举例说明</div></a></li><li id="#### 常见攻击方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:48px">常见攻击方式</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 11）sql 注入" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#11sql-%E6%B3%A8%E5%85%A5"><div class="truncate" style="padding-left:32px">11）sql 注入</div></a></li><li id="#### 描述" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%8F%8F%E8%BF%B0"><div class="truncate" style="padding-left:48px">描述</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 12）前端数据安全" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#12%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><div class="truncate" style="padding-left:32px">12）前端数据安全</div></a></li><li id="#### 描述" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%8F%8F%E8%BF%B0"><div class="truncate" style="padding-left:48px">描述</div></a></li><li id="#### 预防方案" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E9%A2%84%E9%98%B2%E6%96%B9%E6%A1%88"><div class="truncate" style="padding-left:48px">预防方案</div></a></li><li id="### 13）其他建议" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#13%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE"><div class="truncate" style="padding-left:32px">13）其他建议</div></a></li><li id="## HTTP" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#http"><div class="truncate" style="padding-left:16px">HTTP</div></a></li><li id="## url构成" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#url%E6%9E%84%E6%88%90"><div class="truncate" style="padding-left:16px">url构成</div></a></li><li id="## 反向代理和正向代理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><div class="truncate" style="padding-left:16px">反向代理和正向代理</div></a></li><li id="### 正向代理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><div class="truncate" style="padding-left:32px">正向代理</div></a></li><li id="### 反向代理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><div class="truncate" style="padding-left:32px">反向代理</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## 对称加密和非对称加密" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><div class="truncate" style="padding-left:16px">对称加密和非对称加密</div></a></li><li id="## 一个 tcp 连接能发几个 http 请求？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E4%B8%80%E4%B8%AA-tcp-%E8%BF%9E%E6%8E%A5%E8%83%BD%E5%8F%91%E5%87%A0%E4%B8%AA-http-%E8%AF%B7%E6%B1%82"><div class="truncate" style="padding-left:16px">一个 tcp 连接能发几个 http 请求？</div></a></li><li id="## CDN缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#cdn%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:16px">CDN缓存</div></a></li><li id="## DNS缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#dns%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:16px">DNS缓存</div></a></li><li id="### 浏览器DNS缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E6%B5%8F%E8%A7%88%E5%99%A8dns%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:32px">浏览器DNS缓存</div></a></li><li id="### 系统DNS缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#%E7%B3%BB%E7%BB%9Fdns%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:32px">系统DNS缓存</div></a></li><li id="### ISP DNS缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#isp-dns%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:32px">ISP DNS缓存</div></a></li><li id="## TLS原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/608#tls%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">TLS原理</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/608","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/608/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/608/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/608/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/608","id":2131538666,"node_id":"I_kwDOBiJZIc5_DLLq","number":608,"title":"网络相关的面试题","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536825198,"node_id":"LA_kwDOBiJZIc8AAAABhaAJbg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/network","name":"network","color":"D613F5","default":false,"description":"分类-网络相关"},{"id":6552343574,"node_id":"LA_kwDOBiJZIc8AAAABhozUFg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview","name":"interview","color":"79D677","default":false,"description":"分类-面试题相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-13T06:15:19Z","updated_at":"2024-02-13T08:51:12Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"---\r\n\r\ntitle: 网络相关的面试题\r\n\r\ndate: 2024-02-13 16:51:10\r\n\r\ntag: [blog, interview, network]\r\n\r\n---\r\n\r\n## 强缓存与协商缓存\r\n\r\n### 浏览器缓存\r\n\r\n当浏览器去请求某个文件的时候，服务端就在response header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制\r\n\r\n#### 缓存优点\r\n\r\n1. 减少不必要的数据传输，节省带宽\r\n2. 减少服务器的负担，提升网站性能\r\n3. 加快了客户端加载网页的速度，用户体验友好\r\n\r\n#### 缓存缺点\r\n\r\n资源如果有更改,会导致客户端不及时更新就会造成用户获取信息滞后\r\n\r\n#### 缓存流程\r\n\r\n浏览器第一次请求时\r\n\r\n![浏览器缓存第一次请求](https://user-images.githubusercontent.com/8088864/125554789-a7d7d647-b89f-4c84-a326-5af87e6782f6.png)\r\n\r\n浏览器后续在进行请求时\r\n\r\n![浏览器缓存再次请求](https://user-images.githubusercontent.com/8088864/125554810-255dcfd2-a1f0-4e09-a329-56bacdee6d22.png)\r\n\r\n从上图可以知道,浏览器缓存包括两种类型,即强缓存(本地缓存)和协商缓存,浏览器在第一次请求发生后,再次请求时\r\n\r\n- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（`cache-control`和`expires`信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信。\r\n\r\n请求头信息\r\n\r\n```\r\nAccept: xxx\r\nAccept-Encoding: gzip,deflate\r\nAccept-Language: zh-cn\r\nConnection: keep-alive\r\nHost: xxx\r\nReferer: xxx\r\nUser-Agent: xxx\r\n```\r\n\r\n来自缓存的响应头的信息\r\n\r\n```\r\nAccept-Ranges: bytes\r\nCache-Control: max-age= xxxx\r\nContent-Encoding: gzip\r\nContent-length: 3333\r\nContent-Type: application/javascript\r\nDate: xxx\r\nExpires: xxx\r\nLast-Modified: xxx\r\nServer: 服务器\r\n```\r\n\r\n- 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（`Last-Modified`/`If-Modified-Since`和`Etag`/`If-None-Match`），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。\r\n\r\n强缓存与协商缓存的区别，可以用下表来进行描述：\r\n\r\n|  | 获取资源形式 | 状态码 | 发送请求到服务器 |\r\n| ---- | ---- | ---- | ---- |\r\n| **强缓存** | 从缓存取 | 200（from cache） | 否，直接从缓存取 |\r\n| **协商缓存** | 从缓存取 |  304（not modified） | 是，正如其名，通过服务器来告知缓存是否可用 |\r\n\r\n### 强缓存相关的header字段\r\n\r\n强缓存上面已经介绍了，直接从缓存中获取资源而不经过服务器；与强缓存相关的header字段有两个：\r\n\r\n1. **expires**: 这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如**Mon, 10 Jun 2015 21:31:12 GMT**，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。\r\n2. **cache-control：max-age=number**: 这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值：\r\n\r\n- **no-cache**: 不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。\r\n- **no-store**: 直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\r\n- **public**: 可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。\r\n- **private**: 只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。\r\n\r\n**注意：如果cache-control与expires同时存在的话，cache-control的优先级高于expires。**\r\n\r\n### 协商缓存相关的header字段\r\n\r\n协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（`Last-Modified`或者`Etag`），则后续请求则会带上对应的请求字段（`If-Modified-Since`或者`If-None-Match`），若响应头没有`Last-Modified`或者`Etag`字段，则请求头也不会有对应的字段。\r\n\r\n#### 1. Last-Modified/If-Modified-Since\r\n\r\n二者的值都是GMT格式的时间字符串，具体过程：\r\n\r\n- 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上`Last-Modified`的header，这个header表示这个资源在服务器上的最后修改时间\r\n\r\n- 浏览器再次跟服务器请求这个资源时，在request的header上加上`If-Modified-Since`的header，这个header的值就是上一次请求时返回的Last-Modified的值\r\n\r\n- 服务器再次收到资源请求时，根据浏览器传过来`If-Modified-Since`和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回`304 Not Modified`，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回`304 Not Modified`的响应时，response header中不会再添加`Last-Modified`的header，因为既然资源没有变化，那么`Last-Modified`也就不会改变，这是服务器返回304时的response header\r\n\r\n- 浏览器收到304的响应后，就会从缓存中加载资源\r\n\r\n- 如果协商缓存没有命中，浏览器直接从服务器加载资源时，`Last-Modified`的Header在重新加载的时候会被更新，下次请求时，`If-Modified-Since`会启用上次返回的`Last-Modified`值\r\n\r\n#### 2. Etag/If-None-Match\r\n\r\n这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与**Last-Modified/If-Modified-Since**类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\r\n\r\n### 既生Last-Modified何生Etag\r\n\r\n你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：\r\n\r\n- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；\r\n\r\n- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\r\n\r\n- 某些服务器不能精确的得到文件的最后修改时间。\r\n\r\n这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。\r\n\r\n**注意: Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。**\r\n\r\n### 用户的行为对缓存的影响\r\n\r\n| 用户操作 | Expires/Cache-Control | Last-Modified/ETag |\r\n| ---- | ---- | ---- |\r\n| 地址栏回车 | 有效 | 有效 |\r\n| 页面链接条状 | 有效 | 有效 |\r\n| 新开窗口 | 有效 | 有效 |\r\n| 前进后退 | 有效 | 有效 |\r\n| F5刷新 | 无效 | 有效 |\r\n| Ctrl + F5强制刷新 | 无效 | 无效 |\r\n\r\n### 强缓存如何重新加载缓存缓存过的资源\r\n\r\n使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？\r\n\r\n**通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。**\r\n\r\n``` html\r\n\u003clink rel=\"stylesheet\" href=\"a.css?a=1.0\" /\u003e\r\n...\r\n\u003cdiv class=\"app\"\u003eapp\u003c/div\u003e\r\n```\r\n\r\n这样每次文件改变后就会生成新的query值，这样query值不同，也就是页面引用的资源路径不同了，之前缓存过的资源就被浏览器忽略了，因为资源请求的路径变了。\r\n\r\n## HTTP 各版本特点与区别\r\n\r\nHTTP协议到现在为止总共经历了3个版本的演化，第一个HTTP协议诞生于1989年3月。\r\n\r\n| 版本 | 功能 | 备注 |\r\n| ---- | ---- | ---- |\r\n| HTTP 0.9 | 仅支持 Get \u003cbr /\u003e 仅能访问 HTML 格式资源 | 简单单一 |\r\n| HTTP 1.0 | 新增POST，DELETE，PUT，HEADER等方式 \u003cbr /\u003e  增加请求头和响应头概念，指定协议版本号，携带其他元信息（状态码、权限、缓存、内容编码）\u003cbr /\u003e  扩展传输内容格式（图片、音视频、二进制等都可以传输） | 存活时间短 |\r\n| HTTP 1.1 | 长连接：新增 Connection 字段,可以通过keep-alive保持长连接 \u003cbr /\u003e 管道化：一次连接就形成一次管道，管道内进行多次有序响应。允许向服务端发生多次请求，但是响应按序返回 \u003cbr /\u003e 缓存处理：新增 cache-control 和 etag 首部字段\u003cbr /\u003e 断点续传 \u003cbr /\u003e 状态码增加 | 当前主流版本号 \u003cbr /\u003e 存在Header 重复问题 |\r\n| HTTP 2.0 | 二进制分帧：数据体和头信息可以都是二进制，统称帧 \u003cbr /\u003e 多路复用与数据流：能同时发送和响应多个请求，通过数据流来传输 \u003cbr /\u003e 头部压缩：对 Header 进行压缩,避免重复浪费 \u003cbr /\u003e 服务器推送：服务器可以向客户端主动发送资源 | 2005发布 |\r\n\r\n### 1、HTTP 0.9\r\n\r\nHTTP 0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP 0.9协议只支持一种内容，即纯文本。不过网页仍然支持用HTML语言格式化，同时无法插入图片。\r\n\r\nHTTP 0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。由此可见，HTTP协议的无状态特点在其第一个版本0.9中已经成型。一次HTTP 0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。\r\n\r\n### 2、HTTP 1.0\r\n\r\nHTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用。相对于HTTP 0.9 增加了如下主要特性：\r\n\r\n- 请求与响应支持头域\r\n- 响应对象以一个响应状态行开始\r\n- 响应对象不只限于超文本\r\n- 开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法\r\n- （短连接）每一个请求建立一个TCP连接，请求完成后立马断开连接。这将会导致2个问题：连接无法复用，队头阻塞(head of line blocking)。连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类请求影响较大。队头阻塞(head of line blocking)\r\n\r\n### 3、HTTP 1.1\r\n\r\nHTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 。HTTP 1.1是目前主流的HTTP协议版本，因此这里就多花一些笔墨介绍一下HTTP 1.1的特性。\r\n\r\nHTTP 1.1引入了许多关键性能优化：keepalive连接，chunked编码传输，字节范围请求，请求流水线等\r\n\r\n#### Persistent Connection（keepalive连接）\r\n\r\n允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，以便未来的HTTP请求重用现在的连接，直到客户端或服务器端决定将其关闭为止。在HTTP1.0中使用长连接需要添加请求头 `Connection: Keep-Alive`，而在HTTP 1.1 所有的连接默认都是长连接，除非特殊声明不支持（ HTTP请求报文首部加上`Connection: close` ）。服务器端按照FIFO原则来处理不同的Request。\r\n\r\n![长连接(keepalive连接)](https://user-images.githubusercontent.com/8088864/125572282-1b48362e-ed29-42a1-9882-3710ab106b76.jpg)\r\n\r\n#### chunked编码传输\r\n\r\n该编码将实体分块传送并逐块标明长度，直到长度为0块表示传输结束，这在实体长度未知时特别有用(比如由数据库动态产生的数据)\r\n\r\n#### 字节范围请求\r\n\r\nHTTP1.1支持传送内容的一部分。比方说，当客户端已经有内容的一部分，为了节省带宽，可以只向服务器请求一部分。该功能通过在请求消息中引入了range头域来实现，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码206（Partial Content）\r\n\r\n#### 断点续传\r\n\r\nHeader 字段\r\n\r\n服务端\r\n\r\nAccept-Ranges:表示服务器支持断点续传，并且数据传输以字节为单位\r\n\r\nEtag:资源的唯一 tag 后端自定义，验证文件是否修改过。修改过就重新重头传输\r\n\r\nLast-Modified:文件上次修改时间\r\n\r\nContent-Range:返回数据范围\r\n\r\n客户端\r\n\r\nIf-Range:服务器给的 Etag 值\r\n\r\nRange:请求的数据范围\r\n\r\nIf-Modified-Since: 将服务器响应的 Last-Modified 保存， 下次发送可以携带，后台接受判断文件是否修改，没有可以返回 304状态码，叫客户端使用缓存数据，避免重复发出资源。\r\n\r\n流程\r\n\r\n![断点续传](https://user-images.githubusercontent.com/8088864/125573335-f1eda73b-ad4f-470a-808f-caa393e38b2e.png)\r\n\r\n**注意：断点续传后台返回状态码为 206。**\r\n\r\n#### Pipelining（请求流水线）\r\n\r\n#### 其他特性\r\n\r\n另外，HTTP 1.1还新增了如下特性：\r\n\r\n- 请求消息和响应消息都支持Host头域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。因此，Host头的引入就很有必要了。\r\n\r\n- 新增了一批Request method：HTTP1.1增加了OPTIONS, PUT, DELETE, TRACE, CONNECT方法\r\n\r\n- 缓存处理：HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。\r\n\r\n### 4、HTTP 2.0\r\n\r\nHTTP 2.0是下一代HTTP协议。主要特点有：\r\n\r\n#### 二进制分帧\r\n\r\nHTTP 2.0最大的特点：不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段，等等这些核心概念上一如往常，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。\r\n\r\n![二进制分帧](https://user-images.githubusercontent.com/8088864/125574741-7645e5f9-3476-44f3-94eb-4a3aaebce2ae.jpg)\r\n\r\n#### 多路复用\r\n\r\nHTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。\r\n\r\n通过单一的 HTTP2.0连接连续发起多重请求-响应消息，即客户端和服务器可以同时发送多个请求和响应，而不用顺序一一对应。\r\n\r\n每个数据流以HTTP消息的形式发送，HTTP消息被分为独立的帧，然后由一或多个帧组成，这些帧可以乱序发送，接收端根据这些帧的标识符号和首部将信息重新组装起来。\r\n\r\n默认什么情况下使用同一个连接\r\n\r\n- 同一个域名下的资源\r\n- 不同域名但是满足两个条件：1）解析到同一个 IP；2）使用同一个证书\r\n\r\n#### 头部压缩\r\n\r\n当一个客户端向相同服务器请求许多资源时，像来自同一个网页的图像，将会有大量的请求看上去几乎同样的，这就需要压缩技术对付这种几乎相同的信息。\r\n\r\n由于头信息使用文本，没有压缩，请求时候会来回重复传递，造成流量浪费。\r\n\r\n参考[HTTP2头部压缩技术介绍](https://imququ.com/post/header-compression-in-http2.html)\r\n\r\n头部压缩需要支持 HTTP2的浏览器和服务器之间：\r\n\r\n- 维护一份相同的静态字典（包含常见的头部名称，以及常见的头部名称与值的组合）\r\n- 维护一份相同的动态字典，动态添加内容（即实际的 Header 值）\r\n- 支持基于静态哈夫曼码表的哈夫曼编码（uffman Coding）\r\n\r\n原理图：\r\n\r\n![http头部压缩原理](https://user-images.githubusercontent.com/8088864/125578550-82fd62aa-eb21-4813-87d1-19904e1b42fc.png)\r\n\r\n总结： 通过映射表，传递对应编码和值来达到压缩。\r\n\r\n#### 随时复位\r\n\r\nHTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。\r\n\r\n#### 服务器端推流\r\n\r\nServer Push。客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。\r\n\r\n#### 优先权和依赖\r\n\r\n每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。\r\n\r\n## 队头阻塞以及解决办法\r\n\r\n### 前言\r\n\r\n通常我们提到队头阻塞，指的可能是TCP协议中的队头阻塞，但是HTTP1.1中也有一个类似TCP队头阻塞的问题，下面各自介绍一下。\r\n\r\n### TCP队头阻塞\r\n\r\n队头阻塞（head-of-line blocking）发生在一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止。该后续分节的延迟递送确保接收应用进程能够按照发送端的发送顺序接收数据。这种为了达到完全有序而引入的延迟机制，非常有用，但也有不利之处。\r\n\r\n假设在单个TCP连接上发送语义独立的消息，比如说服务器可能发送3幅不同的图像供Web浏览器显示。为了营造这几幅图像在用户屏幕上并行显示的效果，服务器先发送第一幅图像的一个断片，再发送第二幅图像的一个断片，然后再发送第三幅图像的一个断片；服务器重复这个过程，直到这3幅图像全部成功地发送到浏览器为止。\r\n\r\n要是第一幅图像的某个断片内容的TCP分节丢失了，客户端将保持已到达的不按序的所有数据，直到丢失的分节重传成功。这样不仅延缓了第一幅图像数据的递送，也延缓了第二幅和第三幅图像数据的递送。\r\n\r\n### HTTP队头阻塞\r\n\r\n上面用浏览器请求图片资源举例子，但实际上HTTP自身也有类似TCP队头阻塞的情况。要介绍HTTP队头阻塞，就需要先讲讲HTTP的管道化（pipelining）。\r\n\r\n#### HTTP管道化是什么\r\n\r\nHTTP1.1 允许在持久连接上可选的使用请求管道。这是相对于keep-alive连接的又一性能优化。在响应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。\r\n\r\n非管道化与管道化的区别示意图\r\n\r\n![HTTP非管道化与管道化](https://user-images.githubusercontent.com/8088864/125586316-36604fa7-fcc1-453b-9ae3-4c84b39690bd.png)\r\n\r\n#### HTTP管道化产生的背景\r\n\r\n在一般情况下，HTTP遵守“请求-响应”的模式，也就是客户端每次发送一个请求到服务端，服务端返回响应。这种模式非常容易理解，但是效率并不是那么高，为了提高速度和效率，人们做了很多尝试：\r\n\r\n- 最简单的情况下，服务端一旦返回响应后就会把对应的连接关闭，客户端的多个请求实际上是串行发送的。\r\n- 除此之外，客户端可以选择同时创建多个连接，在多个连接上并行的发送不同请求。但是创建更多连接也带来了更多的消耗，当前大部分浏览器都会限制对同一个域名的连接数。\r\n- 从HTTP1.0开始增加了持久连接的概念（HTTP1.0的Keep-Alive和HTTP1.1的persistent），可以使HTTP能够复用已经创建好的连接。客户端在收到服务端响应后，可以复用上次的连接发送下一个请求，而不用重新建立连接。\r\n- 现代浏览器大多采用并行连接与持久连接共用的方式提高访问速度，对每个域名建立并行地少量持久连接。\r\n- 而在持久连接的基础上，HTTP1.1进一步地支持在持久连接上使用管道化（pipelining）特性。管道化允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，借此来减少等待时间提高吞吐；如果多个请求能在同一个TCP分节发送的话，还能提高网络利用率。但是因为HTTP管道化本身可能会导致队头阻塞的问题，以及一些其他的原因，现代浏览器默认都关闭了管道化。\r\n\r\n#### HTTP管道化的限制\r\n\r\n1. 管道化要求服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。\r\n2. 客户端需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。\r\n3. 只有幂等的请求才能进行管道化，也就是只有GET和HEAD请求才能管道化，否则可能会出现意料之外的结果\r\n\r\n#### HTTP管道化引起的请求队头阻塞\r\n\r\n前面提到HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。\r\n\r\n### 如何解决队头阻塞\r\n\r\n#### 如何解决HTTP队头阻塞\r\n\r\n对于HTTP1.1中管道化导致的请求/响应级别的队头阻塞，可以使用HTTP2解决。HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。\r\n\r\n当然，即使使用HTTP2，如果HTTP2底层使用的是TCP协议，仍可能出现TCP队头阻塞。\r\n\r\n#### 如何解决TCP队头阻塞\r\n\r\nTCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。\r\n\r\n比如google推出的QUIC协议，在某种程度上可以说避免了TCP中的队头阻塞，因为它根本不使用TCP协议，而是在UDP协议的基础上实现了可靠传输。而UDP是面向数据报的协议，数据报之间不会有阻塞约束。\r\n\r\n此外还有一个SCTP（流控制传输协议），它是和TCP、UDP在同一层次的传输协议。SCTP的多流特性也可以尽可能的避免队头阻塞的情况。\r\n\r\n### 总结\r\n\r\n从TCP队头阻塞和HTTP队头阻塞的原因我们可以看到，出现队头阻塞的原因有两个：\r\n\r\n  1. 独立的消息数据都在一个链路上传输，也就是有一个“队列”。比如TCP只有一个流，多个HTTP请求共用一个TCP连接\r\n  2. 队列上传输的数据有严格的顺序约束。比如TCP要求数据严格按照序号顺序，HTTP管道化要求响应严格按照请求顺序返回\r\n\r\n所以要避免队头阻塞，就需要从以上两个方面出发，比如quic协议不使用TCP协议而是使用UDP协议，SCTP协议支持一个连接上存在多个数据流等等。\r\n\r\n## QUIC\r\n\r\nQUIC（Quick UDP Internet Connection）是谷歌制定的一种互联网传输层协议，它基于UDP传输层协议，同时兼具TCP、TLS、HTTP/2等协议的可靠性与安全性，可以有效减少连接与传输延迟，更好地应对当前传输层与应用层的挑战。\r\n\r\n### QUIC的由来：为什么是UDP而非TCP？\r\n\r\nUDP和TCP都属于传输层协议。TCP是面向连接的，更强调的是传输的可靠性，通过TCP连接传送的数据，无差错，不丢失，不重复，按序到达，但是因为TCP在传递数据之前会有三次握手来建立连接，所以效率低、占用系统的CPU、内存等硬件资源较高；而UDP的无连接的（即发送数据之前不需要建立连接），只需要知道对方地址即可发送数据，具有较好的实时性，工作效率比TCP高，占用系统资源比TCP少，但是在数据传递时，如果网络质量不好，就会很容易丢包。\r\n\r\n我们知道，大部分Web平台的数据传输都基于TCP协议。实际上，TCP在设计之初，网络环境复杂、丢包率高、网速差，所以TCP可以完美解决可靠性的问题。而如今的网络环境和网速都已经取得了巨大的改善，网络传输可靠性已经不再是棘手的问题。另外，TCP还有一个很大的问题是更新非常困难。这是因为：TCP网络协议栈的实现依赖于系统内核更新，一旦系统内核更新，终端设备、中间设备的系统更新都会非常缓慢，迭代需要花费几年甚至十几年的时间，这显然跟不上当今互联网的发展速度。所以现在解法就是，抛弃TCP而使用UDP，来实现低延迟的传输需求。\r\n\r\n![QUIC is very similar to TCP TLS HTTP 2 0 implemented on UDP](https://user-images.githubusercontent.com/8088864/125581409-742f54c2-93aa-4d3a-919e-d3710b318361.jpg)\r\n\r\n为了结合两者优点，谷歌公司推出了QUIC，它的升级不依赖于系统内核，只需要Client和Server端更新到指定版本。如此一来，基于UDP的QUIC就能月更甚至周更，很好的解决了TCP部署和更新的困难，更灵活地实现部署和更新。\r\n\r\n### 为什么要用QUIC？\r\n\r\n#### 1. 建连延迟低\r\n\r\n网民传统TCP三次握手+TLS1`~`2RTT握手+http数据，基于TCP的HTTPS一次建连至少需要2`~`3个RTT，而QUIC基于UDP，完整握手只需要1RTT乃至0RTT，可以显著降低延迟。\r\n\r\n![QUIC握手](https://user-images.githubusercontent.com/8088864/125584078-81044014-9ed7-47ba-93a4-24623b716b07.jpg)\r\n\r\n#### 2. 安全又可靠\r\n\r\nQUIC具备TCP、TLS、HTTPS/2等协议的安全、可靠性的特点，通过提供安全功能（如身份验证和加密）来实现加密传输，这些功能由传输协议本身的更高层协议（如TLS）来实现。\r\n\r\n#### 3. 改造灵活\r\n\r\nQUIC在应用程序层面就能实现不同的拥塞控制算法，不需要操作系统和内核支持，这相比于传统的TCP协议改造灵活性更好。\r\n\r\n#### 4. 改进的拥塞控制\r\n\r\nQUIC主要实现了TCP的慢启动、拥塞避免、快重传、快恢复。在这些拥塞控制算法的基础上改进，例如单调递增的 Packet Number，解决了重传的二义性，确保RTT准确性，减少重传次数。\r\n\r\n#### 5. 无队头阻塞的多路复用\r\n\r\nHTTP2实现了多路复用，可以在一条TCP流上并发多个HTTP请求，但基于TCP的HTTP2在传输层却有个问题，TCP无法识别不同的HTTP2流，实际收数据仍是一个队列，当后发的流先收到时，会因前面的流未到达而被阻塞。QUIC一个connection可以复用传输多个stream，每个stream之间都是独立的，一个stream的丢包不会影响到其他stream的接收和处理。\r\n\r\n![QUIC特点](https://user-images.githubusercontent.com/8088864/125585210-a874fcb0-87ab-46a5-b254-825c78034943.jpg)\r\n\r\n综上所述，QUIC具有众多优点，它融合了UDP协议的速度、性能与TCP的安全与可靠，大大优化了互联网传输体验。\r\n\r\n作为提升终端用户访问效率的CDN服务，其节点之间存在大量数据互通，节点之间的网络连接、传输架构等因素都会对CDN服务质量产生影响。而将QUIC应用在CDN系统中，CDN用户开启QUIC功能后，系统将遵循QUIC协议进行用户IP请求处理，既能满足安全传输的需求，也能提升传输效率。\r\n\r\n### QUIC对客户端的要求\r\n\r\n- 如果您使用Chrome浏览器，则只支持QUIC协议Q43版本。当前阿里云CDN的QUIC协议是Q39版本，不支持直接对阿里云CDN发起QUIC请求。\r\n- 如果您使用自研App，则App必须集成支持QUIC协议的网络库，例如：lsquic-client或cronet网络库。\r\n\r\n### QUIC应用场景\r\n\r\n1. 图片小文件：明显降低文件下载总耗时，提升效率\r\n2. 视频点播：提升首屏秒开率，降低卡顿率，提升用户观看体验\r\n3. 动态请求：适用于动态请求，提升访问速度，如网页登录、交易等交互体验提升\r\n4. 弱网环境：在丢包和网络延迟严重的情况下仍可提供可用的服务，并优化卡顿率、请求失败率、秒开率、提高连接成功率等传输指标\r\n5. 大并发连接：连接可靠性强，支持页面资源数较多、并发连接数较多情况下的访问速率提升\r\n6. 加密连接：具备安全、可靠的传输性能\r\n\r\n## HTTP协议\r\n\r\n一面中，如果有笔试，考HTTP协议的可能性较大。\r\n\r\n### 1. 前言\r\n\r\n一面要讲的内容：\r\n\r\n- `HTTP`协议的主要特点\r\n- `HTTP`报文的组成部分\r\n- `HTTP`方法\r\n- `get` 和 `post`的区别\r\n- `HTTP`状态码\r\n- 什么是持久连接\r\n- 什么是管线化\r\n\r\n二面要讲的内容；\r\n\r\n- 缓存\r\n- `CSRF`攻击\r\n- TSL 协商\r\n\r\n### 2. HTTP协议的主要特点\r\n\r\n- 简单快速\r\n- 灵活\r\n- **无连接**\r\n- **无状态**\r\n\r\n\u003e 通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：**无连接、无状态**。\r\n\r\n\r\n我们分别来解释一下。\r\n\r\n\r\n#### 2.1 简单快速\r\n\r\n\u003e **简单**：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在`http`协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。\r\n\r\n\r\n#### 2.2 灵活\r\n\r\n\u003e `http`协议的头部有一个`数据类型`，通过`http`协议，就可以完成不同数据类型的传输。\r\n\r\n#### 2.3 无连接\r\n\r\n\u003e 连接一次，就会断开，不会继续保持连接。\r\n\r\n#### 2.4 无状态\r\n\r\n\u003e 客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，**服务器端并没有记住之前的状态**，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。\r\n\r\n\u003e 有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 `session`）做到的，并不是`http`协议能做到的。\r\n\r\n\r\n### 3 HTTP报文的组成部分\r\n\r\n![](http://img.smyhvae.com/20180306_1400.png)\r\n\r\n\u003e 在回答此问题时，我们要按照顺序回答：\r\n\r\n- 先回答的是，`http`报文包括：**请求报文**和**响应报文**。\r\n- 再回答的是，每个报文包含什么部分。\r\n- 最后回答，每个部分的内容是什么\r\n\r\n#### 3.1 请求报文包括：\r\n\r\n![](http://img.smyhvae.com/20180228_1505.jpg)\r\n\r\n- 请求行：包括请求方法、请求的`url`、`http`协议及版本。\r\n- 请求头：一大堆的键值对。\r\n- **空行**指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体\r\n- 请求体：数据部分。\r\n\r\n#### 3.2 响应报文包括：\r\n\r\n![](http://img.smyhvae.com/20180228_1510.jpg)\r\n\r\n\r\n- 状态行：`http`协议及版本、状态码及状态描述。\r\n- 响应头\r\n- 空行\r\n- 响应体\r\n\r\n\r\n### 4 HTTP方法\r\n\r\n包括：\r\n\r\n- `GET`：获取资源\r\n- `POST`：传输资源\r\n- `put`：更新资源\r\n- `DELETE`：删除资源\r\n- `HEAD`：获得报文首部\r\n\r\n\u003e `HTTP`方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。\r\n\r\n- `get` `和 `post` 比较常见。\r\n- `put` 和 `delete` 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。\r\n- `head` 可能偶尔用的到。\r\n\r\n\r\n### 5 get 和 post的区别\r\n\r\n![](http://img.smyhvae.com/20180306_1415.png)\r\n\r\n- 区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。\r\n- 有一点要强调，**get是相对不隐私的，而post是相对隐私的**。\r\n\r\n\u003e 我们大概要记住以下几点：\r\n\r\n1. 浏览器在回退时，`get` **不会重新请求**，但是`post`会重新请求。【重要】\r\n2. `get`请求会被浏览器**主动缓存**，而`post`不会。【重要】\r\n3. `get`请求的参数，会报**保留**在浏览器的**历史记录**里，而`post`不会。做业务时要注意。为了防止`CSRF`攻击，很多公司把`get`统一改成了`post`。\r\n4. `get`请求在`url`中`传递的参数有大小限制，基本是`2kb`，不同的浏览器略有不同。而post没有注意。\r\n5. `get`的参数是直接暴露在`url`上的，相对不安全。而`post`是放在请求体中的。\r\n\r\n\r\n### 6 http状态码\r\n\r\n\u003e `http`状态码分类：\r\n\r\n![](http://img.smyhvae.com/20180306_1430.png)\r\n\r\n\u003e 常见的`http`状态码：\r\n\r\n![](http://img.smyhvae.com/20180306_1431.png)\r\n\r\n\r\n**部分解释**：\r\n\r\n- `206`的应用：`range`指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到`206`。\r\n- `301`：重定向（永久）。\r\n- `302`：重定向（临时）。\r\n- `304`：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。\r\n\r\n![](http://img.smyhvae.com/20180306_1440.png)\r\n\r\n- `400`和`401`用的不多,未授权。`403`指的是请求被拒绝。`404`指的是资源不存在。\r\n\r\n### 7 持久链接/http长连接\r\n\r\n\u003e 如果你能答出持久链接，这是面试官很想知道的一个点。\r\n\r\n- **轮询**：`http1.0`中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如`1`秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。\r\n- **长连接**：`HTTP1.1`中，通过使用`Connection:keep-alive`进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。\r\n\r\n\u003e 注意，`HTTP 1.1`默认进行持久连接。在一次 `TCP` 连接中可以完成多个 `HTTP` 请求，但是对**每个请求仍然要单独发 header**，`Keep-Alive`不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如`Apache`）中设定这个时间。\r\n\r\n\r\n### 8 长连接中的管线化\r\n\r\n\u003e 如果能答出**管线化**，则属于加分项。\r\n\r\n#### 8.1 管线化的原理\r\n\r\n\u003e 长连接时，**默认**的请求这样的：\r\n\r\n```\r\n\t请求1 --\u003e 响应1 --\u003e请求2 --\u003e 响应2 --\u003e 请求3 --\u003e 响应3\r\n```\r\n\r\n\r\n\u003e 管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。\r\n\r\n\r\n#### 8.2 管线化的注意事项\r\n\r\n\u003e 面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”\r\n\r\n### 9 TLS 协商\r\n\r\nTransport Layer Security (TLS) 是一个为计算机网络提供通信安全的加密协议。它广泛应用于大量应用程序，其中之一即浏览网页。网站可以使用 TLS 来保证服务器和网页浏览器之间的所有通信安全。\r\n\r\n整个 TLS 握手过程包含以下几个步骤：\r\n\r\n- 客户端向服务器发送 『Client hello』 信息，附带着客户端随机值(random_C)和支持的加密算法组合。\r\n- 服务器返回给客户端 『Server hello』信息，附带着服务器随机值(random_S)，以及选择一个客户端发送过来加密算法。\r\n- 服务器返回给客户端认证证书及或许要求客户端返回一个类似的证书，认证证书里面携带服务端的公钥信息。\r\n- 服务器返回『Server hello done』信息。\r\n- 如果服务器要求客户端发送一个证书，客户端进行发送。\r\n- 客户端创建一个随机的 Pre-Master 密钥然后使用服务器证书中的公钥来进行加密，向服务器发送加密过的 Pre-Master 密钥。\r\n- 服务器收到 Pre-Master 密钥。服务器和客户端各自生成基于 Pre-Master 密钥的主密钥和会话密钥。两个明文随机数 random_C 和 random_S 与自己计算产生的 pre-master，计算得到协商密钥enc_key=Fuc(random_C, random_S, pre-master)\r\n- 客户端给服务器发送一个 『Change cipher spec』的通知，表明客户端将会开始使用协商密钥和加密算法进行加密通信。\r\n- 客户端也发送了一个 『Client finished』的消息。\r\n- 服务器接收到『Change cipher spec』的通知然后使用协商密钥和加密算法进行加密通信。\r\n- 服务器返回客户端一个 『Server finished』消息。\r\n- 客户端和服务器现在可以通过建立的安全通道来交换程序数据。所有客户端和服务器之间发送的信息都会使用会话密钥进行加密。\r\n\r\n每当发生任何验证失败的时候，用户会收到警告。比如服务器使用自签名的证书。\r\n\r\n## EventSource和轮询的优缺点\r\n\r\n### EventSource\r\n\r\n#### 简介\r\n\r\nEventSource 是服务器推送的一个网络事件接口。一个EventSource实例会对HTTP服务开启一个持久化的连接，以text/event-stream 格式发送事件, 会一直保持开启直到被要求关闭。\r\n\r\n一旦连接开启，来自服务端传入的消息会以事件的形式分发至你代码中。如果接收消息中有一个事件字段，触发的事件与事件字段的值相同。如果没有事件字段存在，则将触发通用事件。\r\n\r\n与 WebSockets,不同的是，服务端推送是单向的。数据信息被单向从服务端到客户端分发. 当不需要以消息形式将数据从客户端发送到服务器时，这使它们成为绝佳的选择。例如，对于处理社交媒体状态更新，新闻提要或将数据传递到客户端存储机制（如IndexedDB或Web存储）之类的，EventSource无疑是一个有效方案。\r\n\r\n- `EventSource`（Server-sent events）简称SSE用于向服务端发送事件，它是基于http协议的单向通讯技术，以`text/event-stream`格式接受事件，如果不关闭会一直处于连接状态，直到调用`EventSource.close()`方法才能关闭连接；\r\n\r\n- `EvenSource`本质上也就是`XHR-streaming`只不过浏览器给它提供了标准的API封装和协议。\r\n\r\n- 由于`EventSource`是单向通讯，所以只能用来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。\r\n\r\n- `EventSource`虽然不支持双向通讯，但是在功能设计上他也有一些优点比如可以自动重连接,event IDs,以及发送随机事件的等功能\r\n\r\n`EventSource`案例浏览器端代码如下所示:\r\n\r\n``` js\r\n// 实例化 EventSource 参数是服务端监听的路由\r\nvar source = new EventSource('http://localhost:3000');\r\n\r\nsource.onopen = function (event) { // 与服务器连接成功回调\r\n  console.log('成功与服务器连接');\r\n}\r\n\r\n// 监听从服务器发送来的所有没有指定事件类型的消息(没有event字段的消息)\r\nsource.onmessage = function (event) { // 监听未命名事件\r\n  console.log('未命名事件', event.data);\r\n}\r\n\r\nsource.onerror = function (error) { // 监听错误\r\n  console.log('错误');\r\n}\r\n\r\n// 监听指定类型的事件（可以监听多个）\r\nsource.addEventListener(\"ping\", function (event) {\r\n  console.log(\"ping\", event.data)\r\n})\r\n```\r\n\r\n服务器端\r\n\r\n``` js\r\nconst http = require('http');\r\n\r\nhttp.createServer((req, res) =\u003e {\r\n  res.writeHead(200, {\r\n    'Content-Type' :'text/event-stream',\r\n    'Access-Control-Allow-Origin':'*'\r\n  });\r\n\r\n  let i = 0;\r\n  const timer = setInterval(()=\u003e{\r\n    const date = {date:new Date()}\r\n    var content ='event: ping\\n'+\"data:\"+JSON.stringify(date)+\"\" +\"\\n\\n\";\r\n    res.write(content);\r\n  },1000)\r\n\r\n  res.connection.on(\"close\", function(){\r\n    res.end();\r\n    clearInterval(timer);\r\n    console.log(\"Client closed connection. Aborting.\");\r\n  });\r\n\r\n}).listen(3000);\r\nconsole.log('server is run http://localhost:3000');\r\n```\r\n\r\n#### EventSource规范字段\r\n\r\n- **event**: 事件类型，如果指定了该字段，则在客户端接收到该条消息时，会在当前的EventSource对象上触发一个事件，事件类型就是该字段的字段值，你可以使用addEventListener()方法在当前EventSource对象上监听任意类型的命名事件，如果该条消息没有event字段，则会触发onmessage属性上的事件处理函数。\r\n- **data**: 消息的数据字段，如果该消息包含多个data字段，则客户端会用换行符把他们连接成一个字符串来处理\r\n- **id**: 事件ID，会成为当前EventSource对象的内部属性“最后一个事件ID”的属性值；\r\n- **retry**: 一个整数值，指定了重新连接的时间（单位为毫秒），如果该字段不是整数，则会被忽略。\r\n\r\n#### EventSource属性\r\n\r\n- **EventSource.onerror**: 是一个 EventHandler，当发生错误时被调用，并且在此对象上派发 error 事件。\r\n- **EventSource.onmessage**: 是一个 EventHandler，当收到一个 message事件，即消息来自源头时被调用。\r\n- **EventSource.onopen**: 是一个 EventHandler，当收到一个 open 事件，即连接刚打开时被调用。\r\n- **EventSource.readyState**(只读): 一个 unsigned short 值，代表连接状态。可能值是CONNECTING (0), OPEN (1), 或者 CLOSED (2)。\r\n- **EventSource.url**(只读): 一个DOMString，代表源头的URL。\r\n\r\n#### EventSource 通讯过程\r\n\r\n![EventSource通讯过程](https://user-images.githubusercontent.com/8088864/125590756-ffd10207-83de-4166-a8b5-9fc848c191cc.png)\r\n\r\n#### 缺点\r\n\r\n1. 因为是服务器-\u003e客户端的，所以它不能处理客户端请求流\r\n2. 因为是明确指定用于传输UTF-8数据的，所以对于传输二进制流是低效率的，即使你转为base64的话，反而增加带宽的负载，得不偿失。\r\n\r\n### 轮询\r\n\r\n#### 短轮询(Polling)\r\n\r\n是一种简单粗暴，同样也是一种效率低下的实现“实时”通讯方案，这种方案的原理就是定期向服务器发送请求，主动拉取最新的消息队列。\r\n\r\n客户端代码：\r\n\r\n``` js\r\nfunction Polling() {\r\n  fetch(url).then(data =\u003e {\r\n    // somthing\r\n  }).catch(err =\u003e {\r\n    console.error(err);\r\n  });\r\n}\r\n\r\n//每5s执行一次\r\nsetInterval(polling, 5000);\r\n```\r\n\r\n![短轮询流程](https://user-images.githubusercontent.com/8088864/125591641-814c4239-47e3-41da-ad9e-a0c7e64dfe72.png)\r\n\r\n这种轮询方式比较适合服务器信息定期更新的场景，如天气预报股票行情等，每隔一段时间会进行更新，且轮询间隔的服务器更新频率保持一致是比较理想的方式，但很多多时候会因网络或者服务器出现阻塞早场事件间隔不一致。\r\n\r\n优点：\r\n\r\n- 可以看到实现非常简单，它的兼容性也比较好的只要支持http协议就可以用这种方式实现\r\n\r\n缺点：\r\n\r\n- 资源浪费: 比如轮询的间隔小于服务器信息跟新频率，会浪费很多HTTP请求，消耗宝贵的CPU时间和带宽。\r\n\r\n- 容易导致请求轰炸: 例如当服务器负载比较高时，第一个请求还没有处理完，这时第三、第四个请求接踵而来，无用的额外请求对服务器端进行了轰炸。\r\n\r\n#### 长轮询(Long Polling)\r\n\r\n这是一种优化的轮询方式，称为长轮询，sockjs就是使用的这种轮询方式，长轮询值的是浏览器发送一个请求到服务器，服务器只有在有可用的新数据时才会响应。\r\n\r\n客户端代码:\r\n\r\n``` js\r\nfunction LongPolling() {\r\n    fetch(url).then(data =\u003e {\r\n        LongPolling();\r\n    }).catch(err =\u003e {\r\n        LongPolling();\r\n        console.log(err);\r\n    });\r\n}\r\nLongPolling();\r\n```\r\n\r\n![长轮询流程](https://user-images.githubusercontent.com/8088864/125592542-e5c7fb6b-18b8-434f-a4ee-f986684dcbbf.png)\r\n\r\n客户端向服务器发送一个消息获取请求时，服务器会将当前的消息队列返回给客户端，然后关闭连接。当消息队列为空的时，服务器不会立即关闭连接，而是等待指定的时间间隔，如果在这个时间间隔内没有新的消息，则由客户端主动超时关闭连接。\r\n\r\n相比Polling，客户端的轮询请求只有在上一个请求连接关闭后才会重新发起。这就解决了Polling的请求轰炸问题。服务器可以控制的请求时序，因为在服务器未响应之前，客户端不会发送额为的请求。\r\n\r\n优点:\r\n\r\n- 长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。\r\n\r\n缺点:\r\n\r\n- 连接挂起也会导致资源的浪费。\r\n\r\n### EventSource VS 轮询\r\n\r\n|  | 轮询(Polling) | 长轮询(Long-Polling) | EventSource |\r\n| ---- | ---- | ---- | ---- |\r\n| 通信协议 | http | http | http |\r\n| 触发方式 | client(客户端) | client(客户端) | client、server(客户端、服务端) |\r\n| 优点 | 兼容性好容错性强，实现简单 | 比短轮询节约服务器资源 | 实现简便，开发成本低 |\r\n| 缺点 | 安全性差，占较多的内存资源与请求数量，容易对服务器造成压力，请求时间间隔容易导致不一致 | 安全性差，占较多的内存资源与请求数，请求时间间隔容易导致不一致 | 只适用高级浏览器，老版本的浏览器不兼容 |\r\n| 延迟 | 非实时，延迟取决于请求间隔 | 非实时，延迟取决于请求间隔 | 非实时，默认3秒延迟，延迟可自定义 |\r\n\r\n### 总结\r\n\r\n通过对上面两种对通讯技术比较，可以从不同的角度考虑；\r\n\r\n- 兼容性: 短轮询 \u003e 长轮询 \u003e EventSource\r\n- 性能: EvenSource \u003e 长轮询 \u003e 短轮询\r\n- 服务端推送: EventSource \u003e 长连接 （短轮询基本不考虑）\r\n\r\n## WebSocket 是什么原理？为什么可以实现持久连接？\r\n\r\n### WebSocket 机制\r\n\r\n以下简要介绍一下WebSocket的原理及运行机制。\r\n\r\nWebSocket是HTML5下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与HTTP一样通过已建立的TCP连接来传输数据，但是它和HTTP最大不同是：\r\n\r\n- WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；\r\n- WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。\r\n\r\n传统HTTP客户端与服务器请求响应模式如下图所示：\r\n\r\n![传统HTTP客户端与服务器请求响应模型](https://user-images.githubusercontent.com/8088864/125600810-db0eaedf-6a66-4d71-b9c6-1a5d891a7b86.jpg)\r\n\r\nWebSocket模式客户端与服务器请求响应模式如下图：\r\n\r\n![WebSocket模式客户端与服务器请求响应模式](https://user-images.githubusercontent.com/8088864/125600954-0e796b1d-dd3a-482c-ab83-0d43f1abf610.jpg)\r\n\r\n上图对比可以看出，相对于传统HTTP每次请求-响应都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。\r\n\r\n相比HTTP长连接，WebSocket有以下特点：\r\n\r\n- 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。\r\n- HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）。此外还有 multiplexing、不同的URL可以复用同一个WebSocket连接等功能。这些都是HTTP长连接不能做到的。\r\n\r\n### WebSocket协议的原理\r\n\r\n与http协议一样，WebSocket协议也需要通过已建立的TCP连接来传输数据。具体实现上是通过http协议建立通道，然后在此基础上用真正的WebSocket协议进行通信，所以WebSocket协议和http协议是有一定的交叉关系的。\r\n\r\n![WebSocket协议原理流程图](https://user-images.githubusercontent.com/8088864/125603352-ba55e8bd-f554-4ef1-8c0c-add611f63023.jpg)\r\n\r\n下面是WebSocket协议请求头：\r\n\r\n![WebSocket协议请求头](https://user-images.githubusercontent.com/8088864/125603469-ef8dfb8e-988a-4bc6-a041-487f697cb72a.jpg)\r\n\r\n其中请求头中重要的字段：\r\n\r\n``` request header\r\nConnection:Upgrade\r\n\r\nUpgrade:websocket\r\n\r\nSec-WebSocket-Extensions:permessage-deflate; client_max_window_bits\r\n\r\nSec-WebSocket-Key:mg8LvEqrB2vLpyCNnCJV3Q==\r\n\r\nSec-WebSocket-Version:13\r\n```\r\n\r\n1. Connection和Upgrade字段告诉服务器，客户端发起的是WebSocket协议请求\r\n2. Sec-WebSocket-Extensions表示客户端想要表达的协议级的扩展\r\n3. Sec-WebSocket-Key是一个Base64编码值，由浏览器随机生成\r\n4. Sec-WebSocket-Version表明客户端所使用的协议版本\r\n\r\n而得到的响应头中重要的字段：\r\n\r\n``` response header\r\nConnection:Upgrade\r\n\r\nUpgrade:websocket\r\n\r\nSec-WebSocket-Accept:AYtwtwampsFjE0lu3kFQrmOCzLQ=\r\n```\r\n\r\n1. Connection和Upgrade字段与请求头中的作用相同\r\n\r\n2. Sec-WebSocket-Accept表明服务器接受了客户端的请求\r\n\r\n``` response header\r\nStatus Code:101 Switching Protocols\r\n```\r\n\r\n并且http请求完成后响应的状态码为101，表示切换了协议，说明WebSocket协议通过http协议来建立运输层的TCP连接，之后便与http协议无关了。\r\n\r\n### WebSocket协议的优缺点\r\n\r\n优点：\r\n\r\n- WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的\r\n- 服务器可以向客户端推送消息了\r\n\r\n缺点：\r\n\r\n- 少部分浏览器不支持，浏览器支持的程度与方式有区别\r\n\r\nWebSocket协议的应用场景\r\n\r\n- 即时聊天通信\r\n- 多玩家游戏\r\n- 在线协同编辑/编辑\r\n- 实时数据流的拉取与推送\r\n- 体育/游戏实况\r\n- 实时地图位置\r\n\r\n一个使用WebSocket应用于视频的业务思路如下：\r\n\r\n- 使用心跳维护websocket链路，探测客户端端的网红/主播是否在线\r\n- 设置负载均衡7层的proxy_read_timeout默认为60s\r\n- 设置心跳为50s，即可长期保持Websocket不断开\r\n\r\n## 网络相关\r\n\r\n### 1.1 DNS 预解析\r\n\r\n- DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP\r\n\r\n```html\r\n\u003clink rel=\"dns-prefetch\" href=\"//yuchengkai.cn\"\u003e\r\n```\r\n\r\n### 1.2 缓存\r\n\r\n- 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度\r\n- 通常浏览器缓存策略分为两种：强缓存和协商缓存\r\n\r\n**强缓存**\r\n\r\n\u003e 实现强缓存可以通过两种响应头实现：`Expires `和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code `为 `200`\r\n\r\n```\r\nExpires: Wed, 22 Oct 2018 08:41:00 GMT\r\n```\r\n\r\n\u003e `Expires` 是 `HTTP / 1.0` 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效\r\n\r\n```\r\nCache-control: max-age=30\r\n```\r\n\r\n\u003e `Cache-Control` 出现于 `HTTP / 1.1`，优先级高于 `Expires` 。该属性表示资源会在 `30` 秒后过期，需要再次请求\r\n\r\n**协商缓存**\r\n\r\n- 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304\r\n- 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式\r\n\r\nLast-Modified 和 If-Modified-Since\r\n\r\n- `Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified `的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来\r\n- 但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 `HTTP / 1.1` 出现了 `ETag`\r\n\r\nETag 和 If-None-Match\r\n\r\n- `ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高\r\n\r\n**选择合适的缓存策略**\r\n\r\n\u003e 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\r\n\r\n- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存\r\n- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\r\n- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件\r\n\r\n### 1.3 使用 HTTP / 2.0\r\n\r\n- 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间\r\n- 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小\r\n\r\n\r\n### 1.4 预加载\r\n\r\n- 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载\r\n- 预加载其实是声明式的 `fetch` ，强制浏览器请求资源，并且不会阻塞 `onload` 事件，可以使用以下代码开启预加载\r\n\r\n```html\r\n\u003clink rel=\"preload\" href=\"http://example.com\"\u003e\r\n```\r\n\r\n\u003e 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好\r\n\r\n\r\n\r\n### 1.5 预渲染\r\n\r\n\u003e 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染\r\n\r\n```html\r\n\u003clink rel=\"prerender\" href=\"http://example.com\"\u003e\r\n```\r\n\r\n- 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染\r\n\r\n## 优化渲染过程\r\n\r\n### 2.1 懒执行\r\n\r\n- 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒\r\n\r\n### 2.2 懒加载\r\n\r\n- 懒加载就是将不关键的资源延后加载\r\n\r\n\u003e 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载\r\n\r\n- 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等\r\n\r\n## HTTP method\r\n\r\n1. 一台服务器要与 HTTP1.1 兼容，只要为资源实现**GET**和**HEAD**方法即可\r\n2. **GET**是最常用的方法，通常用于**请求服务器发送某个资源**。\r\n3. **HEAD**与 GET 类似，但**服务器在响应中只返回首部，不返回实体的主体部分**\r\n4. **PUT**让服务器**用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它**\r\n5. **POST**起初是用来向服务器输入数据的。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。\r\n6. **TRACE**会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个 TRACE 响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。\r\n7. **OPTIONS**方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。\r\n8. **DELETE**请求服务器删除请求 URL 指定的资源\r\n\r\n## 从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)\r\n\r\n1. 在浏览器地址栏输入 URL\r\n2. 浏览器查看**缓存**，如果请求资源在缓存中并且判断缓存是否过期，跳转到转码步骤\r\n   1. 如果资源未缓存，发起新请求\r\n   2. 如果已缓存，检验判断缓存是否过期，缓存未过期直接提供给客户端，否则与服务器进行验证。\r\n   3. 检验缓存是否过期通常有两个 HTTP 头进行控制`Expires`和`Cache-Control`：\r\n      - HTTP1.0 提供 Expires，值为一个绝对时间表示缓存过期日期\r\n      - HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大过期时间\r\n3. 浏览器**解析 URL**获取协议，主机，端口，path\r\n4. 浏览器**组装一个 HTTP（GET）请求报文**\r\n5. 浏览器**获取主机 ip 地址**，过程如下：\r\n   1. 浏览器缓存\r\n   2. 本机缓存\r\n   3. hosts 文件\r\n   4. 路由器缓存\r\n   5. ISP DNS 缓存\r\n   6. DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）\r\n6. **打开一个 socket 与目标 IP 地址，端口建立 TCP 链接**，三次握手如下：\r\n   1. 客户端发送一个 TCP 的**SYN=1，Seq=X**的包到服务器端口\r\n   2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包\r\n   3. 客户端发送**ACK=Y+1， Seq=Z**\r\n7. TCP 链接建立后**发送 HTTP 请求**\r\n8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序\r\n9. 服务器检查**HTTP 请求头是否包含缓存验证信息**如果验证缓存未过期，返回**304**等对应状态码\r\n10. 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作\r\n11. 服务器将**响应报文通过 TCP 连接发送回浏览器**\r\n12. 浏览器接收 HTTP 响应，然后根据情况选择**关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下**：\r\n    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文\r\n    2. 被动方发送**ACK=X+1， Seq=Z**报文\r\n    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文\r\n    4. 主动方发送**ACK=Y+1， Seq=X**报文\r\n13. 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同\r\n14. 如果资源可缓存，**进行缓存协商**\r\n15. 对响应进行**解码**（例如 gzip 压缩）\r\n16. 根据资源类型决定如何处理（假设资源为 HTML 文档）\r\n17. **解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本**，这些操作没有严格的先后顺序，以下分别解释\r\n18. **构建 DOM 树**：\r\n    1. **Tokenizing**：根据 HTML 规范将字符流解析为标记\r\n    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则\r\n    3. **DOM construction**：根据 HTML 标记关系将对象组成 DOM 树\r\n19. 解析过程中遇到图片、样式表、js 文件，**启动下载**\r\n20. 构建**CSSOM 树**：\r\n    1. **Tokenizing**：字符流转换为标记流\r\n    2. **Node**：根据标记创建节点\r\n    3. **CSSOM**：节点创建 CSSOM 树\r\n21. **[根据 DOM 树和 CSSOM 树构建渲染树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)**:\r\n    1. 从 DOM 树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被 css 隐藏的节点，如`display: none`\r\n    2. 对每一个可见节点，找到恰当的 CSSOM 规则并应用\r\n    3. 发布可视节点的内容和计算样式\r\n22. **js 解析如下**：\r\n    1. 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate 为 loading**\r\n    2. HTML 解析器遇到**没有 async 和 defer 的 script 时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容**\r\n    3. 当解析器遇到设置了**async**属性的 script 时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用 document.write()**，它们可以访问自己 script 和之前的文档元素\r\n    4. 当文档完成解析，document.readState 变成 interactive\r\n    5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用 document.write()\r\n    6. 浏览器**在 Document 对象上触发 DOMContentLoaded 事件**\r\n    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState 变为 complete,window 触发 load 事件\r\n23. **显示页面**（HTML 解析过程中会逐步显示页面）\r\n\r\n![HTTP访问过程](https://user-images.githubusercontent.com/8088864/126057166-67172419-c265-4be2-bc9f-5c8e4a3214ee.png)\r\n\r\n## HTTP request 报文结构是怎样的\r\n\r\n[rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)中进行了定义：\r\n\r\n1. 首行是**Request-Line**包括：**请求方法**，**请求 URI**，**协议版本**，**CRLF**\r\n2. 首行之后是若干行**请求头**，包括**general-header**，**request-header**或者**entity-header**，每个一行以 CRLF 结束\r\n3. 请求头和消息实体之间有一个**CRLF 分隔**\r\n4. 根据实际请求需要可能包含一个**消息实体**\r\n   一个请求报文例子如下：\r\n\r\n```\r\nGET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1\r\nHost: www.w3.org\r\nConnection: keep-alive\r\nCache-Control: max-age=0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\r\nReferer: https://www.google.com.hk/\r\nAccept-Encoding: gzip,deflate,sdch\r\nAccept-Language: zh-CN,zh;q=0.8,en;q=0.6\r\nCookie: authorstyle=yes\r\nIf-None-Match: \"2cc8-3e3073913b100\"\r\nIf-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT\r\n\r\nname=qiu\u0026age=25\r\n```\r\n\r\n## HTTP response 报文结构是怎样的\r\n\r\n[rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html)中进行了定义：\r\n\r\n1. 首行是状态行包括：**HTTP 版本，状态码，状态描述**，后面跟一个 CRLF\r\n2. 首行之后是**若干行响应头**，包括：**通用头部，响应头部，实体头部**\r\n3. 响应头部和响应实体之间用**一个 CRLF 空行**分隔\r\n4. 最后是一个可能的**消息实体**\r\n   响应报文例子如下：\r\n\r\n```\r\nHTTP/1.1 200 OK\r\nDate: Tue, 08 Jul 2014 05:28:43 GMT\r\nServer: Apache/2\r\nLast-Modified: Wed, 01 Sep 2004 13:24:52 GMT\r\nETag: \"40d7-3e3073913b100\"\r\nAccept-Ranges: bytes\r\nContent-Length: 16599\r\nCache-Control: max-age=21600\r\nExpires: Tue, 08 Jul 2014 11:28:43 GMT\r\nP3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\"\r\nContent-Type: text/html; charset=iso-8859-1\r\n\r\n{\"name\": \"qiu\", \"age\": 25}\r\n```\r\n\r\n## HTTP 状态码及其含义\r\n\r\n参考[RFC 2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)\r\n\r\n- 1XX：信息状态码\r\n  - **100 Continue**：客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应\r\n  - **101 Switching Protocols**：服务器理解了客户端切换协议的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应后，服务器将会切换到 Upgrade 消息头中定义的那些协议。\r\n- 2XX：成功状态码\r\n  - **200 OK**：请求成功，请求所希望的响应头或数据体将随此响应返回\r\n  - **201 Created**：请求成功并且服务器创建了新的资源\r\n  - **202 Accepted**：服务器已接受请求，但尚未处理\r\n  - **203 Non-Authoritative Information**：表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。（HTTP 1.1新）\r\n  - **204 No Content**：没有新文档，浏览器应该继续显示原来的文档。\r\n  - **205 Reset Content**：没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）\r\n  - **206 Partial Content**：请求成功，返回范围请求的部分资源\r\n- 3XX：重定向\r\n  - **300 Multiple Choices**：客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location响应头中指明\r\n  - **301 Moved Permanently**：请求的资源已永久移动到新位置\r\n  - **302 Found**：临时性重定向\r\n  - **303 See Other**：类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）\r\n  - **304 Not Modified**：自从上次请求后，请求的资源未修改过\r\n  - **305 Use Proxy**：客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）\r\n  - **306 （unused）**：未使用\r\n  - **307 Temporary Redirect**：和302 （Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新）\r\n- 4XX：客户端错误\r\n  - **400 Bad Request**：服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求\r\n  - **401 Unauthorized**：求未授权\r\n  - **402 Payment Required**：\r\n  - **403 Forbidden**：禁止访问\r\n  - **404 Not Found**：找不到与 URI 相匹配的资源\r\n  - **405 Method Not Allowed**：请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）\r\n  - **406 Not Acceptable**：指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）\r\n  - **407 Proxy Authentication Required**：类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）\r\n  - **408 Request Timeout**：在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）\r\n  - **409 Conflict**：通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）\r\n  - **410 Gone**：所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而 404表示由于未知的原因文档不可用。（HTTP 1.1新）\r\n  - **411 Length Required**：服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新）\r\n  - **412 Precondition Failed**：请求头中指定的一些前提条件失败（HTTP 1.1新）\r\n  - **413 Request Entity Too Large**：目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）\r\n  - **414 Request-URI Too Long**：URI太长（HTTP 1.1新）\r\n  - **415 Unsupported Media Type**：请求所带的附件的格式类型服务器不知道如何处理。（HTTP 1.1新）\r\n\r\n  - **416 Requested Range Not Satisfiable**：服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）\r\n  - **417 Expectation Failed**：如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。（HTTP 1.1新）\r\n- 5XX: 服务器错误\r\n  - **500 Internal Server Error**：服务器端错误\r\n  - **501 Not Implemented**：服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求\r\n  - **502 Bad Gateway**：服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。\r\n  - **503 Service Unavailable**：服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。\r\n  - **504 Gateway Timeout**：由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）\r\n  - **505 HTTP Version Not Supported**：服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新\r\n\r\n## 说一下 Http 缓存策略，有什么区别，分别解决了什么问题\r\n\r\n### 1）浏览器缓存策略\r\n\r\n浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使\r\n用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：\r\n强制缓存和协商缓存，强缓优先于协商缓存。\r\n\r\n- 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。\r\n\r\n- 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified\r\n通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\r\n\r\nHTTP缓存都是从第二次请求开始的：\r\n\r\n- 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；\r\n\r\n- 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：\r\n\r\n![浏览器缓存策略流程图](https://user-images.githubusercontent.com/8088864/126058683-beef4f08-b60d-493d-b870-998d0238e212.png)\r\n\r\n### 2）强缓存\r\n\r\n- 强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk\r\n- 控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）\r\n- Cache-control是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。\r\n- Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求\r\n- Cache-Control的优先级比Expires的优先级高。前者的出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。\r\n- 如果同时存在则使用Cache-control。\r\n\r\n### 3）强缓存(expires)\r\n\r\n- 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。\r\n\r\n- Expires 是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。\r\n\r\n- 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。\r\n\r\n- 优势特点\r\n\r\n  - 1. HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。\r\n  - 2. 以时刻标识失效时间。\r\n\r\n- 劣势问题\r\n\r\n  - 1. 时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。\r\n  - 2. 存在版本问题，到期之前的修改客户端是不可知的。\r\n\r\n### 4）强缓存(cache-control)\r\n\r\n- 已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。\r\n\r\n- 这两者的区别就是前者是绝对时间，而后者是相对时间。下面列举一些 Cache-control 字段常用的值：(完整的列表可以查看MDN)\r\n\r\n  - `max-age`：即最大有效时间。\r\n  - `must-revalidate`：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。\r\n  - `no-cache`：不使用强缓存，需要与服务器验证缓存是否新鲜。\r\n  - `no-store`: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。\r\n  - `public`：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)\r\n  - `private`：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。\r\n\r\n- **Cache-control 的优先级高于 Expires**，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都可以设置。\r\n\r\n- 该字段可以在请求头或者响应头设置，可组合使用多种指令：\r\n  - **可缓存性：**\r\n    - public：浏览器和缓存服务器都可以缓存页面信息\r\n    - private：default，代理服务器不可缓存，只能被单个用户缓存\r\n    - no-cache：浏览器器和服务器都不应该缓存页面信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配合private，过期时间设置为过去时间。\r\n    - only-if-cache：客户端只接受已缓存的响应\r\n  - **到期：**\r\n    - max-age=：缓存存储的最大周期，超过这个周期被认为过期。\r\n    - s-maxage=：设置共享缓存，比如can。会覆盖max-age和expires。\r\n    - max-stale[=]：客户端愿意接收一个已经过期的资源\r\n    - min-fresh=：客户端希望在指定的时间内获取最新的响应\r\n    - stale-while-revalidate=：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应的时间长度。\r\n    - stale-if-error=：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。\r\n  - **重新验证和重新加载**\r\n    - must-revalidate：如页面过期，则去服务器进行获取。\r\n    - proxy-revalidate：用于共享缓存。\r\n    - immutable：响应正文不随时间改变。\r\n  - **其他**\r\n    - no-store：绝对禁止缓存\r\n    - no-transform：不得对资源进行转换和转变。例如，不得对图像格式进行转换。\r\n\r\n- 优势特点\r\n  - 1. HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。\r\n  - 2. 比Expires多了很多选项设置。\r\n\r\n- 劣势问题\r\n  - 1. 存在版本问题，到期之前的修改客户端是不可知的。\r\n\r\n### 5）协商缓存\r\n\r\n- 协商缓存的状态码由服务器决策返回200或者304\r\n- 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。\r\n- 对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。\r\n- 协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和Etag/If-None-match（http1.1）\r\n- Last-Modified/If-Modified-since表示的是服务器的资源最后一次修改的时间；Etag/If-None-match表示的是服务器资源的唯一标\r\n识，只要资源变化，Etag就会重新生成。\r\n- Etag/If-None-match的优先级比Last-Modified/If-Modified-since高。\r\n\r\n### 协商缓存(Last-Modified/If-Modified-since)\r\n\r\n- 服务器通过 `Last-Modified` 字段告知客户端，资源最后一次被修改的时间，例如 `Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT`\r\n\r\n- 浏览器将这个值和内容一起记录在缓存数据库中。\r\n\r\n- 下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 `Last-Modified` 的值写入到请求头的 `If-Modified-Since` 字段\r\n\r\n- 服务器会将 `If-Modified-Since` 的值与 `Last-Modified` 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。\r\n\r\n- 优势特点\r\n  - 1. 不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。\r\n\r\n- 劣势问题\r\n  - 1. 只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。\r\n  - 2. 以时刻作为标识，无法识别一秒内进行多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。\r\n  - 3. 某些服务器不能精确的得到文件的最后修改时间。\r\n  - 4. 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。\r\n\r\n### 协商缓存(Etag/If-None-match)\r\n\r\n- 为了解决上述问题，出现了一组新的字段 `Etag` 和 `If-None-Match`\r\n\r\n- `Etag` 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 `Etag` 字段。之后的流程和 `Last-Modified` 一致，只是 `Last-Modified` 字段和它所表示的更新时间改变成了 `Etag` 字段和它所表示的文件 hash，把 `If-Modified-Since` 变成了 `If-None-Match`。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。\r\n\r\n- 浏览器在发起请求时，服务器返回在Response header中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的Etag值赋值给If-No-Matched并添加在Request Header中。服务器将浏览器传来的if-no-matched跟自己的本地的资源的ETag做对比，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。\r\n\r\n- **Etag 的优先级高于 Last-Modified。**\r\n\r\n- 优势特点\r\n  - 1. 可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。\r\n  - 2. 不存在版本问题，每次请求都回去服务器进行校验。\r\n\r\n- 劣势问题\r\n  - 1. 计算ETag值需要性能损耗。\r\n  - 2. 分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现ETag不匹配的情况。\r\n\r\n## 前端安全、中间人攻击\r\n\r\n### 1）XSS：跨站脚本攻击\r\n\r\n就是攻击者想尽一切办法将可以执行的代码注入到网页中。\r\n\r\n#### 存储型(server端)\r\n\r\n- 场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\r\n\r\n- 攻击步骤：\r\n  - 1. 攻击者将恶意代码提交到目标网站的数据库中\r\n  - 2. 用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器\r\n  - 3. 用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行\r\n  - 4. 恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作\r\n\r\n#### 反射型(Server端)\r\n\r\n与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在URL上\r\n\r\n- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。\r\n\r\n- 攻击步骤：\r\n  - 1. 攻击者构造出特殊的 URL，其中包含恶意代码。\r\n  - 2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\r\n  - 3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\r\n  - 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\r\n\r\n#### Dom 型(浏览器端)\r\n\r\nDOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\r\n\r\n- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。\r\n- 攻击步骤：\r\n  - 1. 攻击者构造出特殊的 URL，其中包含恶意代码。\r\n  - 2. 用户打开带有恶意代码的 URL。\r\n  - 3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\r\n  - 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\r\n\r\n#### 预防方案\r\n\r\n防止攻击者提交恶意代码，防止浏览器执行恶意代码。\r\n\r\n- 1. 对数据进行严格的输出编码：如HTML元素的编码，JS编码，CSS编码，URL编码等等\r\n  - 避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML\r\n\r\n- 2. CSP HTTP Header，即 Content-Security-Policy、X-XSS-Protection\r\n  - 增加攻击难度，配置CSP(本质是建立白名单，由浏览器进行拦截)\r\n  - `Content-Security-Policy: default-src 'self'` - 所有内容均来自站点的同一个源（不包括其子域名）\r\n  - `Content-Security-Policy: default-src 'self' *.trusted.com` - 允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)\r\n  - `Content-Security-Policy: default-src https://yideng.com` - 该服务器仅允许通过HTTPS方式并仅从yideng.com域名来访问文档\r\n\r\n- 3. 输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断\r\n\r\n- 4. 开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。\r\n\r\n- 5. 验证码\r\n\r\n### CSRF：跨站请求伪造\r\n\r\n攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\r\n\r\n#### 攻击流程举例\r\n\r\n1. 受害者登录 a.com，并保留了登录凭证（Cookie）\r\n2. 攻击者引诱受害者访问了b.com\r\n3. b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie\r\n4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求\r\n5. a.com以受害者的名义执行了act=xx\r\n6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作\r\n\r\n#### 攻击类型\r\n\r\n1. GET型：如在页面的某个 img 中发起一个 get 请求\r\n2. POST型：通过自动提交表单到恶意网站\r\n3. 链接型：需要诱导用户点击链接\r\n\r\n#### 预防方案\r\n\r\nCSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。\r\n\r\n- 1. 同源检测：通过Header中的Origin Header 、Referer Header 确定，但不同浏览器可能会有不一样的实现，不能完全保证\r\n\r\n- 2. CSRF Token 校验：将CSRF Token输出到页面中（通常保存在Session中），页面提交的请求携带这个Token，服务器验证Token是否正确\r\n\r\n- 3. 双重cookie验证：\r\n  - 流程：\r\n    - 步骤1：在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）\r\n    - 步骤2：在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）\r\n    - 步骤3：后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。\r\n  - 优点：\r\n    - 无需使用Session，适用面更广，易于实施。\r\n    - Token储存于客户端中，不会给服务器带来压力。\r\n    - 相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。\r\n  - 缺点：\r\n    - Cookie中增加了额外的字段。\r\n    - 如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。\r\n    - 难以做到子域名的隔离。\r\n    - 为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。\r\n- 4. Samesite Cookie属性：Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，Strict 为任何情况下都不可以作为第三方 Cookie ，Lax 为可以作为第三方 Cookie , 但必须是Get请求\r\n\r\n### 3）iframe 安全\r\n\r\n#### 说明\r\n\r\n- 1. 嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题\r\n- 2. 点击劫持\r\n  - 攻击者将目标网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，诱导用户点击。\r\n- 3. 禁止自己的 iframe 中的链接外部网站的JS\r\n\r\n#### 预防方案\r\n\r\n- 1. 为 iframe 设置 sandbox 属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则\r\n- 2. 服务端设置 X-Frame-Options Header头，拒绝页面被嵌套，X-Frame-Options 是HTTP 响应头中用来告诉浏览器一个页面是否可以嵌入 \\\u003ciframe\u003e 中\r\n  - eg.X-Frame-Options: SAMEORIGIN\r\n  - SAMEORIGIN: iframe 页面的地址只能为同源域名下的页面\r\n  - ALLOW-FROM: 可以嵌套在指定来源的 iframe 里\r\n  - DENY: 当前页面不能被嵌套在 iframe 里\r\n- 3. 设置 CSP 即 Content-Security-Policy 请求头\r\n- 4. 减少对 iframe 的使用\r\n\r\n\r\n### 4）错误的内容推断\r\n\r\n#### 说明\r\n\r\n文件上传类型校验失败后，导致恶意的JS文件上传后，浏览器 Content-Type Header 的默认解析为可执行的 JS 文件\r\n\r\n#### 预防方案\r\n\r\n设置 X-Content-Type-Options 头\r\n\r\n### 5）第三方依赖包\r\n\r\n减少对第三方依赖包的使用，如之前 npm 的包如：event-stream 被爆出恶意攻击数字货币；\r\n\r\n### 6）HTTPS\r\n\r\n#### 描述\r\n\r\n黑客可以利用SSL Stripping这种攻击手段，强制让HTTPS降级回HTTP，从而继续进行中间人攻击。\r\n\r\n#### 预防方案\r\n解决这个安全问题的办法是使用HSTS（HTTP Strict Transport Security），它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信：\r\n\r\n``` header\r\nStrict-Transport-Security: max-age=\u003cseconds\u003e; includeSubDomains; preload\r\n```\r\n\r\n这里的“强制性”表现为浏览器无论在何种情况下都直接向服务器端发起HTTPS请求，而不再像以往那样从HTTP跳转到HTTPS。另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户选择是否继续进行不安全的通信。\r\n\r\n### 7）本地存储数据\r\n\r\n避免重要的用户信息存在浏览器缓存中\r\n\r\n### 8）静态资源完整性校验\r\n\r\n#### 描述\r\n\r\n使用 内容分发网络 (CDNs) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件），因此可能潜在地攻击所有从该 CDN 获取文件的站点。\r\n\r\n#### 预防方案\r\n\r\n将使用 base64 编码过后的文件哈希值写入你所引用的 `\u003cscript\u003e` 或 标签的 integrity 属性值中即可启用子资源完整性能。\r\n\r\n### 9）网络劫持\r\n\r\n#### 描述\r\n\r\n- DNS劫持（涉嫌违法）：修改运行商的 DNS 记录，重定向到其他网站。DNS 劫持是违法的行为，目前 DNS 劫持已被监管，现在很少见 DNS 劫持\r\n- HTTP劫持：前提有 HTTP 请求。因 HTTP 是明文传输，运营商便可借机修改 HTTP 响应内容（如加广告）。\r\n\r\n#### 预防方案\r\n\r\n全站 HTTPS\r\n\r\n### 10）中间人攻击\r\n\r\n中间人攻击（Man-in-the-middle attack, MITM），指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者窃听、篡改甚至完全控制。没有进行严格的证书校验是中间人攻击着手点。目前大多数加密协议都提供了一些特殊认证方法以阻止中间人攻击。如 SSL （安全套接字层）协议可以验证参与通讯的用户的证书是否有权威、受信任的数字证书认证机构颁发，并且能执行双向身份认证。攻击场景如用户在一个未加密的 WiFi下访问网站。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。\r\n\r\n#### 场景\r\n\r\n1. 在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络\r\n2. Fiddler / Charles （花瓶）代理工具\r\n3. 12306 之前的自己证书\r\n\r\n#### 过程\r\n\r\n1. 客户端发送请求到服务端，请求被中间人截获\r\n2. 服务器向客户端发送公钥\r\n3. 中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端\r\n4. 客户端收到伪造的公钥后，生成加密hash值发给服务器\r\n5. 中间人获得加密hash值，用自己的私钥解密获得真秘钥,同时生成假的加密hash值，发给服务器\r\n6. 服务器用私钥解密获得假密钥,然后加密数据传输给客户端\r\n\r\n#### 使用抓包工具fiddle来进行举例说明\r\n\r\n1. 首先通过一些途径在客户端安装证书\r\n2. 然后客户端发送连接请求，fiddle在中间截取请求，并返回自己伪造的证书\r\n3. 客户端已经安装了攻击者的根证书，所以验证通过\r\n4. 客户端就会正常和fiddle进行通信，把fiddle当作正确的服务器\r\n5. 同时fiddle会跟原有的服务器进行通信，获取数据以及加密的密钥，去解密密钥\r\n\r\n#### 常见攻击方式\r\n\r\n1. 嗅探：嗅探是一种用来捕获流进和流出的网络数据包的技术，就好像是监听电话一样。比如：抓包工具\r\n2. 数据包注入：在这种，攻击者会将恶意数据包注入到常规数据中的，因为这些恶意数据包是在正常的数据包里面的，用户和系统都很难发现这个内容。\r\n3. 会话劫持：当我们进行一个网站的登录的时候到退出登录这个时候，会产生一个会话，这个会话是攻击者用来攻击的首要目标，因为这个会话，包含了用户大量的数据和私密信息。\r\n4. SSL剥离：HTTPS是通过SSL/TLS进行加密过的，在SSL剥离攻击中，会使SSL/TLS连接断开，让受保护的HTTPS，变成不受保护的HTTP（这对于网站非常致命）\r\n5. DNS欺骗：攻击者往往通过入侵到DNS服务器，或者篡改用户本地hosts文件，然后去劫持用户发送的请求，然后转发到攻击者想要转发到的服务器\r\n6. ARP欺骗： ARP(address resolution protocol)地址解析协议，攻击者利用APR的漏洞，用当前局域网之间的一台服务器，来冒充客户端想要请求的服务端，向客户端发送自己的MAC地址，客户端无从得到真正的主机的MAC地址，所以，他会把这个地址当作真正的主机来进行通信，将MAC存入ARP缓存表。\r\n7. 代理服务器\r\n\r\n#### 预防方案\r\n\r\n1. 用可信的第三方CA厂商\r\n2. 不下载未知来源的证书，不要去下载一些不安全的文件\r\n3. 确认你访问的URL是HTTPS的，确保网站使用了SSL，确保禁用一些不安全的SSL，只开启：TLS1.1，TLS1.2\r\n4. 不要使用公用网络发送一些敏感的信息\r\n5. 不要去点击一些不安全的连接或者恶意链接或邮件信息\r\n\r\n### 11）sql 注入\r\n\r\n#### 描述\r\n\r\n就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗数据库服务器执行恶意的SQL命令,从而达到和服务器\r\n进行直接的交互\r\n\r\n#### 预防方案\r\n\r\n1. 后台进行输入验证，对敏感字符过滤。\r\n2. 使用参数化查询，能避免拼接SQL，就不要拼接SQL语句。\r\n\r\n### 12）前端数据安全\r\n\r\n#### 描述\r\n\r\n反爬虫。如猫眼电影、天眼查等等，以数据内容为核心资产的企业\r\n\r\n#### 预防方案\r\n\r\n1. font-face拼接方式：猫眼电影、天眼查\r\n2. background 拼接：美团\r\n3. 伪元素隐藏：汽车之家\r\n4. 元素定位覆盖式：去哪儿\r\n5. iframe 异步加载：网易云音乐\r\n\r\n### 13）其他建议\r\n\r\n1. 定期请第三方机构做安全性测试，漏洞扫描\r\n2. 使用第三方开源库做上线前的安全测试，可以考虑融合到CI中\r\n3. code review 保证代码质量\r\n4. 默认项目中设置对应的 Header 请求头，如 X-XSS-Protection、 X-Content-Type-Options 、X-Frame-Options Header、Content-Security-Policy 等等\r\n5. 对第三方包和库做检测：NSP(Node Security Platform)，Snyk\r\n\r\n## HTTP\r\n\r\n**http状态码有那些？分别代表是什么意思？**\r\n\r\n```\r\n 简单版\r\n    [\r\n        100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\r\n        200  OK         正常返回信息\r\n        201  Created    请求成功并且服务器创建了新的资源\r\n        202  Accepted   服务器已接受请求，但尚未处理\r\n        301  Moved Permanently  请求的网页已永久移动到新位置。\r\n        302 Found       临时性重定向。\r\n        303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。\r\n        304  Not Modified 自从上次请求后，请求的网页未修改过。\r\n\r\n        400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\r\n        401 Unauthorized 请求未授权。\r\n        403 Forbidden   禁止访问。\r\n        404 Not Found   找不到如何与 URI 相匹配的资源。\r\n\r\n        500 Internal Server Error  最常见的服务器端错误。\r\n        503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\r\n    ]\r\n```\r\n\r\n**一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）**\r\n\r\n\r\n- 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，\r\n- 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、\r\n- 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；\r\n\r\n- 详细版：\r\n    - 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;\r\n    - 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;\r\n    - 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;\r\n    - 进行HTTP协议会话，客户端发送报头(请求报头);\r\n    - 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;\r\n    - 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;\r\n    - 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;\r\n    - 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;\r\n    - 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;\r\n    - 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。\r\n\r\n- 简洁版：\r\n    - 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\r\n    - 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\r\n    - 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；\r\n    - 载入解析到的资源文件，渲染页面，完成。\r\n\r\n**说说TCP传输的三次握手四次挥手策略**\r\n\r\n- 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK\r\n\r\n- 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包\r\n\r\n**断开一个TCP连接则需要“四次握手”：**\r\n\r\n- 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据\r\n\r\n- 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）\r\n\r\n- 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了\r\n\r\n- 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手\r\n\r\n**TCP和UDP的区别**\r\n\r\n- TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来\r\n\r\n- UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境\r\n\r\n\r\n\r\n**HTTP和HTTPS**\r\n\r\n- HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS\r\n- 默认HTTP的端口号为80，HTTPS的端口号为443\r\n\r\n**为什么HTTPS安全**\r\n\r\n- 因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性\r\n\r\n**关于Http 2.0 你知道多少？**\r\n\r\n- HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。\r\n\r\n- HTTP/2提供更多的加密支持\r\n\r\n- HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。\r\n\r\n- 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽\r\n\r\n**GET和POST的区别，何时使用POST？**\r\n\r\n-  GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符\r\n-  POST：一般用于修改服务器上的资源，对所发送的信息没有限制。\r\n-  GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。\r\n-  然而，在以下情况中，请使用 POST 请求：\r\n   - 无法使用缓存文件（更新服务器上的文件或数据库）\r\n\r\n   - 向服务器发送大量数据（POST 没有数据量限制）\r\n\r\n   - 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\r\n\r\n\r\n\r\n**说说网络分层里七层模型是哪七层**\r\n\r\n  - 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）\r\n\r\n  - 传输层（TCP和UDP）\r\n\r\n  - 网络层（IP）\r\n\r\n  - 物理和数据链路层（以太网）\r\n\r\n- 每一层的作用如下：\r\n\r\n  - 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）\r\n数据链路层：将比特组装成帧和点到点的传递（帧Frame）\r\n  - 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）\r\n  - 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）\r\n  - 会话层：建立、管理和终止会话（会话协议数据单元SPDU）\r\n  - 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）\r\n  - 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）\r\n\r\n**讲讲304缓存的原理**\r\n\r\n- 服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存\r\n- 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件\r\n- 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体\r\n\r\n**HTTP/2 与 HTTP/1.x 的关键区别**\r\n\r\n  * 二进制协议代替文本协议，更加简洁高效\r\n  * 针对每个域只使用一个多路复用的连接\r\n  * 压缩头部信息减小开销\r\n  * 允许服务器主动推送应答到客户端的缓存中\r\n\r\n**一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？**\r\n\r\n- 01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-\u003e系统缓存-\u003e路由器缓存-\u003eISP DNS 缓存-\u003e根域名服务器)\r\n- 02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）\r\n- 03.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com）\r\n- 04.浏览器跟踪重定向地址，请求另一个带 www 的网址\r\n- 05.服务器处理请求（通过路由读取资源）\r\n- 06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 'text/html'）\r\n- 07.浏览器进 DOM 树构建\r\n- 08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）\r\n- 09.浏览器显示完成页面\r\n- 10.浏览器发送异步请求\r\n\r\n## url构成\r\n\r\n- protocol 协议，常用的协议是http\r\n- hostname 主机地址，可以是域名，也可以是IP地址\r\n- port 端口 http协议默认端口是：80端口，如果不写默认就是:80端口\r\n- path 路径 网络资源在服务器中的指定路径\r\n- parameter 参数 如果要向服务器传入参数，在这部分输入\r\n- query 查询字符串 如果需要从服务器那里查询内容，在这里编辑\r\n- fragment 片段 网页中可能会分为不同的片段，如果想访问网页后直接到达指定位置，可以在这部分设置\r\n\r\n## 反向代理和正向代理\r\n\r\n### 正向代理\r\n\r\n正向代理类似一个跳板机，代理访问外部资源\r\n\r\n比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了\r\n\r\n用途：\r\n- 访问原来无法访问的资源，如google\r\n\r\n- 可以做缓存，加速访问资源\r\n\r\n- 对客户端访问授权，上网进行认证\r\n\r\n- 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息\r\n\r\n### 反向代理\r\n\r\n反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器\r\n\r\n用途:\r\n\r\n- 保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网\r\n\r\n- 负载均衡，通过反向代理服务器来优化网站的负载\r\n\r\n### 总结\r\n\r\n正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.\r\n\r\n反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端\r\n\r\n## 对称加密和非对称加密\r\n\r\n对称加密：\r\n\r\n在对称加密算法中，加密和解密使用的是同一把钥匙，即：使用相同的密匙对同一密码进行加密和解密；\r\n\r\n优点：算法简单，加密解密容易，效率高，执行快。\r\n\r\n缺点：相对来说不算特别安全，只有一把钥匙，密文如果被拦截，且密钥也被劫持，那么，信息很容易被破译。\r\n\r\n非对称加密：\r\n\r\n在非对称加密算法中，公钥和私钥不是同一把密钥，用户A会将公钥公开，发送给用户B，保留住自己的私钥，用户B发送数据给A时，用A的公钥加密数据，然后发送给A，A收到加密数据后用自己的私钥解密数据。\r\n\r\n优点：安全，即使密文被拦截、公钥被获取，但是无法获取到私钥，也就无法破译密文。作为接收方，务必要保管好自己的密钥。\r\n\r\n缺点：加密算法及其复杂，安全性依赖算法与密钥，而且加密和解密效率很低。\r\n\r\n## 一个 tcp 连接能发几个 http 请求？\r\n\r\n如果是 HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP 连接即会断开，因此一个 TCP 发送一个 HTTP 请求，但是有一种情况可以将一条 TCP 连接保持在活跃状态，那就是通过 Connection 和 Keep-Alive 首部，在请求头带上 Connection: Keep-Alive，并且可以通过 Keep-Alive 通用首部中指定的，用逗号分隔的选项调节 keep-alive 的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有限制，可以关注《HTTP 权威指南》4.5.5 节对于 Keep-Alive 连接的限制和规则。\r\n而如果是 HTTP 1.1 版本协议，支持了长连接，因此只要 TCP 连接不断开，便可以一直发送 HTTP 请求，持续不断，没有上限；\r\n同样，如果是 HTTP 2.0 版本协议，支持多用复用，一个 TCP 连接是可以并发多个 HTTP 请求的，同样也是支持长连接，因此只要不断开 TCP 的连接，HTTP 请求数也是可以没有上限地持续发送\r\n\r\n## CDN缓存\r\n\r\nhttp缓存是浏览器端缓存，cdn是服务器端缓存。\r\n\r\n客户端浏览器先检查是否有本地缓存是否过期，如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求（back to the source request）,来拉取最新的数据。\r\n\r\n## DNS缓存\r\n\r\n### 浏览器DNS缓存\r\n\r\n浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关。\r\n\r\n浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的DNS缓存时间，其中Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入\r\n\r\n``` url\r\nchrome://net-internals/#dns\r\n```\r\n\r\n### 系统DNS缓存\r\n\r\n系统缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。\r\n\r\n### ISP DNS缓存\r\n\r\nISP（电信运营商）缓存有些不靠谱，有些缓存服务器会忽略网站DNS提供的TTL，自己设置一个较长的TTL，导致顶级DNS更新时不能及时拿到新的IP地址。\r\n\r\n## TLS原理\r\n\r\nTransport Layer Security (TLS) 是一个为计算机网络提供通信安全的加密协议。它广泛应用于大量应用程序，其中之一即浏览网页。网站可以使用 TLS 来保证服务器和网页浏览器之间的所有通信安全。\r\n\r\n整个 TLS 握手过程包含以下几个步骤：\r\n\r\n- 客户端向服务器发送 『Client hello』 信息，附带着客户端随机值(random_C)和支持的加密算法组合。\r\n- 服务器返回给客户端 『Server hello』信息，附带着服务器随机值(random_S)，以及选择一个客户端发送过来加密算法。\r\n- 服务器返回给客户端认证证书及或许要求客户端返回一个类似的证书，认证证书里面携带服务端的公钥信息。\r\n- 服务器返回『Server hello done』信息。\r\n- 如果服务器要求客户端发送一个证书，客户端进行发送。\r\n- 客户端创建一个随机的 Pre-Master 密钥然后使用服务器证书中的公钥来进行加密，向服务器发送加密过的 Pre-Master 密钥。\r\n- 服务器收到 Pre-Master 密钥。服务器和客户端各自生成基于 Pre-Master 密钥的主密钥和会话密钥。两个明文随机数 random_C 和 random_S 与自己计算产生的 pre-master，计算得到协商密钥enc_key=Fuc(random_C, random_S, pre-master)\r\n- 客户端给服务器发送一个 『Change cipher spec』的通知，表明客户端将会开始使用协商密钥和加密算法进行加密通信。\r\n- 客户端也发送了一个 『Client finished』的消息。\r\n- 服务器接收到『Change cipher spec』的通知然后使用协商密钥和加密算法进行加密通信。\r\n- 服务器返回客户端一个 『Server finished』消息。\r\n- 客户端和服务器现在可以通过建立的安全通道来交换程序数据。所有客户端和服务器之间发送的信息都会使用会话密钥进行加密。\r\n\r\n每当发生任何验证失败的时候，用户会收到警告。比如服务器使用自签名的证书。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/608/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/608/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 强缓存与协商缓存","### 浏览器缓存","#### 缓存优点","#### 缓存缺点","#### 缓存流程","### 强缓存相关的header字段","### 协商缓存相关的header字段","#### 1. Last-Modified/If-Modified-Since","#### 2. Etag/If-None-Match","### 既生Last-Modified何生Etag","### 用户的行为对缓存的影响","### 强缓存如何重新加载缓存缓存过的资源","## HTTP 各版本特点与区别","### 1、HTTP 0.9","### 2、HTTP 1.0","### 3、HTTP 1.1","#### Persistent Connection（keepalive连接）","#### chunked编码传输","#### 字节范围请求","#### 断点续传","#### Pipelining（请求流水线）","#### 其他特性","### 4、HTTP 2.0","#### 二进制分帧","#### 多路复用","#### 头部压缩","#### 随时复位","#### 服务器端推流","#### 优先权和依赖","## 队头阻塞以及解决办法","### 前言","### TCP队头阻塞","### HTTP队头阻塞","#### HTTP管道化是什么","#### HTTP管道化产生的背景","#### HTTP管道化的限制","#### HTTP管道化引起的请求队头阻塞","### 如何解决队头阻塞","#### 如何解决HTTP队头阻塞","#### 如何解决TCP队头阻塞","### 总结","## QUIC","### QUIC的由来：为什么是UDP而非TCP？","### 为什么要用QUIC？","#### 1. 建连延迟低","#### 2. 安全又可靠","#### 3. 改造灵活","#### 4. 改进的拥塞控制","#### 5. 无队头阻塞的多路复用","### QUIC对客户端的要求","### QUIC应用场景","## HTTP协议","### 1. 前言","### 2. HTTP协议的主要特点","#### 2.1 简单快速","#### 2.2 灵活","#### 2.3 无连接","#### 2.4 无状态","### 3 HTTP报文的组成部分","#### 3.1 请求报文包括：","#### 3.2 响应报文包括：","### 4 HTTP方法","### 5 get 和 post的区别","### 6 http状态码","### 7 持久链接/http长连接","### 8 长连接中的管线化","#### 8.1 管线化的原理","#### 8.2 管线化的注意事项","### 9 TLS 协商","## EventSource和轮询的优缺点","### EventSource","#### 简介","#### EventSource规范字段","#### EventSource属性","#### EventSource 通讯过程","#### 缺点","### 轮询","#### 短轮询(Polling)","#### 长轮询(Long Polling)","### EventSource VS 轮询","### 总结","## WebSocket 是什么原理？为什么可以实现持久连接？","### WebSocket 机制","### WebSocket协议的原理","### WebSocket协议的优缺点","## 网络相关","### 1.1 DNS 预解析","### 1.2 缓存","### 1.3 使用 HTTP / 2.0","### 1.4 预加载","### 1.5 预渲染","## 优化渲染过程","### 2.1 懒执行","### 2.2 懒加载","## HTTP method","## 从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)","## HTTP request 报文结构是怎样的","## HTTP response 报文结构是怎样的","## HTTP 状态码及其含义","## 说一下 Http 缓存策略，有什么区别，分别解决了什么问题","### 1）浏览器缓存策略","### 2）强缓存","### 3）强缓存(expires)","### 4）强缓存(cache-control)","### 5）协商缓存","### 协商缓存(Last-Modified/If-Modified-since)","### 协商缓存(Etag/If-None-match)","## 前端安全、中间人攻击","### 1）XSS：跨站脚本攻击","#### 存储型(server端)","#### 反射型(Server端)","#### Dom 型(浏览器端)","#### 预防方案","### CSRF：跨站请求伪造","#### 攻击流程举例","#### 攻击类型","#### 预防方案","### 3）iframe 安全","#### 说明","#### 预防方案","### 4）错误的内容推断","#### 说明","#### 预防方案","### 5）第三方依赖包","### 6）HTTPS","#### 描述","#### 预防方案","### 7）本地存储数据","### 8）静态资源完整性校验","#### 描述","#### 预防方案","### 9）网络劫持","#### 描述","#### 预防方案","### 10）中间人攻击","#### 场景","#### 过程","#### 使用抓包工具fiddle来进行举例说明","#### 常见攻击方式","#### 预防方案","### 11）sql 注入","#### 描述","#### 预防方案","### 12）前端数据安全","#### 描述","#### 预防方案","### 13）其他建议","## HTTP","## url构成","## 反向代理和正向代理","### 正向代理","### 反向代理","### 总结","## 对称加密和非对称加密","## 一个 tcp 连接能发几个 http 请求？","## CDN缓存","## DNS缓存","### 浏览器DNS缓存","### 系统DNS缓存","### ISP DNS缓存","## TLS原理"]},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"608"},"buildId":"0Vvb4_ySYrEYJ5MFNauen","assetPrefix":"/toolbox-frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>