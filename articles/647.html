<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具</title><link rel="icon" href="/frontend/favicon.ico"/><meta name="description" content="卡鲁秋的前端工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋,Hank,HankLiu"/><meta name="author" content="Hank.Liu"/><meta name="next-head-count" content="7"/><link rel="stylesheet" href="/frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/frontend/_next/static/css/48e12760546808a2.css" as="style"/><link rel="stylesheet" href="/frontend/_next/static/css/48e12760546808a2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/frontend/_next/static/chunks/webpack-6fff9d468fdb49d1.js" defer=""></script><script src="/frontend/_next/static/chunks/framework-0e8d27528ba61906.js" defer=""></script><script src="/frontend/_next/static/chunks/main-d236bc00457e5dc2.js" defer=""></script><script src="/frontend/_next/static/chunks/pages/_app-bc774d0c387ddf39.js" defer=""></script><script src="/frontend/_next/static/chunks/4853-4e02ebf21637e379.js" defer=""></script><script src="/frontend/_next/static/chunks/3239-4699acf95684b42e.js" defer=""></script><script src="/frontend/_next/static/chunks/1664-e769dc1505626ddd.js" defer=""></script><script src="/frontend/_next/static/chunks/pages/articles/%5Bid%5D-15cbf11aeca29499.js" defer=""></script><script src="/frontend/_next/static/a3cZ70FNaLN28WmGwcIOw/_buildManifest.js" defer=""></script><script src="/frontend/_next/static/a3cZ70FNaLN28WmGwcIOw/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1 overflow-x-hidden"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-1okl62o"><div class="ant-card-body"><article><div class="mx-auto mb-[36px] max-w-[1045px] px-[30px] lg:mb-[52px] lg:flex lg:px-0"><div id="banner" class="media-wrapper image-media-wrapper w-full overflow-hidden rounded-[8px] border-[1px] border-solid border-[#1D2129] lg:ml-0 lg:h-[320px] lg:w-[500px]"><div class="hidden before"></div><div class="hidden after"></div><div class="scale-103 h-full w-full border-[8px] border-solid border-white lg:scale-100 cover-wrapper"><img class="h-full w-full rounded-md object-cover cover" src="/frontend/dashboard/images/banner.png" alt=""/></div></div><div class="mt-[60px] overflow-hidden lg:ml-[32px] lg:mt-0 lg:flex-1"><h1 class="leading-130 montserrat-bold mb-[9px] text-[36px] font-medium text-[#1D2129] lg:mb-[8px]">Webpack Plugin插件机制</h1><div class="mb-[9px] flex whitespace-nowrap lg:mb-[10px]"><div class="leading-120 cursor-pointer truncate text-[24px] font-normal text-[#1D2129] underline-offset-2 hover:underline lg:text-[20px]" aria-hidden="true"># VOL.<!-- -->647</div><div class="leading-120 ml-[48px] text-[24px] font-normal text-[#1D2129] lg:ml-[32px] lg:text-[20px]">2024/04/01</div></div><div class="mb-[12px] flex flex-wrap lg:mb-0"><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">blog</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">javascript</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">webpack</div></div><div class="my-[30px] hidden w-[213px] border border-[#1D2129] lg:mb-[20px] lg:mt-[8px] lg:block"></div><div class="lg:rounded-0 rounded-[12px] bg-white/30 p-[36px] lg:flex lg:bg-transparent lg:p-0"><div class="float-left h-[118px] w-[118px] lg:float-none lg:h-[112px] lg:w-[112px]"><img src="https://avatars.githubusercontent.com/u/8088864?v=4" class="h-full w-full rounded-[8px] object-cover lg:rounded-[12px]" alt=""/></div><div class="lg:ml-[32px] lg:flex-1 lg:overflow-hidden"><div class="mb-[10px] flex h-[118px] flex-col justify-center pl-[36px] lg:h-auto lg:flex-row lg:items-center lg:justify-between lg:pl-0"><div class="leading-130 montserrat-bold mb-[12px] w-full truncate text-[30px] font-medium text-[#1D2129] lg:mb-0 lg:flex-1 lg:text-[24px]">hankliu62</div><a class="leading-170 ml-0 whitespace-pre-wrap text-[20px] font-normal !text-[#1D2129] !underline hover:!text-[#1D2129] hover:!underline focus:!text-[#1D2129] lg:ml-[5px] lg:text-[14px]" href="https://github.com/hankliu62" target="_blank" rel="noreferrer">TA的个人名片</a></div><div class="leading-170 text-[20px] font-normal text-[#4E5969] lg:text-[14px]">HankLiu前端开发工程师，精通前端，涉猎后端，对前端有着浓厚的兴趣，希望能够在前端这条路上一直走下去。努力去听风的声音，不必在意风的方向。</div></div></div></div></div><div class="ant-divider css-1okl62o ant-divider-horizontal !mt-0 !border-[#bfc3c7]" role="separator"></div><section><div><div class="ant-skeleton ant-skeleton-active css-1okl62o"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-1okl62o"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="## Webpack Plugin插件机制

### plugin机制出现原因

前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。

那如果我们需要在项目中实现`打包前自动清理上次打包生成的文件`、`将一些文件复制到打包目录中`、`自动生成html文件`、`将打包产物自动上传至服务器`、`将打包后代码进行压缩、拆分`等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。

没错，webpack的plugin机制让webpack有了定制化的能力。

### plugin原理

那具体如何通过plugin机制去实现这些定制化功能呢？

其实是webpack在打包过程中的不同阶段（配置文件读取完成后、打包开始前、打包完成后等阶段）会触发不同的钩子，我们只需要明确要实现的功能应该在哪个阶段，然后将具体实现代码注册为对应钩子的事件即可。

### webpack运行原理

我们在了解这些钩子之前，必须要知道webpack的运行原理。

这是一个简化版的webpack打包过程，当我们执行 `webpack build` 命令后，webpack会先读取配置文件，然后根据配置文件中的配置项去初始化，创建一个 `compiler` 对象，然后调用 `compiler` 对象的 `run` 方法，初始化一个 `compilation` 对象，执行 `compilation` 中的 `build` 方法进行编译，编译完成后，触发 `compiler` 对象的 `done` 钩子，完成打包。

![image](https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82)

``` js
//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数
function webpack(webpackOptions) {
  //第二步：用配置参数对象初始化 `Compiler` 对象
  const compiler = new Compiler(webpackOptions);
  //第三步：挂载配置文件中的插件
 const { plugins } = webpackOptions;
 for (let plugin of plugins) {
   plugin.apply(compiler);
 }
  return compiler;
}
```

``` js
//Compiler其实是一个类，它是整个编译过程的大管家，而且是单例模式
class Compiler {
  constructor(webpackOptions) {
   //省略
  }

  // 第五步：创建compilation对象
  compile(callback){
    //虽然webpack只有一个Compiler，但是每次编译都会产出一个新的Compilation，
    //这里主要是为了考虑到watch模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译
    //每次编译都会产出一个新的Compilation，代表每次的编译结果
    let compilation = new Compilation(this.options);
    compilation.build(callback); //执行compilation的build方法进行编译，编译成功之后执行回调
  }

  //第四步：执行`Compiler`对象的`run`方法开始执行编译
  run(callback) {
    this.hooks.run.call(); //在编译前触发run钩子执行，表示开始启动编译了
    const onCompiled = () =&gt; {
      // 第七步：当编译成功后会触发done这个钩子执行
      this.hooks.done.call();
    };
    this.compile(onCompiled); //开始编译，成功之后调用onCompiled
  }
}


class Compilation {
  constructor(webpackOptions) {
    this.options = webpackOptions;
    this.modules = []; //本次编译所有生成出来的模块
    this.chunks = []; //本次编译产出的所有代码块，入口模块和依赖的模块打包在一起为代码块
    this.assets = {}; //本次编译产出的资源文件
    this.fileDependencies = []; //本次打包涉及到的文件，这里主要是为了实现watch模式下监听文件的变化，文件发生变化后会重新编译
  }

  //第六步：执行compilation的build方法进行编译
  build(callback) {
  //这里开始做编译工作，编译成功执行callback

  // ... 编译过程代码省略

  // 编译完成后，触发callback回调
  callback()
  }
}
```

&lt;!-- more --&gt;

### compiler 与 compilation

那上面提到的 `compiler` 对象和 `compilation` 对象到底是什么呢？又有什么区别与联系？

- `compiler` 对象包含了webpack的所有配置信息，包括`entry`、`output`、`module`、`plugins`等，`compiler` 对象会在启动webpack时，一次性地初始化创建，它是全局唯一的，可以简单理解为webpack的实例。
- `compilation` 对象代表一次资源的构建，通过一系列API可以访问/修改本次模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息等，当我们以开发模式运行webpack时，每当检测到一个文件变化，就会创建一个新的 `compilation` 对象，所以 `compilation` 对象也是一次性的，只能用于当前的编译。

**他有以下主要属性：**

- `compilation.modules` 解析后的所有模块
- `compilation.chunks` 所有的代码分块chunk
- `compilation.assets` 本次打包生成的所有文件
- `compilation.hooks` compilation所有的钩子

所以说呢，`compiler` 代表的是整个 webpack 从启动到关闭的生命周期（终端结束，该生命周期结束）， 而 `compilation` 只是代表了一次性的编译过程，如果是watch模式，每次监听到文件变化，都会产生一个新的 `compilation`，所以 `compilation` 代表一次资源的构建，会多次被创建，而 `compiler` 只会被创建一次。

**我们了解了`compiler`和`compilation`对象后，就可以来看一下到底有哪些钩子。**

### compiler钩子
compiler有很多钩子[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，介绍几个常用的：

- `environment` SyncHook类型，在编译器准备环境时调用，时机就在配置文件中初始化插件之后。
- `afterEnvironment` SyncHook类型，当编译器环境设置完成后，在 `environment hook` 后直接调用。
- `entryOption` SyncBailHook类型，在 `webpack` 选项中的 `entry` 被处理过之后调用。
- `afterPlugins` SyncHook类型，在插件初始化之后。
- `afterResolvers` SyncHook类型，`resolver` 设置完成之后触发。
- `beforeRun` AsyncSeriesHook类型，在开始执行一次构建之前调用，`compiler.run` 方法开始执行后立刻进行调用。
- `run` AsyncSeriesHook类型，在开始读取 `records` 之前调用。
- `watchRun` AsyncSeriesHook类型，在监听模式下，一个新的 `compilation` 触发之后，但在 `compilation` 实际开始之前触发。
- `beforeCompile` AsyncSeriesHook类型，在创建 `compilation` 参数之后执行。
- `compile` SyncHook类型，`beforeCompile` 之后立即调用，但在一个新的 `compilation` 创建之前。
- `thisCompilation` SyncHook类型，初始化 `compilation` 时调用，在触发 `compilation` 事件之前调用。
- `compilation` SyncHook类型，一次新的编译 `compilation` 创建之后触发。
- `make` AsyncParallelHook类型，`compilation` 结束之前执行，`seal` 之前执行。
- `afterCompile` AsyncSeriesHook类型，`compilation` 结束和封印之后执行。
- `shouldEmit` SyncBailHook类型，在输出 `asset` 之前调用。返回一个布尔值，告知是否输出。
- `emit` AsyncSeriesHook类型，生成资源到 `output` 目录之前触发。
- `afterEmit` AsyncSeriesHook类型，输出 `asset` 到 `output` 目录之后执行。
- `done` AsyncSeriesHook类型，`compilation` 编译完成后触发。
- `failed` SyncHook类型，`compilation` 编译失败后触发。

### compilation钩子

compilation对象也有很多钩子[官方地址](https://webpack.js.org/api/compilation-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compilation-hooks/)，介绍几个常用的：

- `buildModule` SyncHook类型，模块开始编译前，执行该钩子，可以用于修改模块内容。
- `succeedModule` SyncHook类型，模块编译成功后，执行该钩子。
- `finishModules` AsyncSeriesHook类型，所有模块编译完成后，执行该钩子。
- `moduleAsset` SyncHook类型，一个模块中的一个 asset 被添加到 compilation 时调用。
- `chunkAsset` SyncHook类型，一个 chunk 中的 asset 被添加到 compilation 时调用。
- `seal` SyncHook类型，在构建过程封存前触发，允许在最终资源生成之前进行一些操作。
- `optimize` SyncHook类型，优化阶段开始时触发，可以用于自定义资源优化逻辑。
- `optimizeAssets` AsyncSeriesHook类型，优化存储在 compilation.assets 中的所有 asset，可以监听和修改资源的优化过程。
- `afterOptimizeAssets` SyncHook类型，asset 已经优化。
- `optimizeTree` AsyncSeriesHook类型，在优化依赖树之前触发，允许修改资源树的优化逻辑。
- `afterOptimizeTree` SyncHook类型，在优化依赖树之后触发，可用于处理优化完成后的资源树。
- `optimizeChunkAssets` AsyncSeriesHook类型，优化所有 chunk asset，弃用，可使用 processAssets 来代替，可用于自定义块资源的优化逻辑。
- `processAssets` AsyncSeriesHook类型，asset 处理时触发，可以监听和修改资源的生成。
- `beforeHash` SyncHook类型，在 compilation 添加哈希（hash）之前。
- `afterHash` SyncHook类型，在 compilation 添加哈希（hash）之后。
- `beforeModuleAssets` SyncHook类型，在创建模块 asset 之前执行，可用于在模块资源生成前执行一些操作。

每个钩子都有对应的类型，那这些类型有什么区别呢？

## Tapable

[Tapable](https://github.com/webpack/tapable)是一个提供**事件发布订阅**的工具，通过其提供的一系列钩子，我们可以注册事件，然后在不同的阶段去触发这些注册的事件。 webpack的plugin机制正是基于 Tapable 实现的，在不同编译阶段触发不同的钩子。

Tapable 官方文档提供了这九种钩子，也就是我们上面提到的钩子类型：

``` js
const {
  SyncHook,
  SyncBailHook,
  SyncWaterfallHook,
  SyncLoopHook,
  AsyncParallelHook,
  AsyncParallelBailHook,
  AsyncSeriesHook,
  AsyncSeriesBailHook,
  AsyncSeriesWaterfallHook
} = require(&quot;tapable&quot;);
```

可以看到，这些钩子有两种开头，分别是 `Sync` 和 `Async` ，这两种钩子的区别是： `Sync` 开头的为同步钩子，表示注册的事件函数会同步进行执行；`Async` 开头的为异步钩子，表示注册的事件函数会异步进行执行

同时呢，这些钩子还有三种结尾，分别是`Hook`、`BailHook`、`WaterfallHook`、`LoopHook`，

这三种结尾的区别是如下所示

- `Hook`结尾的为普通钩子，只会按顺序挨个执行注册的事件，不会去管事件函数的返回值是什么。

![image](https://github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab)

- `BailHook`结尾的为保险钩子，只要注册的事件函数有一个返回值不为`undefined`，就会停止执行后面的事件函数。

![image](https://github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5)

- `WaterfallHook`结尾的为瀑布钩子，注册的事件函数会按顺序执行，每个事件函数的返回值会作为下一个事件函数的参数，只会影响下一个事件函数的第一个参数。

![image](https://github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143)

- `LoopHook`结尾的为循环钩子，注册的事件函数会按顺序执行，只要执行的事件返回值非`undefined`，就会立即重头开始执行，直到所有的事件函数都返回`undefined`，这个钩子才会结束。

![image](https://github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7)

接下来，我们又发现，异步钩子又是以`AsyncParallel`、`AsyncSeries`开头，这又有什么区别呢？

- `AsyncSeries` 为异步串行钩子，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。
- `AsyncParallel` 为异步并行钩子，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。

下面我们就来讲一下这些钩子如何去使用。

### Tapable同步钩子

同步钩子只需要调用 `tap` 方法注册事件，然后调用 `call` 方法触发事件即可。

#### 1. SyncHook

SyncHook 是一个同步的、普通类型的 Hook，注册的事件函数会按顺序挨个执行，不会去管事件函数的返回值是什么。

``` js
const { SyncHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new SyncHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tap(&#x27;事件1&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件1执行:&#x27;, name, age);
});

// 注册事件2
hook.tap(&#x27;事件2&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件2执行:&#x27;, name, age);
});

// 触发事件，传入实参
hook.call(&#x27;前端&#x27;, 18);

// 执行结果
// 事件1执行: 前端 18
// 事件2执行: 前端 18
```

#### 2. SyncBailHook

SyncBailHook 是一个同步的、保险类型的 Hook，意思是只要其中一个有返回了，后面的就不执行了。

``` js
const { SyncBailHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new SyncBailHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tap(&#x27;事件1&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件1执行:&#x27;, name, age);
});

// 注册事件2
hook.tap(&#x27;事件2&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件2执行:&#x27;, name, age);
  return &#x27;abc&#x27;
});

// 注册事件3
hook.tap(&#x27;事件3&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件3执行:&#x27;, name, age);
});

// 触发事件，传入实参
hook.call(&#x27;前端&#x27;, 18);

// 执行结果
// 事件1执行: 前端 18
// 事件2执行: 前端 18
```

#### 3. SyncWaterfallHook

SyncWaterfallHook 是一个同步的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。

``` js
const { SyncWaterfallHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new SyncWaterfallHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tap(&#x27;事件1&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件1执行:&#x27;, name, age);
  return &#x27;驿站&#x27;
});

// 注册事件2
hook.tap(&#x27;事件2&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件2执行:&#x27;, name, age);
});

// 注册事件3
hook.tap(&#x27;事件3&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件3执行:&#x27;, name, age);
});

// 触发事件，传入实参
hook.call(&#x27;前端&#x27;, 18);

// 执行结果
// 事件1执行: 前端 18
// 事件2执行: 驿站 18
// 事件3执行: 驿站 18
```

#### 4. SyncLoopHook

SyncLoopHook 是一个同步的、循环类型的 Hook，只要执行的事件函数返回值非undefeind，就会立即重头开始执行，直到所有的事件函数都返回undefined，这个钩子才会结束。

``` js
const { SyncLoopHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new SyncLoopHook();

let count = 5;

// 注册事件1
hook.tap(&#x27;事件1&#x27;, () =&gt; {
  count--;
  console.log(&#x27;事件1执行,count为&#x27;,count);
  if (count &gt; 3) {
    return true;
  }
});

// 注册事件2
hook.tap(&#x27;事件2&#x27;, () =&gt; {
  count--;
  console.log(&#x27;事件2执行,count为&#x27;,count);
  if (count &gt; 1) {
    return true;
  }
});

// 注册事件3
hook.tap(&#x27;事件3&#x27;, () =&gt; {
  console.log(&#x27;事件3执行,count为&#x27;,count);
});

// 触发事件
hook.call();

// 执行结果
// 事件1执行,count为 4
// 事件1执行,count为 3
// 事件2执行,count为 2
// 事件1执行,count为 1
// 事件2执行,count为 0
// 事件3执行,count为 0
```

### Tapable异步钩子

异步钩子提供三种注册的方法：

- `tap`：以同步方式注册钩子，用 `call` 来触发，跟同步钩子一样，只不过加持了异步的能力，不过多讲解。
- `tapAsync`: 以异步方式注册钩子，用 `callAsync` 触发，同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成，下面有使用示例。
- `tapPromise`: 以异步方式注册钩子，用 `promise` 的方式触发,下面有使用示例。

#### 1. AsyncParallelHook

AsyncParallelHook 是一个异步的、并行类型的 Hook，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。

``` js
const { AsyncParallelHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncParallelHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapAsync(&#x27;事件1&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件1执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 2000);
});

// 注册事件2
hook.tapAsync(&#x27;事件2&#x27;, (name, age, callback) =&gt; {
  console.log(&#x27;事件2执行:&#x27;, name, age);
  // 调用callback，表示该事件执行完毕
  callback();
});

// 注册事件3
hook.tapAsync(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  console.log(&#x27;事件3执行:&#x27;, name, age);
  // 调用callback，表示该事件执行完毕
  callback();
});

// 触发事件，传入实参
hook.callAsync(&#x27;前端&#x27;, 18, () =&gt; {
  // 该钩子注册的所有事件执行完毕后，会执行该回调
  console.log(&#x27;该钩子所有事件执行完毕&#x27;);
});

// 执行结果
// 事件2执行: 前端 18
// 事件3执行: 前端 18
// 2秒后输出：事件1执行: 前端 18
// 该钩子所有事件执行完毕
```

#### 2. AsyncParallelBailHook

AsyncParallelBailHook 是一个异步、并行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。

``` js
const { AsyncParallelBailHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncParallelBailHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapPromise(&#x27;事件1&#x27;, (name, age) =&gt; {
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      console.log(&#x27;事件1执行:&#x27;, name, age);
      resolve(&#x27;123&#x27;);
    }, 2000);
  })
});

// 注册事件2
hook.tapPromise(&#x27;事件2&#x27;, (name, age) =&gt; {
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      console.log(&#x27;事件2执行:&#x27;, name, age);
      resolve();
    }, 3000);
  })
});

// 注册事件3
hook.tapPromise(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  return new Promise((resolve) =&gt; {
    console.log(&#x27;事件3执行:&#x27;, name, age);
    resolve();
  })
});

// 触发事件，传入实参
hook.promise(&#x27;前端&#x27;, 18).then((res) =&gt; {
  // 该钩子注册的所有事件执行完毕后，会执行该回调
  console.log(&#x27;该钩子所有事件执行完毕&#x27;,res);
})

// 执行结果
// 事件3执行: 前端 18
// 2秒后输出：事件1执行: 前端 18
// 该钩子所有事件执行完毕123
```

#### 3. AsyncSeriesHook

AsyncSeriesHook 是一个异步的、串行类型的 Hook，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。

``` js
const { AsyncSeriesHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncSeriesHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapAsync(&#x27;事件1&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件1执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback(null, &#x27;123&#x27;);
  }, 4000);
});

// 注册事件2
hook.tapAsync(&#x27;事件2&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件2执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 3000);
});

// 注册事件3
hook.tapAsync(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件3执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 2000);
});

// 触发事件，传入实参
hook.callAsync(&#x27;前端&#x27;, 18, (err, result) =&gt; {
  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值
  console.log(&#x27;该钩子所有事件执行完毕&#x27;,result);
});

// 执行结果
// 事件3执行: 前端 18
// 事件2执行: 前端 18
// 事件1执行: 前端 18
// 该钩子所有事件执行完毕123
```

#### 4. AsyncSeriesBailHook

AsyncSeriesBailHook 是一个异步的、串行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。

``` js
const { AsyncSeriesBailHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncSeriesBailHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapAsync(&#x27;事件1&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件1执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 4000);
});

// 注册事件2
hook.tapAsync(&#x27;事件2&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件2执行:&#x27;, name, age);
    callback(null, &quot;88717&quot;);
  }, 3000);
});

// 注册事件3
hook.tapAsync(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件3执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 2000);
});

// 触发事件，传入实参
hook.callAsync(&#x27;前端&#x27;, 18, (err, result) =&gt; {
  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值
  console.log(&#x27;该钩子所有事件执行完毕&#x27;,result);
});

// 执行结果
// 事件3执行: 前端 18
// 事件2执行: 前端 18
// 该钩子所有事件执行完毕88717
```

#### 5. AsyncSeriesWaterfallHook

AsyncSeriesWaterfallHook 是一个异步的、串行的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。

``` js
const { AsyncSeriesWaterfallHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncSeriesWaterfallHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapAsync(&#x27;事件1&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件1执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback(null,3);
  }, 4000);
});

// 注册事件2
hook.tapAsync(&#x27;事件2&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件2执行:&#x27;, name, age);
    callback(null, 2);
  }, 3000);
});

// 注册事件3
hook.tapAsync(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件3执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback(null, 1);
  }, 2000);
});

// 触发事件，传入实参
hook.callAsync(&#x27;前端&#x27;, 18, (err, result) =&gt; {
  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值
  console.log(&#x27;该钩子所有事件执行完毕&#x27;,result);
});

// 执行结果
// 事件3执行: 前端 18
// 事件2执行: 1 18
// 事件1执行: 2 18
// 该钩子所有事件执行完毕3
```

### 如何自定义plugin

了解Tapable之后，我们就可以学习如何自定义plugin了。

webpack 插件由以下几部分组成：

- 一个 `JavaScript` 类 一个构造方法，可以接受一个 `options` 对象参数
- 一个 `apply` 方法，该方法在 `webpack` 装载这个插件的时候被调用，并且会传入 `compiler` 对象
根据我们的需求，确定要在哪个阶段挂载到哪个钩子上，根据钩子的类型（同步/异步），选择合适的事件注册方式，将需求实现代码注册为事件。

事件回调中具体有哪些参数，需要根据钩子的类型去官网查看[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，这里就不一一列举了。

&gt; 注意 ： webpack4 可以用 plugin方法来注册插件，webpack5之后被取消了。
&gt; compiler.plugin(&#x27;emit&#x27;, function (compilation, cb) {})

``` js
class BasicPlugin{
  // 在构造函数中获取用户给该插件传入的配置项
  constructor(options){
    this.options = options;
  }

  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象
  apply(compiler) {
    // 注册第1个事件, 这个事件名叫什么都无所谓，只是个标示而已
    compiler.hooks.run.tapAsync(&#x27;BasicPlugin&#x27;, (compiler, callback) =&gt; {
      console.log(&#x27;以异步方式触及 run 钩子。&#x27;)
      callback()
    })

    // 注册第2个事件
    // 在compiler的compilation钩子上注册一个事件BasicPlugin
    compiler.hooks.compilation.tap(&#x27;BasicPlugin&#x27;, (compilation) =&gt; {
      // 测试compilation对象在模块构建之前能得到什么
      compilation.hooks.buildModule.tap(&#x27;BasicPlugin&#x27;, (data) =&gt; {
          console.log(data);
      })
    })

    // 注册第3个事件
    compiler.hooks.emit.tap(&#x27;BasicPlugin&#x27;, (compilation) =&gt; {
      // 业务逻辑代码
    });
  }
}

module.exports = BasicPlugin;
```

``` js
// webpack.config.js
const path = require(&#x27;path&#x27;);
const BasicPlugin = require(&#x27;./BasicPlugin&#x27;);

module.exports = {
  entry: &#x27;./src/index.js&#x27;,
  output: {
    filename: &#x27;[name].bundle.js&#x27;,
    path: path.resolve(__dirname, &#x27;dist&#x27;)
  },
  plugins: [
    new BasicPlugin(),
  ]
}
```


### 自定义plugin实战

为了更好的实践，给大家提供3个自定义插件来参考。

#### 1. FileListPlugin

需求：在打包完成后，生成一个`fileList.md`文件，文件内容为打包生成的所有文件名。

```
# 一共有2个文件

- main.bundle.js
- index.html
```

代码实现

``` js
function FileListPlugin (options) {
  this.options = options || {};
  this.filename = this.options.filename || &#x27;fileList.md&#x27;
}

FileListPlugin.prototype.apply = function (compiler) {
  // 1.通过compiler.hooks.emit.tapAsync()来触发生成资源到output目录之前的钩子，且回调函数会有两个参数，一个是compilation，一个是cb回调函数
  compiler.hooks.emit.tapAsync(&#x27;FileListPlugin&#x27;, (compilation, cb) =&gt; {
    // 2.要生成的markdown文件的名称
    const fileListName = this.filename;
    // 3.通过compilation.assets获取到所有待生成的文件，这里是获取它的长度
    let len = Object.keys(compilation.assets).length;
    // 4.定义markdown文件的内容，也就是先定义一个一级标题，\n表示的是换行符
    let content = `# 一共有${len}个文件\n\n`;
    // 5.将每一项文件的名称写入markdown文件内
    for (let filename in compilation.assets) {
      content += `- ${filename}\n`
    }
    // 6.给我们即将生成的dist文件夹里添加一个新的资源，资源的名称就是fileListName变量
    compilation.assets[fileListName] = {
      // 7.写入资源的内容
      source: function () {
        return content;
      },
      // 8.指定新资源的大小，用于webpack展示
      size: function () {
        return content.length;
      }
    }
    // 9.由于我们使用的是tapAsync异步调用，所以必须执行一个回调函数cb，否则打包后就只会创建一个空的dist文件夹。
    cb();
  })
}
module.exports = FileListPlugin;
module.exports = {
  new FileListPlugin({
    filename: &#x27;fileList.md&#x27;
  })
}
```

#### 2. CompressAssetsPlugin

需求：每次打包完成后，将打包生成的文件生成一个压缩包。

``` js
const JSZip = require(&#x27;jszip&#x27;);
const { RawSource } = require(&#x27;webpack-sources&#x27;);
/*
  将本次打包的资源都打包成为一个压缩包
  需求:获取所有打包后的资源
*/

const pluginName = &#x27;CompressAssetsPlugin&#x27;;

class CompressAssetsPlugin {
  constructor({ output }) {
    this.output = output;
  }

  apply(compiler) {
    // AsyncSeriesHook 将 assets 输出到 output 目录之前调用该钩子
    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) =&gt; {
      // 创建zip对象
      const zip = new JSZip();
      // 获取本次打包生成所有的assets资源
      const assets = compilation.getAssets();
      // 循环每一个资源
      assets.forEach(({ name, source }) =&gt; {
        // 调用source()方法获得对应的源代码 这是一个源代码的字符串
        const sourceCode = source.source();
        // 往 zip 对象中添加资源名称和源代码内容
        zip.file(name, sourceCode);
      });
      // 调用 zip.generateAsync 生成 zip 压缩包
      zip.generateAsync({ type: &#x27;nodebuffer&#x27; }).then((result) =&gt; {
        // 通过 new RawSource 创建压缩包
        // 并且同时通过 compilation.emitAsset 方法将生成的 Zip 压缩包输出到 this.output
        compilation.emitAsset(this.output, new RawSource(result));
        // 调用 callback 表示本次事件函数结束
        callback();
      });
    });
  }
}

module.exports = CompressAssetsPlugin;
```

#### 3. BundleSizeWebpackPlugin

需求：文件超过一定大小时给出警告

``` js
const { resolve } = require(&#x27;path&#x27;)
const fs = require(&#x27;fs&#x27;)

class BundleSizeWebpackPlugin {
  constructor(options) {
    this.options = options
  }
  apply(compiler) {
    const { sizeLimit } = this.options
    console.log(&#x27;bundle size plugin&#x27;)
    // 在编译完成后，执行回调，拿到打包后文件路径，然后读取文件信息获取文件大小，然后定义一些逻辑
    compiler.hooks.done.tap(&#x27;BundleSizePlugin&#x27;, stats =&gt; {
      const { path, filename } = stats.compilation.outputOptions
      const bundlePath = resolve(path, filename)
      const { size } = fs.statSync(bundlePath)
      const bundleSize = size / 1024
      if (bundleSize &lt; sizeLimit) {
        console.log(
          &#x27;safe: bundle-size&#x27;,
          bundleSize,
          &#x27;\n size limit: &#x27;,
          sizeLimit
        )
      } else {
        console.warn(
          &#x27;unsafe: bundle-size&#x27;,
          bundleSize,
          &#x27;\n size limit: &#x27;,
          sizeLimit
        )
      }
    })
  }
}

module.exports = BundleSizeWebpackPlugin
```

### 常用插件

目前，webpack社区已经有很多成熟的插件了，如果非特殊需求，不用自定义插件。下面介绍几个常用的插件。

#### 1. html-webpack-plugin

`html-webpack-plugin`可以在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中。

``` js
const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      filename: &#x27;index.html&#x27;,
      template: path.join(__dirname, &#x27;/index.html&#x27;),
      minify: {
        // 压缩HTML文件
        removeComments: true, // 移除HTML中的注释
        collapseWhitespace: true, // 删除空白符与换行符
        minifyCSS: true, // 压缩内联css
      },
      inject: true,
    }),
  ]
}
```

**inject 有四个选项值**

- `true`：默认值，*script* 标签位于 *html* 文件的 *body* 底部
- `body`：*script* 标签位于 *html* 文件的 *body* 底部（同 *true*）
- `head`：*script* 标签位于 *head* 标签内
- `false`：不插入生成的 *js* 文件，只是单纯的生成一个 *html* 文件

#### 2. clean-webpack-plugin

`clean-webpack-plugin` 用于在打包前清理上一次项目生成的 `bundle` 文件，它会根据 `output.path` 自动清理文件夹。

``` js
const { CleanWebpackPlugin } = require(&#x27;clean-webpack-plugin&#x27;)

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, &#x27;/index.html&#x27;),
    }),
    new CleanWebpackPlugin(), // 所要清理的文件夹名称
  ]
}
```

#### 3. extract-text-webpack-plugin

将css样式从js文件中提取出来最终合成一个css文件，该插件只支持webpack4之前的版本，如果你当前是webpack4及以上版本那么就会报错。

``` js
const extractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: extractTextPlugin.extract({
          fallback: &quot;style-loader&quot;,
          use: &quot;css-loader&quot;
        })
      }
    ]
  },
  plugins: [
    new extractTextPlugin({
      filename: &quot;[name].css&quot;,
      allChunks: true
    })
  ]
}
```

#### 4. mini-css-extract-plugin

该插件与上面的`extract-text-webpack-plugin`的一样，都是将css样式提取出来, 唯一就是用法不同，本插件的webpack4版本之后推荐使用。

``` js
const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          &quot;css-loader&quot;
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: &quot;css/[name].css&quot;,
      chunkFilename: &quot;css/[name].css&quot;
    })
  ]
}
```

#### 5. purifycss-webpack

有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。

``` js
const path = require(&#x27;path&#x27;)
const PurifyCssWebpack = require(&#x27;purifycss-webpack&#x27;) // 引入PurifyCssWebpack插件
const glob = require(&#x27;glob&#x27;) // 引入glob模块,用于扫描全部html文件中所引用的css

module.exports = merge(common, {
  plugins: [
    new PurifyCssWebpack({
      paths: glob.sync(path.join(__dirname, &#x27;src/*.html&#x27;)),
    }),
  ],
})
```

#### 6. optimize-css-assets-webpack-plugin

`optimize-css-assets-webpack-plugin` 用于优化和最小化 css 的插件，它会压缩 css，但是不会像 cssnano 那样移除或合并样式。

``` js
const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;) // 压缩css代码

module.exports = {
  optimization: {
    minimizer: [
      // 压缩css
      new OptimizeCSSAssetsPlugin({})
    ]
  }
}
```

#### 7. DefinePlugin

用于注入全局变量，一般用在环境变量上。无需安装，webpack内置

``` js
const Webpack = require(&quot;webpack&quot;)
module.exports = {
  plugins: [
    new Webpack.DefinePlugin({
      STR: JSON.stringify(&quot;蛙人&quot;),
      &quot;process.env&quot;: JSON.stringify(&quot;dev&quot;),
      name: &quot;蛙人&quot;
    })
  ]
}
```

#### 8. copy-webpack-plugin

`copy-webpack-plugin` 用于在 webpack 中拷贝文件和文件夹，比如我们需要把一些静态文件拷贝到打包目录，这时候就可以使用这个插件。

``` js
const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;)
module.exports = {
  plugins: [
    new CopyWebpackPlugin({
      patterns: [
        {
          from: &#x27;public/js/*.js&#x27;,
          to: path.resolve(__dirname, &#x27;dist&#x27;, &#x27;js&#x27;),
          flatten: true,
        },
      ],
    }),
  ],
}
```

#### 9. imagemin-webpack-plugin

用于压缩图片。

``` js
const ImageminPlugin =  require(&#x27;imagemin-webpack-plugin&#x27;).default
module.exports = {
  plugins: [
    new ImageminPlugin({
        test: /\.(jpe?g|png|gif|svg)$/i
    })
  ]
}
```


来源：https://zhuanlan.zhihu.com/p/661670534" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/frontend/articles/647#webpack-plugin%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6--###-plugin%E6%9C%BA%E5%88%B6%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0--%E5%89%8D%E9%9D%A2%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E7%9F%A5%E9%81%93%E4%BA%86loader%E6%9C%BA%E5%88%B6%E8%AE%A9webpack%E6%8B%A5%E6%9C%89%E4%BA%86%E5%A4%84%E7%90%86%E9%99%A4js%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E4%BB%A5%E5%A4%96%E7%9A%84%E8%83%BD%E5%8A%9B--%E9%82%A3%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%60%E6%89%93%E5%8C%85%E5%89%8D%E8%87%AA%E5%8A%A8%E6%B8%85%E7%90%86%E4%B8%8A%E6%AC%A1%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%60%60%E5%B0%86%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%88%B0%E6%89%93%E5%8C%85%E7%9B%AE%E5%BD%95%E4%B8%AD%60%60%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90html%E6%96%87%E4%BB%B6%60%60%E5%B0%86%E6%89%93%E5%8C%85%E4%BA%A7%E7%89%A9%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%60%60%E5%B0%86%E6%89%93%E5%8C%85%E5%90%8E%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9%E6%8B%86%E5%88%86%60%E7%AD%89%E4%B8%80%E7%B3%BB%E5%88%97%E5%AE%9A%E5%88%B6%E5%8C%96%E5%8A%9F%E8%83%BD%E6%AD%A4%E6%97%B6%E5%B0%B1%E5%BF%85%E9%A1%BB%E5%80%9F%E5%8A%A9webpack%E7%9A%84plugin%E6%9C%BA%E5%88%B6%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%BA%86--%E6%B2%A1%E9%94%99webpack%E7%9A%84plugin%E6%9C%BA%E5%88%B6%E8%AE%A9webpack%E6%9C%89%E4%BA%86%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E8%83%BD%E5%8A%9B--###-plugin%E5%8E%9F%E7%90%86--%E9%82%A3%E5%85%B7%E4%BD%93%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87plugin%E6%9C%BA%E5%88%B6%E5%8E%BB%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%BA%9B%E5%AE%9A%E5%88%B6%E5%8C%96%E5%8A%9F%E8%83%BD%E5%91%A2--%E5%85%B6%E5%AE%9E%E6%98%AFwebpack%E5%9C%A8%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%93%E5%8C%85%E5%BC%80%E5%A7%8B%E5%89%8D%E6%89%93%E5%8C%85%E5%AE%8C%E6%88%90%E5%90%8E%E7%AD%89%E9%98%B6%E6%AE%B5%E4%BC%9A%E8%A7%A6%E5%8F%91%E4%B8%8D%E5%90%8C%E7%9A%84%E9%92%A9%E5%AD%90%E6%88%91%E4%BB%AC%E5%8F%AA%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%84%B6%E5%90%8E%E5%B0%86%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%86%8C%E4%B8%BA%E5%AF%B9%E5%BA%94%E9%92%A9%E5%AD%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%8D%B3%E5%8F%AF--###-webpack%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86--%E6%88%91%E4%BB%AC%E5%9C%A8%E4%BA%86%E8%A7%A3%E8%BF%99%E4%BA%9B%E9%92%A9%E5%AD%90%E4%B9%8B%E5%89%8D%E5%BF%85%E9%A1%BB%E8%A6%81%E7%9F%A5%E9%81%93webpack%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86--%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8C%96%E7%89%88%E7%9A%84webpack%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%E5%BD%93%E6%88%91%E4%BB%AC%E6%89%A7%E8%A1%8C-%60webpack-build%60-%E5%91%BD%E4%BB%A4%E5%90%8Ewebpack%E4%BC%9A%E5%85%88%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%84%B6%E5%90%8E%E6%A0%B9%E6%8D%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%8E%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-%60compiler%60-%E5%AF%B9%E8%B1%A1%E7%84%B6%E5%90%8E%E8%B0%83%E7%94%A8-%60compiler%60-%E5%AF%B9%E8%B1%A1%E7%9A%84-%60run%60-%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA-%60compilation%60-%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C-%60compilation%60-%E4%B8%AD%E7%9A%84-%60build%60-%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A6%E5%8F%91-%60compiler%60-%E5%AF%B9%E8%B1%A1%E7%9A%84-%60done%60-%E9%92%A9%E5%AD%90%E5%AE%8C%E6%88%90%E6%89%93%E5%8C%85--![image](https:/github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82)--%60%60%60-js-/%E7%AC%AC%E4%B8%80%E6%AD%A5%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%BF%99%E9%87%8C%E6%8E%A5%E5%8F%97%E7%9A%84%E6%98%AFwebpack.config.js%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0-function-webpack(webpackoptions)-{---/%E7%AC%AC%E4%BA%8C%E6%AD%A5%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96-%60compiler%60-%E5%AF%B9%E8%B1%A1---const-compiler-=-new-compiler(webpackoptions);---/%E7%AC%AC%E4%B8%89%E6%AD%A5%E6%8C%82%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8F%92%E4%BB%B6--const-{-plugins-}-=-webpackoptions;--for-(let-plugin-of-plugins)-{----plugin.apply(compiler);--}---return-compiler;-}-%60%60%60--%60%60%60-js-/compiler%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%83%E6%98%AF%E6%95%B4%E4%B8%AA%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%A4%A7%E7%AE%A1%E5%AE%B6%E8%80%8C%E4%B8%94%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-class-compiler-{---constructor(webpackoptions)-{----/%E7%9C%81%E7%95%A5---}----/-%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%88%9B%E5%BB%BAcompilation%E5%AF%B9%E8%B1%A1---compile(callback){-----/%E8%99%BD%E7%84%B6webpack%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAcompiler%E4%BD%86%E6%98%AF%E6%AF%8F%E6%AC%A1%E7%BC%96%E8%AF%91%E9%83%BD%E4%BC%9A%E4%BA%A7%E5%87%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84compilation-----/%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E8%80%83%E8%99%91%E5%88%B0watch%E6%A8%A1%E5%BC%8F%E5%AE%83%E4%BC%9A%E5%9C%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E5%85%88%E7%BC%96%E8%AF%91%E4%B8%80%E6%AC%A1%E7%84%B6%E5%90%8E%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96%E5%A6%82%E6%9E%9C%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E4%BC%9A%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91-----/%E6%AF%8F%E6%AC%A1%E7%BC%96%E8%AF%91%E9%83%BD%E4%BC%9A%E4%BA%A7%E5%87%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84compilation%E4%BB%A3%E8%A1%A8%E6%AF%8F%E6%AC%A1%E7%9A%84%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C-----let-compilation-=-new-compilation(this.options);-----compilation.build(callback);-/%E6%89%A7%E8%A1%8Ccompilation%E7%9A%84build%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83---}----/%E7%AC%AC%E5%9B%9B%E6%AD%A5%E6%89%A7%E8%A1%8C%60compiler%60%E5%AF%B9%E8%B1%A1%E7%9A%84%60run%60%E6%96%B9%E6%B3%95%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%BC%96%E8%AF%91---run(callback)-{-----this.hooks.run.call();-/%E5%9C%A8%E7%BC%96%E8%AF%91%E5%89%8D%E8%A7%A6%E5%8F%91run%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E8%A1%A8%E7%A4%BA%E5%BC%80%E5%A7%8B%E5%90%AF%E5%8A%A8%E7%BC%96%E8%AF%91%E4%BA%86-----const-oncompiled-=-()-=%3E-{-------/-%E7%AC%AC%E4%B8%83%E6%AD%A5%E5%BD%93%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E5%90%8E%E4%BC%9A%E8%A7%A6%E5%8F%91done%E8%BF%99%E4%B8%AA%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C-------this.hooks.done.call();-----};-----this.compile(oncompiled);-/%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E%E8%B0%83%E7%94%A8oncompiled---}-}---class-compilation-{---constructor(webpackoptions)-{-----this.options-=-webpackoptions;-----this.modules-=-[];-/%E6%9C%AC%E6%AC%A1%E7%BC%96%E8%AF%91%E6%89%80%E6%9C%89%E7%94%9F%E6%88%90%E5%87%BA%E6%9D%A5%E7%9A%84%E6%A8%A1%E5%9D%97-----this.chunks-=-[];-/%E6%9C%AC%E6%AC%A1%E7%BC%96%E8%AF%91%E4%BA%A7%E5%87%BA%E7%9A%84%E6%89%80%E6%9C%89%E4%BB%A3%E7%A0%81%E5%9D%97%E5%85%A5%E5%8F%A3%E6%A8%A1%E5%9D%97%E5%92%8C%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%B8%BA%E4%BB%A3%E7%A0%81%E5%9D%97-----this.assets-=-{};-/%E6%9C%AC%E6%AC%A1%E7%BC%96%E8%AF%91%E4%BA%A7%E5%87%BA%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6-----this.filedependencies-=-[];-/%E6%9C%AC%E6%AC%A1%E6%89%93%E5%8C%85%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E5%AE%9E%E7%8E%B0watch%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%96%87%E4%BB%B6%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E5%90%8E%E4%BC%9A%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91---}----/%E7%AC%AC%E5%85%AD%E6%AD%A5%E6%89%A7%E8%A1%8Ccompilation%E7%9A%84build%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91---build(callback)-{---/%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E5%81%9A%E7%BC%96%E8%AF%91%E5%B7%A5%E4%BD%9C%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E6%89%A7%E8%A1%8Ccallback----/-...-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%BB%A3%E7%A0%81%E7%9C%81%E7%95%A5----/-%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A6%E5%8F%91callback%E5%9B%9E%E8%B0%83---callback()---}-}-%60%60%60--%3C!---more---%3E--###-compiler-%E4%B8%8E-compilation--%E9%82%A3%E4%B8%8A%E9%9D%A2%E6%8F%90%E5%88%B0%E7%9A%84-%60compiler%60-%E5%AF%B9%E8%B1%A1%E5%92%8C-%60compilation%60-%E5%AF%B9%E8%B1%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%E5%8F%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB----%60compiler%60-%E5%AF%B9%E8%B1%A1%E5%8C%85%E5%90%AB%E4%BA%86webpack%E7%9A%84%E6%89%80%E6%9C%89%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E5%8C%85%E6%8B%AC%60entry%60%60output%60%60module%60%60plugins%60%E7%AD%89%60compiler%60-%E5%AF%B9%E8%B1%A1%E4%BC%9A%E5%9C%A8%E5%90%AF%E5%8A%A8webpack%E6%97%B6%E4%B8%80%E6%AC%A1%E6%80%A7%E5%9C%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%9B%E5%BB%BA%E5%AE%83%E6%98%AF%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E7%9A%84%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%BAwebpack%E7%9A%84%E5%AE%9E%E4%BE%8B---%60compilation%60-%E5%AF%B9%E8%B1%A1%E4%BB%A3%E8%A1%A8%E4%B8%80%E6%AC%A1%E8%B5%84%E6%BA%90%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9A%E8%BF%87%E4%B8%80%E7%B3%BB%E5%88%97api%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE/%E4%BF%AE%E6%94%B9%E6%9C%AC%E6%AC%A1%E6%A8%A1%E5%9D%97%E8%B5%84%E6%BA%90%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E7%9A%84%E8%B5%84%E6%BA%90%E5%8F%98%E5%8C%96%E7%9A%84%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E8%A2%AB%E8%B7%9F%E8%B8%AA%E4%BE%9D%E8%B5%96%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E7%AD%89%E5%BD%93%E6%88%91%E4%BB%AC%E4%BB%A5%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8Cwebpack%E6%97%B6%E6%AF%8F%E5%BD%93%E6%A3%80%E6%B5%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96%E5%B0%B1%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-%60compilation%60-%E5%AF%B9%E8%B1%A1%E6%89%80%E4%BB%A5-%60compilation%60-%E5%AF%B9%E8%B1%A1%E4%B9%9F%E6%98%AF%E4%B8%80%E6%AC%A1%E6%80%A7%E7%9A%84%E5%8F%AA%E8%83%BD%E7%94%A8%E4%BA%8E%E5%BD%93%E5%89%8D%E7%9A%84%E7%BC%96%E8%AF%91--**%E4%BB%96%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7**----%60compilation.modules%60-%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E6%89%80%E6%9C%89%E6%A8%A1%E5%9D%97---%60compilation.chunks%60-%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%9D%97chunk---%60compilation.assets%60-%E6%9C%AC%E6%AC%A1%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6---%60compilation.hooks%60-compilation%E6%89%80%E6%9C%89%E7%9A%84%E9%92%A9%E5%AD%90--%E6%89%80%E4%BB%A5%E8%AF%B4%E5%91%A2%60compiler%60-%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%98%AF%E6%95%B4%E4%B8%AA-webpack-%E4%BB%8E%E5%90%AF%E5%8A%A8%E5%88%B0%E5%85%B3%E9%97%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%88%E7%AB%AF%E7%BB%93%E6%9D%9F%E8%AF%A5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%93%E6%9D%9F-%E8%80%8C-%60compilation%60-%E5%8F%AA%E6%98%AF%E4%BB%A3%E8%A1%A8%E4%BA%86%E4%B8%80%E6%AC%A1%E6%80%A7%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%A6%82%E6%9E%9C%E6%98%AFwatch%E6%A8%A1%E5%BC%8F%E6%AF%8F%E6%AC%A1%E7%9B%91%E5%90%AC%E5%88%B0%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96%E9%83%BD%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-%60compilation%60%E6%89%80%E4%BB%A5-%60compilation%60-%E4%BB%A3%E8%A1%A8%E4%B8%80%E6%AC%A1%E8%B5%84%E6%BA%90%E7%9A%84%E6%9E%84%E5%BB%BA%E4%BC%9A%E5%A4%9A%E6%AC%A1%E8%A2%AB%E5%88%9B%E5%BB%BA%E8%80%8C-%60compiler%60-%E5%8F%AA%E4%BC%9A%E8%A2%AB%E5%88%9B%E5%BB%BA%E4%B8%80%E6%AC%A1--**%E6%88%91%E4%BB%AC%E4%BA%86%E8%A7%A3%E4%BA%86%60compiler%60%E5%92%8C%60compilation%60%E5%AF%B9%E8%B1%A1%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%8B%E5%88%B0%E5%BA%95%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90**--###-compiler%E9%92%A9%E5%AD%90-compiler%E6%9C%89%E5%BE%88%E5%A4%9A%E9%92%A9%E5%AD%90[%E5%AE%98%E6%96%B9%E5%9C%B0%E5%9D%80](https:/webpack.js.org/api/compiler-hooks/#root)[%E4%B8%AD%E6%96%87%E5%9C%B0%E5%9D%80](https:/webpack.docschina.org/api/compiler-hooks/)%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84----%60environment%60-synchook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E7%BC%96%E8%AF%91%E5%99%A8%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83%E6%97%B6%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E5%B0%B1%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8F%92%E4%BB%B6%E4%B9%8B%E5%90%8E---%60afterenvironment%60-synchook%E7%B1%BB%E5%9E%8B%E5%BD%93%E7%BC%96%E8%AF%91%E5%99%A8%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E5%9C%A8-%60environment-hook%60-%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8---%60entryoption%60-syncbailhook%E7%B1%BB%E5%9E%8B%E5%9C%A8-%60webpack%60-%E9%80%89%E9%A1%B9%E4%B8%AD%E7%9A%84-%60entry%60-%E8%A2%AB%E5%A4%84%E7%90%86%E8%BF%87%E4%B9%8B%E5%90%8E%E8%B0%83%E7%94%A8---%60afterplugins%60-synchook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E6%8F%92%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%90%8E---%60afterresolvers%60-synchook%E7%B1%BB%E5%9E%8B%60resolver%60-%E8%AE%BE%E7%BD%AE%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E8%A7%A6%E5%8F%91---%60beforerun%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E6%9E%84%E5%BB%BA%E4%B9%8B%E5%89%8D%E8%B0%83%E7%94%A8%60compiler.run%60-%E6%96%B9%E6%B3%95%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E5%90%8E%E7%AB%8B%E5%88%BB%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8---%60run%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%BC%80%E5%A7%8B%E8%AF%BB%E5%8F%96-%60records%60-%E4%B9%8B%E5%89%8D%E8%B0%83%E7%94%A8---%60watchrun%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E7%9B%91%E5%90%AC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-%60compilation%60-%E8%A7%A6%E5%8F%91%E4%B9%8B%E5%90%8E%E4%BD%86%E5%9C%A8-%60compilation%60-%E5%AE%9E%E9%99%85%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D%E8%A7%A6%E5%8F%91---%60beforecompile%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%88%9B%E5%BB%BA-%60compilation%60-%E5%8F%82%E6%95%B0%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C---%60compile%60-synchook%E7%B1%BB%E5%9E%8B%60beforecompile%60-%E4%B9%8B%E5%90%8E%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E4%BD%86%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-%60compilation%60-%E5%88%9B%E5%BB%BA%E4%B9%8B%E5%89%8D---%60thiscompilation%60-synchook%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%8C%96-%60compilation%60-%E6%97%B6%E8%B0%83%E7%94%A8%E5%9C%A8%E8%A7%A6%E5%8F%91-%60compilation%60-%E4%BA%8B%E4%BB%B6%E4%B9%8B%E5%89%8D%E8%B0%83%E7%94%A8---%60compilation%60-synchook%E7%B1%BB%E5%9E%8B%E4%B8%80%E6%AC%A1%E6%96%B0%E7%9A%84%E7%BC%96%E8%AF%91-%60compilation%60-%E5%88%9B%E5%BB%BA%E4%B9%8B%E5%90%8E%E8%A7%A6%E5%8F%91---%60make%60-asyncparallelhook%E7%B1%BB%E5%9E%8B%60compilation%60-%E7%BB%93%E6%9D%9F%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%60seal%60-%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C---%60aftercompile%60-asyncserieshook%E7%B1%BB%E5%9E%8B%60compilation%60-%E7%BB%93%E6%9D%9F%E5%92%8C%E5%B0%81%E5%8D%B0%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C---%60shouldemit%60-syncbailhook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E8%BE%93%E5%87%BA-%60asset%60-%E4%B9%8B%E5%89%8D%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%B8%83%E5%B0%94%E5%80%BC%E5%91%8A%E7%9F%A5%E6%98%AF%E5%90%A6%E8%BE%93%E5%87%BA---%60emit%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E7%94%9F%E6%88%90%E8%B5%84%E6%BA%90%E5%88%B0-%60output%60-%E7%9B%AE%E5%BD%95%E4%B9%8B%E5%89%8D%E8%A7%A6%E5%8F%91---%60afteremit%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E8%BE%93%E5%87%BA-%60asset%60-%E5%88%B0-%60output%60-%E7%9B%AE%E5%BD%95%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C---%60done%60-asyncserieshook%E7%B1%BB%E5%9E%8B%60compilation%60-%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A6%E5%8F%91---%60failed%60-synchook%E7%B1%BB%E5%9E%8B%60compilation%60-%E7%BC%96%E8%AF%91%E5%A4%B1%E8%B4%A5%E5%90%8E%E8%A7%A6%E5%8F%91--###-compilation%E9%92%A9%E5%AD%90--compilation%E5%AF%B9%E8%B1%A1%E4%B9%9F%E6%9C%89%E5%BE%88%E5%A4%9A%E9%92%A9%E5%AD%90[%E5%AE%98%E6%96%B9%E5%9C%B0%E5%9D%80](https:/webpack.js.org/api/compilation-hooks/#root)[%E4%B8%AD%E6%96%87%E5%9C%B0%E5%9D%80](https:/webpack.docschina.org/api/compilation-hooks/)%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84----%60buildmodule%60-synchook%E7%B1%BB%E5%9E%8B%E6%A8%A1%E5%9D%97%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E5%89%8D%E6%89%A7%E8%A1%8C%E8%AF%A5%E9%92%A9%E5%AD%90%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E4%BF%AE%E6%94%B9%E6%A8%A1%E5%9D%97%E5%86%85%E5%AE%B9---%60succeedmodule%60-synchook%E7%B1%BB%E5%9E%8B%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E5%90%8E%E6%89%A7%E8%A1%8C%E8%AF%A5%E9%92%A9%E5%AD%90---%60finishmodules%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E6%89%80%E6%9C%89%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%A7%E8%A1%8C%E8%AF%A5%E9%92%A9%E5%AD%90---%60moduleasset%60-synchook%E7%B1%BB%E5%9E%8B%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA-asset-%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0-compilation-%E6%97%B6%E8%B0%83%E7%94%A8---%60chunkasset%60-synchook%E7%B1%BB%E5%9E%8B%E4%B8%80%E4%B8%AA-chunk-%E4%B8%AD%E7%9A%84-asset-%E8%A2%AB%E6%B7%BB%E5%8A%A0%E5%88%B0-compilation-%E6%97%B6%E8%B0%83%E7%94%A8---%60seal%60-synchook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%B0%81%E5%AD%98%E5%89%8D%E8%A7%A6%E5%8F%91%E5%85%81%E8%AE%B8%E5%9C%A8%E6%9C%80%E7%BB%88%E8%B5%84%E6%BA%90%E7%94%9F%E6%88%90%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C---%60optimize%60-synchook%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96%E9%98%B6%E6%AE%B5%E5%BC%80%E5%A7%8B%E6%97%B6%E8%A7%A6%E5%8F%91%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E9%80%BB%E8%BE%91---%60optimizeassets%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96%E5%AD%98%E5%82%A8%E5%9C%A8-compilation.assets-%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89-asset%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%92%8C%E4%BF%AE%E6%94%B9%E8%B5%84%E6%BA%90%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B---%60afteroptimizeassets%60-synchook%E7%B1%BB%E5%9E%8Basset-%E5%B7%B2%E7%BB%8F%E4%BC%98%E5%8C%96---%60optimizetree%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E4%BC%98%E5%8C%96%E4%BE%9D%E8%B5%96%E6%A0%91%E4%B9%8B%E5%89%8D%E8%A7%A6%E5%8F%91%E5%85%81%E8%AE%B8%E4%BF%AE%E6%94%B9%E8%B5%84%E6%BA%90%E6%A0%91%E7%9A%84%E4%BC%98%E5%8C%96%E9%80%BB%E8%BE%91---%60afteroptimizetree%60-synchook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E4%BC%98%E5%8C%96%E4%BE%9D%E8%B5%96%E6%A0%91%E4%B9%8B%E5%90%8E%E8%A7%A6%E5%8F%91%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84%E8%B5%84%E6%BA%90%E6%A0%91---%60optimizechunkassets%60-asyncserieshook%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96%E6%89%80%E6%9C%89-chunk-asset%E5%BC%83%E7%94%A8%E5%8F%AF%E4%BD%BF%E7%94%A8-processassets-%E6%9D%A5%E4%BB%A3%E6%9B%BF%E5%8F%AF%E7%94%A8%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9D%97%E8%B5%84%E6%BA%90%E7%9A%84%E4%BC%98%E5%8C%96%E9%80%BB%E8%BE%91---%60processassets%60-asyncserieshook%E7%B1%BB%E5%9E%8Basset-%E5%A4%84%E7%90%86%E6%97%B6%E8%A7%A6%E5%8F%91%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%92%8C%E4%BF%AE%E6%94%B9%E8%B5%84%E6%BA%90%E7%9A%84%E7%94%9F%E6%88%90---%60beforehash%60-synchook%E7%B1%BB%E5%9E%8B%E5%9C%A8-compilation-%E6%B7%BB%E5%8A%A0%E5%93%88%E5%B8%8Chash%E4%B9%8B%E5%89%8D---%60afterhash%60-synchook%E7%B1%BB%E5%9E%8B%E5%9C%A8-compilation-%E6%B7%BB%E5%8A%A0%E5%93%88%E5%B8%8Chash%E4%B9%8B%E5%90%8E---%60beforemoduleassets%60-synchook%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97-asset-%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%9C%A8%E6%A8%A1%E5%9D%97%E8%B5%84%E6%BA%90%E7%94%9F%E6%88%90%E5%89%8D%E6%89%A7%E8%A1%8C%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C--%E6%AF%8F%E4%B8%AA%E9%92%A9%E5%AD%90%E9%83%BD%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%82%A3%E8%BF%99%E4%BA%9B%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2--##-tapable--[tapable](https:/github.com/webpack/tapable)%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8F%90%E4%BE%9B**%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85**%E7%9A%84%E5%B7%A5%E5%85%B7%E9%80%9A%E8%BF%87%E5%85%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%92%A9%E5%AD%90%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E7%84%B6%E5%90%8E%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E9%98%B6%E6%AE%B5%E5%8E%BB%E8%A7%A6%E5%8F%91%E8%BF%99%E4%BA%9B%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6-webpack%E7%9A%84plugin%E6%9C%BA%E5%88%B6%E6%AD%A3%E6%98%AF%E5%9F%BA%E4%BA%8E-tapable-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E8%A7%A6%E5%8F%91%E4%B8%8D%E5%90%8C%E7%9A%84%E9%92%A9%E5%AD%90--tapable-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%8F%90%E4%BE%9B%E4%BA%86%E8%BF%99%E4%B9%9D%E7%A7%8D%E9%92%A9%E5%AD%90%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E4%B8%8A%E9%9D%A2%E6%8F%90%E5%88%B0%E7%9A%84%E9%92%A9%E5%AD%90%E7%B1%BB%E5%9E%8B--%60%60%60-js-const-{---synchook,---syncbailhook,---syncwaterfallhook,---syncloophook,---asyncparallelhook,---asyncparallelbailhook,---asyncserieshook,---asyncseriesbailhook,---asyncserieswaterfallhook-}-=-require(%22tapable%22);-%60%60%60--%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%BF%99%E4%BA%9B%E9%92%A9%E5%AD%90%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BC%80%E5%A4%B4%E5%88%86%E5%88%AB%E6%98%AF-%60sync%60-%E5%92%8C-%60async%60-%E8%BF%99%E4%B8%A4%E7%A7%8D%E9%92%A9%E5%AD%90%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF-%60sync%60-%E5%BC%80%E5%A4%B4%E7%9A%84%E4%B8%BA%E5%90%8C%E6%AD%A5%E9%92%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E5%90%8C%E6%AD%A5%E8%BF%9B%E8%A1%8C%E6%89%A7%E8%A1%8C%60async%60-%E5%BC%80%E5%A4%B4%E7%9A%84%E4%B8%BA%E5%BC%82%E6%AD%A5%E9%92%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E5%BC%82%E6%AD%A5%E8%BF%9B%E8%A1%8C%E6%89%A7%E8%A1%8C--%E5%90%8C%E6%97%B6%E5%91%A2%E8%BF%99%E4%BA%9B%E9%92%A9%E5%AD%90%E8%BF%98%E6%9C%89%E4%B8%89%E7%A7%8D%E7%BB%93%E5%B0%BE%E5%88%86%E5%88%AB%E6%98%AF%60hook%60%60bailhook%60%60waterfallhook%60%60loophook%60--%E8%BF%99%E4%B8%89%E7%A7%8D%E7%BB%93%E5%B0%BE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA----%60hook%60%E7%BB%93%E5%B0%BE%E7%9A%84%E4%B8%BA%E6%99%AE%E9%80%9A%E9%92%A9%E5%AD%90%E5%8F%AA%E4%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%8C%A8%E4%B8%AA%E6%89%A7%E8%A1%8C%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%B8%8D%E4%BC%9A%E5%8E%BB%E7%AE%A1%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88--![image](https:/github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab)----%60bailhook%60%E7%BB%93%E5%B0%BE%E7%9A%84%E4%B8%BA%E4%BF%9D%E9%99%A9%E9%92%A9%E5%AD%90%E5%8F%AA%E8%A6%81%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8D%E4%B8%BA%60undefined%60%E5%B0%B1%E4%BC%9A%E5%81%9C%E6%AD%A2%E6%89%A7%E8%A1%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0--![image](https:/github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5)----%60waterfallhook%60%E7%BB%93%E5%B0%BE%E7%9A%84%E4%B8%BA%E7%80%91%E5%B8%83%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%9A%E4%BD%9C%E4%B8%BA%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AA%E4%BC%9A%E5%BD%B1%E5%93%8D%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0--![image](https:/github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143)----%60loophook%60%E7%BB%93%E5%B0%BE%E7%9A%84%E4%B8%BA%E5%BE%AA%E7%8E%AF%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8F%AA%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E9%9D%9E%60undefined%60%E5%B0%B1%E4%BC%9A%E7%AB%8B%E5%8D%B3%E9%87%8D%E5%A4%B4%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%9B%B4%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E9%83%BD%E8%BF%94%E5%9B%9E%60undefined%60%E8%BF%99%E4%B8%AA%E9%92%A9%E5%AD%90%E6%89%8D%E4%BC%9A%E7%BB%93%E6%9D%9F--![image](https:/github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7)--%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E5%8F%88%E5%8F%91%E7%8E%B0%E5%BC%82%E6%AD%A5%E9%92%A9%E5%AD%90%E5%8F%88%E6%98%AF%E4%BB%A5%60asyncparallel%60%60asyncseries%60%E5%BC%80%E5%A4%B4%E8%BF%99%E5%8F%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2----%60asyncseries%60-%E4%B8%BA%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%8C%A8%E4%B8%AA%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%90%8E%E4%BC%9A%E8%B0%83%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%84%B6%E5%90%8E%E5%86%8D%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0---%60asyncparallel%60-%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E4%B8%8D%E4%BC%9A%E7%AD%89%E5%BE%85%E4%B8%8A%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E5%86%8D%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0--%E4%B8%8B%E9%9D%A2%E6%88%91%E4%BB%AC%E5%B0%B1%E6%9D%A5%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%BF%99%E4%BA%9B%E9%92%A9%E5%AD%90%E5%A6%82%E4%BD%95%E5%8E%BB%E4%BD%BF%E7%94%A8--###-tapable%E5%90%8C%E6%AD%A5%E9%92%A9%E5%AD%90--%E5%90%8C%E6%AD%A5%E9%92%A9%E5%AD%90%E5%8F%AA%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8-%60tap%60-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E7%84%B6%E5%90%8E%E8%B0%83%E7%94%A8-%60call%60-%E6%96%B9%E6%B3%95%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%8D%B3%E5%8F%AF--####-1.-synchook--synchook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84%E6%99%AE%E9%80%9A%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%8C%A8%E4%B8%AA%E6%89%A7%E8%A1%8C%E4%B8%8D%E4%BC%9A%E5%8E%BB%E7%AE%A1%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88--%60%60%60-js-const-{-synchook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-synchook([&#x27;name&#x27;,-&#x27;age&#x27;]);--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tap(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-(name,-age)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tap(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-(name,-age)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82-hook.call(&#x27;%E5%89%8D%E7%AB%AF&#x27;,-18);--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-%60%60%60--####-2.-syncbailhook--syncbailhook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BF%9D%E9%99%A9%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E6%84%8F%E6%80%9D%E6%98%AF%E5%8F%AA%E8%A6%81%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%9C%89%E8%BF%94%E5%9B%9E%E4%BA%86%E5%90%8E%E9%9D%A2%E7%9A%84%E5%B0%B1%E4%B8%8D%E6%89%A7%E8%A1%8C%E4%BA%86--%60%60%60-js-const-{-syncbailhook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-syncbailhook([&#x27;name&#x27;,-&#x27;age&#x27;]);--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tap(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-(name,-age)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tap(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-(name,-age)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);---return-&#x27;abc&#x27;-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B63-hook.tap(&#x27;%E4%BA%8B%E4%BB%B63&#x27;,-(name,-age)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82-hook.call(&#x27;%E5%89%8D%E7%AB%AF&#x27;,-18);--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-%60%60%60--####-3.-syncwaterfallhook--syncwaterfallhook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84%E7%80%91%E5%B8%83%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%9A%E4%BD%9C%E4%B8%BA%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%9A%84%E5%8F%82%E6%95%B0,%E5%8F%AA%E4%BC%9A%E5%BD%B1%E5%93%8D%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0--%60%60%60-js-const-{-syncwaterfallhook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-syncwaterfallhook([&#x27;name&#x27;,-&#x27;age&#x27;]);--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tap(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-(name,-age)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);---return-&#x27;%E9%A9%BF%E7%AB%99&#x27;-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tap(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-(name,-age)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B63-hook.tap(&#x27;%E4%BA%8B%E4%BB%B63&#x27;,-(name,-age)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82-hook.call(&#x27;%E5%89%8D%E7%AB%AF&#x27;,-18);--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:-%E9%A9%BF%E7%AB%99-18-/-%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:-%E9%A9%BF%E7%AB%99-18-%60%60%60--####-4.-syncloophook--syncloophook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E5%8F%AA%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%9D%9Eundefeind%E5%B0%B1%E4%BC%9A%E7%AB%8B%E5%8D%B3%E9%87%8D%E5%A4%B4%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%9B%B4%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E9%83%BD%E8%BF%94%E5%9B%9Eundefined%E8%BF%99%E4%B8%AA%E9%92%A9%E5%AD%90%E6%89%8D%E4%BC%9A%E7%BB%93%E6%9D%9F--%60%60%60-js-const-{-syncloophook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-syncloophook();--let-count-=-5;--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tap(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-()-=%3E-{---count--;---console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C,count%E4%B8%BA&#x27;,count);---if-(count-%3E-3)-{-----return-true;---}-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tap(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-()-=%3E-{---count--;---console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C,count%E4%B8%BA&#x27;,count);---if-(count-%3E-1)-{-----return-true;---}-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B63-hook.tap(&#x27;%E4%BA%8B%E4%BB%B63&#x27;,-()-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C,count%E4%B8%BA&#x27;,count);-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6-hook.call();--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C,count%E4%B8%BA-4-/-%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C,count%E4%B8%BA-3-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C,count%E4%B8%BA-2-/-%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C,count%E4%B8%BA-1-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C,count%E4%B8%BA-0-/-%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C,count%E4%B8%BA-0-%60%60%60--###-tapable%E5%BC%82%E6%AD%A5%E9%92%A9%E5%AD%90--%E5%BC%82%E6%AD%A5%E9%92%A9%E5%AD%90%E6%8F%90%E4%BE%9B%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%86%8C%E7%9A%84%E6%96%B9%E6%B3%95----%60tap%60%E4%BB%A5%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%92%A9%E5%AD%90%E7%94%A8-%60call%60-%E6%9D%A5%E8%A7%A6%E5%8F%91%E8%B7%9F%E5%90%8C%E6%AD%A5%E9%92%A9%E5%AD%90%E4%B8%80%E6%A0%B7%E5%8F%AA%E4%B8%8D%E8%BF%87%E5%8A%A0%E6%8C%81%E4%BA%86%E5%BC%82%E6%AD%A5%E7%9A%84%E8%83%BD%E5%8A%9B%E4%B8%8D%E8%BF%87%E5%A4%9A%E8%AE%B2%E8%A7%A3---%60tapasync%60:-%E4%BB%A5%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%92%A9%E5%AD%90%E7%94%A8-%60callasync%60-%E8%A7%A6%E5%8F%91%E5%90%8C%E6%97%B6%E4%B9%9F%E4%BC%9A%E5%A4%9A%E4%B8%80%E4%B8%AAcallback%E5%8F%82%E6%95%B0%E6%89%A7%E8%A1%8Ccallback%E5%91%8A%E8%AF%89hook%E8%AF%A5%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E5%B7%B2%E7%BB%8F%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%E4%B8%8B%E9%9D%A2%E6%9C%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B---%60tappromise%60:-%E4%BB%A5%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%86%8C%E9%92%A9%E5%AD%90%E7%94%A8-%60promise%60-%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A6%E5%8F%91,%E4%B8%8B%E9%9D%A2%E6%9C%89%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B--####-1.-asyncparallelhook--asyncparallelhook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E4%B8%8D%E4%BC%9A%E7%AD%89%E5%BE%85%E4%B8%8A%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E5%86%8D%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0--%60%60%60-js-const-{-asyncparallelhook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-asyncparallelhook([&#x27;name&#x27;,-&#x27;age&#x27;]);--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-----callback();---},-2000);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-(name,-age,-callback)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);---/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95---callback();-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B63-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B63&#x27;,-(name,-age,-callback)-=%3E-{---console.log(&#x27;%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);---/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95---callback();-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82-hook.callasync(&#x27;%E5%89%8D%E7%AB%AF&#x27;,-18,-()-=%3E-{---/-%E8%AF%A5%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E4%BC%9A%E6%89%A7%E8%A1%8C%E8%AF%A5%E5%9B%9E%E8%B0%83---console.log(&#x27;%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95&#x27;);-});--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-2%E7%A7%92%E5%90%8E%E8%BE%93%E5%87%BA%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-%60%60%60--####-2.-asyncparallelbailhook--asyncparallelbailhook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%BF%9D%E9%99%A9%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E5%8F%AA%E8%A6%81%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%9C%89%E8%BF%94%E5%9B%9E%E4%BA%86%E5%90%8E%E9%9D%A2%E7%9A%84%E5%B0%B1%E4%B8%8D%E6%89%A7%E8%A1%8C%E4%BA%86--%60%60%60-js-const-{-asyncparallelbailhook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-asyncparallelbailhook([&#x27;name&#x27;,-&#x27;age&#x27;]);--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tappromise(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-(name,-age)-=%3E-{---return-new-promise((resolve)-=%3E-{-----settimeout(()-=%3E-{-------console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-------resolve(&#x27;123&#x27;);-----},-2000);---})-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tappromise(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-(name,-age)-=%3E-{---return-new-promise((resolve)-=%3E-{-----settimeout(()-=%3E-{-------console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-------resolve();-----},-3000);---})-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B63-hook.tappromise(&#x27;%E4%BA%8B%E4%BB%B63&#x27;,-(name,-age,-callback)-=%3E-{---return-new-promise((resolve)-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----resolve();---})-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82-hook.promise(&#x27;%E5%89%8D%E7%AB%AF&#x27;,-18).then((res)-=%3E-{---/-%E8%AF%A5%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%E4%BC%9A%E6%89%A7%E8%A1%8C%E8%AF%A5%E5%9B%9E%E8%B0%83---console.log(&#x27;%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95&#x27;,res);-})--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-2%E7%A7%92%E5%90%8E%E8%BE%93%E5%87%BA%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95123-%60%60%60--####-3.-asyncserieshook--asyncserieshook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%9A%84%E4%B8%B2%E8%A1%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E6%B3%A8%E5%86%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E4%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%8C%A8%E4%B8%AA%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%90%8E%E4%BC%9A%E8%B0%83%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%84%B6%E5%90%8E%E5%86%8D%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0--%60%60%60-js-const-{-asyncserieshook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-asyncserieshook([&#x27;name&#x27;,-&#x27;age&#x27;]);--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-----callback(null,-&#x27;123&#x27;);---},-4000);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-----callback();---},-3000);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B63-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B63&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-----callback();---},-2000);-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82-hook.callasync(&#x27;%E5%89%8D%E7%AB%AF&#x27;,-18,-(err,-result)-=%3E-{---/-%E6%9C%80%E5%90%8E%E7%BB%93%E6%9D%9F%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%B0%83%E7%94%A8%E7%9A%84callback%E4%BC%9A%E4%BC%A0%E5%85%A5%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC---console.log(&#x27;%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95&#x27;,result);-});--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95123-%60%60%60--####-4.-asyncseriesbailhook--asyncseriesbailhook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%9A%84%E4%B8%B2%E8%A1%8C%E7%9A%84%E4%BF%9D%E9%99%A9%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E5%8F%AA%E8%A6%81%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%9C%89%E8%BF%94%E5%9B%9E%E4%BA%86%E5%90%8E%E9%9D%A2%E7%9A%84%E5%B0%B1%E4%B8%8D%E6%89%A7%E8%A1%8C%E4%BA%86--%60%60%60-js-const-{-asyncseriesbailhook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-asyncseriesbailhook([&#x27;name&#x27;,-&#x27;age&#x27;]);--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-----callback();---},-4000);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----callback(null,-%2288717%22);---},-3000);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B63-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B63&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-----callback();---},-2000);-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82-hook.callasync(&#x27;%E5%89%8D%E7%AB%AF&#x27;,-18,-(err,-result)-=%3E-{---/-%E6%9C%80%E5%90%8E%E7%BB%93%E6%9D%9F%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%B0%83%E7%94%A8%E7%9A%84callback%E4%BC%9A%E4%BC%A0%E5%85%A5%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC---console.log(&#x27;%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95&#x27;,result);-});--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%9588717-%60%60%60--####-5.-asyncserieswaterfallhook--asyncserieswaterfallhook-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%9A%84%E4%B8%B2%E8%A1%8C%E7%9A%84%E7%80%91%E5%B8%83%E7%B1%BB%E5%9E%8B%E7%9A%84-hook%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%9A%E4%BD%9C%E4%B8%BA%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%9A%84%E5%8F%82%E6%95%B0,%E5%8F%AA%E4%BC%9A%E5%BD%B1%E5%93%8D%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0--%60%60%60-js-const-{-asyncserieswaterfallhook-}-=-require(&#x27;tapable&#x27;);--/-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%92%A9%E5%AD%90%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%8F%82-const-hook-=-new-asyncserieswaterfallhook([&#x27;name&#x27;,-&#x27;age&#x27;]);--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B61-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B61&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-----callback(null,3);---},-4000);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B62-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B62&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----callback(null,-2);---},-3000);-});--/-%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B63-hook.tapasync(&#x27;%E4%BA%8B%E4%BB%B63&#x27;,-(name,-age,-callback)-=%3E-{---settimeout(()-=%3E-{-----console.log(&#x27;%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:&#x27;,-name,-age);-----/-%E8%B0%83%E7%94%A8callback%E8%A1%A8%E7%A4%BA%E8%AF%A5%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-----callback(null,-1);---},-2000);-});--/-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82-hook.callasync(&#x27;%E5%89%8D%E7%AB%AF&#x27;,-18,-(err,-result)-=%3E-{---/-%E6%9C%80%E5%90%8E%E7%BB%93%E6%9D%9F%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%B0%83%E7%94%A8%E7%9A%84callback%E4%BC%9A%E4%BC%A0%E5%85%A5%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC---console.log(&#x27;%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95&#x27;,result);-});--/-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-/-%E4%BA%8B%E4%BB%B63%E6%89%A7%E8%A1%8C:-%E5%89%8D%E7%AB%AF-18-/-%E4%BA%8B%E4%BB%B62%E6%89%A7%E8%A1%8C:-1-18-/-%E4%BA%8B%E4%BB%B61%E6%89%A7%E8%A1%8C:-2-18-/-%E8%AF%A5%E9%92%A9%E5%AD%90%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%953-%60%60%60--###-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89plugin--%E4%BA%86%E8%A7%A3tapable%E4%B9%8B%E5%90%8E%E6%88%91%E4%BB%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89plugin%E4%BA%86--webpack-%E6%8F%92%E4%BB%B6%E7%94%B1%E4%BB%A5%E4%B8%8B%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90----%E4%B8%80%E4%B8%AA-%60javascript%60-%E7%B1%BB-%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA-%60options%60-%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0---%E4%B8%80%E4%B8%AA-%60apply%60-%E6%96%B9%E6%B3%95%E8%AF%A5%E6%96%B9%E6%B3%95%E5%9C%A8-%60webpack%60-%E8%A3%85%E8%BD%BD%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8%E5%B9%B6%E4%B8%94%E4%BC%9A%E4%BC%A0%E5%85%A5-%60compiler%60-%E5%AF%B9%E8%B1%A1-%E6%A0%B9%E6%8D%AE%E6%88%91%E4%BB%AC%E7%9A%84%E9%9C%80%E6%B1%82%E7%A1%AE%E5%AE%9A%E8%A6%81%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%8C%82%E8%BD%BD%E5%88%B0%E5%93%AA%E4%B8%AA%E9%92%A9%E5%AD%90%E4%B8%8A%E6%A0%B9%E6%8D%AE%E9%92%A9%E5%AD%90%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%90%8C%E6%AD%A5/%E5%BC%82%E6%AD%A5%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F%E5%B0%86%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%86%8C%E4%B8%BA%E4%BA%8B%E4%BB%B6--%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E4%B8%AD%E5%85%B7%E4%BD%93%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E9%92%A9%E5%AD%90%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8E%BB%E5%AE%98%E7%BD%91%E6%9F%A5%E7%9C%8B[%E5%AE%98%E6%96%B9%E5%9C%B0%E5%9D%80](https:/webpack.js.org/api/compiler-hooks/#root)[%E4%B8%AD%E6%96%87%E5%9C%B0%E5%9D%80](https:/webpack.docschina.org/api/compiler-hooks/)%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E4%B8%80%E4%B8%80%E5%88%97%E4%B8%BE%E4%BA%86--%3E-%E6%B3%A8%E6%84%8F--webpack4-%E5%8F%AF%E4%BB%A5%E7%94%A8-plugin%E6%96%B9%E6%B3%95%E6%9D%A5%E6%B3%A8%E5%86%8C%E6%8F%92%E4%BB%B6webpack5%E4%B9%8B%E5%90%8E%E8%A2%AB%E5%8F%96%E6%B6%88%E4%BA%86-%3E-compiler.plugin(&#x27;emit&#x27;,-function-(compilation,-cb)-{})--%60%60%60-js-class-basicplugin{---/-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%BB%99%E8%AF%A5%E6%8F%92%E4%BB%B6%E4%BC%A0%E5%85%A5%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9---constructor(options){-----this.options-=-options;---}----/-webpack-%E4%BC%9A%E8%B0%83%E7%94%A8-basicplugin-%E5%AE%9E%E4%BE%8B%E7%9A%84-apply-%E6%96%B9%E6%B3%95%E7%BB%99%E6%8F%92%E4%BB%B6%E5%AE%9E%E4%BE%8B%E4%BC%A0%E5%85%A5-compiler-%E5%AF%B9%E8%B1%A1---apply(compiler)-{-----/-%E6%B3%A8%E5%86%8C%E7%AC%AC1%E4%B8%AA%E4%BA%8B%E4%BB%B6,-%E8%BF%99%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%90%8D%E5%8F%AB%E4%BB%80%E4%B9%88%E9%83%BD%E6%97%A0%E6%89%80%E8%B0%93%E5%8F%AA%E6%98%AF%E4%B8%AA%E6%A0%87%E7%A4%BA%E8%80%8C%E5%B7%B2-----compiler.hooks.run.tapasync(&#x27;basicplugin&#x27;,-(compiler,-callback)-=%3E-{-------console.log(&#x27;%E4%BB%A5%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F%E8%A7%A6%E5%8F%8A-run-%E9%92%A9%E5%AD%90&#x27;)-------callback()-----})------/-%E6%B3%A8%E5%86%8C%E7%AC%AC2%E4%B8%AA%E4%BA%8B%E4%BB%B6-----/-%E5%9C%A8compiler%E7%9A%84compilation%E9%92%A9%E5%AD%90%E4%B8%8A%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6basicplugin-----compiler.hooks.compilation.tap(&#x27;basicplugin&#x27;,-(compilation)-=%3E-{-------/-%E6%B5%8B%E8%AF%95compilation%E5%AF%B9%E8%B1%A1%E5%9C%A8%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E4%B9%8B%E5%89%8D%E8%83%BD%E5%BE%97%E5%88%B0%E4%BB%80%E4%B9%88-------compilation.hooks.buildmodule.tap(&#x27;basicplugin&#x27;,-(data)-=%3E-{-----------console.log(data);-------})-----})------/-%E6%B3%A8%E5%86%8C%E7%AC%AC3%E4%B8%AA%E4%BA%8B%E4%BB%B6-----compiler.hooks.emit.tap(&#x27;basicplugin&#x27;,-(compilation)-=%3E-{-------/-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81-----});---}-}--module.exports-=-basicplugin;-%60%60%60--%60%60%60-js-/-webpack.config.js-const-path-=-require(&#x27;path&#x27;);-const-basicplugin-=-require(&#x27;./basicplugin&#x27;);--module.exports-=-{---entry:-&#x27;./src/index.js&#x27;,---output:-{-----filename:-&#x27;[name].bundle.js&#x27;,-----path:-path.resolve(__dirname,-&#x27;dist&#x27;)---},---plugins:-[-----new-basicplugin(),---]-}-%60%60%60---###-%E8%87%AA%E5%AE%9A%E4%B9%89plugin%E5%AE%9E%E6%88%98--%E4%B8%BA%E4%BA%86%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%AE%9E%E8%B7%B5%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%8F%90%E4%BE%9B3%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E6%9D%A5%E5%8F%82%E8%80%83--####-1.-filelistplugin--%E9%9C%80%E6%B1%82%E5%9C%A8%E6%89%93%E5%8C%85%E5%AE%8C%E6%88%90%E5%90%8E%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%60filelist.md%60%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E4%B8%BA%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D--%60%60%60-#-%E4%B8%80%E5%85%B1%E6%9C%892%E4%B8%AA%E6%96%87%E4%BB%B6----main.bundle.js---index.html-%60%60%60--%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0--%60%60%60-js-function-filelistplugin-(options)-{---this.options-=-options-||-{};---this.filename-=-this.options.filename-||-&#x27;filelist.md&#x27;-}--filelistplugin.prototype.apply-=-function-(compiler)-{---/-1.%E9%80%9A%E8%BF%87compiler.hooks.emit.tapasync()%E6%9D%A5%E8%A7%A6%E5%8F%91%E7%94%9F%E6%88%90%E8%B5%84%E6%BA%90%E5%88%B0output%E7%9B%AE%E5%BD%95%E4%B9%8B%E5%89%8D%E7%9A%84%E9%92%A9%E5%AD%90%E4%B8%94%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%80%E4%B8%AA%E6%98%AFcompilation%E4%B8%80%E4%B8%AA%E6%98%AFcb%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0---compiler.hooks.emit.tapasync(&#x27;filelistplugin&#x27;,-(compilation,-cb)-=%3E-{-----/-2.%E8%A6%81%E7%94%9F%E6%88%90%E7%9A%84markdown%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8D%E7%A7%B0-----const-filelistname-=-this.filename;-----/-3.%E9%80%9A%E8%BF%87compilation.assets%E8%8E%B7%E5%8F%96%E5%88%B0%E6%89%80%E6%9C%89%E5%BE%85%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%99%E9%87%8C%E6%98%AF%E8%8E%B7%E5%8F%96%E5%AE%83%E7%9A%84%E9%95%BF%E5%BA%A6-----let-len-=-object.keys(compilation.assets).length;-----/-4.%E5%AE%9A%E4%B9%89markdown%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%85%88%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98/n%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%98%AF%E6%8D%A2%E8%A1%8C%E7%AC%A6-----let-content-=-%60#-%E4%B8%80%E5%85%B1%E6%9C%89${len}%E4%B8%AA%E6%96%87%E4%BB%B6/n/n%60;-----/-5.%E5%B0%86%E6%AF%8F%E4%B8%80%E9%A1%B9%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8D%E7%A7%B0%E5%86%99%E5%85%A5markdown%E6%96%87%E4%BB%B6%E5%86%85-----for-(let-filename-in-compilation.assets)-{-------content-+=-%60--${filename}/n%60-----}-----/-6.%E7%BB%99%E6%88%91%E4%BB%AC%E5%8D%B3%E5%B0%86%E7%94%9F%E6%88%90%E7%9A%84dist%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%B5%84%E6%BA%90%E8%B5%84%E6%BA%90%E7%9A%84%E5%90%8D%E7%A7%B0%E5%B0%B1%E6%98%AFfilelistname%E5%8F%98%E9%87%8F-----compilation.assets[filelistname]-=-{-------/-7.%E5%86%99%E5%85%A5%E8%B5%84%E6%BA%90%E7%9A%84%E5%86%85%E5%AE%B9-------source:-function-()-{---------return-content;-------},-------/-8.%E6%8C%87%E5%AE%9A%E6%96%B0%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%94%A8%E4%BA%8Ewebpack%E5%B1%95%E7%A4%BA-------size:-function-()-{---------return-content.length;-------}-----}-----/-9.%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFtapasync%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%89%80%E4%BB%A5%E5%BF%85%E9%A1%BB%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0cb%E5%90%A6%E5%88%99%E6%89%93%E5%8C%85%E5%90%8E%E5%B0%B1%E5%8F%AA%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84dist%E6%96%87%E4%BB%B6%E5%A4%B9-----cb();---})-}-module.exports-=-filelistplugin;-module.exports-=-{---new-filelistplugin({-----filename:-&#x27;filelist.md&#x27;---})-}-%60%60%60--####-2.-compressassetsplugin--%E9%9C%80%E6%B1%82%E6%AF%8F%E6%AC%A1%E6%89%93%E5%8C%85%E5%AE%8C%E6%88%90%E5%90%8E%E5%B0%86%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%8E%8B%E7%BC%A9%E5%8C%85--%60%60%60-js-const-jszip-=-require(&#x27;jszip&#x27;);-const-{-rawsource-}-=-require(&#x27;webpack-sources&#x27;);-/*---%E5%B0%86%E6%9C%AC%E6%AC%A1%E6%89%93%E5%8C%85%E7%9A%84%E8%B5%84%E6%BA%90%E9%83%BD%E6%89%93%E5%8C%85%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%8E%8B%E7%BC%A9%E5%8C%85---%E9%9C%80%E6%B1%82:%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E8%B5%84%E6%BA%90-*/--const-pluginname-=-&#x27;compressassetsplugin&#x27;;--class-compressassetsplugin-{---constructor({-output-})-{-----this.output-=-output;---}----apply(compiler)-{-----/-asyncserieshook-%E5%B0%86-assets-%E8%BE%93%E5%87%BA%E5%88%B0-output-%E7%9B%AE%E5%BD%95%E4%B9%8B%E5%89%8D%E8%B0%83%E7%94%A8%E8%AF%A5%E9%92%A9%E5%AD%90-----compiler.hooks.emit.tapasync(pluginname,-(compilation,-callback)-=%3E-{-------/-%E5%88%9B%E5%BB%BAzip%E5%AF%B9%E8%B1%A1-------const-zip-=-new-jszip();-------/-%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%AC%A1%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90%E6%89%80%E6%9C%89%E7%9A%84assets%E8%B5%84%E6%BA%90-------const-assets-=-compilation.getassets();-------/-%E5%BE%AA%E7%8E%AF%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90-------assets.foreach(({-name,-source-})-=%3E-{---------/-%E8%B0%83%E7%94%A8source()%E6%96%B9%E6%B3%95%E8%8E%B7%E5%BE%97%E5%AF%B9%E5%BA%94%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2---------const-sourcecode-=-source.source();---------/-%E5%BE%80-zip-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E5%90%8D%E7%A7%B0%E5%92%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E5%86%85%E5%AE%B9---------zip.file(name,-sourcecode);-------});-------/-%E8%B0%83%E7%94%A8-zip.generateasync-%E7%94%9F%E6%88%90-zip-%E5%8E%8B%E7%BC%A9%E5%8C%85-------zip.generateasync({-type:-&#x27;nodebuffer&#x27;-}).then((result)-=%3E-{---------/-%E9%80%9A%E8%BF%87-new-rawsource-%E5%88%9B%E5%BB%BA%E5%8E%8B%E7%BC%A9%E5%8C%85---------/-%E5%B9%B6%E4%B8%94%E5%90%8C%E6%97%B6%E9%80%9A%E8%BF%87-compilation.emitasset-%E6%96%B9%E6%B3%95%E5%B0%86%E7%94%9F%E6%88%90%E7%9A%84-zip-%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%BE%93%E5%87%BA%E5%88%B0-this.output---------compilation.emitasset(this.output,-new-rawsource(result));---------/-%E8%B0%83%E7%94%A8-callback-%E8%A1%A8%E7%A4%BA%E6%9C%AC%E6%AC%A1%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%BB%93%E6%9D%9F---------callback();-------});-----});---}-}--module.exports-=-compressassetsplugin;-%60%60%60--####-3.-bundlesizewebpackplugin--%E9%9C%80%E6%B1%82%E6%96%87%E4%BB%B6%E8%B6%85%E8%BF%87%E4%B8%80%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%97%B6%E7%BB%99%E5%87%BA%E8%AD%A6%E5%91%8A--%60%60%60-js-const-{-resolve-}-=-require(&#x27;path&#x27;)-const-fs-=-require(&#x27;fs&#x27;)--class-bundlesizewebpackplugin-{---constructor(options)-{-----this.options-=-options---}---apply(compiler)-{-----const-{-sizelimit-}-=-this.options-----console.log(&#x27;bundle-size-plugin&#x27;)-----/-%E5%9C%A8%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83%E6%8B%BF%E5%88%B0%E6%89%93%E5%8C%85%E5%90%8E%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%84%B6%E5%90%8E%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%84%B6%E5%90%8E%E5%AE%9A%E4%B9%89%E4%B8%80%E4%BA%9B%E9%80%BB%E8%BE%91-----compiler.hooks.done.tap(&#x27;bundlesizeplugin&#x27;,-stats-=%3E-{-------const-{-path,-filename-}-=-stats.compilation.outputoptions-------const-bundlepath-=-resolve(path,-filename)-------const-{-size-}-=-fs.statsync(bundlepath)-------const-bundlesize-=-size-/-1024-------if-(bundlesize-%3C-sizelimit)-{---------console.log(-----------&#x27;safe:-bundle-size&#x27;,-----------bundlesize,-----------&#x27;/n-size-limit:-&#x27;,-----------sizelimit---------)-------}-else-{---------console.warn(-----------&#x27;unsafe:-bundle-size&#x27;,-----------bundlesize,-----------&#x27;/n-size-limit:-&#x27;,-----------sizelimit---------)-------}-----})---}-}--module.exports-=-bundlesizewebpackplugin-%60%60%60--###-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6--%E7%9B%AE%E5%89%8Dwebpack%E7%A4%BE%E5%8C%BA%E5%B7%B2%E7%BB%8F%E6%9C%89%E5%BE%88%E5%A4%9A%E6%88%90%E7%86%9F%E7%9A%84%E6%8F%92%E4%BB%B6%E4%BA%86%E5%A6%82%E6%9E%9C%E9%9D%9E%E7%89%B9%E6%AE%8A%E9%9C%80%E6%B1%82%E4%B8%8D%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6--####-1.-html-webpack-plugin--%60html-webpack-plugin%60%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%89%93%E5%8C%85%E7%BB%93%E6%9D%9F%E5%90%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAhtml%E6%96%87%E4%BB%B6%E5%B9%B6%E6%8A%8A%E6%89%93%E5%8C%85%E7%94%9F%E6%88%90%E7%9A%84js%E8%87%AA%E5%8A%A8%E5%BC%95%E5%85%A5%E5%88%B0%E8%BF%99%E4%B8%AAhtml%E6%96%87%E4%BB%B6%E4%B8%AD--%60%60%60-js-const-htmlwebpackplugin-=-require(&#x27;html-webpack-plugin&#x27;)--module.exports-=-{---plugins:-[-----new-htmlwebpackplugin({-------filename:-&#x27;index.html&#x27;,-------template:-path.join(__dirname,-&#x27;/index.html&#x27;),-------minify:-{---------/-%E5%8E%8B%E7%BC%A9html%E6%96%87%E4%BB%B6---------removecomments:-true,-/-%E7%A7%BB%E9%99%A4html%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A---------collapsewhitespace:-true,-/-%E5%88%A0%E9%99%A4%E7%A9%BA%E7%99%BD%E7%AC%A6%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%AC%A6---------minifycss:-true,-/-%E5%8E%8B%E7%BC%A9%E5%86%85%E8%81%94css-------},-------inject:-true,-----}),---]-}-%60%60%60--**inject-%E6%9C%89%E5%9B%9B%E4%B8%AA%E9%80%89%E9%A1%B9%E5%80%BC**----%60true%60%E9%BB%98%E8%AE%A4%E5%80%BC*script*-%E6%A0%87%E7%AD%BE%E4%BD%8D%E4%BA%8E-*html*-%E6%96%87%E4%BB%B6%E7%9A%84-*body*-%E5%BA%95%E9%83%A8---%60body%60*script*-%E6%A0%87%E7%AD%BE%E4%BD%8D%E4%BA%8E-*html*-%E6%96%87%E4%BB%B6%E7%9A%84-*body*-%E5%BA%95%E9%83%A8%E5%90%8C-*true*---%60head%60*script*-%E6%A0%87%E7%AD%BE%E4%BD%8D%E4%BA%8E-*head*-%E6%A0%87%E7%AD%BE%E5%86%85---%60false%60%E4%B8%8D%E6%8F%92%E5%85%A5%E7%94%9F%E6%88%90%E7%9A%84-*js*-%E6%96%87%E4%BB%B6%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA-*html*-%E6%96%87%E4%BB%B6--####-2.-clean-webpack-plugin--%60clean-webpack-plugin%60-%E7%94%A8%E4%BA%8E%E5%9C%A8%E6%89%93%E5%8C%85%E5%89%8D%E6%B8%85%E7%90%86%E4%B8%8A%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E7%9A%84-%60bundle%60-%E6%96%87%E4%BB%B6%E5%AE%83%E4%BC%9A%E6%A0%B9%E6%8D%AE-%60output.path%60-%E8%87%AA%E5%8A%A8%E6%B8%85%E7%90%86%E6%96%87%E4%BB%B6%E5%A4%B9--%60%60%60-js-const-{-cleanwebpackplugin-}-=-require(&#x27;clean-webpack-plugin&#x27;)--module.exports-=-{---plugins:-[-----new-htmlwebpackplugin({-------template:-path.join(__dirname,-&#x27;/index.html&#x27;),-----}),-----new-cleanwebpackplugin(),-/-%E6%89%80%E8%A6%81%E6%B8%85%E7%90%86%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0---]-}-%60%60%60--####-3.-extract-text-webpack-plugin--%E5%B0%86css%E6%A0%B7%E5%BC%8F%E4%BB%8Ejs%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%90%E5%8F%96%E5%87%BA%E6%9D%A5%E6%9C%80%E7%BB%88%E5%90%88%E6%88%90%E4%B8%80%E4%B8%AAcss%E6%96%87%E4%BB%B6%E8%AF%A5%E6%8F%92%E4%BB%B6%E5%8F%AA%E6%94%AF%E6%8C%81webpack4%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%BD%93%E5%89%8D%E6%98%AFwebpack4%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E9%82%A3%E4%B9%88%E5%B0%B1%E4%BC%9A%E6%8A%A5%E9%94%99--%60%60%60-js-const-extracttextplugin-=-require(&#x27;extract-text-webpack-plugin&#x27;);-module.exports-=-{---module:-{-----rules:-[-------{---------test:-/.css$/,---------use:-extracttextplugin.extract({-----------fallback:-%22style-loader%22,-----------use:-%22css-loader%22---------})-------}-----]---},---plugins:-[-----new-extracttextplugin({-------filename:-%22[name].css%22,-------allchunks:-true-----})---]-}-%60%60%60--####-4.-mini-css-extract-plugin--%E8%AF%A5%E6%8F%92%E4%BB%B6%E4%B8%8E%E4%B8%8A%E9%9D%A2%E7%9A%84%60extract-text-webpack-plugin%60%E7%9A%84%E4%B8%80%E6%A0%B7%E9%83%BD%E6%98%AF%E5%B0%86css%E6%A0%B7%E5%BC%8F%E6%8F%90%E5%8F%96%E5%87%BA%E6%9D%A5,-%E5%94%AF%E4%B8%80%E5%B0%B1%E6%98%AF%E7%94%A8%E6%B3%95%E4%B8%8D%E5%90%8C%E6%9C%AC%E6%8F%92%E4%BB%B6%E7%9A%84webpack4%E7%89%88%E6%9C%AC%E4%B9%8B%E5%90%8E%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8--%60%60%60-js-const-minicssextractplugin-=-require(&#x27;mini-css-extract-plugin&#x27;);-module.exports-=-{---module:-{-----rules:-[-------{---------test:-/.css$/,---------use:-[-----------minicssextractplugin.loader,-----------%22css-loader%22---------]-------}-----]---},---plugins:-[-----new-minicssextractplugin({-------filename:-%22css/[name].css%22,-------chunkfilename:-%22css/[name].css%22-----})---]-}-%60%60%60--####-5.-purifycss-webpack--%E6%9C%89%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC-css-%E5%86%99%E5%BE%97%E5%A4%9A%E4%BA%86%E6%88%96%E8%80%85%E9%87%8D%E5%A4%8D%E4%BA%86%E8%BF%99%E5%B0%B1%E9%80%A0%E6%88%90%E4%BA%86%E5%A4%9A%E4%BD%99%E7%9A%84%E4%BB%A3%E7%A0%81%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%BF%9B%E8%A1%8C%E5%8E%BB%E9%99%A4--%60%60%60-js-const-path-=-require(&#x27;path&#x27;)-const-purifycsswebpack-=-require(&#x27;purifycss-webpack&#x27;)-/-%E5%BC%95%E5%85%A5purifycsswebpack%E6%8F%92%E4%BB%B6-const-glob-=-require(&#x27;glob&#x27;)-/-%E5%BC%95%E5%85%A5glob%E6%A8%A1%E5%9D%97,%E7%94%A8%E4%BA%8E%E6%89%AB%E6%8F%8F%E5%85%A8%E9%83%A8html%E6%96%87%E4%BB%B6%E4%B8%AD%E6%89%80%E5%BC%95%E7%94%A8%E7%9A%84css--module.exports-=-merge(common,-{---plugins:-[-----new-purifycsswebpack({-------paths:-glob.sync(path.join(__dirname,-&#x27;src/*.html&#x27;)),-----}),---],-})-%60%60%60--####-6.-optimize-css-assets-webpack-plugin--%60optimize-css-assets-webpack-plugin%60-%E7%94%A8%E4%BA%8E%E4%BC%98%E5%8C%96%E5%92%8C%E6%9C%80%E5%B0%8F%E5%8C%96-css-%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AE%83%E4%BC%9A%E5%8E%8B%E7%BC%A9-css%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%83%8F-cssnano-%E9%82%A3%E6%A0%B7%E7%A7%BB%E9%99%A4%E6%88%96%E5%90%88%E5%B9%B6%E6%A0%B7%E5%BC%8F--%60%60%60-js-const-optimizecssassetsplugin-=-require(%22optimize-css-assets-webpack-plugin%22)-/-%E5%8E%8B%E7%BC%A9css%E4%BB%A3%E7%A0%81--module.exports-=-{---optimization:-{-----minimizer:-[-------/-%E5%8E%8B%E7%BC%A9css-------new-optimizecssassetsplugin({})-----]---}-}-%60%60%60--####-7.-defineplugin--%E7%94%A8%E4%BA%8E%E6%B3%A8%E5%85%A5%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%80%E8%88%AC%E7%94%A8%E5%9C%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8A%E6%97%A0%E9%9C%80%E5%AE%89%E8%A3%85webpack%E5%86%85%E7%BD%AE--%60%60%60-js-const-webpack-=-require(%22webpack%22)-module.exports-=-{---plugins:-[-----new-webpack.defineplugin({-------str:-json.stringify(%22%E8%9B%99%E4%BA%BA%22),-------%22process.env%22:-json.stringify(%22dev%22),-------name:-%22%E8%9B%99%E4%BA%BA%22-----})---]-}-%60%60%60--####-8.-copy-webpack-plugin--%60copy-webpack-plugin%60-%E7%94%A8%E4%BA%8E%E5%9C%A8-webpack-%E4%B8%AD%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9%E6%AF%94%E5%A6%82%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8A%8A%E4%B8%80%E4%BA%9B%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E5%88%B0%E6%89%93%E5%8C%85%E7%9B%AE%E5%BD%95%E8%BF%99%E6%97%B6%E5%80%99%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6--%60%60%60-js-const-copywebpackplugin-=-require(&#x27;copy-webpack-plugin&#x27;)-module.exports-=-{---plugins:-[-----new-copywebpackplugin({-------patterns:-[---------{-----------from:-&#x27;public/js/*.js&#x27;,-----------to:-path.resolve(__dirname,-&#x27;dist&#x27;,-&#x27;js&#x27;),-----------flatten:-true,---------},-------],-----}),---],-}-%60%60%60--####-9.-imagemin-webpack-plugin--%E7%94%A8%E4%BA%8E%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87--%60%60%60-js-const-imageminplugin-=--require(&#x27;imagemin-webpack-plugin&#x27;).default-module.exports-=-{---plugins:-[-----new-imageminplugin({---------test:-/.(jpe?g|png|gif|svg)$/i-----})---]-}-%60%60%60---%E6%9D%A5%E6%BA%90https://zhuanlan.zhihu.com/p/661670534"><div class="truncate" style="padding-left:16px">Webpack Plugin插件机制

### plugin机制出现原因

前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。

那如果我们需要在项目中实现`打包前自动清理上次打包生成的文件`、`将一些文件复制到打包目录中`、`自动生成html文件`、`将打包产物自动上传至服务器`、`将打包后代码进行压缩、拆分`等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。

没错，webpack的plugin机制让webpack有了定制化的能力。

### plugin原理

那具体如何通过plugin机制去实现这些定制化功能呢？

其实是webpack在打包过程中的不同阶段（配置文件读取完成后、打包开始前、打包完成后等阶段）会触发不同的钩子，我们只需要明确要实现的功能应该在哪个阶段，然后将具体实现代码注册为对应钩子的事件即可。

### webpack运行原理

我们在了解这些钩子之前，必须要知道webpack的运行原理。

这是一个简化版的webpack打包过程，当我们执行 `webpack build` 命令后，webpack会先读取配置文件，然后根据配置文件中的配置项去初始化，创建一个 `compiler` 对象，然后调用 `compiler` 对象的 `run` 方法，初始化一个 `compilation` 对象，执行 `compilation` 中的 `build` 方法进行编译，编译完成后，触发 `compiler` 对象的 `done` 钩子，完成打包。

![image](https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82)

``` js
//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数
function webpack(webpackOptions) {
  //第二步：用配置参数对象初始化 `Compiler` 对象
  const compiler = new Compiler(webpackOptions);
  //第三步：挂载配置文件中的插件
 const { plugins } = webpackOptions;
 for (let plugin of plugins) {
   plugin.apply(compiler);
 }
  return compiler;
}
```

``` js
//Compiler其实是一个类，它是整个编译过程的大管家，而且是单例模式
class Compiler {
  constructor(webpackOptions) {
   //省略
  }

  // 第五步：创建compilation对象
  compile(callback){
    //虽然webpack只有一个Compiler，但是每次编译都会产出一个新的Compilation，
    //这里主要是为了考虑到watch模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译
    //每次编译都会产出一个新的Compilation，代表每次的编译结果
    let compilation = new Compilation(this.options);
    compilation.build(callback); //执行compilation的build方法进行编译，编译成功之后执行回调
  }

  //第四步：执行`Compiler`对象的`run`方法开始执行编译
  run(callback) {
    this.hooks.run.call(); //在编译前触发run钩子执行，表示开始启动编译了
    const onCompiled = () =&gt; {
      // 第七步：当编译成功后会触发done这个钩子执行
      this.hooks.done.call();
    };
    this.compile(onCompiled); //开始编译，成功之后调用onCompiled
  }
}


class Compilation {
  constructor(webpackOptions) {
    this.options = webpackOptions;
    this.modules = []; //本次编译所有生成出来的模块
    this.chunks = []; //本次编译产出的所有代码块，入口模块和依赖的模块打包在一起为代码块
    this.assets = {}; //本次编译产出的资源文件
    this.fileDependencies = []; //本次打包涉及到的文件，这里主要是为了实现watch模式下监听文件的变化，文件发生变化后会重新编译
  }

  //第六步：执行compilation的build方法进行编译
  build(callback) {
  //这里开始做编译工作，编译成功执行callback

  // ... 编译过程代码省略

  // 编译完成后，触发callback回调
  callback()
  }
}
```

&lt;!-- more --&gt;

### compiler 与 compilation

那上面提到的 `compiler` 对象和 `compilation` 对象到底是什么呢？又有什么区别与联系？

- `compiler` 对象包含了webpack的所有配置信息，包括`entry`、`output`、`module`、`plugins`等，`compiler` 对象会在启动webpack时，一次性地初始化创建，它是全局唯一的，可以简单理解为webpack的实例。
- `compilation` 对象代表一次资源的构建，通过一系列API可以访问/修改本次模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息等，当我们以开发模式运行webpack时，每当检测到一个文件变化，就会创建一个新的 `compilation` 对象，所以 `compilation` 对象也是一次性的，只能用于当前的编译。

**他有以下主要属性：**

- `compilation.modules` 解析后的所有模块
- `compilation.chunks` 所有的代码分块chunk
- `compilation.assets` 本次打包生成的所有文件
- `compilation.hooks` compilation所有的钩子

所以说呢，`compiler` 代表的是整个 webpack 从启动到关闭的生命周期（终端结束，该生命周期结束）， 而 `compilation` 只是代表了一次性的编译过程，如果是watch模式，每次监听到文件变化，都会产生一个新的 `compilation`，所以 `compilation` 代表一次资源的构建，会多次被创建，而 `compiler` 只会被创建一次。

**我们了解了`compiler`和`compilation`对象后，就可以来看一下到底有哪些钩子。**

### compiler钩子
compiler有很多钩子[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，介绍几个常用的：

- `environment` SyncHook类型，在编译器准备环境时调用，时机就在配置文件中初始化插件之后。
- `afterEnvironment` SyncHook类型，当编译器环境设置完成后，在 `environment hook` 后直接调用。
- `entryOption` SyncBailHook类型，在 `webpack` 选项中的 `entry` 被处理过之后调用。
- `afterPlugins` SyncHook类型，在插件初始化之后。
- `afterResolvers` SyncHook类型，`resolver` 设置完成之后触发。
- `beforeRun` AsyncSeriesHook类型，在开始执行一次构建之前调用，`compiler.run` 方法开始执行后立刻进行调用。
- `run` AsyncSeriesHook类型，在开始读取 `records` 之前调用。
- `watchRun` AsyncSeriesHook类型，在监听模式下，一个新的 `compilation` 触发之后，但在 `compilation` 实际开始之前触发。
- `beforeCompile` AsyncSeriesHook类型，在创建 `compilation` 参数之后执行。
- `compile` SyncHook类型，`beforeCompile` 之后立即调用，但在一个新的 `compilation` 创建之前。
- `thisCompilation` SyncHook类型，初始化 `compilation` 时调用，在触发 `compilation` 事件之前调用。
- `compilation` SyncHook类型，一次新的编译 `compilation` 创建之后触发。
- `make` AsyncParallelHook类型，`compilation` 结束之前执行，`seal` 之前执行。
- `afterCompile` AsyncSeriesHook类型，`compilation` 结束和封印之后执行。
- `shouldEmit` SyncBailHook类型，在输出 `asset` 之前调用。返回一个布尔值，告知是否输出。
- `emit` AsyncSeriesHook类型，生成资源到 `output` 目录之前触发。
- `afterEmit` AsyncSeriesHook类型，输出 `asset` 到 `output` 目录之后执行。
- `done` AsyncSeriesHook类型，`compilation` 编译完成后触发。
- `failed` SyncHook类型，`compilation` 编译失败后触发。

### compilation钩子

compilation对象也有很多钩子[官方地址](https://webpack.js.org/api/compilation-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compilation-hooks/)，介绍几个常用的：

- `buildModule` SyncHook类型，模块开始编译前，执行该钩子，可以用于修改模块内容。
- `succeedModule` SyncHook类型，模块编译成功后，执行该钩子。
- `finishModules` AsyncSeriesHook类型，所有模块编译完成后，执行该钩子。
- `moduleAsset` SyncHook类型，一个模块中的一个 asset 被添加到 compilation 时调用。
- `chunkAsset` SyncHook类型，一个 chunk 中的 asset 被添加到 compilation 时调用。
- `seal` SyncHook类型，在构建过程封存前触发，允许在最终资源生成之前进行一些操作。
- `optimize` SyncHook类型，优化阶段开始时触发，可以用于自定义资源优化逻辑。
- `optimizeAssets` AsyncSeriesHook类型，优化存储在 compilation.assets 中的所有 asset，可以监听和修改资源的优化过程。
- `afterOptimizeAssets` SyncHook类型，asset 已经优化。
- `optimizeTree` AsyncSeriesHook类型，在优化依赖树之前触发，允许修改资源树的优化逻辑。
- `afterOptimizeTree` SyncHook类型，在优化依赖树之后触发，可用于处理优化完成后的资源树。
- `optimizeChunkAssets` AsyncSeriesHook类型，优化所有 chunk asset，弃用，可使用 processAssets 来代替，可用于自定义块资源的优化逻辑。
- `processAssets` AsyncSeriesHook类型，asset 处理时触发，可以监听和修改资源的生成。
- `beforeHash` SyncHook类型，在 compilation 添加哈希（hash）之前。
- `afterHash` SyncHook类型，在 compilation 添加哈希（hash）之后。
- `beforeModuleAssets` SyncHook类型，在创建模块 asset 之前执行，可用于在模块资源生成前执行一些操作。

每个钩子都有对应的类型，那这些类型有什么区别呢？

## Tapable

[Tapable](https://github.com/webpack/tapable)是一个提供**事件发布订阅**的工具，通过其提供的一系列钩子，我们可以注册事件，然后在不同的阶段去触发这些注册的事件。 webpack的plugin机制正是基于 Tapable 实现的，在不同编译阶段触发不同的钩子。

Tapable 官方文档提供了这九种钩子，也就是我们上面提到的钩子类型：

``` js
const {
  SyncHook,
  SyncBailHook,
  SyncWaterfallHook,
  SyncLoopHook,
  AsyncParallelHook,
  AsyncParallelBailHook,
  AsyncSeriesHook,
  AsyncSeriesBailHook,
  AsyncSeriesWaterfallHook
} = require(&quot;tapable&quot;);
```

可以看到，这些钩子有两种开头，分别是 `Sync` 和 `Async` ，这两种钩子的区别是： `Sync` 开头的为同步钩子，表示注册的事件函数会同步进行执行；`Async` 开头的为异步钩子，表示注册的事件函数会异步进行执行

同时呢，这些钩子还有三种结尾，分别是`Hook`、`BailHook`、`WaterfallHook`、`LoopHook`，

这三种结尾的区别是如下所示

- `Hook`结尾的为普通钩子，只会按顺序挨个执行注册的事件，不会去管事件函数的返回值是什么。

![image](https://github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab)

- `BailHook`结尾的为保险钩子，只要注册的事件函数有一个返回值不为`undefined`，就会停止执行后面的事件函数。

![image](https://github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5)

- `WaterfallHook`结尾的为瀑布钩子，注册的事件函数会按顺序执行，每个事件函数的返回值会作为下一个事件函数的参数，只会影响下一个事件函数的第一个参数。

![image](https://github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143)

- `LoopHook`结尾的为循环钩子，注册的事件函数会按顺序执行，只要执行的事件返回值非`undefined`，就会立即重头开始执行，直到所有的事件函数都返回`undefined`，这个钩子才会结束。

![image](https://github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7)

接下来，我们又发现，异步钩子又是以`AsyncParallel`、`AsyncSeries`开头，这又有什么区别呢？

- `AsyncSeries` 为异步串行钩子，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。
- `AsyncParallel` 为异步并行钩子，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。

下面我们就来讲一下这些钩子如何去使用。

### Tapable同步钩子

同步钩子只需要调用 `tap` 方法注册事件，然后调用 `call` 方法触发事件即可。

#### 1. SyncHook

SyncHook 是一个同步的、普通类型的 Hook，注册的事件函数会按顺序挨个执行，不会去管事件函数的返回值是什么。

``` js
const { SyncHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new SyncHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tap(&#x27;事件1&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件1执行:&#x27;, name, age);
});

// 注册事件2
hook.tap(&#x27;事件2&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件2执行:&#x27;, name, age);
});

// 触发事件，传入实参
hook.call(&#x27;前端&#x27;, 18);

// 执行结果
// 事件1执行: 前端 18
// 事件2执行: 前端 18
```

#### 2. SyncBailHook

SyncBailHook 是一个同步的、保险类型的 Hook，意思是只要其中一个有返回了，后面的就不执行了。

``` js
const { SyncBailHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new SyncBailHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tap(&#x27;事件1&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件1执行:&#x27;, name, age);
});

// 注册事件2
hook.tap(&#x27;事件2&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件2执行:&#x27;, name, age);
  return &#x27;abc&#x27;
});

// 注册事件3
hook.tap(&#x27;事件3&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件3执行:&#x27;, name, age);
});

// 触发事件，传入实参
hook.call(&#x27;前端&#x27;, 18);

// 执行结果
// 事件1执行: 前端 18
// 事件2执行: 前端 18
```

#### 3. SyncWaterfallHook

SyncWaterfallHook 是一个同步的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。

``` js
const { SyncWaterfallHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new SyncWaterfallHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tap(&#x27;事件1&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件1执行:&#x27;, name, age);
  return &#x27;驿站&#x27;
});

// 注册事件2
hook.tap(&#x27;事件2&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件2执行:&#x27;, name, age);
});

// 注册事件3
hook.tap(&#x27;事件3&#x27;, (name, age) =&gt; {
  console.log(&#x27;事件3执行:&#x27;, name, age);
});

// 触发事件，传入实参
hook.call(&#x27;前端&#x27;, 18);

// 执行结果
// 事件1执行: 前端 18
// 事件2执行: 驿站 18
// 事件3执行: 驿站 18
```

#### 4. SyncLoopHook

SyncLoopHook 是一个同步的、循环类型的 Hook，只要执行的事件函数返回值非undefeind，就会立即重头开始执行，直到所有的事件函数都返回undefined，这个钩子才会结束。

``` js
const { SyncLoopHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new SyncLoopHook();

let count = 5;

// 注册事件1
hook.tap(&#x27;事件1&#x27;, () =&gt; {
  count--;
  console.log(&#x27;事件1执行,count为&#x27;,count);
  if (count &gt; 3) {
    return true;
  }
});

// 注册事件2
hook.tap(&#x27;事件2&#x27;, () =&gt; {
  count--;
  console.log(&#x27;事件2执行,count为&#x27;,count);
  if (count &gt; 1) {
    return true;
  }
});

// 注册事件3
hook.tap(&#x27;事件3&#x27;, () =&gt; {
  console.log(&#x27;事件3执行,count为&#x27;,count);
});

// 触发事件
hook.call();

// 执行结果
// 事件1执行,count为 4
// 事件1执行,count为 3
// 事件2执行,count为 2
// 事件1执行,count为 1
// 事件2执行,count为 0
// 事件3执行,count为 0
```

### Tapable异步钩子

异步钩子提供三种注册的方法：

- `tap`：以同步方式注册钩子，用 `call` 来触发，跟同步钩子一样，只不过加持了异步的能力，不过多讲解。
- `tapAsync`: 以异步方式注册钩子，用 `callAsync` 触发，同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成，下面有使用示例。
- `tapPromise`: 以异步方式注册钩子，用 `promise` 的方式触发,下面有使用示例。

#### 1. AsyncParallelHook

AsyncParallelHook 是一个异步的、并行类型的 Hook，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。

``` js
const { AsyncParallelHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncParallelHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapAsync(&#x27;事件1&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件1执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 2000);
});

// 注册事件2
hook.tapAsync(&#x27;事件2&#x27;, (name, age, callback) =&gt; {
  console.log(&#x27;事件2执行:&#x27;, name, age);
  // 调用callback，表示该事件执行完毕
  callback();
});

// 注册事件3
hook.tapAsync(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  console.log(&#x27;事件3执行:&#x27;, name, age);
  // 调用callback，表示该事件执行完毕
  callback();
});

// 触发事件，传入实参
hook.callAsync(&#x27;前端&#x27;, 18, () =&gt; {
  // 该钩子注册的所有事件执行完毕后，会执行该回调
  console.log(&#x27;该钩子所有事件执行完毕&#x27;);
});

// 执行结果
// 事件2执行: 前端 18
// 事件3执行: 前端 18
// 2秒后输出：事件1执行: 前端 18
// 该钩子所有事件执行完毕
```

#### 2. AsyncParallelBailHook

AsyncParallelBailHook 是一个异步、并行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。

``` js
const { AsyncParallelBailHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncParallelBailHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapPromise(&#x27;事件1&#x27;, (name, age) =&gt; {
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      console.log(&#x27;事件1执行:&#x27;, name, age);
      resolve(&#x27;123&#x27;);
    }, 2000);
  })
});

// 注册事件2
hook.tapPromise(&#x27;事件2&#x27;, (name, age) =&gt; {
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      console.log(&#x27;事件2执行:&#x27;, name, age);
      resolve();
    }, 3000);
  })
});

// 注册事件3
hook.tapPromise(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  return new Promise((resolve) =&gt; {
    console.log(&#x27;事件3执行:&#x27;, name, age);
    resolve();
  })
});

// 触发事件，传入实参
hook.promise(&#x27;前端&#x27;, 18).then((res) =&gt; {
  // 该钩子注册的所有事件执行完毕后，会执行该回调
  console.log(&#x27;该钩子所有事件执行完毕&#x27;,res);
})

// 执行结果
// 事件3执行: 前端 18
// 2秒后输出：事件1执行: 前端 18
// 该钩子所有事件执行完毕123
```

#### 3. AsyncSeriesHook

AsyncSeriesHook 是一个异步的、串行类型的 Hook，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。

``` js
const { AsyncSeriesHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncSeriesHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapAsync(&#x27;事件1&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件1执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback(null, &#x27;123&#x27;);
  }, 4000);
});

// 注册事件2
hook.tapAsync(&#x27;事件2&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件2执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 3000);
});

// 注册事件3
hook.tapAsync(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件3执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 2000);
});

// 触发事件，传入实参
hook.callAsync(&#x27;前端&#x27;, 18, (err, result) =&gt; {
  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值
  console.log(&#x27;该钩子所有事件执行完毕&#x27;,result);
});

// 执行结果
// 事件3执行: 前端 18
// 事件2执行: 前端 18
// 事件1执行: 前端 18
// 该钩子所有事件执行完毕123
```

#### 4. AsyncSeriesBailHook

AsyncSeriesBailHook 是一个异步的、串行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。

``` js
const { AsyncSeriesBailHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncSeriesBailHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapAsync(&#x27;事件1&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件1执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 4000);
});

// 注册事件2
hook.tapAsync(&#x27;事件2&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件2执行:&#x27;, name, age);
    callback(null, &quot;88717&quot;);
  }, 3000);
});

// 注册事件3
hook.tapAsync(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件3执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback();
  }, 2000);
});

// 触发事件，传入实参
hook.callAsync(&#x27;前端&#x27;, 18, (err, result) =&gt; {
  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值
  console.log(&#x27;该钩子所有事件执行完毕&#x27;,result);
});

// 执行结果
// 事件3执行: 前端 18
// 事件2执行: 前端 18
// 该钩子所有事件执行完毕88717
```

#### 5. AsyncSeriesWaterfallHook

AsyncSeriesWaterfallHook 是一个异步的、串行的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。

``` js
const { AsyncSeriesWaterfallHook } = require(&#x27;tapable&#x27;);

// 初始化钩子，定义形参
const hook = new AsyncSeriesWaterfallHook([&#x27;name&#x27;, &#x27;age&#x27;]);

// 注册事件1
hook.tapAsync(&#x27;事件1&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件1执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback(null,3);
  }, 4000);
});

// 注册事件2
hook.tapAsync(&#x27;事件2&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件2执行:&#x27;, name, age);
    callback(null, 2);
  }, 3000);
});

// 注册事件3
hook.tapAsync(&#x27;事件3&#x27;, (name, age, callback) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#x27;事件3执行:&#x27;, name, age);
    // 调用callback，表示该事件执行完毕
    callback(null, 1);
  }, 2000);
});

// 触发事件，传入实参
hook.callAsync(&#x27;前端&#x27;, 18, (err, result) =&gt; {
  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值
  console.log(&#x27;该钩子所有事件执行完毕&#x27;,result);
});

// 执行结果
// 事件3执行: 前端 18
// 事件2执行: 1 18
// 事件1执行: 2 18
// 该钩子所有事件执行完毕3
```

### 如何自定义plugin

了解Tapable之后，我们就可以学习如何自定义plugin了。

webpack 插件由以下几部分组成：

- 一个 `JavaScript` 类 一个构造方法，可以接受一个 `options` 对象参数
- 一个 `apply` 方法，该方法在 `webpack` 装载这个插件的时候被调用，并且会传入 `compiler` 对象
根据我们的需求，确定要在哪个阶段挂载到哪个钩子上，根据钩子的类型（同步/异步），选择合适的事件注册方式，将需求实现代码注册为事件。

事件回调中具体有哪些参数，需要根据钩子的类型去官网查看[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，这里就不一一列举了。

&gt; 注意 ： webpack4 可以用 plugin方法来注册插件，webpack5之后被取消了。
&gt; compiler.plugin(&#x27;emit&#x27;, function (compilation, cb) {})

``` js
class BasicPlugin{
  // 在构造函数中获取用户给该插件传入的配置项
  constructor(options){
    this.options = options;
  }

  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象
  apply(compiler) {
    // 注册第1个事件, 这个事件名叫什么都无所谓，只是个标示而已
    compiler.hooks.run.tapAsync(&#x27;BasicPlugin&#x27;, (compiler, callback) =&gt; {
      console.log(&#x27;以异步方式触及 run 钩子。&#x27;)
      callback()
    })

    // 注册第2个事件
    // 在compiler的compilation钩子上注册一个事件BasicPlugin
    compiler.hooks.compilation.tap(&#x27;BasicPlugin&#x27;, (compilation) =&gt; {
      // 测试compilation对象在模块构建之前能得到什么
      compilation.hooks.buildModule.tap(&#x27;BasicPlugin&#x27;, (data) =&gt; {
          console.log(data);
      })
    })

    // 注册第3个事件
    compiler.hooks.emit.tap(&#x27;BasicPlugin&#x27;, (compilation) =&gt; {
      // 业务逻辑代码
    });
  }
}

module.exports = BasicPlugin;
```

``` js
// webpack.config.js
const path = require(&#x27;path&#x27;);
const BasicPlugin = require(&#x27;./BasicPlugin&#x27;);

module.exports = {
  entry: &#x27;./src/index.js&#x27;,
  output: {
    filename: &#x27;[name].bundle.js&#x27;,
    path: path.resolve(__dirname, &#x27;dist&#x27;)
  },
  plugins: [
    new BasicPlugin(),
  ]
}
```


### 自定义plugin实战

为了更好的实践，给大家提供3个自定义插件来参考。

#### 1. FileListPlugin

需求：在打包完成后，生成一个`fileList.md`文件，文件内容为打包生成的所有文件名。

```
# 一共有2个文件

- main.bundle.js
- index.html
```

代码实现

``` js
function FileListPlugin (options) {
  this.options = options || {};
  this.filename = this.options.filename || &#x27;fileList.md&#x27;
}

FileListPlugin.prototype.apply = function (compiler) {
  // 1.通过compiler.hooks.emit.tapAsync()来触发生成资源到output目录之前的钩子，且回调函数会有两个参数，一个是compilation，一个是cb回调函数
  compiler.hooks.emit.tapAsync(&#x27;FileListPlugin&#x27;, (compilation, cb) =&gt; {
    // 2.要生成的markdown文件的名称
    const fileListName = this.filename;
    // 3.通过compilation.assets获取到所有待生成的文件，这里是获取它的长度
    let len = Object.keys(compilation.assets).length;
    // 4.定义markdown文件的内容，也就是先定义一个一级标题，\n表示的是换行符
    let content = `# 一共有${len}个文件\n\n`;
    // 5.将每一项文件的名称写入markdown文件内
    for (let filename in compilation.assets) {
      content += `- ${filename}\n`
    }
    // 6.给我们即将生成的dist文件夹里添加一个新的资源，资源的名称就是fileListName变量
    compilation.assets[fileListName] = {
      // 7.写入资源的内容
      source: function () {
        return content;
      },
      // 8.指定新资源的大小，用于webpack展示
      size: function () {
        return content.length;
      }
    }
    // 9.由于我们使用的是tapAsync异步调用，所以必须执行一个回调函数cb，否则打包后就只会创建一个空的dist文件夹。
    cb();
  })
}
module.exports = FileListPlugin;
module.exports = {
  new FileListPlugin({
    filename: &#x27;fileList.md&#x27;
  })
}
```

#### 2. CompressAssetsPlugin

需求：每次打包完成后，将打包生成的文件生成一个压缩包。

``` js
const JSZip = require(&#x27;jszip&#x27;);
const { RawSource } = require(&#x27;webpack-sources&#x27;);
/*
  将本次打包的资源都打包成为一个压缩包
  需求:获取所有打包后的资源
*/

const pluginName = &#x27;CompressAssetsPlugin&#x27;;

class CompressAssetsPlugin {
  constructor({ output }) {
    this.output = output;
  }

  apply(compiler) {
    // AsyncSeriesHook 将 assets 输出到 output 目录之前调用该钩子
    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) =&gt; {
      // 创建zip对象
      const zip = new JSZip();
      // 获取本次打包生成所有的assets资源
      const assets = compilation.getAssets();
      // 循环每一个资源
      assets.forEach(({ name, source }) =&gt; {
        // 调用source()方法获得对应的源代码 这是一个源代码的字符串
        const sourceCode = source.source();
        // 往 zip 对象中添加资源名称和源代码内容
        zip.file(name, sourceCode);
      });
      // 调用 zip.generateAsync 生成 zip 压缩包
      zip.generateAsync({ type: &#x27;nodebuffer&#x27; }).then((result) =&gt; {
        // 通过 new RawSource 创建压缩包
        // 并且同时通过 compilation.emitAsset 方法将生成的 Zip 压缩包输出到 this.output
        compilation.emitAsset(this.output, new RawSource(result));
        // 调用 callback 表示本次事件函数结束
        callback();
      });
    });
  }
}

module.exports = CompressAssetsPlugin;
```

#### 3. BundleSizeWebpackPlugin

需求：文件超过一定大小时给出警告

``` js
const { resolve } = require(&#x27;path&#x27;)
const fs = require(&#x27;fs&#x27;)

class BundleSizeWebpackPlugin {
  constructor(options) {
    this.options = options
  }
  apply(compiler) {
    const { sizeLimit } = this.options
    console.log(&#x27;bundle size plugin&#x27;)
    // 在编译完成后，执行回调，拿到打包后文件路径，然后读取文件信息获取文件大小，然后定义一些逻辑
    compiler.hooks.done.tap(&#x27;BundleSizePlugin&#x27;, stats =&gt; {
      const { path, filename } = stats.compilation.outputOptions
      const bundlePath = resolve(path, filename)
      const { size } = fs.statSync(bundlePath)
      const bundleSize = size / 1024
      if (bundleSize &lt; sizeLimit) {
        console.log(
          &#x27;safe: bundle-size&#x27;,
          bundleSize,
          &#x27;\n size limit: &#x27;,
          sizeLimit
        )
      } else {
        console.warn(
          &#x27;unsafe: bundle-size&#x27;,
          bundleSize,
          &#x27;\n size limit: &#x27;,
          sizeLimit
        )
      }
    })
  }
}

module.exports = BundleSizeWebpackPlugin
```

### 常用插件

目前，webpack社区已经有很多成熟的插件了，如果非特殊需求，不用自定义插件。下面介绍几个常用的插件。

#### 1. html-webpack-plugin

`html-webpack-plugin`可以在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中。

``` js
const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      filename: &#x27;index.html&#x27;,
      template: path.join(__dirname, &#x27;/index.html&#x27;),
      minify: {
        // 压缩HTML文件
        removeComments: true, // 移除HTML中的注释
        collapseWhitespace: true, // 删除空白符与换行符
        minifyCSS: true, // 压缩内联css
      },
      inject: true,
    }),
  ]
}
```

**inject 有四个选项值**

- `true`：默认值，*script* 标签位于 *html* 文件的 *body* 底部
- `body`：*script* 标签位于 *html* 文件的 *body* 底部（同 *true*）
- `head`：*script* 标签位于 *head* 标签内
- `false`：不插入生成的 *js* 文件，只是单纯的生成一个 *html* 文件

#### 2. clean-webpack-plugin

`clean-webpack-plugin` 用于在打包前清理上一次项目生成的 `bundle` 文件，它会根据 `output.path` 自动清理文件夹。

``` js
const { CleanWebpackPlugin } = require(&#x27;clean-webpack-plugin&#x27;)

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, &#x27;/index.html&#x27;),
    }),
    new CleanWebpackPlugin(), // 所要清理的文件夹名称
  ]
}
```

#### 3. extract-text-webpack-plugin

将css样式从js文件中提取出来最终合成一个css文件，该插件只支持webpack4之前的版本，如果你当前是webpack4及以上版本那么就会报错。

``` js
const extractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: extractTextPlugin.extract({
          fallback: &quot;style-loader&quot;,
          use: &quot;css-loader&quot;
        })
      }
    ]
  },
  plugins: [
    new extractTextPlugin({
      filename: &quot;[name].css&quot;,
      allChunks: true
    })
  ]
}
```

#### 4. mini-css-extract-plugin

该插件与上面的`extract-text-webpack-plugin`的一样，都是将css样式提取出来, 唯一就是用法不同，本插件的webpack4版本之后推荐使用。

``` js
const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          &quot;css-loader&quot;
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: &quot;css/[name].css&quot;,
      chunkFilename: &quot;css/[name].css&quot;
    })
  ]
}
```

#### 5. purifycss-webpack

有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。

``` js
const path = require(&#x27;path&#x27;)
const PurifyCssWebpack = require(&#x27;purifycss-webpack&#x27;) // 引入PurifyCssWebpack插件
const glob = require(&#x27;glob&#x27;) // 引入glob模块,用于扫描全部html文件中所引用的css

module.exports = merge(common, {
  plugins: [
    new PurifyCssWebpack({
      paths: glob.sync(path.join(__dirname, &#x27;src/*.html&#x27;)),
    }),
  ],
})
```

#### 6. optimize-css-assets-webpack-plugin

`optimize-css-assets-webpack-plugin` 用于优化和最小化 css 的插件，它会压缩 css，但是不会像 cssnano 那样移除或合并样式。

``` js
const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;) // 压缩css代码

module.exports = {
  optimization: {
    minimizer: [
      // 压缩css
      new OptimizeCSSAssetsPlugin({})
    ]
  }
}
```

#### 7. DefinePlugin

用于注入全局变量，一般用在环境变量上。无需安装，webpack内置

``` js
const Webpack = require(&quot;webpack&quot;)
module.exports = {
  plugins: [
    new Webpack.DefinePlugin({
      STR: JSON.stringify(&quot;蛙人&quot;),
      &quot;process.env&quot;: JSON.stringify(&quot;dev&quot;),
      name: &quot;蛙人&quot;
    })
  ]
}
```

#### 8. copy-webpack-plugin

`copy-webpack-plugin` 用于在 webpack 中拷贝文件和文件夹，比如我们需要把一些静态文件拷贝到打包目录，这时候就可以使用这个插件。

``` js
const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;)
module.exports = {
  plugins: [
    new CopyWebpackPlugin({
      patterns: [
        {
          from: &#x27;public/js/*.js&#x27;,
          to: path.resolve(__dirname, &#x27;dist&#x27;, &#x27;js&#x27;),
          flatten: true,
        },
      ],
    }),
  ],
}
```

#### 9. imagemin-webpack-plugin

用于压缩图片。

``` js
const ImageminPlugin =  require(&#x27;imagemin-webpack-plugin&#x27;).default
module.exports = {
  plugins: [
    new ImageminPlugin({
        test: /\.(jpe?g|png|gif|svg)$/i
    })
  ]
}
```


来源：https://zhuanlan.zhihu.com/p/661670534</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/647","id":2218786056,"node_id":"I_kwDOBiJZIc6EP_0I","number":647,"title":"Webpack Plugin插件机制","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536118829,"node_id":"LA_kwDOBiJZIc8AAAABhZVCLQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/javascript","name":"javascript","color":"383040","default":false,"description":"分类-Javascript相关"},{"id":6536123165,"node_id":"LA_kwDOBiJZIc8AAAABhZVTHQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/webpack","name":"webpack","color":"923874","default":false,"description":"分类-Webpack相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-04-01T18:08:43Z","updated_at":"2024-04-01T18:08:44Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## Webpack Plugin插件机制\n\n### plugin机制出现原因\n\n前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。\n\n那如果我们需要在项目中实现`打包前自动清理上次打包生成的文件`、`将一些文件复制到打包目录中`、`自动生成html文件`、`将打包产物自动上传至服务器`、`将打包后代码进行压缩、拆分`等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。\n\n没错，webpack的plugin机制让webpack有了定制化的能力。\n\n### plugin原理\n\n那具体如何通过plugin机制去实现这些定制化功能呢？\n\n其实是webpack在打包过程中的不同阶段（配置文件读取完成后、打包开始前、打包完成后等阶段）会触发不同的钩子，我们只需要明确要实现的功能应该在哪个阶段，然后将具体实现代码注册为对应钩子的事件即可。\n\n### webpack运行原理\n\n我们在了解这些钩子之前，必须要知道webpack的运行原理。\n\n这是一个简化版的webpack打包过程，当我们执行 `webpack build` 命令后，webpack会先读取配置文件，然后根据配置文件中的配置项去初始化，创建一个 `compiler` 对象，然后调用 `compiler` 对象的 `run` 方法，初始化一个 `compilation` 对象，执行 `compilation` 中的 `build` 方法进行编译，编译完成后，触发 `compiler` 对象的 `done` 钩子，完成打包。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82)\n\n``` js\n//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数\nfunction webpack(webpackOptions) {\n  //第二步：用配置参数对象初始化 `Compiler` 对象\n  const compiler = new Compiler(webpackOptions);\n  //第三步：挂载配置文件中的插件\n const { plugins } = webpackOptions;\n for (let plugin of plugins) {\n   plugin.apply(compiler);\n }\n  return compiler;\n}\n```\n\n``` js\n//Compiler其实是一个类，它是整个编译过程的大管家，而且是单例模式\nclass Compiler {\n  constructor(webpackOptions) {\n   //省略\n  }\n\n  // 第五步：创建compilation对象\n  compile(callback){\n    //虽然webpack只有一个Compiler，但是每次编译都会产出一个新的Compilation，\n    //这里主要是为了考虑到watch模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译\n    //每次编译都会产出一个新的Compilation，代表每次的编译结果\n    let compilation = new Compilation(this.options);\n    compilation.build(callback); //执行compilation的build方法进行编译，编译成功之后执行回调\n  }\n\n  //第四步：执行`Compiler`对象的`run`方法开始执行编译\n  run(callback) {\n    this.hooks.run.call(); //在编译前触发run钩子执行，表示开始启动编译了\n    const onCompiled = () =\u003e {\n      // 第七步：当编译成功后会触发done这个钩子执行\n      this.hooks.done.call();\n    };\n    this.compile(onCompiled); //开始编译，成功之后调用onCompiled\n  }\n}\n\n\nclass Compilation {\n  constructor(webpackOptions) {\n    this.options = webpackOptions;\n    this.modules = []; //本次编译所有生成出来的模块\n    this.chunks = []; //本次编译产出的所有代码块，入口模块和依赖的模块打包在一起为代码块\n    this.assets = {}; //本次编译产出的资源文件\n    this.fileDependencies = []; //本次打包涉及到的文件，这里主要是为了实现watch模式下监听文件的变化，文件发生变化后会重新编译\n  }\n\n  //第六步：执行compilation的build方法进行编译\n  build(callback) {\n  //这里开始做编译工作，编译成功执行callback\n\n  // ... 编译过程代码省略\n\n  // 编译完成后，触发callback回调\n  callback()\n  }\n}\n```\n\n\u003c!-- more --\u003e\n\n### compiler 与 compilation\n\n那上面提到的 `compiler` 对象和 `compilation` 对象到底是什么呢？又有什么区别与联系？\n\n- `compiler` 对象包含了webpack的所有配置信息，包括`entry`、`output`、`module`、`plugins`等，`compiler` 对象会在启动webpack时，一次性地初始化创建，它是全局唯一的，可以简单理解为webpack的实例。\n- `compilation` 对象代表一次资源的构建，通过一系列API可以访问/修改本次模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息等，当我们以开发模式运行webpack时，每当检测到一个文件变化，就会创建一个新的 `compilation` 对象，所以 `compilation` 对象也是一次性的，只能用于当前的编译。\n\n**他有以下主要属性：**\n\n- `compilation.modules` 解析后的所有模块\n- `compilation.chunks` 所有的代码分块chunk\n- `compilation.assets` 本次打包生成的所有文件\n- `compilation.hooks` compilation所有的钩子\n\n所以说呢，`compiler` 代表的是整个 webpack 从启动到关闭的生命周期（终端结束，该生命周期结束）， 而 `compilation` 只是代表了一次性的编译过程，如果是watch模式，每次监听到文件变化，都会产生一个新的 `compilation`，所以 `compilation` 代表一次资源的构建，会多次被创建，而 `compiler` 只会被创建一次。\n\n**我们了解了`compiler`和`compilation`对象后，就可以来看一下到底有哪些钩子。**\n\n### compiler钩子\ncompiler有很多钩子[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，介绍几个常用的：\n\n- `environment` SyncHook类型，在编译器准备环境时调用，时机就在配置文件中初始化插件之后。\n- `afterEnvironment` SyncHook类型，当编译器环境设置完成后，在 `environment hook` 后直接调用。\n- `entryOption` SyncBailHook类型，在 `webpack` 选项中的 `entry` 被处理过之后调用。\n- `afterPlugins` SyncHook类型，在插件初始化之后。\n- `afterResolvers` SyncHook类型，`resolver` 设置完成之后触发。\n- `beforeRun` AsyncSeriesHook类型，在开始执行一次构建之前调用，`compiler.run` 方法开始执行后立刻进行调用。\n- `run` AsyncSeriesHook类型，在开始读取 `records` 之前调用。\n- `watchRun` AsyncSeriesHook类型，在监听模式下，一个新的 `compilation` 触发之后，但在 `compilation` 实际开始之前触发。\n- `beforeCompile` AsyncSeriesHook类型，在创建 `compilation` 参数之后执行。\n- `compile` SyncHook类型，`beforeCompile` 之后立即调用，但在一个新的 `compilation` 创建之前。\n- `thisCompilation` SyncHook类型，初始化 `compilation` 时调用，在触发 `compilation` 事件之前调用。\n- `compilation` SyncHook类型，一次新的编译 `compilation` 创建之后触发。\n- `make` AsyncParallelHook类型，`compilation` 结束之前执行，`seal` 之前执行。\n- `afterCompile` AsyncSeriesHook类型，`compilation` 结束和封印之后执行。\n- `shouldEmit` SyncBailHook类型，在输出 `asset` 之前调用。返回一个布尔值，告知是否输出。\n- `emit` AsyncSeriesHook类型，生成资源到 `output` 目录之前触发。\n- `afterEmit` AsyncSeriesHook类型，输出 `asset` 到 `output` 目录之后执行。\n- `done` AsyncSeriesHook类型，`compilation` 编译完成后触发。\n- `failed` SyncHook类型，`compilation` 编译失败后触发。\n\n### compilation钩子\n\ncompilation对象也有很多钩子[官方地址](https://webpack.js.org/api/compilation-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compilation-hooks/)，介绍几个常用的：\n\n- `buildModule` SyncHook类型，模块开始编译前，执行该钩子，可以用于修改模块内容。\n- `succeedModule` SyncHook类型，模块编译成功后，执行该钩子。\n- `finishModules` AsyncSeriesHook类型，所有模块编译完成后，执行该钩子。\n- `moduleAsset` SyncHook类型，一个模块中的一个 asset 被添加到 compilation 时调用。\n- `chunkAsset` SyncHook类型，一个 chunk 中的 asset 被添加到 compilation 时调用。\n- `seal` SyncHook类型，在构建过程封存前触发，允许在最终资源生成之前进行一些操作。\n- `optimize` SyncHook类型，优化阶段开始时触发，可以用于自定义资源优化逻辑。\n- `optimizeAssets` AsyncSeriesHook类型，优化存储在 compilation.assets 中的所有 asset，可以监听和修改资源的优化过程。\n- `afterOptimizeAssets` SyncHook类型，asset 已经优化。\n- `optimizeTree` AsyncSeriesHook类型，在优化依赖树之前触发，允许修改资源树的优化逻辑。\n- `afterOptimizeTree` SyncHook类型，在优化依赖树之后触发，可用于处理优化完成后的资源树。\n- `optimizeChunkAssets` AsyncSeriesHook类型，优化所有 chunk asset，弃用，可使用 processAssets 来代替，可用于自定义块资源的优化逻辑。\n- `processAssets` AsyncSeriesHook类型，asset 处理时触发，可以监听和修改资源的生成。\n- `beforeHash` SyncHook类型，在 compilation 添加哈希（hash）之前。\n- `afterHash` SyncHook类型，在 compilation 添加哈希（hash）之后。\n- `beforeModuleAssets` SyncHook类型，在创建模块 asset 之前执行，可用于在模块资源生成前执行一些操作。\n\n每个钩子都有对应的类型，那这些类型有什么区别呢？\n\n## Tapable\n\n[Tapable](https://github.com/webpack/tapable)是一个提供**事件发布订阅**的工具，通过其提供的一系列钩子，我们可以注册事件，然后在不同的阶段去触发这些注册的事件。 webpack的plugin机制正是基于 Tapable 实现的，在不同编译阶段触发不同的钩子。\n\nTapable 官方文档提供了这九种钩子，也就是我们上面提到的钩子类型：\n\n``` js\nconst {\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  SyncLoopHook,\n  AsyncParallelHook,\n  AsyncParallelBailHook,\n  AsyncSeriesHook,\n  AsyncSeriesBailHook,\n  AsyncSeriesWaterfallHook\n} = require(\"tapable\");\n```\n\n可以看到，这些钩子有两种开头，分别是 `Sync` 和 `Async` ，这两种钩子的区别是： `Sync` 开头的为同步钩子，表示注册的事件函数会同步进行执行；`Async` 开头的为异步钩子，表示注册的事件函数会异步进行执行\n\n同时呢，这些钩子还有三种结尾，分别是`Hook`、`BailHook`、`WaterfallHook`、`LoopHook`，\n\n这三种结尾的区别是如下所示\n\n- `Hook`结尾的为普通钩子，只会按顺序挨个执行注册的事件，不会去管事件函数的返回值是什么。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab)\n\n- `BailHook`结尾的为保险钩子，只要注册的事件函数有一个返回值不为`undefined`，就会停止执行后面的事件函数。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5)\n\n- `WaterfallHook`结尾的为瀑布钩子，注册的事件函数会按顺序执行，每个事件函数的返回值会作为下一个事件函数的参数，只会影响下一个事件函数的第一个参数。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143)\n\n- `LoopHook`结尾的为循环钩子，注册的事件函数会按顺序执行，只要执行的事件返回值非`undefined`，就会立即重头开始执行，直到所有的事件函数都返回`undefined`，这个钩子才会结束。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7)\n\n接下来，我们又发现，异步钩子又是以`AsyncParallel`、`AsyncSeries`开头，这又有什么区别呢？\n\n- `AsyncSeries` 为异步串行钩子，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。\n- `AsyncParallel` 为异步并行钩子，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。\n\n下面我们就来讲一下这些钩子如何去使用。\n\n### Tapable同步钩子\n\n同步钩子只需要调用 `tap` 方法注册事件，然后调用 `call` 方法触发事件即可。\n\n#### 1. SyncHook\n\nSyncHook 是一个同步的、普通类型的 Hook，注册的事件函数会按顺序挨个执行，不会去管事件函数的返回值是什么。\n\n``` js\nconst { SyncHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) =\u003e {\n  console.log('事件1执行:', name, age);\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) =\u003e {\n  console.log('事件2执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 前端 18\n```\n\n#### 2. SyncBailHook\n\nSyncBailHook 是一个同步的、保险类型的 Hook，意思是只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { SyncBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) =\u003e {\n  console.log('事件1执行:', name, age);\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) =\u003e {\n  console.log('事件2执行:', name, age);\n  return 'abc'\n});\n\n// 注册事件3\nhook.tap('事件3', (name, age) =\u003e {\n  console.log('事件3执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 前端 18\n```\n\n#### 3. SyncWaterfallHook\n\nSyncWaterfallHook 是一个同步的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。\n\n``` js\nconst { SyncWaterfallHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncWaterfallHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) =\u003e {\n  console.log('事件1执行:', name, age);\n  return '驿站'\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) =\u003e {\n  console.log('事件2执行:', name, age);\n});\n\n// 注册事件3\nhook.tap('事件3', (name, age) =\u003e {\n  console.log('事件3执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 驿站 18\n// 事件3执行: 驿站 18\n```\n\n#### 4. SyncLoopHook\n\nSyncLoopHook 是一个同步的、循环类型的 Hook，只要执行的事件函数返回值非undefeind，就会立即重头开始执行，直到所有的事件函数都返回undefined，这个钩子才会结束。\n\n``` js\nconst { SyncLoopHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncLoopHook();\n\nlet count = 5;\n\n// 注册事件1\nhook.tap('事件1', () =\u003e {\n  count--;\n  console.log('事件1执行,count为',count);\n  if (count \u003e 3) {\n    return true;\n  }\n});\n\n// 注册事件2\nhook.tap('事件2', () =\u003e {\n  count--;\n  console.log('事件2执行,count为',count);\n  if (count \u003e 1) {\n    return true;\n  }\n});\n\n// 注册事件3\nhook.tap('事件3', () =\u003e {\n  console.log('事件3执行,count为',count);\n});\n\n// 触发事件\nhook.call();\n\n// 执行结果\n// 事件1执行,count为 4\n// 事件1执行,count为 3\n// 事件2执行,count为 2\n// 事件1执行,count为 1\n// 事件2执行,count为 0\n// 事件3执行,count为 0\n```\n\n### Tapable异步钩子\n\n异步钩子提供三种注册的方法：\n\n- `tap`：以同步方式注册钩子，用 `call` 来触发，跟同步钩子一样，只不过加持了异步的能力，不过多讲解。\n- `tapAsync`: 以异步方式注册钩子，用 `callAsync` 触发，同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成，下面有使用示例。\n- `tapPromise`: 以异步方式注册钩子，用 `promise` 的方式触发,下面有使用示例。\n\n#### 1. AsyncParallelHook\n\nAsyncParallelHook 是一个异步的、并行类型的 Hook，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。\n\n``` js\nconst { AsyncParallelHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncParallelHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) =\u003e {\n  console.log('事件2执行:', name, age);\n  // 调用callback，表示该事件执行完毕\n  callback();\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) =\u003e {\n  console.log('事件3执行:', name, age);\n  // 调用callback，表示该事件执行完毕\n  callback();\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, () =\u003e {\n  // 该钩子注册的所有事件执行完毕后，会执行该回调\n  console.log('该钩子所有事件执行完毕');\n});\n\n// 执行结果\n// 事件2执行: 前端 18\n// 事件3执行: 前端 18\n// 2秒后输出：事件1执行: 前端 18\n// 该钩子所有事件执行完毕\n```\n\n#### 2. AsyncParallelBailHook\n\nAsyncParallelBailHook 是一个异步、并行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { AsyncParallelBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncParallelBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tapPromise('事件1', (name, age) =\u003e {\n  return new Promise((resolve) =\u003e {\n    setTimeout(() =\u003e {\n      console.log('事件1执行:', name, age);\n      resolve('123');\n    }, 2000);\n  })\n});\n\n// 注册事件2\nhook.tapPromise('事件2', (name, age) =\u003e {\n  return new Promise((resolve) =\u003e {\n    setTimeout(() =\u003e {\n      console.log('事件2执行:', name, age);\n      resolve();\n    }, 3000);\n  })\n});\n\n// 注册事件3\nhook.tapPromise('事件3', (name, age, callback) =\u003e {\n  return new Promise((resolve) =\u003e {\n    console.log('事件3执行:', name, age);\n    resolve();\n  })\n});\n\n// 触发事件，传入实参\nhook.promise('前端', 18).then((res) =\u003e {\n  // 该钩子注册的所有事件执行完毕后，会执行该回调\n  console.log('该钩子所有事件执行完毕',res);\n})\n\n// 执行结果\n// 事件3执行: 前端 18\n// 2秒后输出：事件1执行: 前端 18\n// 该钩子所有事件执行完毕123\n```\n\n#### 3. AsyncSeriesHook\n\nAsyncSeriesHook 是一个异步的、串行类型的 Hook，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。\n\n``` js\nconst { AsyncSeriesHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null, '123');\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件2执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) =\u003e {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 前端 18\n// 事件1执行: 前端 18\n// 该钩子所有事件执行完毕123\n```\n\n#### 4. AsyncSeriesBailHook\n\nAsyncSeriesBailHook 是一个异步的、串行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { AsyncSeriesBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件2执行:', name, age);\n    callback(null, \"88717\");\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) =\u003e {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 前端 18\n// 该钩子所有事件执行完毕88717\n```\n\n#### 5. AsyncSeriesWaterfallHook\n\nAsyncSeriesWaterfallHook 是一个异步的、串行的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。\n\n``` js\nconst { AsyncSeriesWaterfallHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesWaterfallHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null,3);\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件2执行:', name, age);\n    callback(null, 2);\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null, 1);\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) =\u003e {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 1 18\n// 事件1执行: 2 18\n// 该钩子所有事件执行完毕3\n```\n\n### 如何自定义plugin\n\n了解Tapable之后，我们就可以学习如何自定义plugin了。\n\nwebpack 插件由以下几部分组成：\n\n- 一个 `JavaScript` 类 一个构造方法，可以接受一个 `options` 对象参数\n- 一个 `apply` 方法，该方法在 `webpack` 装载这个插件的时候被调用，并且会传入 `compiler` 对象\n根据我们的需求，确定要在哪个阶段挂载到哪个钩子上，根据钩子的类型（同步/异步），选择合适的事件注册方式，将需求实现代码注册为事件。\n\n事件回调中具体有哪些参数，需要根据钩子的类型去官网查看[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，这里就不一一列举了。\n\n\u003e 注意 ： webpack4 可以用 plugin方法来注册插件，webpack5之后被取消了。\n\u003e compiler.plugin('emit', function (compilation, cb) {})\n\n``` js\nclass BasicPlugin{\n  // 在构造函数中获取用户给该插件传入的配置项\n  constructor(options){\n    this.options = options;\n  }\n\n  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply(compiler) {\n    // 注册第1个事件, 这个事件名叫什么都无所谓，只是个标示而已\n    compiler.hooks.run.tapAsync('BasicPlugin', (compiler, callback) =\u003e {\n      console.log('以异步方式触及 run 钩子。')\n      callback()\n    })\n\n    // 注册第2个事件\n    // 在compiler的compilation钩子上注册一个事件BasicPlugin\n    compiler.hooks.compilation.tap('BasicPlugin', (compilation) =\u003e {\n      // 测试compilation对象在模块构建之前能得到什么\n      compilation.hooks.buildModule.tap('BasicPlugin', (data) =\u003e {\n          console.log(data);\n      })\n    })\n\n    // 注册第3个事件\n    compiler.hooks.emit.tap('BasicPlugin', (compilation) =\u003e {\n      // 业务逻辑代码\n    });\n  }\n}\n\nmodule.exports = BasicPlugin;\n```\n\n``` js\n// webpack.config.js\nconst path = require('path');\nconst BasicPlugin = require('./BasicPlugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  plugins: [\n    new BasicPlugin(),\n  ]\n}\n```\n\n\n### 自定义plugin实战\n\n为了更好的实践，给大家提供3个自定义插件来参考。\n\n#### 1. FileListPlugin\n\n需求：在打包完成后，生成一个`fileList.md`文件，文件内容为打包生成的所有文件名。\n\n```\n# 一共有2个文件\n\n- main.bundle.js\n- index.html\n```\n\n代码实现\n\n``` js\nfunction FileListPlugin (options) {\n  this.options = options || {};\n  this.filename = this.options.filename || 'fileList.md'\n}\n\nFileListPlugin.prototype.apply = function (compiler) {\n  // 1.通过compiler.hooks.emit.tapAsync()来触发生成资源到output目录之前的钩子，且回调函数会有两个参数，一个是compilation，一个是cb回调函数\n  compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, cb) =\u003e {\n    // 2.要生成的markdown文件的名称\n    const fileListName = this.filename;\n    // 3.通过compilation.assets获取到所有待生成的文件，这里是获取它的长度\n    let len = Object.keys(compilation.assets).length;\n    // 4.定义markdown文件的内容，也就是先定义一个一级标题，\\n表示的是换行符\n    let content = `# 一共有${len}个文件\\n\\n`;\n    // 5.将每一项文件的名称写入markdown文件内\n    for (let filename in compilation.assets) {\n      content += `- ${filename}\\n`\n    }\n    // 6.给我们即将生成的dist文件夹里添加一个新的资源，资源的名称就是fileListName变量\n    compilation.assets[fileListName] = {\n      // 7.写入资源的内容\n      source: function () {\n        return content;\n      },\n      // 8.指定新资源的大小，用于webpack展示\n      size: function () {\n        return content.length;\n      }\n    }\n    // 9.由于我们使用的是tapAsync异步调用，所以必须执行一个回调函数cb，否则打包后就只会创建一个空的dist文件夹。\n    cb();\n  })\n}\nmodule.exports = FileListPlugin;\nmodule.exports = {\n  new FileListPlugin({\n    filename: 'fileList.md'\n  })\n}\n```\n\n#### 2. CompressAssetsPlugin\n\n需求：每次打包完成后，将打包生成的文件生成一个压缩包。\n\n``` js\nconst JSZip = require('jszip');\nconst { RawSource } = require('webpack-sources');\n/*\n  将本次打包的资源都打包成为一个压缩包\n  需求:获取所有打包后的资源\n*/\n\nconst pluginName = 'CompressAssetsPlugin';\n\nclass CompressAssetsPlugin {\n  constructor({ output }) {\n    this.output = output;\n  }\n\n  apply(compiler) {\n    // AsyncSeriesHook 将 assets 输出到 output 目录之前调用该钩子\n    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) =\u003e {\n      // 创建zip对象\n      const zip = new JSZip();\n      // 获取本次打包生成所有的assets资源\n      const assets = compilation.getAssets();\n      // 循环每一个资源\n      assets.forEach(({ name, source }) =\u003e {\n        // 调用source()方法获得对应的源代码 这是一个源代码的字符串\n        const sourceCode = source.source();\n        // 往 zip 对象中添加资源名称和源代码内容\n        zip.file(name, sourceCode);\n      });\n      // 调用 zip.generateAsync 生成 zip 压缩包\n      zip.generateAsync({ type: 'nodebuffer' }).then((result) =\u003e {\n        // 通过 new RawSource 创建压缩包\n        // 并且同时通过 compilation.emitAsset 方法将生成的 Zip 压缩包输出到 this.output\n        compilation.emitAsset(this.output, new RawSource(result));\n        // 调用 callback 表示本次事件函数结束\n        callback();\n      });\n    });\n  }\n}\n\nmodule.exports = CompressAssetsPlugin;\n```\n\n#### 3. BundleSizeWebpackPlugin\n\n需求：文件超过一定大小时给出警告\n\n``` js\nconst { resolve } = require('path')\nconst fs = require('fs')\n\nclass BundleSizeWebpackPlugin {\n  constructor(options) {\n    this.options = options\n  }\n  apply(compiler) {\n    const { sizeLimit } = this.options\n    console.log('bundle size plugin')\n    // 在编译完成后，执行回调，拿到打包后文件路径，然后读取文件信息获取文件大小，然后定义一些逻辑\n    compiler.hooks.done.tap('BundleSizePlugin', stats =\u003e {\n      const { path, filename } = stats.compilation.outputOptions\n      const bundlePath = resolve(path, filename)\n      const { size } = fs.statSync(bundlePath)\n      const bundleSize = size / 1024\n      if (bundleSize \u003c sizeLimit) {\n        console.log(\n          'safe: bundle-size',\n          bundleSize,\n          '\\n size limit: ',\n          sizeLimit\n        )\n      } else {\n        console.warn(\n          'unsafe: bundle-size',\n          bundleSize,\n          '\\n size limit: ',\n          sizeLimit\n        )\n      }\n    })\n  }\n}\n\nmodule.exports = BundleSizeWebpackPlugin\n```\n\n### 常用插件\n\n目前，webpack社区已经有很多成熟的插件了，如果非特殊需求，不用自定义插件。下面介绍几个常用的插件。\n\n#### 1. html-webpack-plugin\n\n`html-webpack-plugin`可以在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中。\n\n``` js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: path.join(__dirname, '/index.html'),\n      minify: {\n        // 压缩HTML文件\n        removeComments: true, // 移除HTML中的注释\n        collapseWhitespace: true, // 删除空白符与换行符\n        minifyCSS: true, // 压缩内联css\n      },\n      inject: true,\n    }),\n  ]\n}\n```\n\n**inject 有四个选项值**\n\n- `true`：默认值，*script* 标签位于 *html* 文件的 *body* 底部\n- `body`：*script* 标签位于 *html* 文件的 *body* 底部（同 *true*）\n- `head`：*script* 标签位于 *head* 标签内\n- `false`：不插入生成的 *js* 文件，只是单纯的生成一个 *html* 文件\n\n#### 2. clean-webpack-plugin\n\n`clean-webpack-plugin` 用于在打包前清理上一次项目生成的 `bundle` 文件，它会根据 `output.path` 自动清理文件夹。\n\n``` js\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.join(__dirname, '/index.html'),\n    }),\n    new CleanWebpackPlugin(), // 所要清理的文件夹名称\n  ]\n}\n```\n\n#### 3. extract-text-webpack-plugin\n\n将css样式从js文件中提取出来最终合成一个css文件，该插件只支持webpack4之前的版本，如果你当前是webpack4及以上版本那么就会报错。\n\n``` js\nconst extractTextPlugin = require('extract-text-webpack-plugin');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: extractTextPlugin.extract({\n          fallback: \"style-loader\",\n          use: \"css-loader\"\n        })\n      }\n    ]\n  },\n  plugins: [\n    new extractTextPlugin({\n      filename: \"[name].css\",\n      allChunks: true\n    })\n  ]\n}\n```\n\n#### 4. mini-css-extract-plugin\n\n该插件与上面的`extract-text-webpack-plugin`的一样，都是将css样式提取出来, 唯一就是用法不同，本插件的webpack4版本之后推荐使用。\n\n``` js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          \"css-loader\"\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: \"css/[name].css\",\n      chunkFilename: \"css/[name].css\"\n    })\n  ]\n}\n```\n\n#### 5. purifycss-webpack\n\n有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。\n\n``` js\nconst path = require('path')\nconst PurifyCssWebpack = require('purifycss-webpack') // 引入PurifyCssWebpack插件\nconst glob = require('glob') // 引入glob模块,用于扫描全部html文件中所引用的css\n\nmodule.exports = merge(common, {\n  plugins: [\n    new PurifyCssWebpack({\n      paths: glob.sync(path.join(__dirname, 'src/*.html')),\n    }),\n  ],\n})\n```\n\n#### 6. optimize-css-assets-webpack-plugin\n\n`optimize-css-assets-webpack-plugin` 用于优化和最小化 css 的插件，它会压缩 css，但是不会像 cssnano 那样移除或合并样式。\n\n``` js\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\") // 压缩css代码\n\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      // 压缩css\n      new OptimizeCSSAssetsPlugin({})\n    ]\n  }\n}\n```\n\n#### 7. DefinePlugin\n\n用于注入全局变量，一般用在环境变量上。无需安装，webpack内置\n\n``` js\nconst Webpack = require(\"webpack\")\nmodule.exports = {\n  plugins: [\n    new Webpack.DefinePlugin({\n      STR: JSON.stringify(\"蛙人\"),\n      \"process.env\": JSON.stringify(\"dev\"),\n      name: \"蛙人\"\n    })\n  ]\n}\n```\n\n#### 8. copy-webpack-plugin\n\n`copy-webpack-plugin` 用于在 webpack 中拷贝文件和文件夹，比如我们需要把一些静态文件拷贝到打包目录，这时候就可以使用这个插件。\n\n``` js\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nmodule.exports = {\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: 'public/js/*.js',\n          to: path.resolve(__dirname, 'dist', 'js'),\n          flatten: true,\n        },\n      ],\n    }),\n  ],\n}\n```\n\n#### 9. imagemin-webpack-plugin\n\n用于压缩图片。\n\n``` js\nconst ImageminPlugin =  require('imagemin-webpack-plugin').default\nmodule.exports = {\n  plugins: [\n    new ImageminPlugin({\n        test: /\\.(jpe?g|png|gif|svg)$/i\n    })\n  ]\n}\n```\n\n\n来源：https://zhuanlan.zhihu.com/p/661670534","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## Webpack Plugin插件机制\n\n### plugin机制出现原因\n\n前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。\n\n那如果我们需要在项目中实现`打包前自动清理上次打包生成的文件`、`将一些文件复制到打包目录中`、`自动生成html文件`、`将打包产物自动上传至服务器`、`将打包后代码进行压缩、拆分`等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。\n\n没错，webpack的plugin机制让webpack有了定制化的能力。\n\n### plugin原理\n\n那具体如何通过plugin机制去实现这些定制化功能呢？\n\n其实是webpack在打包过程中的不同阶段（配置文件读取完成后、打包开始前、打包完成后等阶段）会触发不同的钩子，我们只需要明确要实现的功能应该在哪个阶段，然后将具体实现代码注册为对应钩子的事件即可。\n\n### webpack运行原理\n\n我们在了解这些钩子之前，必须要知道webpack的运行原理。\n\n这是一个简化版的webpack打包过程，当我们执行 `webpack build` 命令后，webpack会先读取配置文件，然后根据配置文件中的配置项去初始化，创建一个 `compiler` 对象，然后调用 `compiler` 对象的 `run` 方法，初始化一个 `compilation` 对象，执行 `compilation` 中的 `build` 方法进行编译，编译完成后，触发 `compiler` 对象的 `done` 钩子，完成打包。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82)\n\n``` js\n//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数\nfunction webpack(webpackOptions) {\n  //第二步：用配置参数对象初始化 `Compiler` 对象\n  const compiler = new Compiler(webpackOptions);\n  //第三步：挂载配置文件中的插件\n const { plugins } = webpackOptions;\n for (let plugin of plugins) {\n   plugin.apply(compiler);\n }\n  return compiler;\n}\n```\n\n``` js\n//Compiler其实是一个类，它是整个编译过程的大管家，而且是单例模式\nclass Compiler {\n  constructor(webpackOptions) {\n   //省略\n  }\n\n  // 第五步：创建compilation对象\n  compile(callback){\n    //虽然webpack只有一个Compiler，但是每次编译都会产出一个新的Compilation，\n    //这里主要是为了考虑到watch模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译\n    //每次编译都会产出一个新的Compilation，代表每次的编译结果\n    let compilation = new Compilation(this.options);\n    compilation.build(callback); //执行compilation的build方法进行编译，编译成功之后执行回调\n  }\n\n  //第四步：执行`Compiler`对象的`run`方法开始执行编译\n  run(callback) {\n    this.hooks.run.call(); //在编译前触发run钩子执行，表示开始启动编译了\n    const onCompiled = () =\u003e {\n      // 第七步：当编译成功后会触发done这个钩子执行\n      this.hooks.done.call();\n    };\n    this.compile(onCompiled); //开始编译，成功之后调用onCompiled\n  }\n}\n\n\nclass Compilation {\n  constructor(webpackOptions) {\n    this.options = webpackOptions;\n    this.modules = []; //本次编译所有生成出来的模块\n    this.chunks = []; //本次编译产出的所有代码块，入口模块和依赖的模块打包在一起为代码块\n    this.assets = {}; //本次编译产出的资源文件\n    this.fileDependencies = []; //本次打包涉及到的文件，这里主要是为了实现watch模式下监听文件的变化，文件发生变化后会重新编译\n  }\n\n  //第六步：执行compilation的build方法进行编译\n  build(callback) {\n  //这里开始做编译工作，编译成功执行callback\n\n  // ... 编译过程代码省略\n\n  // 编译完成后，触发callback回调\n  callback()\n  }\n}\n```\n\n\u003c!-- more --\u003e\n\n### compiler 与 compilation\n\n那上面提到的 `compiler` 对象和 `compilation` 对象到底是什么呢？又有什么区别与联系？\n\n- `compiler` 对象包含了webpack的所有配置信息，包括`entry`、`output`、`module`、`plugins`等，`compiler` 对象会在启动webpack时，一次性地初始化创建，它是全局唯一的，可以简单理解为webpack的实例。\n- `compilation` 对象代表一次资源的构建，通过一系列API可以访问/修改本次模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息等，当我们以开发模式运行webpack时，每当检测到一个文件变化，就会创建一个新的 `compilation` 对象，所以 `compilation` 对象也是一次性的，只能用于当前的编译。\n\n**他有以下主要属性：**\n\n- `compilation.modules` 解析后的所有模块\n- `compilation.chunks` 所有的代码分块chunk\n- `compilation.assets` 本次打包生成的所有文件\n- `compilation.hooks` compilation所有的钩子\n\n所以说呢，`compiler` 代表的是整个 webpack 从启动到关闭的生命周期（终端结束，该生命周期结束）， 而 `compilation` 只是代表了一次性的编译过程，如果是watch模式，每次监听到文件变化，都会产生一个新的 `compilation`，所以 `compilation` 代表一次资源的构建，会多次被创建，而 `compiler` 只会被创建一次。\n\n**我们了解了`compiler`和`compilation`对象后，就可以来看一下到底有哪些钩子。**\n\n### compiler钩子\ncompiler有很多钩子[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，介绍几个常用的：\n\n- `environment` SyncHook类型，在编译器准备环境时调用，时机就在配置文件中初始化插件之后。\n- `afterEnvironment` SyncHook类型，当编译器环境设置完成后，在 `environment hook` 后直接调用。\n- `entryOption` SyncBailHook类型，在 `webpack` 选项中的 `entry` 被处理过之后调用。\n- `afterPlugins` SyncHook类型，在插件初始化之后。\n- `afterResolvers` SyncHook类型，`resolver` 设置完成之后触发。\n- `beforeRun` AsyncSeriesHook类型，在开始执行一次构建之前调用，`compiler.run` 方法开始执行后立刻进行调用。\n- `run` AsyncSeriesHook类型，在开始读取 `records` 之前调用。\n- `watchRun` AsyncSeriesHook类型，在监听模式下，一个新的 `compilation` 触发之后，但在 `compilation` 实际开始之前触发。\n- `beforeCompile` AsyncSeriesHook类型，在创建 `compilation` 参数之后执行。\n- `compile` SyncHook类型，`beforeCompile` 之后立即调用，但在一个新的 `compilation` 创建之前。\n- `thisCompilation` SyncHook类型，初始化 `compilation` 时调用，在触发 `compilation` 事件之前调用。\n- `compilation` SyncHook类型，一次新的编译 `compilation` 创建之后触发。\n- `make` AsyncParallelHook类型，`compilation` 结束之前执行，`seal` 之前执行。\n- `afterCompile` AsyncSeriesHook类型，`compilation` 结束和封印之后执行。\n- `shouldEmit` SyncBailHook类型，在输出 `asset` 之前调用。返回一个布尔值，告知是否输出。\n- `emit` AsyncSeriesHook类型，生成资源到 `output` 目录之前触发。\n- `afterEmit` AsyncSeriesHook类型，输出 `asset` 到 `output` 目录之后执行。\n- `done` AsyncSeriesHook类型，`compilation` 编译完成后触发。\n- `failed` SyncHook类型，`compilation` 编译失败后触发。\n\n### compilation钩子\n\ncompilation对象也有很多钩子[官方地址](https://webpack.js.org/api/compilation-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compilation-hooks/)，介绍几个常用的：\n\n- `buildModule` SyncHook类型，模块开始编译前，执行该钩子，可以用于修改模块内容。\n- `succeedModule` SyncHook类型，模块编译成功后，执行该钩子。\n- `finishModules` AsyncSeriesHook类型，所有模块编译完成后，执行该钩子。\n- `moduleAsset` SyncHook类型，一个模块中的一个 asset 被添加到 compilation 时调用。\n- `chunkAsset` SyncHook类型，一个 chunk 中的 asset 被添加到 compilation 时调用。\n- `seal` SyncHook类型，在构建过程封存前触发，允许在最终资源生成之前进行一些操作。\n- `optimize` SyncHook类型，优化阶段开始时触发，可以用于自定义资源优化逻辑。\n- `optimizeAssets` AsyncSeriesHook类型，优化存储在 compilation.assets 中的所有 asset，可以监听和修改资源的优化过程。\n- `afterOptimizeAssets` SyncHook类型，asset 已经优化。\n- `optimizeTree` AsyncSeriesHook类型，在优化依赖树之前触发，允许修改资源树的优化逻辑。\n- `afterOptimizeTree` SyncHook类型，在优化依赖树之后触发，可用于处理优化完成后的资源树。\n- `optimizeChunkAssets` AsyncSeriesHook类型，优化所有 chunk asset，弃用，可使用 processAssets 来代替，可用于自定义块资源的优化逻辑。\n- `processAssets` AsyncSeriesHook类型，asset 处理时触发，可以监听和修改资源的生成。\n- `beforeHash` SyncHook类型，在 compilation 添加哈希（hash）之前。\n- `afterHash` SyncHook类型，在 compilation 添加哈希（hash）之后。\n- `beforeModuleAssets` SyncHook类型，在创建模块 asset 之前执行，可用于在模块资源生成前执行一些操作。\n\n每个钩子都有对应的类型，那这些类型有什么区别呢？\n\n## Tapable\n\n[Tapable](https://github.com/webpack/tapable)是一个提供**事件发布订阅**的工具，通过其提供的一系列钩子，我们可以注册事件，然后在不同的阶段去触发这些注册的事件。 webpack的plugin机制正是基于 Tapable 实现的，在不同编译阶段触发不同的钩子。\n\nTapable 官方文档提供了这九种钩子，也就是我们上面提到的钩子类型：\n\n``` js\nconst {\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  SyncLoopHook,\n  AsyncParallelHook,\n  AsyncParallelBailHook,\n  AsyncSeriesHook,\n  AsyncSeriesBailHook,\n  AsyncSeriesWaterfallHook\n} = require(\"tapable\");\n```\n\n可以看到，这些钩子有两种开头，分别是 `Sync` 和 `Async` ，这两种钩子的区别是： `Sync` 开头的为同步钩子，表示注册的事件函数会同步进行执行；`Async` 开头的为异步钩子，表示注册的事件函数会异步进行执行\n\n同时呢，这些钩子还有三种结尾，分别是`Hook`、`BailHook`、`WaterfallHook`、`LoopHook`，\n\n这三种结尾的区别是如下所示\n\n- `Hook`结尾的为普通钩子，只会按顺序挨个执行注册的事件，不会去管事件函数的返回值是什么。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab)\n\n- `BailHook`结尾的为保险钩子，只要注册的事件函数有一个返回值不为`undefined`，就会停止执行后面的事件函数。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5)\n\n- `WaterfallHook`结尾的为瀑布钩子，注册的事件函数会按顺序执行，每个事件函数的返回值会作为下一个事件函数的参数，只会影响下一个事件函数的第一个参数。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143)\n\n- `LoopHook`结尾的为循环钩子，注册的事件函数会按顺序执行，只要执行的事件返回值非`undefined`，就会立即重头开始执行，直到所有的事件函数都返回`undefined`，这个钩子才会结束。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7)\n\n接下来，我们又发现，异步钩子又是以`AsyncParallel`、`AsyncSeries`开头，这又有什么区别呢？\n\n- `AsyncSeries` 为异步串行钩子，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。\n- `AsyncParallel` 为异步并行钩子，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。\n\n下面我们就来讲一下这些钩子如何去使用。\n\n### Tapable同步钩子\n\n同步钩子只需要调用 `tap` 方法注册事件，然后调用 `call` 方法触发事件即可。\n\n#### 1. SyncHook\n\nSyncHook 是一个同步的、普通类型的 Hook，注册的事件函数会按顺序挨个执行，不会去管事件函数的返回值是什么。\n\n``` js\nconst { SyncHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) =\u003e {\n  console.log('事件1执行:', name, age);\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) =\u003e {\n  console.log('事件2执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 前端 18\n```\n\n#### 2. SyncBailHook\n\nSyncBailHook 是一个同步的、保险类型的 Hook，意思是只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { SyncBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) =\u003e {\n  console.log('事件1执行:', name, age);\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) =\u003e {\n  console.log('事件2执行:', name, age);\n  return 'abc'\n});\n\n// 注册事件3\nhook.tap('事件3', (name, age) =\u003e {\n  console.log('事件3执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 前端 18\n```\n\n#### 3. SyncWaterfallHook\n\nSyncWaterfallHook 是一个同步的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。\n\n``` js\nconst { SyncWaterfallHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncWaterfallHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) =\u003e {\n  console.log('事件1执行:', name, age);\n  return '驿站'\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) =\u003e {\n  console.log('事件2执行:', name, age);\n});\n\n// 注册事件3\nhook.tap('事件3', (name, age) =\u003e {\n  console.log('事件3执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 驿站 18\n// 事件3执行: 驿站 18\n```\n\n#### 4. SyncLoopHook\n\nSyncLoopHook 是一个同步的、循环类型的 Hook，只要执行的事件函数返回值非undefeind，就会立即重头开始执行，直到所有的事件函数都返回undefined，这个钩子才会结束。\n\n``` js\nconst { SyncLoopHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncLoopHook();\n\nlet count = 5;\n\n// 注册事件1\nhook.tap('事件1', () =\u003e {\n  count--;\n  console.log('事件1执行,count为',count);\n  if (count \u003e 3) {\n    return true;\n  }\n});\n\n// 注册事件2\nhook.tap('事件2', () =\u003e {\n  count--;\n  console.log('事件2执行,count为',count);\n  if (count \u003e 1) {\n    return true;\n  }\n});\n\n// 注册事件3\nhook.tap('事件3', () =\u003e {\n  console.log('事件3执行,count为',count);\n});\n\n// 触发事件\nhook.call();\n\n// 执行结果\n// 事件1执行,count为 4\n// 事件1执行,count为 3\n// 事件2执行,count为 2\n// 事件1执行,count为 1\n// 事件2执行,count为 0\n// 事件3执行,count为 0\n```\n\n### Tapable异步钩子\n\n异步钩子提供三种注册的方法：\n\n- `tap`：以同步方式注册钩子，用 `call` 来触发，跟同步钩子一样，只不过加持了异步的能力，不过多讲解。\n- `tapAsync`: 以异步方式注册钩子，用 `callAsync` 触发，同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成，下面有使用示例。\n- `tapPromise`: 以异步方式注册钩子，用 `promise` 的方式触发,下面有使用示例。\n\n#### 1. AsyncParallelHook\n\nAsyncParallelHook 是一个异步的、并行类型的 Hook，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。\n\n``` js\nconst { AsyncParallelHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncParallelHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) =\u003e {\n  console.log('事件2执行:', name, age);\n  // 调用callback，表示该事件执行完毕\n  callback();\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) =\u003e {\n  console.log('事件3执行:', name, age);\n  // 调用callback，表示该事件执行完毕\n  callback();\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, () =\u003e {\n  // 该钩子注册的所有事件执行完毕后，会执行该回调\n  console.log('该钩子所有事件执行完毕');\n});\n\n// 执行结果\n// 事件2执行: 前端 18\n// 事件3执行: 前端 18\n// 2秒后输出：事件1执行: 前端 18\n// 该钩子所有事件执行完毕\n```\n\n#### 2. AsyncParallelBailHook\n\nAsyncParallelBailHook 是一个异步、并行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { AsyncParallelBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncParallelBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tapPromise('事件1', (name, age) =\u003e {\n  return new Promise((resolve) =\u003e {\n    setTimeout(() =\u003e {\n      console.log('事件1执行:', name, age);\n      resolve('123');\n    }, 2000);\n  })\n});\n\n// 注册事件2\nhook.tapPromise('事件2', (name, age) =\u003e {\n  return new Promise((resolve) =\u003e {\n    setTimeout(() =\u003e {\n      console.log('事件2执行:', name, age);\n      resolve();\n    }, 3000);\n  })\n});\n\n// 注册事件3\nhook.tapPromise('事件3', (name, age, callback) =\u003e {\n  return new Promise((resolve) =\u003e {\n    console.log('事件3执行:', name, age);\n    resolve();\n  })\n});\n\n// 触发事件，传入实参\nhook.promise('前端', 18).then((res) =\u003e {\n  // 该钩子注册的所有事件执行完毕后，会执行该回调\n  console.log('该钩子所有事件执行完毕',res);\n})\n\n// 执行结果\n// 事件3执行: 前端 18\n// 2秒后输出：事件1执行: 前端 18\n// 该钩子所有事件执行完毕123\n```\n\n#### 3. AsyncSeriesHook\n\nAsyncSeriesHook 是一个异步的、串行类型的 Hook，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。\n\n``` js\nconst { AsyncSeriesHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null, '123');\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件2执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) =\u003e {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 前端 18\n// 事件1执行: 前端 18\n// 该钩子所有事件执行完毕123\n```\n\n#### 4. AsyncSeriesBailHook\n\nAsyncSeriesBailHook 是一个异步的、串行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { AsyncSeriesBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件2执行:', name, age);\n    callback(null, \"88717\");\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) =\u003e {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 前端 18\n// 该钩子所有事件执行完毕88717\n```\n\n#### 5. AsyncSeriesWaterfallHook\n\nAsyncSeriesWaterfallHook 是一个异步的、串行的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。\n\n``` js\nconst { AsyncSeriesWaterfallHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesWaterfallHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null,3);\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件2执行:', name, age);\n    callback(null, 2);\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) =\u003e {\n  setTimeout(() =\u003e {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null, 1);\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) =\u003e {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 1 18\n// 事件1执行: 2 18\n// 该钩子所有事件执行完毕3\n```\n\n### 如何自定义plugin\n\n了解Tapable之后，我们就可以学习如何自定义plugin了。\n\nwebpack 插件由以下几部分组成：\n\n- 一个 `JavaScript` 类 一个构造方法，可以接受一个 `options` 对象参数\n- 一个 `apply` 方法，该方法在 `webpack` 装载这个插件的时候被调用，并且会传入 `compiler` 对象\n根据我们的需求，确定要在哪个阶段挂载到哪个钩子上，根据钩子的类型（同步/异步），选择合适的事件注册方式，将需求实现代码注册为事件。\n\n事件回调中具体有哪些参数，需要根据钩子的类型去官网查看[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，这里就不一一列举了。\n\n\u003e 注意 ： webpack4 可以用 plugin方法来注册插件，webpack5之后被取消了。\n\u003e compiler.plugin('emit', function (compilation, cb) {})\n\n``` js\nclass BasicPlugin{\n  // 在构造函数中获取用户给该插件传入的配置项\n  constructor(options){\n    this.options = options;\n  }\n\n  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply(compiler) {\n    // 注册第1个事件, 这个事件名叫什么都无所谓，只是个标示而已\n    compiler.hooks.run.tapAsync('BasicPlugin', (compiler, callback) =\u003e {\n      console.log('以异步方式触及 run 钩子。')\n      callback()\n    })\n\n    // 注册第2个事件\n    // 在compiler的compilation钩子上注册一个事件BasicPlugin\n    compiler.hooks.compilation.tap('BasicPlugin', (compilation) =\u003e {\n      // 测试compilation对象在模块构建之前能得到什么\n      compilation.hooks.buildModule.tap('BasicPlugin', (data) =\u003e {\n          console.log(data);\n      })\n    })\n\n    // 注册第3个事件\n    compiler.hooks.emit.tap('BasicPlugin', (compilation) =\u003e {\n      // 业务逻辑代码\n    });\n  }\n}\n\nmodule.exports = BasicPlugin;\n```\n\n``` js\n// webpack.config.js\nconst path = require('path');\nconst BasicPlugin = require('./BasicPlugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  plugins: [\n    new BasicPlugin(),\n  ]\n}\n```\n\n\n### 自定义plugin实战\n\n为了更好的实践，给大家提供3个自定义插件来参考。\n\n#### 1. FileListPlugin\n\n需求：在打包完成后，生成一个`fileList.md`文件，文件内容为打包生成的所有文件名。\n\n```\n# 一共有2个文件\n\n- main.bundle.js\n- index.html\n```\n\n代码实现\n\n``` js\nfunction FileListPlugin (options) {\n  this.options = options || {};\n  this.filename = this.options.filename || 'fileList.md'\n}\n\nFileListPlugin.prototype.apply = function (compiler) {\n  // 1.通过compiler.hooks.emit.tapAsync()来触发生成资源到output目录之前的钩子，且回调函数会有两个参数，一个是compilation，一个是cb回调函数\n  compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, cb) =\u003e {\n    // 2.要生成的markdown文件的名称\n    const fileListName = this.filename;\n    // 3.通过compilation.assets获取到所有待生成的文件，这里是获取它的长度\n    let len = Object.keys(compilation.assets).length;\n    // 4.定义markdown文件的内容，也就是先定义一个一级标题，\\n表示的是换行符\n    let content = `# 一共有${len}个文件\\n\\n`;\n    // 5.将每一项文件的名称写入markdown文件内\n    for (let filename in compilation.assets) {\n      content += `- ${filename}\\n`\n    }\n    // 6.给我们即将生成的dist文件夹里添加一个新的资源，资源的名称就是fileListName变量\n    compilation.assets[fileListName] = {\n      // 7.写入资源的内容\n      source: function () {\n        return content;\n      },\n      // 8.指定新资源的大小，用于webpack展示\n      size: function () {\n        return content.length;\n      }\n    }\n    // 9.由于我们使用的是tapAsync异步调用，所以必须执行一个回调函数cb，否则打包后就只会创建一个空的dist文件夹。\n    cb();\n  })\n}\nmodule.exports = FileListPlugin;\nmodule.exports = {\n  new FileListPlugin({\n    filename: 'fileList.md'\n  })\n}\n```\n\n#### 2. CompressAssetsPlugin\n\n需求：每次打包完成后，将打包生成的文件生成一个压缩包。\n\n``` js\nconst JSZip = require('jszip');\nconst { RawSource } = require('webpack-sources');\n/*\n  将本次打包的资源都打包成为一个压缩包\n  需求:获取所有打包后的资源\n*/\n\nconst pluginName = 'CompressAssetsPlugin';\n\nclass CompressAssetsPlugin {\n  constructor({ output }) {\n    this.output = output;\n  }\n\n  apply(compiler) {\n    // AsyncSeriesHook 将 assets 输出到 output 目录之前调用该钩子\n    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) =\u003e {\n      // 创建zip对象\n      const zip = new JSZip();\n      // 获取本次打包生成所有的assets资源\n      const assets = compilation.getAssets();\n      // 循环每一个资源\n      assets.forEach(({ name, source }) =\u003e {\n        // 调用source()方法获得对应的源代码 这是一个源代码的字符串\n        const sourceCode = source.source();\n        // 往 zip 对象中添加资源名称和源代码内容\n        zip.file(name, sourceCode);\n      });\n      // 调用 zip.generateAsync 生成 zip 压缩包\n      zip.generateAsync({ type: 'nodebuffer' }).then((result) =\u003e {\n        // 通过 new RawSource 创建压缩包\n        // 并且同时通过 compilation.emitAsset 方法将生成的 Zip 压缩包输出到 this.output\n        compilation.emitAsset(this.output, new RawSource(result));\n        // 调用 callback 表示本次事件函数结束\n        callback();\n      });\n    });\n  }\n}\n\nmodule.exports = CompressAssetsPlugin;\n```\n\n#### 3. BundleSizeWebpackPlugin\n\n需求：文件超过一定大小时给出警告\n\n``` js\nconst { resolve } = require('path')\nconst fs = require('fs')\n\nclass BundleSizeWebpackPlugin {\n  constructor(options) {\n    this.options = options\n  }\n  apply(compiler) {\n    const { sizeLimit } = this.options\n    console.log('bundle size plugin')\n    // 在编译完成后，执行回调，拿到打包后文件路径，然后读取文件信息获取文件大小，然后定义一些逻辑\n    compiler.hooks.done.tap('BundleSizePlugin', stats =\u003e {\n      const { path, filename } = stats.compilation.outputOptions\n      const bundlePath = resolve(path, filename)\n      const { size } = fs.statSync(bundlePath)\n      const bundleSize = size / 1024\n      if (bundleSize \u003c sizeLimit) {\n        console.log(\n          'safe: bundle-size',\n          bundleSize,\n          '\\n size limit: ',\n          sizeLimit\n        )\n      } else {\n        console.warn(\n          'unsafe: bundle-size',\n          bundleSize,\n          '\\n size limit: ',\n          sizeLimit\n        )\n      }\n    })\n  }\n}\n\nmodule.exports = BundleSizeWebpackPlugin\n```\n\n### 常用插件\n\n目前，webpack社区已经有很多成熟的插件了，如果非特殊需求，不用自定义插件。下面介绍几个常用的插件。\n\n#### 1. html-webpack-plugin\n\n`html-webpack-plugin`可以在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中。\n\n``` js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: path.join(__dirname, '/index.html'),\n      minify: {\n        // 压缩HTML文件\n        removeComments: true, // 移除HTML中的注释\n        collapseWhitespace: true, // 删除空白符与换行符\n        minifyCSS: true, // 压缩内联css\n      },\n      inject: true,\n    }),\n  ]\n}\n```\n\n**inject 有四个选项值**\n\n- `true`：默认值，*script* 标签位于 *html* 文件的 *body* 底部\n- `body`：*script* 标签位于 *html* 文件的 *body* 底部（同 *true*）\n- `head`：*script* 标签位于 *head* 标签内\n- `false`：不插入生成的 *js* 文件，只是单纯的生成一个 *html* 文件\n\n#### 2. clean-webpack-plugin\n\n`clean-webpack-plugin` 用于在打包前清理上一次项目生成的 `bundle` 文件，它会根据 `output.path` 自动清理文件夹。\n\n``` js\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.join(__dirname, '/index.html'),\n    }),\n    new CleanWebpackPlugin(), // 所要清理的文件夹名称\n  ]\n}\n```\n\n#### 3. extract-text-webpack-plugin\n\n将css样式从js文件中提取出来最终合成一个css文件，该插件只支持webpack4之前的版本，如果你当前是webpack4及以上版本那么就会报错。\n\n``` js\nconst extractTextPlugin = require('extract-text-webpack-plugin');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: extractTextPlugin.extract({\n          fallback: \"style-loader\",\n          use: \"css-loader\"\n        })\n      }\n    ]\n  },\n  plugins: [\n    new extractTextPlugin({\n      filename: \"[name].css\",\n      allChunks: true\n    })\n  ]\n}\n```\n\n#### 4. mini-css-extract-plugin\n\n该插件与上面的`extract-text-webpack-plugin`的一样，都是将css样式提取出来, 唯一就是用法不同，本插件的webpack4版本之后推荐使用。\n\n``` js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          \"css-loader\"\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: \"css/[name].css\",\n      chunkFilename: \"css/[name].css\"\n    })\n  ]\n}\n```\n\n#### 5. purifycss-webpack\n\n有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。\n\n``` js\nconst path = require('path')\nconst PurifyCssWebpack = require('purifycss-webpack') // 引入PurifyCssWebpack插件\nconst glob = require('glob') // 引入glob模块,用于扫描全部html文件中所引用的css\n\nmodule.exports = merge(common, {\n  plugins: [\n    new PurifyCssWebpack({\n      paths: glob.sync(path.join(__dirname, 'src/*.html')),\n    }),\n  ],\n})\n```\n\n#### 6. optimize-css-assets-webpack-plugin\n\n`optimize-css-assets-webpack-plugin` 用于优化和最小化 css 的插件，它会压缩 css，但是不会像 cssnano 那样移除或合并样式。\n\n``` js\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\") // 压缩css代码\n\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      // 压缩css\n      new OptimizeCSSAssetsPlugin({})\n    ]\n  }\n}\n```\n\n#### 7. DefinePlugin\n\n用于注入全局变量，一般用在环境变量上。无需安装，webpack内置\n\n``` js\nconst Webpack = require(\"webpack\")\nmodule.exports = {\n  plugins: [\n    new Webpack.DefinePlugin({\n      STR: JSON.stringify(\"蛙人\"),\n      \"process.env\": JSON.stringify(\"dev\"),\n      name: \"蛙人\"\n    })\n  ]\n}\n```\n\n#### 8. copy-webpack-plugin\n\n`copy-webpack-plugin` 用于在 webpack 中拷贝文件和文件夹，比如我们需要把一些静态文件拷贝到打包目录，这时候就可以使用这个插件。\n\n``` js\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nmodule.exports = {\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: 'public/js/*.js',\n          to: path.resolve(__dirname, 'dist', 'js'),\n          flatten: true,\n        },\n      ],\n    }),\n  ],\n}\n```\n\n#### 9. imagemin-webpack-plugin\n\n用于压缩图片。\n\n``` js\nconst ImageminPlugin =  require('imagemin-webpack-plugin').default\nmodule.exports = {\n  plugins: [\n    new ImageminPlugin({\n        test: /\\.(jpe?g|png|gif|svg)$/i\n    })\n  ]\n}\n```\n\n\n来源：https://zhuanlan.zhihu.com/p/661670534"]},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"647"},"buildId":"a3cZ70FNaLN28WmGwcIOw","assetPrefix":"/frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>