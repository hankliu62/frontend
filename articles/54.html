<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具集合</title><link rel="icon" href="/toolbox-frontend/favicon.ico"/><meta name="description" content="卡鲁秋的前端工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋"/><meta name="author" content="Hank.Liu"/><meta name="next-head-count" content="7"/><link rel="stylesheet" href="/toolbox-frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/toolbox-frontend/_next/static/css/e443953a41d4ccca.css" as="style"/><link rel="stylesheet" href="/toolbox-frontend/_next/static/css/e443953a41d4ccca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/toolbox-frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/toolbox-frontend/_next/static/chunks/webpack-c5f674d417b86779.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/framework-aec4381329cec0e4.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/main-82d23b26b43cd32b.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/_app-baf3db6f3e140b26.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/6396-e9161609a76be07a.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/8490-2f2be535c5ee8413.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/1664-f865873e77459860.js" defer=""></script><script src="/toolbox-frontend/_next/static/chunks/pages/articles/%5Bid%5D-f54ba9d880ba11c9.js" defer=""></script><script src="/toolbox-frontend/_next/static/LqJKClp1oY6FcMMGt_JyX/_buildManifest.js" defer=""></script><script src="/toolbox-frontend/_next/static/LqJKClp1oY6FcMMGt_JyX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1 overflow-x-hidden"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-12jzuas"><div class="ant-card-body"><article><div class="mx-auto mb-[36px] max-w-[1045px] px-[30px] lg:mb-[52px] lg:flex lg:px-0"><div id="banner" class="media-wrapper image-media-wrapper w-full rounded-[8px] border-[1px] border-solid border-[#1D2129] lg:ml-0 lg:h-[320px] lg:w-[500px]"><div class="hidden before"></div><div class="hidden after"></div><div class="scale-103 h-full w-full border-[8px] border-solid border-white lg:scale-100 cover-wrapper"><img class="h-full w-full rounded-md object-cover cover" src="/toolbox-frontend/dashboard/images/banner.png" alt=""/></div></div><div class="mt-[60px] overflow-hidden lg:ml-[32px] lg:mt-0 lg:flex-1"><h1 class="leading-130 montserrat-bold mb-[9px] text-[36px] font-medium text-[#1D2129] lg:mb-[8px]">安宁宝典</h1><div class="mb-[9px] flex whitespace-nowrap lg:mb-[10px]"><div class="leading-120 cursor-pointer truncate text-[24px] font-normal text-[#1D2129] underline-offset-2 hover:underline lg:text-[20px]" aria-hidden="true"># VOL.<!-- -->54</div><div class="leading-120 ml-[48px] text-[24px] font-normal text-[#1D2129] lg:ml-[32px] lg:text-[20px]">2021/07/08</div></div><div class="mb-[12px] flex flex-wrap lg:mb-0"><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">blog</div></div><div class="my-[30px] hidden w-[213px] border border-[#1D2129] lg:mb-[20px] lg:mt-[8px] lg:block"></div><div class="lg:rounded-0 rounded-[12px] bg-white/30 p-[36px] lg:flex lg:bg-transparent lg:p-0"><div class="float-left h-[118px] w-[118px] lg:float-none lg:h-[112px] lg:w-[112px]"><img src="https://avatars.githubusercontent.com/u/8088864?v=4" class="h-full w-full rounded-[8px] object-cover lg:rounded-[12px]" alt=""/></div><div class="lg:ml-[32px] lg:flex-1 lg:overflow-hidden"><div class="mb-[10px] flex h-[118px] flex-col justify-center pl-[36px] lg:h-auto lg:flex-row lg:items-center lg:justify-between lg:pl-0"><div class="leading-130 montserrat-bold mb-[12px] w-full truncate text-[30px] font-medium text-[#1D2129] lg:mb-0 lg:flex-1 lg:text-[24px]">hankliu62</div><a class="leading-170 ml-0 whitespace-pre-wrap text-[20px] font-normal !text-[#1D2129] !underline hover:!text-[#1D2129] hover:!underline focus:!text-[#1D2129] lg:ml-[5px] lg:text-[14px]" href="https://github.com/hankliu62" target="_blank" rel="noreferrer">TA的个人名片</a></div><div class="leading-170 text-[20px] font-normal text-[#4E5969] lg:text-[14px]">HankLiu前端开发工程师，精通前端，涉猎后端，对前端有着浓厚的兴趣，希望能够在前端这条路上一直走下去。努力去听风的声音，不必在意风的方向。</div></div></div></div></div><div class="ant-divider css-12jzuas ant-divider-horizontal !mt-0 !border-[#bfc3c7]" role="separator"></div><section><div><div class="ant-skeleton ant-skeleton-active css-12jzuas"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-12jzuas"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="## 一、Event Loop" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/toolbox-frontend/articles/54#%E4%B8%80event-loop"><div class="truncate" style="padding-left:16px">一、Event Loop</div></a></li><li id="### 宏队列和微队列" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97"><div class="truncate" style="padding-left:32px">宏队列和微队列</div></a></li><li id="### 浏览器中的Event Loop" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84event-loop"><div class="truncate" style="padding-left:32px">浏览器中的Event Loop</div></a></li><li id="### NodeJs中的Event Loop" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#nodejs%E4%B8%AD%E7%9A%84event-loop"><div class="truncate" style="padding-left:32px">NodeJs中的Event Loop</div></a></li><li id="## 二、Fetch API使用的常见问题及其解决办法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BA%8Cfetch-api%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><div class="truncate" style="padding-left:16px">二、Fetch API使用的常见问题及其解决办法</div></a></li><li id="### Fetch 兼容性问题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#fetch-%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:32px">Fetch 兼容性问题</div></a></li><li id="### fetch默认不携带cookie" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#fetch%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%90%BA%E5%B8%A6cookie"><div class="truncate" style="padding-left:32px">fetch默认不携带cookie</div></a></li><li id="### fetch请求对某些错误http状态不会reject" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#fetch%E8%AF%B7%E6%B1%82%E5%AF%B9%E6%9F%90%E4%BA%9B%E9%94%99%E8%AF%AFhttp%E7%8A%B6%E6%80%81%E4%B8%8D%E4%BC%9Areject"><div class="truncate" style="padding-left:32px">fetch请求对某些错误http状态不会reject</div></a></li><li id="### fetch不支持超时timeout处理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#fetch%E4%B8%8D%E6%94%AF%E6%8C%81%E8%B6%85%E6%97%B6timeout%E5%A4%84%E7%90%86"><div class="truncate" style="padding-left:32px">fetch不支持超时timeout处理</div></a></li><li id="### fetch不支持JSONP" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#fetch%E4%B8%8D%E6%94%AF%E6%8C%81jsonp"><div class="truncate" style="padding-left:32px">fetch不支持JSONP</div></a></li><li id="### fetch不支持progress事件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#fetch%E4%B8%8D%E6%94%AF%E6%8C%81progress%E4%BA%8B%E4%BB%B6"><div class="truncate" style="padding-left:32px">fetch不支持progress事件</div></a></li><li id="### fetch跨域问题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#fetch%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:32px">fetch跨域问题</div></a></li><li id="## 三、原型链和继承" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%B8%89%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF"><div class="truncate" style="padding-left:16px">三、原型链和继承</div></a></li><li id="### 函数与对象的关系" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><div class="truncate" style="padding-left:32px">函数与对象的关系</div></a></li><li id="### 函数与原型的关系" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><div class="truncate" style="padding-left:32px">函数与原型的关系</div></a></li><li id="### 原型和实例的关系" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><div class="truncate" style="padding-left:32px">原型和实例的关系</div></a></li><li id="### 原型链" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8E%9F%E5%9E%8B%E9%93%BE"><div class="truncate" style="padding-left:32px">原型链</div></a></li><li id="### 6种继承方法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#6%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95"><div class="truncate" style="padding-left:32px">6种继承方法</div></a></li><li id="#### 第一种: 原型链继承" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AC%AC%E4%B8%80%E7%A7%8D:-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><div class="truncate" style="padding-left:48px">第一种: 原型链继承</div></a></li><li id="#### 第二种: 构造函数继承" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AC%AC%E4%BA%8C%E7%A7%8D:-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><div class="truncate" style="padding-left:48px">第二种: 构造函数继承</div></a></li><li id="#### 第三种: 组合继承" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AC%AC%E4%B8%89%E7%A7%8D:-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><div class="truncate" style="padding-left:48px">第三种: 组合继承</div></a></li><li id="#### 第四种: 原型式继承" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AC%AC%E5%9B%9B%E7%A7%8D:-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><div class="truncate" style="padding-left:48px">第四种: 原型式继承</div></a></li><li id="#### 第五种: 寄生继承" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AC%AC%E4%BA%94%E7%A7%8D:-%E5%AF%84%E7%94%9F%E7%BB%A7%E6%89%BF"><div class="truncate" style="padding-left:48px">第五种: 寄生继承</div></a></li><li id="#### 第六种: 寄生组合继承" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AC%AC%E5%85%AD%E7%A7%8D:-%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><div class="truncate" style="padding-left:48px">第六种: 寄生组合继承</div></a></li><li id="#### 第七种: ES6 Class类和extends关键字" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AC%AC%E4%B8%83%E7%A7%8D:-es6-class%E7%B1%BB%E5%92%8Cextends%E5%85%B3%E9%94%AE%E5%AD%97"><div class="truncate" style="padding-left:48px">第七种: ES6 Class类和extends关键字</div></a></li><li id="## 四、前端性能优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%9B%9B%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:16px">四、前端性能优化</div></a></li><li id="### 1. 减少 HTTP 请求" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#1.-%E5%87%8F%E5%B0%91-http-%E8%AF%B7%E6%B1%82"><div class="truncate" style="padding-left:32px">1. 减少 HTTP 请求</div></a></li><li id="### 2. 使用 HTTP2" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#2.-%E4%BD%BF%E7%94%A8-http2"><div class="truncate" style="padding-left:32px">2. 使用 HTTP2</div></a></li><li id="#### 解析速度快" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E8%A7%A3%E6%9E%90%E9%80%9F%E5%BA%A6%E5%BF%AB"><div class="truncate" style="padding-left:48px">解析速度快</div></a></li><li id="#### 多路复用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><div class="truncate" style="padding-left:48px">多路复用</div></a></li><li id="#### 首部压缩" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9"><div class="truncate" style="padding-left:48px">首部压缩</div></a></li><li id="#### 优先级" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BC%98%E5%85%88%E7%BA%A7"><div class="truncate" style="padding-left:48px">优先级</div></a></li><li id="#### 流量控制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><div class="truncate" style="padding-left:48px">流量控制</div></a></li><li id="#### 服务器推送" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><div class="truncate" style="padding-left:48px">服务器推送</div></a></li><li id="### 3. 使用服务端渲染" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#3.-%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><div class="truncate" style="padding-left:32px">3. 使用服务端渲染</div></a></li><li id="#### 客户端渲染过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:48px">客户端渲染过程</div></a></li><li id="#### 服务端渲染过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:48px">服务端渲染过程</div></a></li><li id="### 4. 静态资源使用 CDN" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#4.-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8-cdn"><div class="truncate" style="padding-left:32px">4. 静态资源使用 CDN</div></a></li><li id="#### CDN 原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#cdn-%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:48px">CDN 原理</div></a></li><li id="### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#5.-%E5%B0%86-css-%E6%94%BE%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8javascript-%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%E5%BA%95%E9%83%A8"><div class="truncate" style="padding-left:32px">5. 将 CSS 放在文件头部，JavaScript 文件放在底部</div></a></li><li id="### 6. 使用字体图标 iconfont 代替图片图标" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#6.-%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87-iconfont-%E4%BB%A3%E6%9B%BF%E5%9B%BE%E7%89%87%E5%9B%BE%E6%A0%87"><div class="truncate" style="padding-left:32px">6. 使用字体图标 iconfont 代替图片图标</div></a></li><li id="#### 压缩字体文件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8E%8B%E7%BC%A9%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6"><div class="truncate" style="padding-left:48px">压缩字体文件</div></a></li><li id="### 7. 善用缓存，不重复加载相同的资源" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#7.-%E5%96%84%E7%94%A8%E7%BC%93%E5%AD%98%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD%E7%9B%B8%E5%90%8C%E7%9A%84%E8%B5%84%E6%BA%90"><div class="truncate" style="padding-left:32px">7. 善用缓存，不重复加载相同的资源</div></a></li><li id="### 8. 压缩文件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#8.-%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><div class="truncate" style="padding-left:32px">8. 压缩文件</div></a></li><li id="### 9. 图片优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#9.-%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">9. 图片优化</div></a></li><li id="#### (1). 图片延迟加载" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#(1).-%E5%9B%BE%E7%89%87%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><div class="truncate" style="padding-left:48px">(1). 图片延迟加载</div></a></li><li id="#### (2). 响应式图片" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#(2).-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E7%89%87"><div class="truncate" style="padding-left:48px">(2). 响应式图片</div></a></li><li id="#### (3). 调整图片大小" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#(3).-%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F"><div class="truncate" style="padding-left:48px">(3). 调整图片大小</div></a></li><li id="#### (4). 降低图片质量" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#(4).-%E9%99%8D%E4%BD%8E%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F"><div class="truncate" style="padding-left:48px">(4). 降低图片质量</div></a></li><li id="#### (5). 尽可能利用 CSS3 效果代替图片" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#(5).-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%88%A9%E7%94%A8-css3-%E6%95%88%E6%9E%9C%E4%BB%A3%E6%9B%BF%E5%9B%BE%E7%89%87"><div class="truncate" style="padding-left:48px">(5). 尽可能利用 CSS3 效果代替图片</div></a></li><li id="#### (6). 使用 webp 格式的图片" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#(6).-%E4%BD%BF%E7%94%A8-webp-%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%9B%BE%E7%89%87"><div class="truncate" style="padding-left:48px">(6). 使用 webp 格式的图片</div></a></li><li id="### 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#10.-%E9%80%9A%E8%BF%87-webpack-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%A0%81%E6%8F%90%E5%8F%96%E7%AC%AC%E4%B8%89%E5%BA%93%E4%BB%A3%E7%A0%81%E5%87%8F%E5%B0%91-es6-%E8%BD%AC%E4%B8%BA-es5-%E7%9A%84%E5%86%97%E4%BD%99%E4%BB%A3%E7%A0%81"><div class="truncate" style="padding-left:32px">10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码</div></a></li><li id="#### 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E5%90%8D%E7%BB%93%E5%90%88-import-%E5%8A%A8%E6%80%81%E5%BC%95%E5%85%A5%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><div class="truncate" style="padding-left:48px">根据文件内容生成文件名，结合 import 动态引入组件实现按需加载</div></a></li><li id="#### 提取第三方库" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%8F%90%E5%8F%96%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><div class="truncate" style="padding-left:48px">提取第三方库</div></a></li><li id="#### 减少 ES6 转为 ES5 的冗余代码" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%87%8F%E5%B0%91-es6-%E8%BD%AC%E4%B8%BA-es5-%E7%9A%84%E5%86%97%E4%BD%99%E4%BB%A3%E7%A0%81"><div class="truncate" style="padding-left:48px">减少 ES6 转为 ES5 的冗余代码</div></a></li><li id="### 11. 减少重绘重排" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#11.-%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92"><div class="truncate" style="padding-left:32px">11. 减少重绘重排</div></a></li><li id="#### 重排" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%87%8D%E6%8E%92"><div class="truncate" style="padding-left:48px">重排</div></a></li><li id="#### 重绘" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%87%8D%E7%BB%98"><div class="truncate" style="padding-left:48px">重绘</div></a></li><li id="### 12. 使用事件委托" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#12.-%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><div class="truncate" style="padding-left:32px">12. 使用事件委托</div></a></li><li id="### 13. 注意程序的局部性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#13.-%E6%B3%A8%E6%84%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7"><div class="truncate" style="padding-left:32px">13. 注意程序的局部性</div></a></li><li id="### 14. if-else 对比 switch" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#14.-if-else-%E5%AF%B9%E6%AF%94-switch"><div class="truncate" style="padding-left:32px">14. if-else 对比 switch</div></a></li><li id="### 15. 查找表" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#15.-%E6%9F%A5%E6%89%BE%E8%A1%A8"><div class="truncate" style="padding-left:32px">15. 查找表</div></a></li><li id="### 16. 避免页面卡顿" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#16.-%E9%81%BF%E5%85%8D%E9%A1%B5%E9%9D%A2%E5%8D%A1%E9%A1%BF"><div class="truncate" style="padding-left:32px">16. 避免页面卡顿</div></a></li><li id="### 17. 使用 requestAnimationFrame 来实现视觉变化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#17.-%E4%BD%BF%E7%94%A8-requestanimationframe-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%86%E8%A7%89%E5%8F%98%E5%8C%96"><div class="truncate" style="padding-left:32px">17. 使用 requestAnimationFrame 来实现视觉变化</div></a></li><li id="### 18. 使用 Web Workers" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#18.-%E4%BD%BF%E7%94%A8-web-workers"><div class="truncate" style="padding-left:32px">18. 使用 Web Workers</div></a></li><li id="### 19. 使用位操作" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#19.-%E4%BD%BF%E7%94%A8%E4%BD%8D%E6%93%8D%E4%BD%9C"><div class="truncate" style="padding-left:32px">19. 使用位操作</div></a></li><li id="#### 取模" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8F%96%E6%A8%A1"><div class="truncate" style="padding-left:48px">取模</div></a></li><li id="#### 取整" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8F%96%E6%95%B4"><div class="truncate" style="padding-left:48px">取整</div></a></li><li id="#### 位掩码" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BD%8D%E6%8E%A9%E7%A0%81"><div class="truncate" style="padding-left:48px">位掩码</div></a></li><li id="### 20. 不要覆盖原生方法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#20.-%E4%B8%8D%E8%A6%81%E8%A6%86%E7%9B%96%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><div class="truncate" style="padding-left:32px">20. 不要覆盖原生方法</div></a></li><li id="### 21. 降低 CSS 选择器的复杂性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#21.-%E9%99%8D%E4%BD%8E-css-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><div class="truncate" style="padding-left:32px">21. 降低 CSS 选择器的复杂性</div></a></li><li id="#### (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#(1).-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E9%80%89%E6%8B%A9%E5%99%A8%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%8E%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%8F%B3%E8%BE%B9%E5%88%B0%E5%B7%A6%E8%BE%B9%E8%AF%BB%E5%8F%96"><div class="truncate" style="padding-left:48px">(1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取</div></a></li><li id="#### (2). CSS 选择器优先级" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#(2).-css-%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><div class="truncate" style="padding-left:48px">(2). CSS 选择器优先级</div></a></li><li id="### 22. 使用 flexbox 而不是较早的布局模型" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#22.-%E4%BD%BF%E7%94%A8-flexbox-%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BE%83%E6%97%A9%E7%9A%84%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B"><div class="truncate" style="padding-left:32px">22. 使用 flexbox 而不是较早的布局模型</div></a></li><li id="### 23. 使用 transform 和 opacity 属性更改来实现动画" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#23.-%E4%BD%BF%E7%94%A8-transform-%E5%92%8C-opacity-%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%94%B9%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB"><div class="truncate" style="padding-left:32px">23. 使用 transform 和 opacity 属性更改来实现动画</div></a></li><li id="### 24. 合理使用规则，避免过度优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#24.-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">24. 合理使用规则，避免过度优化</div></a></li><li id="#### 检查加载性能" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%A3%80%E6%9F%A5%E5%8A%A0%E8%BD%BD%E6%80%A7%E8%83%BD"><div class="truncate" style="padding-left:48px">检查加载性能</div></a></li><li id="#### 检查运行性能" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%A3%80%E6%9F%A5%E8%BF%90%E8%A1%8C%E6%80%A7%E8%83%BD"><div class="truncate" style="padding-left:48px">检查运行性能</div></a></li><li id="## 五、强缓存与协商缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BA%94%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:16px">五、强缓存与协商缓存</div></a></li><li id="### 浏览器缓存" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><div class="truncate" style="padding-left:32px">浏览器缓存</div></a></li><li id="#### 缓存优点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%BC%93%E5%AD%98%E4%BC%98%E7%82%B9"><div class="truncate" style="padding-left:48px">缓存优点</div></a></li><li id="#### 缓存缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%BC%93%E5%AD%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:48px">缓存缺点</div></a></li><li id="#### 缓存流程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B"><div class="truncate" style="padding-left:48px">缓存流程</div></a></li><li id="### 强缓存相关的header字段" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%BC%BA%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84header%E5%AD%97%E6%AE%B5"><div class="truncate" style="padding-left:32px">强缓存相关的header字段</div></a></li><li id="### 协商缓存相关的header字段" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84header%E5%AD%97%E6%AE%B5"><div class="truncate" style="padding-left:32px">协商缓存相关的header字段</div></a></li><li id="#### 1. Last-Modified/If-Modified-Since" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#1.-last-modified/if-modified-since"><div class="truncate" style="padding-left:48px">1. Last-Modified/If-Modified-Since</div></a></li><li id="#### 2. Etag/If-None-Match" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#2.-etag/if-none-match"><div class="truncate" style="padding-left:48px">2. Etag/If-None-Match</div></a></li><li id="### 既生Last-Modified何生Etag" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%97%A2%E7%94%9Flast-modified%E4%BD%95%E7%94%9Fetag"><div class="truncate" style="padding-left:32px">既生Last-Modified何生Etag</div></a></li><li id="### 用户的行为对缓存的影响" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%94%A8%E6%88%B7%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%AF%B9%E7%BC%93%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D"><div class="truncate" style="padding-left:32px">用户的行为对缓存的影响</div></a></li><li id="### 强缓存如何重新加载缓存缓存过的资源" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%BC%BA%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%E7%BC%93%E5%AD%98%E7%BC%93%E5%AD%98%E8%BF%87%E7%9A%84%E8%B5%84%E6%BA%90"><div class="truncate" style="padding-left:32px">强缓存如何重新加载缓存缓存过的资源</div></a></li><li id="## 六、HTTP 各版本特点与区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%85%ADhttp-%E5%90%84%E7%89%88%E6%9C%AC%E7%89%B9%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">六、HTTP 各版本特点与区别</div></a></li><li id="### 1、HTTP 0.9" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#1http-0.9"><div class="truncate" style="padding-left:32px">1、HTTP 0.9</div></a></li><li id="### 2、HTTP 1.0" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#2http-1.0"><div class="truncate" style="padding-left:32px">2、HTTP 1.0</div></a></li><li id="### 3、HTTP 1.1" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#3http-1.1"><div class="truncate" style="padding-left:32px">3、HTTP 1.1</div></a></li><li id="#### Persistent Connection（keepalive连接）" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#persistent-connectionkeepalive%E8%BF%9E%E6%8E%A5"><div class="truncate" style="padding-left:48px">Persistent Connection（keepalive连接）</div></a></li><li id="#### chunked编码传输" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#chunked%E7%BC%96%E7%A0%81%E4%BC%A0%E8%BE%93"><div class="truncate" style="padding-left:48px">chunked编码传输</div></a></li><li id="#### 字节范围请求" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%AD%97%E8%8A%82%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82"><div class="truncate" style="padding-left:48px">字节范围请求</div></a></li><li id="#### 断点续传" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><div class="truncate" style="padding-left:48px">断点续传</div></a></li><li id="#### Pipelining（请求流水线）" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#pipelining%E8%AF%B7%E6%B1%82%E6%B5%81%E6%B0%B4%E7%BA%BF"><div class="truncate" style="padding-left:48px">Pipelining（请求流水线）</div></a></li><li id="#### 其他特性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><div class="truncate" style="padding-left:48px">其他特性</div></a></li><li id="### 4、HTTP 2.0" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#4http-2.0"><div class="truncate" style="padding-left:32px">4、HTTP 2.0</div></a></li><li id="#### 二进制分帧" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7"><div class="truncate" style="padding-left:48px">二进制分帧</div></a></li><li id="#### 多路复用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><div class="truncate" style="padding-left:48px">多路复用</div></a></li><li id="#### 头部压缩" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><div class="truncate" style="padding-left:48px">头部压缩</div></a></li><li id="#### 随时复位" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%9A%8F%E6%97%B6%E5%A4%8D%E4%BD%8D"><div class="truncate" style="padding-left:48px">随时复位</div></a></li><li id="#### 服务器端推流" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%8E%A8%E6%B5%81"><div class="truncate" style="padding-left:48px">服务器端推流</div></a></li><li id="#### 优先权和依赖" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BC%98%E5%85%88%E6%9D%83%E5%92%8C%E4%BE%9D%E8%B5%96"><div class="truncate" style="padding-left:48px">优先权和依赖</div></a></li><li id="## 七、队头阻塞以及解决办法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%B8%83%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><div class="truncate" style="padding-left:16px">七、队头阻塞以及解决办法</div></a></li><li id="### 前言" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%89%8D%E8%A8%80"><div class="truncate" style="padding-left:32px">前言</div></a></li><li id="### TCP队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:32px">TCP队头阻塞</div></a></li><li id="### HTTP队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#http%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:32px">HTTP队头阻塞</div></a></li><li id="#### HTTP管道化是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#http%E7%AE%A1%E9%81%93%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:48px">HTTP管道化是什么</div></a></li><li id="#### HTTP管道化产生的背景" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#http%E7%AE%A1%E9%81%93%E5%8C%96%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF"><div class="truncate" style="padding-left:48px">HTTP管道化产生的背景</div></a></li><li id="#### HTTP管道化的限制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#http%E7%AE%A1%E9%81%93%E5%8C%96%E7%9A%84%E9%99%90%E5%88%B6"><div class="truncate" style="padding-left:48px">HTTP管道化的限制</div></a></li><li id="#### HTTP管道化引起的请求队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#http%E7%AE%A1%E9%81%93%E5%8C%96%E5%BC%95%E8%B5%B7%E7%9A%84%E8%AF%B7%E6%B1%82%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:48px">HTTP管道化引起的请求队头阻塞</div></a></li><li id="### 如何解决队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:32px">如何解决队头阻塞</div></a></li><li id="#### 如何解决HTTP队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3http%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:48px">如何解决HTTP队头阻塞</div></a></li><li id="#### 如何解决TCP队头阻塞" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><div class="truncate" style="padding-left:48px">如何解决TCP队头阻塞</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## 八、QUIC" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%85%ABquic"><div class="truncate" style="padding-left:16px">八、QUIC</div></a></li><li id="### QUIC的由来：为什么是UDP而非TCP？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#quic%E7%9A%84%E7%94%B1%E6%9D%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFudp%E8%80%8C%E9%9D%9Etcp"><div class="truncate" style="padding-left:32px">QUIC的由来：为什么是UDP而非TCP？</div></a></li><li id="### 为什么要用QUIC？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8quic"><div class="truncate" style="padding-left:32px">为什么要用QUIC？</div></a></li><li id="#### 1. 建连延迟低" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#1.-%E5%BB%BA%E8%BF%9E%E5%BB%B6%E8%BF%9F%E4%BD%8E"><div class="truncate" style="padding-left:48px">1. 建连延迟低</div></a></li><li id="#### 2. 安全又可靠" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#2.-%E5%AE%89%E5%85%A8%E5%8F%88%E5%8F%AF%E9%9D%A0"><div class="truncate" style="padding-left:48px">2. 安全又可靠</div></a></li><li id="#### 3. 改造灵活" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#3.-%E6%94%B9%E9%80%A0%E7%81%B5%E6%B4%BB"><div class="truncate" style="padding-left:48px">3. 改造灵活</div></a></li><li id="#### 4. 改进的拥塞控制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#4.-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><div class="truncate" style="padding-left:48px">4. 改进的拥塞控制</div></a></li><li id="#### 5. 无队头阻塞的多路复用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#5.-%E6%97%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><div class="truncate" style="padding-left:48px">5. 无队头阻塞的多路复用</div></a></li><li id="### QUIC对客户端的要求" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#quic%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%A6%81%E6%B1%82"><div class="truncate" style="padding-left:32px">QUIC对客户端的要求</div></a></li><li id="### QUIC应用场景" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#quic%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><div class="truncate" style="padding-left:32px">QUIC应用场景</div></a></li><li id="## 九、WebRTC的优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%B9%9Dwebrtc%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:16px">九、WebRTC的优缺点</div></a></li><li id="### 优点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BC%98%E7%82%B9"><div class="truncate" style="padding-left:32px">优点</div></a></li><li id="### 缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:32px">缺点</div></a></li><li id="## 十、EventSource和轮询的优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81eventsource%E5%92%8C%E8%BD%AE%E8%AF%A2%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:16px">十、EventSource和轮询的优缺点</div></a></li><li id="### EventSource" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#eventsource"><div class="truncate" style="padding-left:32px">EventSource</div></a></li><li id="#### 简介" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AE%80%E4%BB%8B"><div class="truncate" style="padding-left:48px">简介</div></a></li><li id="#### EventSource规范字段" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#eventsource%E8%A7%84%E8%8C%83%E5%AD%97%E6%AE%B5"><div class="truncate" style="padding-left:48px">EventSource规范字段</div></a></li><li id="#### EventSource属性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#eventsource%E5%B1%9E%E6%80%A7"><div class="truncate" style="padding-left:48px">EventSource属性</div></a></li><li id="#### EventSource 通讯过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#eventsource-%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:48px">EventSource 通讯过程</div></a></li><li id="#### 缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:48px">缺点</div></a></li><li id="### 轮询" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E8%BD%AE%E8%AF%A2"><div class="truncate" style="padding-left:32px">轮询</div></a></li><li id="#### 短轮询(Polling)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%9F%AD%E8%BD%AE%E8%AF%A2(polling)"><div class="truncate" style="padding-left:48px">短轮询(Polling)</div></a></li><li id="#### 长轮询(Long Polling)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%95%BF%E8%BD%AE%E8%AF%A2(long-polling)"><div class="truncate" style="padding-left:48px">长轮询(Long Polling)</div></a></li><li id="### EventSource VS 轮询" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#eventsource-vs-%E8%BD%AE%E8%AF%A2"><div class="truncate" style="padding-left:32px">EventSource VS 轮询</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## 十一、WebSocket 是什么原理？为什么可以实现持久连接？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E4%B8%80websocket-%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><div class="truncate" style="padding-left:16px">十一、WebSocket 是什么原理？为什么可以实现持久连接？</div></a></li><li id="### WebSocket 机制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#websocket-%E6%9C%BA%E5%88%B6"><div class="truncate" style="padding-left:32px">WebSocket 机制</div></a></li><li id="### WebSocket协议的原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#websocket%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:32px">WebSocket协议的原理</div></a></li><li id="### WebSocket协议的优缺点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#websocket%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><div class="truncate" style="padding-left:32px">WebSocket协议的优缺点</div></a></li><li id="## 十二、Sass" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E4%BA%8Csass"><div class="truncate" style="padding-left:16px">十二、Sass</div></a></li><li id="## 十三、三栏弹性布局的5种方法(绝对定位、圣杯、双飞翼、flex、grid)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E4%B8%89%E4%B8%89%E6%A0%8F%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E7%9A%845%E7%A7%8D%E6%96%B9%E6%B3%95(%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%9C%A3%E6%9D%AF%E5%8F%8C%E9%A3%9E%E7%BF%BCflexgrid)"><div class="truncate" style="padding-left:16px">十三、三栏弹性布局的5种方法(绝对定位、圣杯、双飞翼、flex、grid)</div></a></li><li id="### 需求" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%9C%80%E6%B1%82"><div class="truncate" style="padding-left:32px">需求</div></a></li><li id="### 5种具体实现和优缺点比较" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#5%E7%A7%8D%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83"><div class="truncate" style="padding-left:32px">5种具体实现和优缺点比较</div></a></li><li id="#### 1. 绝对定位布局" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#1.-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%B8%83%E5%B1%80"><div class="truncate" style="padding-left:48px">1. 绝对定位布局</div></a></li><li id="#### 2. 圣杯布局" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#2.-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80"><div class="truncate" style="padding-left:48px">2. 圣杯布局</div></a></li><li id="#### 3. 双飞翼布局" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#3.-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80"><div class="truncate" style="padding-left:48px">3. 双飞翼布局</div></a></li><li id="#### 4. flex布局" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#4.-flex%E5%B8%83%E5%B1%80"><div class="truncate" style="padding-left:48px">4. flex布局</div></a></li><li id="#### 5. grid布局" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#5.-grid%E5%B8%83%E5%B1%80"><div class="truncate" style="padding-left:48px">5. grid布局</div></a></li><li id="## 十四、浅析CSS里的BFC和IFC的用法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E5%9B%9B%E6%B5%85%E6%9E%90css%E9%87%8C%E7%9A%84bfc%E5%92%8Cifc%E7%9A%84%E7%94%A8%E6%B3%95"><div class="truncate" style="padding-left:16px">十四、浅析CSS里的BFC和IFC的用法</div></a></li><li id="### BFC简介" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#bfc%E7%AE%80%E4%BB%8B"><div class="truncate" style="padding-left:32px">BFC简介</div></a></li><li id="### BFC的特性及应用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#bfc%E7%9A%84%E7%89%B9%E6%80%A7%E5%8F%8A%E5%BA%94%E7%94%A8"><div class="truncate" style="padding-left:32px">BFC的特性及应用</div></a></li><li id="#### 同一个 BFC下外边距 会发生折叠" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%90%8C%E4%B8%80%E4%B8%AA-bfc%E4%B8%8B%E5%A4%96%E8%BE%B9%E8%B7%9D-%E4%BC%9A%E5%8F%91%E7%94%9F%E6%8A%98%E5%8F%A0"><div class="truncate" style="padding-left:48px">同一个 BFC下外边距 会发生折叠</div></a></li><li id="#### BFC可以包含浮动的元素(清除浮动)" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#bfc%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%85%83%E7%B4%A0(%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8)"><div class="truncate" style="padding-left:48px">BFC可以包含浮动的元素(清除浮动)</div></a></li><li id="#### BFC可以阻止元素被浮动元素覆盖" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#bfc%E5%8F%AF%E4%BB%A5%E9%98%BB%E6%AD%A2%E5%85%83%E7%B4%A0%E8%A2%AB%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E8%A6%86%E7%9B%96"><div class="truncate" style="padding-left:48px">BFC可以阻止元素被浮动元素覆盖</div></a></li><li id="### 简要介绍IFC" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8Difc"><div class="truncate" style="padding-left:32px">简要介绍IFC</div></a></li><li id="## 十五、浅析CSS的性能优化：transform与position区别、硬件加速工作原理及注意事项、强制使用GPU渲染的友好CSS属性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E4%BA%94%E6%B5%85%E6%9E%90css%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96transform%E4%B8%8Eposition%E5%8C%BA%E5%88%AB%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8gpu%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8F%8B%E5%A5%BDcss%E5%B1%9E%E6%80%A7"><div class="truncate" style="padding-left:16px">十五、浅析CSS的性能优化：transform与position区别、硬件加速工作原理及注意事项、强制使用GPU渲染的友好CSS属性</div></a></li><li id="### 问题背景" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><div class="truncate" style="padding-left:32px">问题背景</div></a></li><li id="#### 1. position + top/left 的效果" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#1.-position-+-top/left-%E7%9A%84%E6%95%88%E6%9E%9C"><div class="truncate" style="padding-left:48px">1. position + top/left 的效果</div></a></li><li id="#### 2. transform 的效果" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#2.-transform-%E7%9A%84%E6%95%88%E6%9E%9C"><div class="truncate" style="padding-left:48px">2. transform 的效果</div></a></li><li id="### 硬件加速工作原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:32px">硬件加速工作原理</div></a></li><li id="### 使用 GPU 渲染元素" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BD%BF%E7%94%A8-gpu-%E6%B8%B2%E6%9F%93%E5%85%83%E7%B4%A0"><div class="truncate" style="padding-left:32px">使用 GPU 渲染元素</div></a></li><li id="#### 能触发GPU渲染的属性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E8%83%BD%E8%A7%A6%E5%8F%91gpu%E6%B8%B2%E6%9F%93%E7%9A%84%E5%B1%9E%E6%80%A7"><div class="truncate" style="padding-left:48px">能触发GPU渲染的属性</div></a></li><li id="#### 强制使用GPU渲染" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8gpu%E6%B8%B2%E6%9F%93"><div class="truncate" style="padding-left:48px">强制使用GPU渲染</div></a></li><li id="#### 使用硬件加速需要注意的事项" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BD%BF%E7%94%A8%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><div class="truncate" style="padding-left:48px">使用硬件加速需要注意的事项</div></a></li><li id="#### will-change" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#will-change"><div class="truncate" style="padding-left:48px">will-change</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## 十六、深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E5%85%AD%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-eventloop-%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%B8%A7%E5%8A%A8%E7%94%BB%E7%A9%BA%E9%97%B2%E5%9B%9E%E8%B0%83"><div class="truncate" style="padding-left:16px">十六、深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调</div></a></li><li id="### 前言" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%89%8D%E8%A8%80"><div class="truncate" style="padding-left:32px">前言</div></a></li><li id="### 事件循环" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><div class="truncate" style="padding-left:32px">事件循环</div></a></li><li id="#### 定义" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%AE%9A%E4%B9%89"><div class="truncate" style="padding-left:48px">定义</div></a></li><li id="#### 流程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%B5%81%E7%A8%8B"><div class="truncate" style="padding-left:48px">流程</div></a></li><li id="#### 多任务队列" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><div class="truncate" style="padding-left:48px">多任务队列</div></a></li><li id="#### requestAnimationFrame" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#requestanimationframe"><div class="truncate" style="padding-left:48px">requestAnimationFrame</div></a></li><li id="##### 闪烁动画" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%97%AA%E7%83%81%E5%8A%A8%E7%94%BB"><div class="truncate" style="padding-left:64px">闪烁动画</div></a></li><li id="##### 定时器合并" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%90%88%E5%B9%B6"><div class="truncate" style="padding-left:64px">定时器合并</div></a></li><li id="#### requestIdleCallback" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#requestidlecallback"><div class="truncate" style="padding-left:48px">requestIdleCallback</div></a></li><li id="#### 草案解读" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E8%8D%89%E6%A1%88%E8%A7%A3%E8%AF%BB"><div class="truncate" style="padding-left:48px">草案解读</div></a></li><li id="#### 动画例子" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8A%A8%E7%94%BB%E4%BE%8B%E5%AD%90"><div class="truncate" style="padding-left:48px">动画例子</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## 十七、React Fiber架构中，迭代器和requestIdleCallback结合的优势" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E4%B8%83react-fiber%E6%9E%B6%E6%9E%84%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8Crequestidlecallback%E7%BB%93%E5%90%88%E7%9A%84%E4%BC%98%E5%8A%BF"><div class="truncate" style="padding-left:16px">十七、React Fiber架构中，迭代器和requestIdleCallback结合的优势</div></a></li><li id="### requestIdleCallback API" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#requestidlecallback-api"><div class="truncate" style="padding-left:32px">requestIdleCallback API</div></a></li><li id="#### API 介绍" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#api-%E4%BB%8B%E7%BB%8D"><div class="truncate" style="padding-left:48px">API 介绍</div></a></li><li id="#### 浏览器空余时间" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4"><div class="truncate" style="padding-left:48px">浏览器空余时间</div></a></li><li id="#### 应用场景" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><div class="truncate" style="padding-left:48px">应用场景</div></a></li><li id="#### 使用方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:48px">使用方式</div></a></li><li id="#### 功能体验" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8A%9F%E8%83%BD%E4%BD%93%E9%AA%8C"><div class="truncate" style="padding-left:48px">功能体验</div></a></li><li id="### Fiber 出现的目的" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#fiber-%E5%87%BA%E7%8E%B0%E7%9A%84%E7%9B%AE%E7%9A%84"><div class="truncate" style="padding-left:32px">Fiber 出现的目的</div></a></li><li id="#### React 16之前的版本存在的问题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#react-16%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><div class="truncate" style="padding-left:48px">React 16之前的版本存在的问题</div></a></li><li id="### Stack 算法模拟" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#stack-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F"><div class="truncate" style="padding-left:32px">Stack 算法模拟</div></a></li><li id="### React 16 解决方案 - Fiber" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#react-16-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88---fiber"><div class="truncate" style="padding-left:32px">React 16 解决方案 - Fiber</div></a></li><li id="### 实现思路" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><div class="truncate" style="padding-left:32px">实现思路</div></a></li><li id="### 什么是 Fiber" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BB%80%E4%B9%88%E6%98%AF-fiber"><div class="truncate" style="padding-left:32px">什么是 Fiber</div></a></li><li id="#### 执行单元" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83"><div class="truncate" style="padding-left:48px">执行单元</div></a></li><li id="#### 数据结构" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><div class="truncate" style="padding-left:48px">数据结构</div></a></li><li id="## 十八、canvas" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E5%85%ABcanvas"><div class="truncate" style="padding-left:16px">十八、canvas</div></a></li><li id="### 标签" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%A0%87%E7%AD%BE"><div class="truncate" style="padding-left:32px">标签</div></a></li><li id="### 怎么用" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%80%8E%E4%B9%88%E7%94%A8"><div class="truncate" style="padding-left:32px">怎么用</div></a></li><li id="### 相关的api及用法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%9B%B8%E5%85%B3%E7%9A%84api%E5%8F%8A%E7%94%A8%E6%B3%95"><div class="truncate" style="padding-left:32px">相关的api及用法</div></a></li><li id="#### 画矩形" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%94%BB%E7%9F%A9%E5%BD%A2"><div class="truncate" style="padding-left:48px">画矩形</div></a></li><li id="#### 圆形绘制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%9C%86%E5%BD%A2%E7%BB%98%E5%88%B6"><div class="truncate" style="padding-left:48px">圆形绘制</div></a></li><li id="#### 画飞镖转盘" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%94%BB%E9%A3%9E%E9%95%96%E8%BD%AC%E7%9B%98"><div class="truncate" style="padding-left:48px">画飞镖转盘</div></a></li><li id="#### 线性渐变" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98"><div class="truncate" style="padding-left:48px">线性渐变</div></a></li><li id="#### 径向渐变" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98"><div class="truncate" style="padding-left:48px">径向渐变</div></a></li><li id="#### 径向渐变画球" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98%E7%94%BB%E7%90%83"><div class="truncate" style="padding-left:48px">径向渐变画球</div></a></li><li id="#### 径向渐变画彩虹" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98%E7%94%BB%E5%BD%A9%E8%99%B9"><div class="truncate" style="padding-left:48px">径向渐变画彩虹</div></a></li><li id="#### 阴影效果" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C"><div class="truncate" style="padding-left:48px">阴影效果</div></a></li><li id="#### 绘制文字api" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97api"><div class="truncate" style="padding-left:48px">绘制文字api</div></a></li><li id="#### 文字对齐方式" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F"><div class="truncate" style="padding-left:48px">文字对齐方式</div></a></li><li id="#### 垂直方向" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91"><div class="truncate" style="padding-left:48px">垂直方向</div></a></li><li id="#### 图片的绘制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%9B%BE%E7%89%87%E7%9A%84%E7%BB%98%E5%88%B6"><div class="truncate" style="padding-left:48px">图片的绘制</div></a></li><li id="## 十九、WebWorker和postMessage" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%8D%81%E4%B9%9Dwebworker%E5%92%8Cpostmessage"><div class="truncate" style="padding-left:16px">十九、WebWorker和postMessage</div></a></li><li id="### 概述" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%A6%82%E8%BF%B0"><div class="truncate" style="padding-left:32px">概述</div></a></li><li id="#### （1）同源限制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#1%E5%90%8C%E6%BA%90%E9%99%90%E5%88%B6"><div class="truncate" style="padding-left:48px">（1）同源限制</div></a></li><li id="#### （2）DOM 限制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#2dom-%E9%99%90%E5%88%B6"><div class="truncate" style="padding-left:48px">（2）DOM 限制</div></a></li><li id="#### （3）通信联系" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#3%E9%80%9A%E4%BF%A1%E8%81%94%E7%B3%BB"><div class="truncate" style="padding-left:48px">（3）通信联系</div></a></li><li id="#### （4）脚本限制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#4%E8%84%9A%E6%9C%AC%E9%99%90%E5%88%B6"><div class="truncate" style="padding-left:48px">（4）脚本限制</div></a></li><li id="#### （5）文件限制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#5%E6%96%87%E4%BB%B6%E9%99%90%E5%88%B6"><div class="truncate" style="padding-left:48px">（5）文件限制</div></a></li><li id="### 基本用法" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><div class="truncate" style="padding-left:32px">基本用法</div></a></li><li id="#### 主线程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><div class="truncate" style="padding-left:48px">主线程</div></a></li><li id="#### Worker 线程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#worker-%E7%BA%BF%E7%A8%8B"><div class="truncate" style="padding-left:48px">Worker 线程</div></a></li><li id="#### Worker 加载脚本" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#worker-%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC"><div class="truncate" style="padding-left:48px">Worker 加载脚本</div></a></li><li id="#### Worker 错误处理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#worker-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><div class="truncate" style="padding-left:48px">Worker 错误处理</div></a></li><li id="#### 关闭 Worker" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%85%B3%E9%97%AD-worker"><div class="truncate" style="padding-left:48px">关闭 Worker</div></a></li><li id="### 数据通信" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1"><div class="truncate" style="padding-left:32px">数据通信</div></a></li><li id="### 同页面的 Web Worker" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%90%8C%E9%A1%B5%E9%9D%A2%E7%9A%84-web-worker"><div class="truncate" style="padding-left:32px">同页面的 Web Worker</div></a></li><li id="### Worker 线程完成轮询" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#worker-%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E8%BD%AE%E8%AF%A2"><div class="truncate" style="padding-left:32px">Worker 线程完成轮询</div></a></li><li id="### Worker 新建 Worker" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#worker-%E6%96%B0%E5%BB%BA-worker"><div class="truncate" style="padding-left:32px">Worker 新建 Worker</div></a></li><li id="### API" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#api"><div class="truncate" style="padding-left:32px">API</div></a></li><li id="#### 主线程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><div class="truncate" style="padding-left:48px">主线程</div></a></li><li id="#### Worker 线程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#worker-%E7%BA%BF%E7%A8%8B"><div class="truncate" style="padding-left:48px">Worker 线程</div></a></li><li id="## 二十、OffscreenCanvas 离屏Canvas — 使用Web Worker提高你的Canvas运行速度" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BA%8C%E5%8D%81offscreencanvas-%E7%A6%BB%E5%B1%8Fcanvas-%E2%80%94-%E4%BD%BF%E7%94%A8web-worker%E6%8F%90%E9%AB%98%E4%BD%A0%E7%9A%84canvas%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6"><div class="truncate" style="padding-left:16px">二十、OffscreenCanvas 离屏Canvas — 使用Web Worker提高你的Canvas运行速度</div></a></li><li id="### 兼容性" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%85%BC%E5%AE%B9%E6%80%A7"><div class="truncate" style="padding-left:32px">兼容性</div></a></li><li id="### 在Worker中使用OffscreenCanvas" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%9C%A8worker%E4%B8%AD%E4%BD%BF%E7%94%A8offscreencanvas"><div class="truncate" style="padding-left:32px">在Worker中使用OffscreenCanvas</div></a></li><li id="### 不要阻塞主线程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%B8%8D%E8%A6%81%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B"><div class="truncate" style="padding-left:32px">不要阻塞主线程</div></a></li><li id="### WebRTC的YUV媒体流数据的离屏渲染" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#webrtc%E7%9A%84yuv%E5%AA%92%E4%BD%93%E6%B5%81%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93"><div class="truncate" style="padding-left:32px">WebRTC的YUV媒体流数据的离屏渲染</div></a></li><li id="### 总结" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E6%80%BB%E7%BB%93"><div class="truncate" style="padding-left:32px">总结</div></a></li><li id="## 二十一、Vue与React Virtual DOM对比" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BA%8C%E5%8D%81%E4%B8%80vue%E4%B8%8Ereact-virtual-dom%E5%AF%B9%E6%AF%94"><div class="truncate" style="padding-left:16px">二十一、Vue与React Virtual DOM对比</div></a></li><li id="### 相同点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E7%9B%B8%E5%90%8C%E7%82%B9"><div class="truncate" style="padding-left:32px">相同点</div></a></li><li id="### 不同点" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%B8%8D%E5%90%8C%E7%82%B9"><div class="truncate" style="padding-left:32px">不同点</div></a></li><li id="#### dom的更新策略不同" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#dom%E7%9A%84%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E4%B8%8D%E5%90%8C"><div class="truncate" style="padding-left:48px">dom的更新策略不同</div></a></li><li id="### 建议" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E5%BB%BA%E8%AE%AE"><div class="truncate" style="padding-left:32px">建议</div></a></li><li id="## 二十二、Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/toolbox-frontend/articles/54#%E4%BA%8C%E5%8D%81%E4%BA%8Cvue2.0-%E4%B8%AD%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%92%8C%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%A2%9E%E9%87%8F%E5%BC%80%E5%8F%91%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">二十二、Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/54","id":939419432,"node_id":"MDU6SXNzdWU5Mzk0MTk0MzI=","number":54,"title":"安宁宝典","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2021-07-08T03:00:08Z","updated_at":"2021-07-27T07:20:11Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"# 安宁宝典\r\n\r\n## 一、Event Loop\r\n\r\nEvent Loop即事件循环，是指浏览器或者Nodejs解决javascript单线程运行时不会阻塞的一种机制，使用异步的原理。\r\n\r\nEvent Loop是一个执行模型，不同的运行环境有不同的实现，浏览器和nodejs基于不同的技术实现自己的event loop。\r\n\r\n- 浏览器的Event Loop是在HTML5规范中明确定义。\r\n- Nodejs的Event Loop是libuv实现的。\r\n- libuv已经对Event Loop作出了实现，HTML5规范中只是定义的浏览器中Event Loop的模型，具体的实现交给了浏览器厂商。\r\n\r\n### 宏队列和微队列\r\n\r\n在javascript中，任务被分为两种，一种为宏任务(macrotask)，也称为task，一种为微任务(microtask)，也称为jobs。\r\n\r\n宏任务主要包括:\r\n\r\n- script全部代码\r\n- setTimeout\r\n- setInterval\r\n- setImmediate (Nodejs独有，浏览器暂时不支持，只有IE10支持)\r\n- requestAnimationFrame (浏览器独有)\r\n- I/O\r\n- UI rendering (浏览器独有)\r\n\r\n微任务主要包括:\r\n\r\n- process.nextTick (Nodejs独有)\r\n- Promise\r\n- Object.observe (废弃)\r\n- MutationObserver\r\n\r\n### 浏览器中的Event Loop\r\n\r\nJavascript 有一个主线程 main thread 和 一个调用栈(执行栈) call-stack，所有任务都会被放到调用栈等待主线程的执行。\r\n\r\nJS调用栈采用的是后进先出的规则，当函数执行时，会被添加到调用栈的顶部，当执行栈执行完后，就会从栈顶移除，直到栈内被清空。\r\n\r\nJavascript单线程任务可以分为同步任务和异步任务，同步任务会在调用栈内按照顺序依次被主线程执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空的时候），被读取到调用栈内等待主线程的执行\r\n\r\n任务队列 Task Queue, 是先进先出的数据结构。\r\n\r\n![浏览器事件循环的进程模型](https://user-images.githubusercontent.com/8088864/124855609-c2904a00-dfdb-11eb-9138-df80150fa3a3.jpg)\r\n\r\n浏览器Event Loop的具体流程:\r\n\r\n1. 执行全局Javascript的同步代码，可能包含一些同步语句，也可以是异步语句(setTimeout语句不执行回调函数里面的，Promise中.then之前的语句)\r\n2. 全局Javascript执行完毕后，调用栈call-stack会被清空\r\n3. 从微队列microtask queue中取出位于首部的回调函数，放入到调用栈call-stack中执行，执行完毕后从调用栈中删除，microtask queue的长度减1。\r\n4. 继续从微队列microtask queue的队首取出任务，放到调用栈中执行，依次循环往复，直至微任务队列microtask queue中的任务都被调用栈执行完毕。**特别注意，如果在执行微任务microtask过程中，又产生了微任务microtask，新产生的微任务也会追加到微任务队列microtask queue的尾部，新生成的微任务也会在当前周期中被执行完毕。**\r\n5. microtask queue中的任务都被执行完毕后，microtask queue为空队列，调用栈也处于空闲阶段\r\n6. 执行UI rendering\r\n7. 从宏队列macrotask queue的队首取出宏任务，放入调用栈中执行。\r\n8. 执行完后，调用栈为空闲状态\r\n9. 重复 3 - 8 的步骤，直至宏任务队列的任务都被执行完毕。\r\n...\r\n\r\n浏览器Event Loop的3个重点:\r\n\r\n1. 宏队列macrotask queue每次只从中取出一个任务放到调用栈中执行，执行完后去执行微任务队列中的所有任务\r\n2. 微任务队列中的所有任务都会依次取出来执行，只是微任务队列中的任务清空\r\n3. UI rendering 的执行节点在微任务队列执行完毕后，宏任务队列中取出任务执行之前执行\r\n\r\n### NodeJs中的Event Loop\r\n\r\nlibuv结构\r\n\r\n![libuv的事件循环模型](https://user-images.githubusercontent.com/8088864/125010304-d64db600-e098-11eb-824f-de433a12a095.png)\r\n\r\nNodeJs中的宏任务队列和微任务队列\r\n\r\nNodeJs的Event Loop中，执行宏任务队列的回调有6个阶段\r\n\r\n![NodeJS中的宏队列执行回调的6个阶段](https://user-images.githubusercontent.com/8088864/125010342-e9608600-e098-11eb-84e0-70a5bd5f5867.png)\r\n\r\nNode的Event Loop可以分为6个阶段，各个阶段执行的任务如下所示:\r\n\r\n- `timers`: 执行setTimeout和setInterval中到期的callback。\r\n- `I/O callbacks`: 执行几乎所有的回调，除了close callbacks以及timers调度的回调和setImmediate()调度的回调。\r\n- `idle, prepare`: 仅在内部使用。\r\n- `poll`: 最重要的阶段，检索新的I/O事件，在适当的情况下回阻塞在该阶段。\r\n- `check`: 执行setImmediate的callback(setImmediate()会将事件插入到事件队列的尾部，主线程和事件队列的任务执行完毕后会立即执行setImmediate中传入的回调函数)。\r\n- `close callbacks`: 执行`close`事件的callback，例如socket.on('close', fn)或则http.server.on('close', fn)等。\r\n\r\nNodeJs中的宏任务队列可以分为下列4个:\r\n\r\n  1. Timers Queue\r\n  2. I/O Callbacks Queue\r\n  3. Check Queue\r\n  4. Close Callbacks Queue\r\n\r\n在浏览器中只有一个宏任务队列，所有宏任务都会放入到宏任务队列中等待放入执行栈中被主线程执行，NodeJs中有4个宏任务队列，不同类型的宏任务会被放入到不同的宏任务队列中。\r\n\r\nNodeJs中的微任务队列可以分为下列2个:\r\n\r\n  1. `Next Tick Queue`: 放置process.nextTick(callback)的回调函数\r\n  2. `Other Micro Queue`: 其他microtask，例如Promise等\r\n\r\n在浏览器中只有一个微任务队列，所有微任务都会放入到微任务队列中等待放入执行栈中被主线程执行，NodeJs中有2个微任务队列，不同类型的微任务会被放入到不同的微任务队列中。\r\n\r\n![NodeJs事件循环](https://user-images.githubusercontent.com/8088864/125030923-71a55200-e0be-11eb-93be-95f1cbc456e3.png)\r\n\r\nNodeJs的Event Loop的具体流程:\r\n\r\n1. 执行全局Javascript的同步代码，可能包含一些同步语句，也可以是异步语句(setTimeout语句不执行回调函数里面的，Promise中.then之前的语句)。\r\n2. 执行微任务队列中的微任务，先执行Next Tick Queue队列中的所有的所有任务，再执行Other Micro Queue队列中的所有任务。\r\n3. 开始执行宏任务队列中的任务，共6个阶段，从第1个阶段开始执行每个阶段对应宏任务队列中的所有任务，**注意，这里执行的是该阶段宏任务队列中的所有的任务，浏览器Event Loop每次只会中宏任务队列中取出队首的任务执行，执行完后开始执行微任务队列中的任务，NodeJs的Event Loop会执行完该阶段中宏任务队列中的所有任务后，才开始执行微任务队列中的任务，也就是步骤2**。\r\n4. Timers Queue -\u003e 步骤2 -\u003e I/O Callbacks Queue -\u003e 步骤2 -\u003e Check Queue -\u003e 步骤2 -\u003e Close Callback Queue -\u003e 步骤2 -\u003e Timers Queue -\u003e ......\r\n\r\nNodeJs的Event Loop的microtask queue和macrotask queue的执行顺序详情\r\n\r\n![NodeJS中的微任务队列执行顺序](https://user-images.githubusercontent.com/8088864/125032436-8aaf0280-e0c0-11eb-926a-30be5bf116f9.png)\r\n\r\n![NodeJS中的宏任务队列执行顺序](https://user-images.githubusercontent.com/8088864/125032451-8f73b680-e0c0-11eb-8349-d6c5f20bd11a.png)\r\n\r\n当setTimeout(fn, 0)和setImmediate(fn)放在同一同步代码中执行时，可能会出现下面两种情况：\r\n\r\n1. **第一种情况**: 同步代码执行完后，timer还没到期，setImmediate中注册的回调函数先放入到Check Queue的宏任务队列中，先执行微任务队列，然后开始执行宏任务队列，先从Timers Queue开始，由于在Timer Queue中未发现任何的回调函数，往下阶段走，直到Check Queue中发现setImmediate中注册的回调函数，先执行，然后timer到期，setTimeout注册的回调函数会放入到Timers Queue的宏任务队列中，下一轮后再次执行到Timers Queue阶段时，才会再Timers Queue中发现了setTimeout注册的回调函数，于是执行该timer的回调，所以，**setImmediate(fn)注册的回调函数会早于setTimeout(fn, 0)注册的回调函数执行**。\r\n2. **第二种情况**: 同步代码执行完之前，timer已经到期，setTimeout注册的回调函数会放入到Timers Queue的宏任务队列中，执行同步代码到setImmediate时，将其回调函数注册到Check Queue中，同步代码执行完后，先执行微任务队列，然后开始执行宏任务队列，先从Timers Queue开始，在Timers Queue发现了timer中注册的回调函数，取出执行，往下阶段走，到Check Queue中发现setImmediate中注册的回调函数，又执行，所以这种情况时，**setTimeout(fn, 0)注册的回调函数会早于setImmediate(fn)注册的回调函数执行**。\r\n\r\n3. 在同步代码中同时调setTimeout(fn, 0)和setImmediate执行顺序情况是不确定的，但是如果把他们放在一个IO的回调，比如readFile('xx', function () {// ....})回调中，那么IO回调是在I/O Callbacks Queue中，setTimeout到期回调注册到Timers Queue，setImmediate回调注册到Check Queue，I/O Callbacks Queue执行完到Check Queue，Timers Queue得到下个循环周期，所以setImmediate回调这种情况下肯定比setTimeout(fn, 0)回调先执行。\r\n\r\n``` js\r\nsetImmediate(function A() {\r\n  console.log(1);\r\n  setImmediate(function B(){console.log(2);});\r\n});\r\n\r\nsetTimeout(function timeout() {\r\n  console.log('TIMEOUT FIRED');\r\n}, 0);\r\n\r\n// 执行结果: 会存在下面两种情况\r\n// 第一种情况:\r\n// 1\r\n// TIMEOUT FIRED\r\n// 2\r\n\r\n// 第二种情况:\r\n// TIMEOUT FIRED\r\n// 1\r\n// 2\r\n```\r\n\r\npoll 阶段详解:\r\n\r\npoll 阶段主要又两个功能:\r\n\r\n1. 当timers到达指定的时间后，执行指定的timer的回调(Executing scripts for timers whose threshold has elapsed, then)。\r\n2. 处理poll队列的事件(Processing events in the poll queue)。\r\n\r\n当进入到poll阶段，并且没有timers被调用的时候，会出现下面的情况:\r\n\r\n- 如果poll队列不为空，Event Loop将同步执行poll queue中的任务，直到poll queue队列为空或者执行的callback达到上限。\r\n- 如果poll队列为空，会发生下面的情况:\r\n  - 如果脚本执行过setImmediate代码，Event Loop会结束poll阶段，直接进入check阶段，执行Check Queue中调用setImmediate注册的回调函数。\r\n  - 如果脚本没有执行过setImmediate代码，poll阶段将等待callback被添加到队列中，然后立即执行。\r\n\r\n当进入到poll阶段，并且调用了timers的话，会发生下面的情况:\r\n\r\n- 一旦poll queue为空，Event Loop会检测Timers Queue中是否存在任务，如果存在任务的话，Event Loop会回到timer阶段并执行Timers Queue中timers注册的回调函数。**执行完后是进入check阶段，还是又重新进入I/O callbacks阶段?**\r\n\r\nsetTimeout 对比 setImmediate\r\n\r\n- setTimeout(fn, 0)在timers阶段执行，并且是在poll阶段进行判断是否达到指定的timer时间才会执行\r\n- setImmediate(fn)在check阶段执行\r\n\r\n两者的执行顺序要根据当前的执行环境才能确定：\r\n\r\n- 如果两者都在主模块(main module)调用，那么执行先后取决于进程性能，顺序随机\r\n- 如果两者都不在主模块调用，即在一个I/O Circle中调用，那么setImmediate的回调永远先执行，因为会先到Check阶段\r\n\r\nsetImmediate 对比 process.nextTick\r\n\r\n- setImmediate(fn)的回调任务会插入到宏队列Check Queue中\r\n- process.nextTick(fn)的回调任务会插入到微队列Next Tick Queue中\r\n- process.nextTick(fn)调用深度有限制，上限是1000，而setImmediate则没有\r\n\r\n## 二、Fetch API使用的常见问题及其解决办法\r\n\r\nXMLHttpRequest在发送web请求时需要开发者配置相关请求信息和成功后的回调，尽管开发者只关心请求成功后的业务处理，但是也要配置其他繁琐内容，导致配置和调用比较混乱，也不符合关注分离的原则；fetch的出现正是为了解决XHR存在的这些问题。\r\n\r\n**fetch是基于Promise设计的**，让开发者只关注请求成功后的业务逻辑处理，其他的不用关心，相当简单，FetchAPI的优点如下:\r\n\r\n- 语法简单，更加语义化\r\n- 基于标准的Promise实现，支持async/await\r\n- 使用isomorphic-fetch可以方便同构\r\n\r\n使用fetch来进行项目开发时，也是有一些常见问题的，下面就来说说fetch使用的常见问题。\r\n\r\n### Fetch 兼容性问题\r\n\r\nfetch是相对较新的技术，当然就会存在浏览器兼容性的问题，借用上面应用文章的一幅图加以说明fetch在各种浏览器的原生支持情况：\r\n\r\n![Fetch兼容性](https://user-images.githubusercontent.com/8088864/125045722-e03edb80-e0cf-11eb-9457-f56b13350846.png)\r\n\r\n从上图可以看出各个浏览器的低版本都不支持fetch技术。\r\n\r\n如何在所有浏览器中通用fetch呢，当然就要考虑fetch的polyfill了。\r\n\r\nfetch是基于Promise来实现的，所以在低版本浏览器中Promise可能也未被原生支持，所以还需要Promise的polyfill；大多数情况下，实现fetch的polyfill需要涉及到的：\r\n\r\n- promise的polyfill，例如es6-promise、babel-polyfill提供的promise实现。\r\n- fetch的polyfill实现，例如isomorphic-fetch和whatwg-fetch\r\n\r\nIE浏览器中IE8/9还比较特殊：IE8它使用的是ES3，而IE9则对ES5部分支持。这种情况下还需要ES5的polyfill es5-shim支持了。\r\n\r\n上述有关promise的polyfill实现，需要说明的是：\r\n\r\nbabel-runtime是不能作为Promise的polyfill的实现的，否则在IE8/9下使用fetch会报Promise未定义。为什么？我想大家猜到了，因为babel-runtime实现的polyfill是局部实现而不是全局实现，fetch底层实现用到Promise就是从全局中去取的，拿不到这报上述错误。\r\n\r\nfetch的polyfill实现思路:\r\n\r\n首先判断浏览器是否原生支持fetch，否则结合Promise使用XMLHttpRequest的方式来实现；这正是whatwg-fetch的实现思路，而同构应用中使用的isomorphic-fetch，其客户端fetch的实现是直接require whatwg-fetch来实现的。\r\n\r\n### fetch默认不携带cookie\r\n\r\nfetch发送请求默认是不发送cookie的，不管是同域还是跨域；\r\n\r\n对于那些需要权限验证的请求就可能无法正常获取数据，可以配置其credentials项，其有3个值：\r\n\r\n- omit: 默认值，忽略cookie的发送\r\n- same-origin: 表示cookie只能同域发送，不能跨域发送\r\n- include: cookie既可以同域发送，也可以跨域发送\r\n\r\ncredentials所表达的含义，其实与XHR2中的withCredentials属性类似，表示请求是否携带cookie；\r\n\r\n若要fetch请求携带cookie信息，只需设置一下credentials选项即可，例如fetch(url, {credentials: 'include'});\r\n\r\nfetch默认对服务端通过Set-Cookie头设置的cookie也会忽略，若想选择接受来自服务端的cookie信息，也必须要配置credentials选项；\r\n\r\n### fetch请求对某些错误http状态不会reject\r\n\r\n主要是由fetch返回promise导致的，因为fetch返回的promise在某些错误的http状态下如400、500等不会reject，相反它会被resolve；只有网络错误会导致请求不能完成时，fetch 才会被 reject；所以一般会对fetch请求做一层封装。\r\n\r\n``` js\r\nfunction checkStatus(response) {\r\n  if (response.status \u003e= 200 \u0026\u0026 response.status \u003c 300) {\r\n    return response;\r\n  }\r\n  const error = new Error(response.statusText);\r\n  error.response = response;\r\n  throw error;\r\n}\r\n\r\nfunction parseJSON(response) {\r\n  return response.json();\r\n}\r\n\r\nexport default function request(url, options) {\r\n  let opt = options||{};\r\n  return fetch(url, {credentials: 'include', ...opt})\r\n    .then(checkStatus)\r\n    .then(parseJSON)\r\n    .then((data) =\u003e ( data ))\r\n    .catch((err) =\u003e ( err ));\r\n}\r\n```\r\n\r\n### fetch不支持超时timeout处理\r\n\r\nfetch不像大多数ajax库那样对请求设置超时timeout，它没有有关请求超时的功能，所以在fetch标准添加超时功能之前，都需要polyfill该特性。\r\n\r\n实际上，我们真正需要的是abort()， timeout可以通过timeout+abort方式来实现，起到真正超时丢弃当前的请求。\r\n\r\n目前的fetch指导规范中，fetch并不是一个具体实例，而只是一个方法；其返回的promise实例根据Promise指导规范标准是不能abort的，也不能手动改变promise实例的状态，只能由内部来根据请求结果来改变promise的状态。\r\n\r\n实现fetch的timeout功能，其思想就是新创建一个可以手动控制promise状态的实例，根据不同情况来对新promise实例进行resolve或者reject，从而达到实现timeout的功能；\r\n\r\n根据github上[timeout handling](https://github.com/github/fetch/issues/175)上的讨论，目前可以有两种不同的解决方法：\r\n\r\n方法一: 单纯setTimeout方法\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  return new Promise(function(resolve, reject) {\r\n    if (options.timeout) {\r\n      var timerId = setTimeout(function() {\r\n        reject(new Error('fetch timeout'));\r\n      }, options.timeout);\r\n    }\r\n\r\n    fetchOrigin(url, option).then(function(response) {\r\n      clearTimeout(timerId);\r\n      resolve(response);\r\n    }, function(error) {\r\n      clearTimeout(timerId);\r\n      reject(error);\r\n    });\r\n  });\r\n}\r\n```\r\n\r\n使用这种方式还可模拟XHR的abort方法\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  return new Promise(function(resolve, reject) {\r\n    var abort = function() {\r\n      reject(new Error('fetch abort'));\r\n    };\r\n\r\n    const p = fetchOrigin(url, option).then(resolve, reject);\r\n    p.abort = abort;\r\n\r\n    return p;\r\n  });\r\n}\r\n```\r\n\r\n方法二: 利用Promise.race方法\r\n\r\nPromise.race方法接受一个promise实例数组参数，表示多个promise实例中任何一个最先改变状态，那么race方法返回的promise实例状态就跟着改变\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  var abortFn = null;\r\n  var timeoutFn = null;\r\n\r\n  var timeoutPromise = new Promise(function(resolve, reject) {\r\n    timeoutFn = function () {\r\n      reject(new Error('fetch timeout'));\r\n    }\r\n  });\r\n\r\n  var abortPromise = new Promise(function(resolve, reject) {\r\n    abortFn = function () {\r\n      reject(new Error('fetch abort'));\r\n    }\r\n  });\r\n\r\n  const fetchPromise = fetchOrigin(url, option);\r\n\r\n  const promise = Promise.race(\r\n    timeoutPromise,\r\n    abortPromise,\r\n    fetchPromise,\r\n  );\r\n\r\n  promise.abort = abortFn;\r\n\r\n  return promise;\r\n}\r\n```\r\n\r\n对fetch的timeout的上述实现方式补充几点：\r\n\r\n- timeout不是请求连接超时的含义，它表示请求的response时间，包括请求的连接、服务器处理及服务器响应回来的时间。\r\n- fetch的timeout即使超时发生了，本次请求也不会被abort丢弃掉，它在后台仍然会发送到服务器端，只是本次请求的响应内容被丢弃而已。\r\n\r\n### fetch不支持JSONP\r\n\r\nfetch是与服务器端进行异步交互的，而JSONP是外链一个javascript资源，是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题，并不是真正ajax，所以fetch与JSONP没有什么直接关联，当然至少目前是不支持JSONP的。\r\n\r\n这里我们把JSONP与fetch关联在一起有点差强人意，fetch只是一个ajax库，我们不可能使fetch支持JSONP；只是我们要实现一个JSONP，只不过这个JSONP的实现要与fetch的实现类似，即基于Promise来实现一个JSONP；而其外在表现给人感觉是fetch支持JSONP一样；\r\n\r\n目前比较成熟的开源JSONP实现[fetch-jsonp](https://github.com/camsong/fetch-jsonp)给我们提供了解决方案，想了解可以自行前往。不过再次想唠叨一下其JSONP的实现步骤，因为在本人面试的前端候选人中大部分人对JSONP的实现语焉不详；\r\n\r\n使用它非常简单，首先需要用npm安装fetch-jsonp\r\n\r\n``` shell\r\nnpm install fetch-jsonp --save-dev\r\n```\r\n\r\n具体的使用方式:\r\n\r\n``` js\r\nfetchJsonp('/users.jsonp', {\r\n  timeout: 3000,\r\n  jsonpCallback: 'custom_callback'\r\n})\r\n.then(function(response) {\r\n  return response.json()\r\n}).catch(function(ex) {\r\n  console.log('parsing failed', ex)\r\n});\r\n```\r\n\r\n### fetch不支持progress事件\r\n\r\nXHR是原生支持progress事件的，例如下面代码这样：\r\n\r\n``` js\r\nvar xhr = new XMLHttpRequest();\r\nxhr.open('POST', '/uploads');\r\nxhr.onload = function() {}\r\nxhr.onerror = function() {}\r\nvar uploadProgress = function(event) {\r\n  if (event.lengthComputable) {\r\n    var percent = Math.round((event.loaded / event.total) * 100);\r\n    console.log(percent);\r\n  }\r\n};\r\n\r\n// 上传的progress事件\r\nxhr.upload.onprogress = uploadProgress;\r\n// 下载的progress事件\r\nxhr.onprogress = uploadProgress;\r\n```\r\n\r\n但是fetch是不支持有关progress事件的；不过可喜的是，根据fetch的指导规范标准，其内部设计实现了Request和Response类；其中Response封装一些方法和属性，通过Response实例可以访问这些方法和属性，例如response.json()、response.body等等；\r\n\r\n值得关注的地方是，response.body是一个可读字节流对象，其实现了一个getRender()方法，其具体作用是：\r\n\r\ngetRender()方法用于读取响应的原始字节流，该字节流是可以循环读取的，直至body内容传输完成；\r\n\r\n因此，利用到这点可以模拟出fetch的progress。\r\n\r\n代码实现如下:\r\n\r\n``` js\r\n// fetch() returns a promise that resolves once headers have been received\r\nfetch(url).then(response =\u003e {\r\n  // response.body is a readable stream.\r\n  // Calling getReader() gives us exclusive access to the stream's content\r\n  var reader = response.body.getReader();\r\n  var bytesReceived = 0;\r\n\r\n  // read() returns a promise that resolves when a value has been received\r\n  reader.read().then(function processResult(result) {\r\n    // Result objects contain two properties:\r\n    // done  - true if the stream has already given you all its data.\r\n    // value - some data. Always undefined when done is true.\r\n    if (result.done) {\r\n      console.log(\"Fetch complete\");\r\n      return;\r\n    }\r\n\r\n    // result.value for fetch streams is a Uint8Array\r\n    bytesReceived += result.value.length;\r\n    console.log('Received', bytesReceived, 'bytes of data so far');\r\n\r\n    // Read some more, and call this function again\r\n    return reader.read().then(processResult);\r\n  });\r\n});\r\n```\r\n\r\ngithub上也有使用Promise+XHR结合的方式实现类fetch的progress效果(当然这跟fetch完全不搭边）可以参考[这里](https://github.com/github/fetch/issues/89#issuecomment-256610849)，具体代码如下：\r\n\r\n``` js\r\nfunction fetchProgress(url, opts={}, onProgress) {\r\n  return new Promise((resolve, reject)=\u003e{\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(opts.method || 'get', url);\r\n\r\n    for (var key in opts.headers||{}) {\r\n      xhr.setRequestHeader(key, opts.headers[key]);\r\n    }\r\n\r\n    xhr.onload = function(event) {\r\n      resolve(e.target.responseText)\r\n    };\r\n\r\n    xhr.onerror = reject;\r\n\r\n    if (xhr.upload \u0026\u0026 onProgress) {\r\n      xhr.upload.onprogress = onProgress; // event.loaded / event.total * 100 ; //event.lengthComputable\r\n    }\r\n\r\n    xhr.send(opts.body);\r\n  });\r\n}\r\n\r\nfetchProgress('/').then(console.log)\r\n```\r\n\r\n### fetch跨域问题\r\n\r\n既然是ajax库，就不可避免与跨域扯上关系；XHR2是支持跨域请求的，只不过要满足浏览器端支持CORS，服务器通过Access-Control-Allow-Origin来允许指定的源进行跨域，仅此一种方式。\r\n\r\n与XHR2一样，fetch也是支持跨域请求的，只不过其跨域请求做法与XHR2一样，需要客户端与服务端支持；另外，fetch还支持一种跨域，不需要服务器支持的形式，具体可以通过其mode的配置项来说明。\r\n\r\nfetch的mode配置项有3个值，如下：\r\n\r\n- same-origin：该模式是不允许跨域的，它需要遵守同源策略，否则浏览器会返回一个error告知不能跨域；其对应的response type为basic。\r\n- cors: 该模式支持跨域请求，顾名思义它是以CORS的形式跨域；当然该模式也可以同域请求不需要后端额外的CORS支持；其对应的response type为cors。\r\n- no-cors: 该模式用于跨域请求但是服务器不带CORS响应头，也就是服务端不支持CORS；这也是fetch的特殊跨域请求方式；其对应的response type为opaque。\r\n\r\n针对跨域请求，cors模式是常见跨域请求实现，但是fetch自带的no-cors跨域请求模式则较为陌生，该模式有一个比较明显的特点：\r\n\r\n该模式允许浏览器发送本次跨域请求，但是不能访问响应返回的内容，这也是其response type为opaque透明的原因。\r\n\r\n这与\u003cimg \\/\u003e发送的请求类似，只是该模式不能访问响应的内容信息；但是它可以被其他APIs进行处理，例如ServiceWorker。另外，该模式返回的response可以在Cache API中被存储起来以便后续的对它的使用，这点对script、css和图片的CDN资源是非常合适的，因为这些资源响应头中都没有CORS头。\r\n\r\n总的来说，fetch的跨域请求是使用CORS方式，需要浏览器和服务端的支持。\r\n\r\n## 三、原型链和继承\r\n\r\nJavaScript是一门面向对象的设计语言，在JS里除了null和undefined，其余一切皆为对象。其中Array/Function/Date/RegExp是Object对象的特殊实例实现，Boolean/Number/String也都有对应的基本包装类型的对象（具有内置的方法）。传统语言是依靠class类来完成面向对象的继承和多态等特性，而JS使用原型链和构造器来实现继承，依靠参数arguments.length来实现多态。并且在ES6里也引入了class关键字来实现类。\r\n\r\n### 函数与对象的关系\r\n\r\n有时我们会好奇为什么能给一个函数添加属性，函数难道不应该就是一个执行过程的作用域吗？\r\n\r\n``` js\r\nvar name = 'Hank';\r\nfunction Person(name) {\r\n    this.name = name;\r\n    this.sayName = function() {\r\n        alert(this.name);\r\n    }\r\n}\r\nPerson.age = 10;\r\nconsole.log(Person.age);    // 10\r\nconsole.log(Person);\r\n/* 输出函数体：\r\nƒ Person(name) {\r\n    this.name = name;\r\n}\r\n*/\r\n```\r\n\r\n我们能够给函数赋一个属性值，当我们输出这个函数时这个属性却无影无踪了，这到底是怎么回事，这个属性又保存在哪里了呢？\r\n\r\n其实，在JS里，函数就是一个对象，这些属性自然就跟对象的属性一样被保存起来，函数名称指向这个对象的存储空间。\r\n\r\n函数调用过程没查到资料，个人理解为：这个对象内部拥有一个内部属性[\\[function]]保存有该函数体的字符串形式，当使用()来调用的时候，就会实时对其进行动态解析和执行，如同**eval()**一样。\r\n\r\n![内存栈和内存堆](https://user-images.githubusercontent.com/8088864/125233637-947b7480-e311-11eb-903e-73397c79b87e.png)\r\n\r\n上图是JS的具体内存分配方式，JS中分为值类型和引用类型，值类型的数据大小固定，我们将其分配在栈里，直接保存其数据。而引用类型是对象，会动态的增删属性，大小不固定，我们把它分配到内存堆里，并用一个指针指向这片地址，也就是Person其实保存的是一个指向这片地址的指针。这里的Person对象是个函数实例，所以拥有特殊的内部对象[\\[function]]用于调用。同时它也拥有内部属性arguments/this/name，因为不相关，这里我们没有绘出，而展示了我们为其添加的属性age。\r\n\r\n### 函数与原型的关系\r\n\r\n同时在JS里，我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个用于包含该对象所有实例的共享属性和方法的对象。而这个对象同时包含一个指针指向这个这个函数，这个指针就是**constructor**，这个函数也被成为构造函数。这样我们就完成了构造函数和原型对象的双向引用。\r\n\r\n而上面的代码实质也就是当我们创建了Person构造函数之后，同步开辟了一片空间创建了一个对象作为Person的原型对象，可以通过Person.prototype来访问这个对象，也可以通过Person.prototype.constructor来访问Person该构造函数。通过构造函数我们可以往实例对象里添加属性，如上面的例子里的name属性和sayName()方法。我们也可以通过prototype来添加原型属性，如：\r\n\r\n![函数原型](https://user-images.githubusercontent.com/8088864/125234076-7f531580-e312-11eb-9c55-3d760c70f5e7.png)\r\n\r\n要注意属性和原型属性不是同一个东西，也并不保存在同一个空间里：\r\n\r\n``` js\r\nPerson.age; // 10\r\nPerson.prototype.age; // 24\r\n```\r\n\r\n### 原型和实例的关系\r\n\r\n现在有了构造函数和原型对象，那我们接下来new一个实例出来，这样才能真正体现面向对象编程的思想，也就是**继承**：\r\n\r\n``` js\r\nvar person1 = new Person('Lee');\r\nvar person2 = new Person('Lucy');\r\n```\r\n\r\n我们新建了两个实例person1和person2，这些实例的内部都会包含一个指向其构造函数的原型对象的指针（内部属性），这个指针叫[\\[Prototype]]，在ES5的标准上没有规定访问这个属性，但是大部分浏览器实现了**__proto__**的属性来访问它，成为了实际的通用属性，于是在ES6的附录里写进了该属性。__proto__前后的双下划线说明其本质上是一个内部属性，而不是对外访问的API，因此官方建议新的代码应当避免使用该属性，转而使用Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。\r\n\r\n这里的prototype我们称为显示原型，__proto__我们称为隐式原型。\r\n\r\n``` js\r\nObject.getPrototypeOf({}) === Object.prototype; // true\r\n```\r\n\r\n同时由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 obj.__proto__ = ... 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象。\r\n\r\n此时它们的关系是（为了清晰，忽略函数属性的指向，用(function)代指）：\r\n\r\n![构造函数实例的原型关系](https://user-images.githubusercontent.com/8088864/125234787-f89f3800-e313-11eb-8f2a-b1e346d904af.png)\r\n\r\n在这里我们可以看到两个实例指向了同一个原型对象，而在new的过程中调用了Person()方法，对每个实例分别初始化了name属性和sayName方法，属性值分别被保存，而方法作为引用对象也指向了不同的内存空间。\r\n\r\n我们可以用几种方法来验证实例的原型指针到底指向的是不是构造函数的原型对象：\r\n\r\n``` js\r\nperson1.__proto__ === Person.prototype // true\r\nPerson.prototype.isPrototypeOf(person1); // true\r\nObject.getPrototypeOf(person2) === Person.prototype; // true\r\nperson1 instanceof Person; // true\r\n```\r\n\r\n### 原型链\r\n\r\n现在我们访问实例person1的属性和方法了：\r\n\r\n``` js\r\nperson1.name; // Lee\r\nperson1.age; // 24\r\nperson1.toString(); // [object Object]\r\n```\r\n\r\n想下这个问题，我们的name值来自于person1的属性，那么age值来自于哪？toString( )方法又在哪定义的呢？\r\n\r\n这就是我们要说的原型链，原型链是实现继承的主要方法，其思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。如果我们让一个原型对象等于另一个类型的实例，那么该原型对象就会包含一个指向另一个原型的指针，而如果另一个原型对象又是另一个原型的实例，那么上述关系依然成立，层层递进，就构成了实例与原型的链条，这就是原型链的概念。\r\n\r\n上面代码的name来自于自身属性，age来自于原型属性，toString( )方法来自于Person原型对象的原型Object。当我们访问一个实例属性的时候，如果没有找到，我们就会继续搜索实例的原型，如果还没有找到，就递归搜索原型链直到原型链末端。我们可以来验证一下原型链的关系：\r\n\r\n``` js\r\nPerson.prototype.__proto__ === Object.prototype // true\r\n```\r\n\r\n同时让我们更加深入的验证一些东西：\r\n\r\n``` js\r\nPerson.__proto__ === Function.prototype // true\r\nFunction.prototype.__proto__ === Object.prototype // true\r\n```\r\n\r\n我们会发现Person是Function对象的实例，Function是Object对象的实例，Person原型是Object对象的实例。这证明了我们开篇的观点：JavaScript是一门面向对象的设计语言，在JS里除了null和undefined，其余一切皆为对象。\r\n\r\n下面祭出我们的原型链图：\r\n\r\n![原型链图](https://user-images.githubusercontent.com/8088864/125235100-7e22e800-e314-11eb-9dd0-bb6d0747ec99.jpg)\r\n\r\n根据我们上面讲述的关于prototype/constructor/__proto__的内容，我相信你可以完全看懂这张图的内容。需要注意两点：\r\n\r\n  1. 构造函数和对象原型一一对应，他们与实例一起作为三要素构成了三面这幅图。最左侧是实例，中间是构造函数，最右侧是对象原型。\r\n  2. 最最右侧的null告诉我们：Object.prototype.__proto__ = null，也就是Object.prototype是JS中一切对象的根源。其余的对象继承于它，并拥有自己的方法和属性。\r\n\r\n### 6种继承方法\r\n\r\n#### 第一种: 原型链继承\r\n\r\n利用原型链的特点进行继承\r\n\r\n``` js\r\nfunction Super(){\r\n  this.name = 'web前端';\r\n  this.type = ['JS','HTML','CSS'];\r\n}\r\nSuper.prototype.sayName=function(){\r\n  return this.name;\r\n}\r\nfunction Sub(){};\r\nSub.prototype = new Super();\r\nSub.prototype.constructor = Sub;\r\nvar sub1 = new Sub();\r\nsub1.sayName();\r\n```\r\n\r\n优点：\r\n\r\n- 可以实现继承。\r\n\r\n缺点:\r\n\r\n- 子类的原型属性集成了父类实例化对象，所有子类的实例化对象都共享原型对象的属性和方法\r\n\r\n``` js\r\nvar sub1 = new Son();\r\nvar sub2 = new Son();\r\nsub1.type.push('VUE');\r\nconsole.log(sub1.type); // ['JS','HTML','CSS','VUE']\r\nconsole.log(sub2.type); // ['JS','HTML','CSS','VUE']\r\n```\r\n\r\n- 子类构造函数实例化对象时，无法传递参数给父类\r\n\r\n#### 第二种: 构造函数继承\r\n\r\n通过构造函数call方法实现继承。\r\n\r\n``` js\r\nfunction Super(){\r\n  this.name = 'web前端';\r\n  this.type = ['JS','HTML','CSS'];\r\n\r\n  this.sayName = function() {\r\n    return this.name;\r\n  }\r\n}\r\nfunction Sub(){\r\n  Super.call(this);\r\n}\r\nvar sub1 = new Sub();\r\nsub1.type.push('VUE');\r\nconsole.log(sub1.type); // ['JS','HTML','CSS','VUE']\r\nvar sub2 = new Sub();\r\nconsole.log(sub2.type); // ['JS','HTML','CSS']\r\n```\r\n\r\n优点:\r\n\r\n- 实现父类实例化对象的独立性\r\n\r\n- 还可以给父类实例化对象添加参数\r\n\r\n缺点:\r\n\r\n- 方法都在构造函数中定义，每次实例化对象都得创建一遍方法，基本无法实现函数复用\r\n\r\n- call方法仅仅调用了父级构造函数的属性及方法，没有办法访问父级构造函数原型对象的属性和方法\r\n\r\n#### 第三种: 组合继承\r\n\r\n利用原型链继承和构造函数继承的各自优势进行组合使用\r\n\r\n``` js\r\n\r\nfunction Super(name){\r\n  this.name = name;\r\n  this.type = ['JS','HTML','CSS'];\r\n}\r\n\r\nSuper.prototype.sayName=function(){\r\n  return this.name;\r\n}\r\n\r\nfunction Sub(name){\r\n  Super.call(this, name);\r\n}\r\n\r\nSub.prototype = new Super();\r\nsub1 = new Sub('张三');\r\nsub2 = new Sub('李四');\r\nsub1.type.push('VUE');\r\nsub2.type.push('PHP');\r\nconsole.log(sub1.type); // ['JS','HTML','CSS','VUE']\r\nconsole.log(sub2.type); // ['JS','HTML','CSS','PHP']\r\nsub1.sayName(); // 张三\r\nsub2.sayName(); // 李四\r\n```\r\n\r\n优点:\r\n\r\n- 利用原型链继承，实现原型对象方法的继承，允许访问父级构造函数原型对象属性和方法，实现方法复用\r\n\r\n- 利用构造函数继承，实现属性的继承，而且可以传递参数\r\n\r\n缺点:\r\n\r\n- 创建子类实例对象时，无论什么情况下，都会调用两次父级构造函数：一次是在创建子级原型的时候，另一次是在子级构造函数内部(call)\r\n\r\n#### 第四种: 原型式继承\r\n\r\n创建一个函数，将参数作为一个对象的原型对象。\r\n\r\n``` js\r\nfunction create(obj) {\r\n  function Sub(){};\r\n  Sub.prototype = obj;\r\n  return new Sub();\r\n}\r\n\r\nvar parent = {\r\n  name: '张三',\r\n  type: ['JS','HTML','CSS'];\r\n};\r\n\r\nvar sub1 = create(parent);\r\nvar sub2 = create(parent);\r\n\r\nconsole.log(sub1.name); // 张三\r\nconsole.log(sub2.name); // 张三\r\n```\r\n\r\nES5规范化了这个原型继承，新增了Object.create()方法，接收两个参数，第一个为原型对象，第二个为要混合进新对象的属性，格式与Object.defineProperties()相同。\r\n\r\n``` js\r\nObject.create(null, {name: {value: 'Greg', enumerable: true}});\r\n\r\n// 相当于\r\nvar parent = {\r\n  name: '张三',\r\n  type: ['JS','HTML','CSS'];\r\n};\r\n\r\nvar sub1 = Object.create(parent);\r\nvar sub2 = Object.create(parent);\r\n\r\nconsole.log(sub1.name); // 张三\r\nconsole.log(sub2.name); // 张三\r\n```\r\n\r\n优缺点：\r\n\r\n- 跟原型链类似\r\n\r\n#### 第五种: 寄生继承\r\n\r\n在原型式继承的基础上，在函数内部丰富对象\r\n\r\n``` js\r\nfunction create(obj) {\r\n  function Sub() {};\r\n  Sub.prototype = obj;\r\n  Sub.prototype.constructor = Sub;\r\n\r\n  return new Sub();\r\n}\r\n\r\nfunction Parasitic(obj) {\r\n  var clone = create(obj);\r\n  clone.sayHi = function() {\r\n    console.log('hi');\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar parent = {\r\n  name: '张三',\r\n  type: ['JS','HTML','CSS'];\r\n};\r\n\r\nvar sub1 = Parasitic(parent);\r\nvar sub2 = Parasitic(parent);\r\n\r\nconsole.log(sub1.name); // 张三\r\nconsole.log(sub2.name); // 张三\r\n```\r\n\r\n如果使用ES5Object.create来代替create函数的话，可以简化成如下所示:\r\n\r\n``` js\r\nfunction Parasitic(obj) {\r\n  var clone = Object.create(obj);\r\n  clone.sayHi = function() {\r\n    console.log('hi');\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar parent = {\r\n  name: '张三',\r\n  type: ['JS','HTML','CSS'];\r\n};\r\n\r\nvar son1 = Parasitic(parent);\r\nvar son2 = Parasitic(parent);\r\n\r\nconsole.log(son1.name); // 张三\r\nconsole.log(son2.name); // 张三\r\nson1.sayHi();\r\nson2.sayHi();\r\n```\r\n\r\n优缺点:\r\n\r\n- 跟构造函数继承类似，调用一次函数就得创建一遍方法，无法实现函数复用，效率较低\r\n\r\n#### 第六种: 寄生组合继承\r\n\r\n利用组合继承和寄生继承各自优势\r\n\r\n组合继承方法我们已经说了，它的缺点是两次调用父级构造函数，一次是在创建子级原型的时候，另一次是在子级构造函数内部，那么我们只需要优化这个问题就行了，即减少一次调用父级构造函数，正好利用寄生继承的特性，继承父级构造函数的原型来创建子级原型。\r\n\r\n``` js\r\nfunction Super(name) {\r\n  this.name = name;\r\n  this.type = ['JS','HTML','CSS'];\r\n};\r\n\r\nSuper.prototype.sayName = function () {\r\n  return this.name;\r\n};\r\n\r\nfunction Sub(name, age) {\r\n  Super.call(this, name);\r\n  this.age = age;\r\n}\r\n\r\n// 我们封装其继承过程\r\nfunction inheritPrototype(Sub, Super) {\r\n  // 以该对象为原型创建一个新对象\r\n  var prototype = Object.create(Super.prototype);\r\n  prototype.constructor = Sub;\r\n  Sub.prototype = prototype;\r\n}\r\n\r\ninheritPrototype(Sub, Super);\r\n\r\n// 必须定义在inheritPrototype方法之后\r\nSub.prototype.sayAge = function () {\r\n  return this.age;\r\n}\r\n\r\nvar instance = new Sub('张三', 40);\r\ninstance.sayName(); // 张三\r\ninstance.sayAge(); // 40\r\n```\r\n\r\n这种方式只调用了一次父类构造函数，只在子类上创建一次对象，同时保持原型链，还可以使用instanceof和isPrototypeOf()来判断原型，是我们最理想的继承方式。\r\n\r\n#### 第七种: ES6 Class类和extends关键字\r\n\r\nES6引进了class关键字，用于创建类，这里的类是作为**ES5构造函数和原型对象的语法糖**存在的，其功能大部分都可以被ES5实现，不过在语言层面上ES6也提供了部分支持。新的写法不过让对象原型看起来更加清晰，更像面向对象的语法而已。\r\n\r\n``` js\r\n//定义类\r\nclass Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  toString() {\r\n    return '(' + this.x + ', ' + this.y + ')';\r\n  }\r\n}\r\n\r\nvar point = new Point(10, 10);\r\n```\r\n\r\n我们看到其中的constructor方法就是之前的构造函数，this就是之前的原型对象，toString()就是定义在原型上的方法，只能使用new关键字来新建实例。语法差别在于我们不需要function关键字和逗号分割符。其中，所有的方法都直接定义在原型上，注意所有的方法都不可枚举。类的内部使用严格模式，并且不存在变量提升，其中的this指向类的实例。\r\n\r\nnew是从构造函数生成实例的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。\r\n\r\n类存在静态方法，使用static关键字表示，其只能类和继承的子类来进行调用，不能被实例调用，也就是不能被实例继承，所以我们称它为静态方法。类不存在内部方法和内部属性。\r\n\r\n``` js\r\nclass Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nFoo.classMethod() // 'hello'\r\n\r\nvar foo = new Foo();\r\nfoo.classMethod()\r\n// TypeError: foo.classMethod is not a function\r\n```\r\n\r\n类通过extends关键字来实现继承，在继承的子类的构造函数里我们使用super关键字来表示对父类构造函数的引用；在静态方法里，super指向父类；在其它函数体内，super表示对父类原型属性的引用。其中super必须在子类的构造函数体内调用一次，因为我们需要调用时来绑定子类的元素对象，否则会报错。\r\n\r\n``` js\r\nclass ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    super(x, y); // 调用父类的constructor(x, y)\r\n    this.color = color;\r\n  }\r\n\r\n  toString() {\r\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\r\n  }\r\n}\r\n```\r\n\r\n## 四、前端性能优化\r\n\r\n性能优化是把双刃剑，有好的一面也有坏的一面。好的一面就是能提升网站性能，坏的一面就是配置麻烦，或者要遵守的规则太多。并且某些性能优化规则并不适用所有场景，需要谨慎使用。\r\n\r\n下面列出来了前端性能的24条建议:\r\n\r\n### 1. 减少 HTTP 请求\r\n\r\n一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。\r\n\r\n接下来看一个具体的例子帮助理解 HTTP ：\r\n\r\n![http请求瀑布图](https://user-images.githubusercontent.com/8088864/125281253-957bc880-e348-11eb-97bf-464d4531ce8e.png)\r\n\r\n这是一个 HTTP 请求，请求的文件大小为 28.4KB。\r\n\r\n名词解释：\r\n\r\n- Queueing: 在请求队列中的时间。\r\n- Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。\r\n- Proxy negotiation: 与代理服务器连接进行协商所花费的时间。\r\n- DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。\r\n- Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。\r\n- SSL: 完成SSL握手所花费的时间。\r\n- Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。\r\n- Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。\r\n- Content Download: 接收响应数据所花费的时间。\r\n\r\n从这个例子可以看出，真正下载数据的时间占比为 13.05 / 204.16 = 6.39%，文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。\r\n\r\n### 2. 使用 HTTP2\r\n\r\nHTTP2 相比 HTTP1.1 有如下几个优点：\r\n\r\n#### 解析速度快\r\n\r\n服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。\r\n\r\n#### 多路复用\r\n\r\nHTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。\r\n\r\n在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。\r\n\r\n#### 首部压缩\r\n\r\nHTTP2 提供了首部压缩功能。\r\n\r\n例如有如下两个请求：\r\n\r\n```\r\n// 请求1\r\n:authority: unpkg.zhimg.com\r\n:method: GET\r\n:path: /za-js-sdk@2.16.0/dist/zap.js\r\n:scheme: https\r\naccept: */*\r\naccept-encoding: gzip, deflate, br\r\naccept-language: zh-CN,zh;q=0.9\r\ncache-control: no-cache\r\npragma: no-cache\r\nreferer: https://www.zhihu.com/\r\nsec-fetch-dest: script\r\nsec-fetch-mode: no-cors\r\nsec-fetch-site: cross-site\r\nuser-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\r\n\r\n// 请求2\r\n:authority: zz.bdstatic.com\r\n:method: GET\r\n:path: /linksubmit/push.js\r\n:scheme: https\r\naccept: */*\r\naccept-encoding: gzip, deflate, br\r\naccept-language: zh-CN,zh;q=0.9\r\ncache-control: no-cache\r\npragma: no-cache\r\nreferer: https://www.zhihu.com/\r\nsec-fetch-dest: script\r\nsec-fetch-mode: no-cors\r\nsec-fetch-site: cross-site\r\nuser-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\r\n```\r\n\r\n从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。\r\n\r\nHTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。\r\n\r\n下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：\r\n\r\n```\r\nHeader1:foo\r\nHeader2:bar\r\nHeader3:bat\r\n```\r\n\r\n当客户端发送请求时，它会根据首部值创建一张表：\r\n\r\n| 索引 | 首部名称 | 值 |\r\n| ---- | ---- | ---- |\r\n| 62 | Header1 | foo |\r\n| 63 | Header2 | bar |\r\n| 64 | Header3 | bar |\r\n\r\n如果服务器收到了请求，它会照样创建一张表。 当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块：\r\n\r\n```\r\n62 63 64\r\n```\r\n\r\n服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。\r\n\r\n#### 优先级\r\n\r\nHTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。\r\n\r\n#### 流量控制\r\n\r\n由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。\r\n\r\n#### 服务器推送\r\n\r\nHTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。\r\n\r\n例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。\r\n\r\n现在有很多网站已经开始使用 HTTP2 了，例如知乎：\r\n\r\n![服务器推送](https://user-images.githubusercontent.com/8088864/125283274-d83ea000-e34a-11eb-95d5-7881c4af0403.jpg)\r\n\r\n其中 h2 是指 HTTP2 协议，http/1.1 则是指 HTTP1.1 协议。\r\n\r\n参考资料：\r\n\r\n- [半小时搞懂 HTTP、HTTPS和HTTP2](https://github.com/woai3c/Front-end-articles/blob/master/http-https-http2.md)\r\n\r\n### 3. 使用服务端渲染\r\n\r\n客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\r\n\r\n服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\r\n\r\n- 优点：首屏渲染快，SEO 好。\r\n- 缺点：配置麻烦，增加了服务器的计算压力。\r\n\r\n下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。\r\n\r\n#### 客户端渲染过程\r\n\r\n1. 访问客户端渲染的网站。\r\n2. 服务器返回一个包含了引入资源语句和 \\\u003cdiv id=\"app\"\u003e\\\u003c/div\u003e 的 HTML 文件。\r\n3. 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。\r\n\r\n#### 服务端渲染过程\r\n\r\n1. 访问服务端渲染的网站。\r\n2. 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。\r\n3. 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面。\r\n\r\n从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。\r\n\r\n这样做的好处是什么？是更快的内容到达时间 (time-to-content)。\r\n\r\n假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。\r\n\r\n这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。这就是服务端渲染更快的原因。\r\n\r\n参考资料：\r\n\r\n- [vue-ssr-demo](https://github.com/woai3c/vue-ssr-demo)\r\n- [Vue.js 服务器端渲染指南](https://ssr.vuejs.org/zh/)\r\n\r\n### 4. 静态资源使用 CDN\r\n\r\n内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。\r\n\r\n#### CDN 原理\r\n\r\n当用户访问一个网站时，如果没有 CDN，过程是这样的：\r\n\r\n1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。\r\n2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。\r\n3. 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。\r\n\r\n![没有CDN的资源请求](https://user-images.githubusercontent.com/8088864/125375921-8171ae80-e3bc-11eb-9d66-adb57433b67a.jpg)\r\n\r\n如果用户访问的网站部署了 CDN，过程是这样的：\r\n\r\n1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。\r\n2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。\r\n3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。\r\n4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。\r\n5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。\r\n6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。\r\n7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。\r\n\r\n![有CDN的资源请求](https://user-images.githubusercontent.com/8088864/125376046-baaa1e80-e3bc-11eb-84ba-c86cd8d63a7f.jpg)\r\n\r\n参考资料：\r\n\r\n- [CDN是什么？使用CDN有什么优势？](https://www.zhihu.com/question/36514327/answer/193768864)\r\n- [CDN原理简析](https://juejin.cn/post/6844903873518239752)\r\n\r\n### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部\r\n\r\n所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。\r\n\r\n那为什么 CSS 文件还要放在头部呢？\r\n\r\n因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。\r\n\r\n另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。\r\n\r\n### 6. 使用字体图标 iconfont 代替图片图标\r\n\r\n字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。\r\n\r\n#### 压缩字体文件\r\n\r\n使用 [fontmin-webpack](https://github.com/patrickhulce/fontmin-webpack) 插件对字体文件进行压缩。\r\n\r\n![fontmin-webpack](https://user-images.githubusercontent.com/8088864/125377089-efb77080-e3be-11eb-845b-d8992de47838.png)\r\n\r\n参考资料：\r\n\r\n- [fontmin-webpack](https://github.com/patrickhulce/fontmin-webpack)\r\n- [Iconfont-阿里巴巴矢量图标库](https://www.iconfont.cn/)\r\n\r\n### 7. 善用缓存，不重复加载相同的资源\r\n\r\n为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。\r\n\r\n不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？\r\n\r\n可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。\r\n\r\n具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用[数据摘要要算法](https://cloud.tencent.com/developer/article/1584742)对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。\r\n\r\n参考资料：\r\n\r\n- [webpack + express 实现文件精确缓存](https://github.com/woai3c/node-blog/blob/master/doc/node-blog7.md)\r\n- [webpack-缓存](https://www.webpackjs.com/guides/caching/)\r\n- [张云龙--大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576/answer/32602154)\r\n\r\n### 8. 压缩文件\r\n\r\n压缩文件可以减少文件下载时间，让用户体验性更好。\r\n\r\n得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。\r\n\r\n在 webpack 可以使用如下插件进行压缩：\r\n\r\n- JavaScript：UglifyPlugin\r\n- CSS ：MiniCssExtractPlugin\r\n- HTML：HtmlWebpackPlugin\r\n\r\n其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。\r\n\r\ngzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。\r\n\r\n附上 webpack 和 node 配置 gzip 的使用方法。\r\n\r\n下载插件\r\n\r\n``` shell\r\nnpm install compression-webpack-plugin --save-dev\r\nnpm install compression\r\n```\r\n\r\nwebpack 配置\r\n\r\n``` js\r\nconst CompressionPlugin = require('compression-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  plugins: [new CompressionPlugin()],\r\n}\r\n```\r\n\r\nnode 配置\r\n\r\n``` js\r\nconst compression = require('compression')\r\n// 在其他中间件前使用\r\napp.use(compression())\r\n```\r\n\r\n### 9. 图片优化\r\n\r\n#### (1). 图片延迟加载\r\n\r\n在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。\r\n\r\n首先可以将图片这样设置，在页面不可见时图片不会加载：\r\n\r\n``` html\r\n\u003cimg data-src=\"https://avatars0.githubusercontent.com/u/22117876?s=460\u0026u=7bd8f32788df6988833da6bd155c3cfbebc68006\u0026v=4\"\u003e\r\n```\r\n\r\n等页面可见时，使用 JS 加载图片：\r\n\r\n``` js\r\nconst img = document.querySelector('img')\r\nimg.src = img.dataset.src\r\n```\r\n\r\n这样图片就加载出来了，完整的代码可以看一下参考资料。\r\n\r\n参考资料：\r\n\r\n- [web 前端图片懒加载实现原理](https://juejin.cn/post/6844903482164510734)\r\n\r\n#### (2). 响应式图片\r\n\r\n响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。\r\n\r\n通过 picture 实现\r\n\r\n``` html\r\n\u003cpicture\u003e\r\n  \u003csource srcset=\"banner_w1000.jpg\" media=\"(min-width: 801px)\"\u003e\r\n  \u003csource srcset=\"banner_w800.jpg\" media=\"(max-width: 800px)\"\u003e\r\n  \u003cimg src=\"banner_w800.jpg\" alt=\"\"\u003e\r\n\u003c/picture\u003e\r\n```\r\n\r\n通过 @media 实现\r\n\r\n``` css\r\n@media (min-width: 769px) {\r\n  .bg {\r\n    background-image: url(bg1080.jpg);\r\n  }\r\n}\r\n@media (max-width: 768px) {\r\n  .bg {\r\n    background-image: url(bg768.jpg);\r\n  }\r\n}\r\n```\r\n\r\n#### (3). 调整图片大小\r\n\r\n例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。\r\n\r\n所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。\r\n\r\n#### (4). 降低图片质量\r\n\r\n例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。\r\n\r\n压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。\r\n\r\n以下附上 webpack 插件 image-webpack-loader 的用法。\r\n\r\n``` shell\r\nnpm install --save-dev image-webpack-loader\r\n```\r\n\r\nwebpack 配置\r\n\r\n``` js\r\n{\r\n  test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\r\n  use:[\r\n    {\r\n    loader: 'url-loader',\r\n    options: {\r\n      limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/\r\n      name: utils.assetsPath('img/[name].[hash:7].[ext]')\r\n      }\r\n    },\r\n    /*对图片进行压缩*/\r\n    {\r\n      loader: 'image-webpack-loader',\r\n      options: {\r\n        bypassOnDebug: true,\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n参考资料：\r\n\r\n- [img图片在webpack中使用](https://juejin.cn/post/6844903816081457159)\r\n\r\n#### (5). 尽可能利用 CSS3 效果代替图片\r\n\r\n有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。\r\n\r\n#### (6). 使用 webp 格式的图片\r\n\r\nWebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。\r\n\r\n参考资料：\r\n\r\n- [WebP 相对于 PNG、JPG 有什么优势？](https://www.zhihu.com/question/27201061)\r\n\r\n### 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码\r\n\r\n懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。\r\n\r\n#### 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载\r\n\r\n通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。\r\n\r\n``` js\r\n{\r\n  output: {\r\n    filename: '[name].[contenthash].js',\r\n    chunkFilename: '[name].[contenthash].js',\r\n    path: path.resolve(__dirname, '../dist'),\r\n  },\r\n}\r\n```\r\n\r\n#### 提取第三方库\r\n\r\n由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。 这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。\r\n\r\n``` js\r\noptimization: {\r\n  runtimeChunk: {\r\n    name: 'manifest' // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。\r\n  },\r\n  splitChunks: {\r\n    cacheGroups: {\r\n      vendor: {\r\n        name: 'chunk-vendors',\r\n        test: /[\\\\/]node_modules[\\\\/]/,\r\n        priority: -10,\r\n        chunks: 'initial'\r\n      },\r\n      common: {\r\n        name: 'chunk-common',\r\n        minChunks: 2,\r\n        priority: -20,\r\n        chunks: 'initial',\r\n        reuseExistingChunk: true\r\n      }\r\n    },\r\n  }\r\n},\r\n```\r\n\r\n- **test**: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function;\r\n- **priority**: 表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；\r\n- **reuseExistingChunk**: 表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。\r\n- **minChunks**(默认是1): 在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）\r\n- **chunks**(默认是async): initial、async和all\r\n- **name**(打包的chunks的名字): 字符串或者函数(函数可以根据条件自定义名字)\r\n\r\n#### 减少 ES6 转为 ES5 的冗余代码\r\n\r\nBabel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数，比如\r\n\r\n``` js\r\nclass Person {}\r\n```\r\n\r\n会被转换为：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n}\r\n\r\nvar Person = function Person() {\r\n  _classCallCheck(this, Person);\r\n};\r\n```\r\n\r\n这里 `_classCallCheck` 就是一个 `helper` 函数，如果在很多文件里都声明了类，那么就会产生很多个这样的 `helper` 函数。\r\n\r\n这里的 `@babel/runtime` 包就声明了所有需要用到的帮助函数，而 `@babel/plugin-transform-runtime` 的作用就是将所有需要 `helper` 函数的文件，从 `@babel/runtime`包 引进来：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nvar _classCallCheck2 = require(\"@babel/runtime/helpers/classCallCheck\");\r\n\r\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\r\n\r\nfunction _interopRequireDefault(obj) {\r\n  return obj \u0026\u0026 obj.__esModule ? obj : { default: obj };\r\n}\r\n\r\nvar Person = function Person() {\r\n  (0, _classCallCheck3.default)(this, Person);\r\n};\r\n```\r\n\r\n这里就没有再编译出 helper 函数 classCallCheck 了，而是直接引用了 @babel/runtime 中的 helpers/classCallCheck。\r\n\r\n**安装**\r\n\r\n``` shell\r\nnpm install --save-dev @babel/plugin-transform-runtime @babel/runtime\r\n```\r\n\r\n**使用** 在 .babelrc 文件中\r\n\r\n``` json\r\n{\r\n  \"plugins\": [\r\n    \"@babel/plugin-transform-runtime\"\r\n  ]\r\n}\r\n```\r\n\r\n参考资料：\r\n\r\n- [Babel 7.1介绍 transform-runtime polyfill env](https://www.jianshu.com/p/d078b5f3036a)\r\n- [webpack 懒加载](https://webpack.docschina.org/guides/lazy-loading/)\r\n- [Vue 路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD)\r\n- [webpack 缓存](https://webpack.docschina.org/guides/caching/)\r\n- [一步一步的了解webpack4的splitChunk插件](https://juejin.cn/post/6844903614759043079)\r\n\r\n### 11. 减少重绘重排\r\n\r\n浏览器渲染过程\r\n\r\n1. 解析HTML生成DOM树。\r\n2. 解析CSS生成CSSOM规则树。\r\n3. 将DOM树与CSSOM规则树合并在一起生成渲染树。\r\n4. 遍历渲染树开始布局，计算每个节点的位置大小信息。\r\n5. 将渲染树每个节点绘制到屏幕。\r\n\r\n![渲染树生成](https://user-images.githubusercontent.com/8088864/125440124-9cc83d52-c342-4959-af1e-dc67cfe7d312.png)\r\n\r\n#### 重排\r\n\r\n当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。\r\n\r\n#### 重绘\r\n\r\n当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排。\r\n\r\n重排和重绘这两个操作都是非常昂贵的，因为 **JavaScript** 引擎线程与 **GUI** 渲染线程是互斥，它们同时只能一个在工作。\r\n\r\n什么操作会导致重排？\r\n\r\n- 添加或删除可见的 **DOM** 元素\r\n- 元素位置改变\r\n- 元素尺寸改变\r\n- 内容改变\r\n- 浏览器窗口尺寸改变\r\n\r\n- 如何减少重排重绘？\r\n\r\n- 用 **JavaScript** 修改样式时，最好不要直接写样式，而是替换 **class** 来改变样式。\r\n- 如果要对 **DOM** 元素执行一系列操作，可以将 **DOM** 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（**display:none**）或文档碎片（**DocumentFragment**），都能很好的实现这个方案。\r\n\r\n### 12. 使用事件委托\r\n\r\n事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。\r\n\r\n``` html\r\n\u003cul\u003e\r\n  \u003cli\u003e苹果\u003c/li\u003e\r\n  \u003cli\u003e香蕉\u003c/li\u003e\r\n  \u003cli\u003e凤梨\u003c/li\u003e\r\n\u003c/ul\u003e\r\n```\r\n\r\n``` js\r\n// good\r\ndocument.querySelector('ul').onclick = (event) =\u003e {\r\n  const target = event.target\r\n  if (target.nodeName === 'LI') {\r\n    console.log(target.innerHTML)\r\n  }\r\n}\r\n\r\n// bad\r\ndocument.querySelectorAll('li').forEach((e) =\u003e {\r\n  e.onclick = function() {\r\n    console.log(this.innerHTML)\r\n  }\r\n})\r\n```\r\n\r\n### 13. 注意程序的局部性\r\n\r\n一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用最近引用过的数据项附近的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。有良好局部性的程序比局部性差的程序运行得更快。\r\n\r\n**局部性通常有两种不同的形式：**\r\n\r\n- 时间局部性: 在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。\r\n- 空间局部性: 在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。\r\n\r\n时间局部性示例\r\n\r\n``` js\r\nfunction sum(arry) {\r\n  let i, sum = 0;\r\n  let len = arry.length;\r\n\r\n  for (i = 0; i \u003c len; i++) {\r\n    sum += arry[i];\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n在这个例子中，变量sum在每次循环迭代中被引用一次，因此，对于sum来说，具有良好的时间局部性\r\n\r\n空间局部性示例\r\n\r\n**具有良好空间局部性的程序**\r\n\r\n``` js\r\n// 二维数组\r\nfunction sum1(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (i = 0; i \u003c rows; i++) {\r\n    for (j = 0; j \u003c cols; j++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n**空间局部性差的程序**\r\n\r\n``` js\r\n// 二维数组\r\nfunction sum2(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (j = 0; j \u003c cols; j++) {\r\n    for (i = 0; i \u003c rows; i++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n看一下上面的两个空间局部性示例，像示例中从每行开始按顺序访问数组每个元素的方式，称为具有步长为1的引用模式。 如果在数组中，每隔k个元素进行访问，就称为步长为k的引用模式。 一般而言，随着步长的增加，空间局部性下降。\r\n\r\n这两个例子有什么区别？区别在于第一个示例是按行扫描数组，每扫描完一行再去扫下一行；第二个示例是按列来扫描数组，扫完一行中的一个元素，马上就去扫下一行中的同一列元素。\r\n\r\n数组在内存中是按照行顺序来存放的，结果就是逐行扫描数组的示例得到了步长为 1 引用模式，具有良好的空间局部性；而另一个示例步长为 rows，空间局部性极差。\r\n\r\n**性能测试**\r\n\r\n运行环境：\r\n\r\n- cpu: i7-10510U\r\n- 浏览器: 83.0.4103.61\r\n\r\n对一个长度为9000的二维数组（子数组长度也为9000）进行10次空间局部性测试，时间（毫秒）取平均值，结果如下：\r\n\r\n``` js\r\nfunction sum2(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (j = 0; j \u003c cols; j++) {\r\n    for (i = 0; i \u003c rows; i++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n\r\n// 二维数组\r\nfunction sum1(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (i = 0; i \u003c rows; i++) {\r\n    for (j = 0; j \u003c cols; j++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n\r\nvar arry = new Array(9000).fill(new Array(9000).fill(1));\r\n\r\nlet ts = 0;\r\nfor (let i = 0; i \u003c 10; i++) {\r\n  const startTime = new Date().valueOf();\r\n  sum1(arry, 9000, 9000);\r\n  ts += (new Date().valueOf() - startTime);\r\n}\r\n\r\nconsole.log('sum1: ' + (ts / 10)); // 81.5ms\r\n\r\nlet ts2 = 0;\r\nfor (let i = 0; i \u003c 10; i++) {\r\n  const startTime = new Date().valueOf();\r\n  sum2(arry, 9000, 9000);\r\n  ts2 += (new Date().valueOf() - startTime);\r\n}\r\n\r\nconsole.log('sum2: ' + (ts2 / 10)); // 167.3ms\r\n```\r\n\r\n所用示例为上述两个空间局部性示例\r\n\r\n| 步长为1(sum1) | 步长为9000(sum2) |\r\n| ---- | ---- |\r\n| 81.5ms | 167.3ms |\r\n\r\n从以上测试结果来看，步长为 1 的数组执行时间比步长为 9000 的数组快了一个数量级。\r\n\r\n总结：\r\n\r\n- 重复引用相同变量的程序具有良好的时间局部性\r\n- 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好；而在内存中以大步长跳来跳去的程序空间局部性会很差\r\n\r\n参考资料：\r\n\r\n- [深入理解计算机系统](https://book.douban.com/subject/26912767/)\r\n\r\n### 14. if-else 对比 switch\r\n\r\n当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\r\n\r\n``` js\r\nif (color == 'blue') {\r\n\r\n} else if (color == 'yellow') {\r\n\r\n} else if (color == 'white') {\r\n\r\n} else if (color == 'black') {\r\n\r\n} else if (color == 'green') {\r\n\r\n} else if (color == 'orange') {\r\n\r\n} else if (color == 'pink') {\r\n\r\n}\r\n\r\nswitch (color) {\r\n  case 'blue':\r\n\r\n    break;\r\n  case 'yellow':\r\n\r\n    break;\r\n  case 'white':\r\n\r\n    break;\r\n  case 'black':\r\n\r\n    break;\r\n  case 'green':\r\n\r\n    break;\r\n  case 'orange':\r\n\r\n    break;\r\n  case 'pink':\r\n\r\n    break;\r\n}\r\n```\r\n\r\n像以上这种情况，使用 switch 是最好的。假设 color 的值为 pink，则 if-else 语句要进行 7 次判断，switch 只需要进行一次判断。 从可读性来说，switch 语句也更好。\r\n\r\n从使用时机来说，当条件值大于两个的时候，使用 switch 更好。不过 if-else 也有 switch 无法做到的事情，例如有多个判断条件的情况下，无法使用 switch。\r\n\r\n### 15. 查找表\r\n\r\n当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。\r\n\r\n``` js\r\nswitch (index) {\r\n  case '0':\r\n    return result0;\r\n  case '1':\r\n    return result1;\r\n  case '2':\r\n    return result2;\r\n  case '3':\r\n    return result3;\r\n  case '4':\r\n    return result4;\r\n  case '5':\r\n    return result5;\r\n  case '6':\r\n    return result6;\r\n  case '7':\r\n    return result7;\r\n  case '8':\r\n    return result8;\r\n  case '9':\r\n    return result9;\r\n  case '10':\r\n    return result10;\r\n  case '11':\r\n    return result11;\r\n}\r\n```\r\n\r\n可以将这个 switch 语句转换为查找表\r\n\r\n``` js\r\nconst results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11];\r\n\r\nreturn results[index];\r\n```\r\n\r\n如果条件语句不是数值而是字符串，可以用对象来建立查找表\r\n\r\n``` js\r\nconst map = {\r\n  red: result0,\r\n  green: result1,\r\n};\r\n\r\nreturn map[color];\r\n```\r\n\r\n### 16. 避免页面卡顿\r\n\r\n**60fps 与设备刷新率**\r\n\r\n目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\r\n\r\n![网页渲染流程](https://user-images.githubusercontent.com/8088864/125445172-29d132ea-e485-49c7-b32d-172956c4349b.jpeg)\r\n\r\n假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。\r\n\r\n对于一些长时间运行的 JavaScript，我们可以使用定时器进行切分，延迟执行。\r\n\r\n``` js\r\nfor (let i = 0, len = arry.length; i \u003c len; i++) {\r\n  process(arry[i]);\r\n}\r\n```\r\n\r\n假设上面的循环结构由于 process() 复杂度过高或数组元素太多，甚至两者都有，可以尝试一下切分。\r\n\r\n``` js\r\nconst todo = arry.concat();\r\nsetTimeout(function(){\r\n  process(todo.shift());\r\n  if (todo.length) {\r\n    setTimeout(arguments.callee, 25);\r\n  } else {\r\n    callback(arry);\r\n  }\r\n}, 25);\r\n```\r\n\r\n如果有兴趣了解更多，可以查看一下高性能JavaScript第 6 章和[高效前端：Web高效编程与优化实践](https://book.douban.com/subject/30170670/)第 3 章。\r\n\r\n### 17. 使用 requestAnimationFrame 来实现视觉变化\r\n\r\n从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 `requestAnimationFrame`。\r\n\r\n``` js\r\n/**\r\n * If run as a requestAnimationFrame callback, this\r\n * will be run at the start of the frame.\r\n */\r\nfunction updateScreen(time) {\r\n  // Make visual updates here.\r\n}\r\n\r\nrequestAnimationFrame(updateScreen);\r\n```\r\n\r\n如果采取 setTimeout 或 setInterval 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。\r\n\r\n![requestAnimationFrame执行点](https://user-images.githubusercontent.com/8088864/125448006-c889aac7-f5d6-4a21-a4fe-b4c6c0cdf197.jpg)\r\n\r\n### 18. 使用 Web Workers\r\n\r\nWeb Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。\r\n\r\nWeb Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。\r\n\r\n创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）：\r\n\r\n``` js\r\nvar myWorker = new Worker('worker.js');\r\n// 你可以通过postMessage() 方法和onmessage事件向worker发送消息。\r\nfirst.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n\r\nsecond.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n```\r\n\r\n在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）：\r\n\r\n``` js\r\nonmessage = function(e) {\r\n  console.log('Message received from main script');\r\n  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);\r\n  console.log('Posting message back to main script');\r\n  postMessage(workerResult);\r\n}\r\n```\r\n\r\nonmessage处理函数在接收到消息后马上执行，代码中消息本身作为事件的data属性进行使用。这里我们简单的对这2个数字作乘法处理并再次使用postMessage()方法，将结果回传给主线程。\r\n\r\n回到主线程，我们再次使用onmessage以响应worker回传的消息：\r\n\r\n``` js\r\nmyWorker.onmessage = function(e) {\r\n  result.textContent = e.data;\r\n  console.log('Message received from worker');\r\n}\r\n```\r\n\r\n在这里我们获取消息事件的data，并且将它设置为result的textContent，所以用户可以直接看到运算的结果。\r\n\r\n不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。\r\n\r\n参考资料：\r\n\r\n- [Web Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)\r\n\r\n### 19. 使用位操作\r\n\r\nJavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。\r\n\r\n#### 取模\r\n\r\n由于偶数的最低位为 0，奇数为 1，所以取模运算可以用位操作来代替。\r\n\r\n``` js\r\nif (value % 2) {\r\n    // 奇数\r\n} else {\r\n    // 偶数\r\n}\r\n// 位操作\r\nif (value \u0026 1) {\r\n    // 奇数\r\n} else {\r\n    // 偶数\r\n}\r\n```\r\n\r\n#### 取整\r\n\r\n``` js\r\n~~10.12 // 10\r\n~~10 // 10\r\n~~'1.5' // 1\r\n~~undefined // 0\r\n~~null // 0\r\n```\r\n\r\n#### 位掩码\r\n\r\n``` js\r\nconst a = 1\r\nconst b = 2\r\nconst c = 4\r\nconst options = a | b | c\r\n```\r\n\r\n通过定义这些选项，可以用按位与操作来判断 a/b/c 是否在 options 中。\r\n\r\n``` js\r\n// 选项 b 是否在选项中\r\nif (b \u0026 options) {\r\n  // ...\r\n}\r\n```\r\n\r\n### 20. 不要覆盖原生方法\r\n\r\n无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。\r\n\r\n### 21. 降低 CSS 选择器的复杂性\r\n\r\n#### (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取\r\n\r\n看个示例\r\n\r\n``` css\r\n#block .text p {\r\n    color: red;\r\n}\r\n```\r\n\r\n1. 查找所有 P 元素。\r\n2. 查找结果 1 中的元素是否有类名为 text 的父元素\r\n3. 查找结果 2 中的元素是否有 id 为 block 的父元素\r\n\r\n#### (2). CSS 选择器优先级\r\n\r\n```\r\n内联 \u003e ID选择器 \u003e 类选择器 \u003e 标签选择器\r\n```\r\n\r\n根据以上两个信息可以得出结论。\r\n\r\n1. 选择器越短越好。\r\n2. 尽量使用高优先级的选择器，例如 ID 和类选择器。\r\n3. 避免使用通配符 *。\r\n\r\n最后要说一句，据我查找的资料所得，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小。\r\n\r\n### 22. 使用 flexbox 而不是较早的布局模型\r\n\r\n在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 [flexbox](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)，它比起早期的布局方式来说有个优势，那就是性能比较好。\r\n\r\n下面的截图显示了在 1300 个框上使用浮动的布局开销：\r\n\r\n![float布局的元素](https://user-images.githubusercontent.com/8088864/125547454-c911b26b-4a1c-44d8-9044-e83a09dc618d.jpg)\r\n\r\n然后我们用 flexbox 来重现这个例子：\r\n\r\n![flexbox布局的元素](https://user-images.githubusercontent.com/8088864/125547509-ecf25fd0-a9ef-438c-827a-987ea0bb9ae5.jpg)\r\n\r\n现在，对于相同数量的元素和相同的视觉外观，布局的时间要少得多（本例中为分别 3.5 毫秒和 14 毫秒）。\r\n\r\n不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。\r\n\r\n各浏览器兼容性：\r\n\r\n- Chrome 29+\r\n- Firefox 28+\r\n- Internet Explorer 11\r\n- Opera 17+\r\n- Safari 6.1+ (prefixed with -webkit-)\r\n- Android 4.4+\r\n- iOS 7.1+ (prefixed with -webkit-)\r\n\r\n但是在可能的情况下，至少应研究布局模型对网站性能的影响，并且采用最大程度减少网页执行开销的模型。\r\n\r\n在任何情况下，不管是否选择 Flexbox，都应当在应用的高压力点期间尝试完全避免触发布局！\r\n\r\n### 23. 使用 transform 和 opacity 属性更改来实现动画\r\n\r\n在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。\r\n\r\n![使用 transform 和 opacity 属性更改来实现动画](https://user-images.githubusercontent.com/8088864/125547800-ab61c27b-23fb-45bd-9d6a-2585df8d804e.jpeg)\r\n\r\n### 24. 合理使用规则，避免过度优化\r\n\r\n性能优化主要分为两类：\r\n\r\n1. 加载时优化\r\n2. 运行时优化\r\n\r\n上述 23 条建议中，属于加载时优化的是前面 10 条建议，属于运行时优化的是后面 13 条建议。通常来说，没有必要 23 条性能优化规则都用上，根据网站用户群体来做针对性的调整是最好的，节省精力，节省时间。\r\n\r\n在解决问题之前，得先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。\r\n\r\n#### 检查加载性能\r\n\r\n一个网站加载性能如何主要看白屏时间和首屏时间。\r\n\r\n- 白屏时间：指从输入网址，到页面开始显示内容的时间。\r\n- 首屏时间：指从输入网址，到页面完全渲染的时间。\r\n\r\n将以下脚本放在 \\\u003c/head\u003e 前面就能获取白屏时间。\r\n\r\n``` html\r\n\u003cscript\u003e\r\n  new Date() - performance.timing.navigationStart\r\n\u003c/script\u003e\r\n```\r\n\r\n在 `window.onload` 事件里执行 `new Date() - performance.timing.navigationStart` 即可获取首屏时间。\r\n\r\n#### 检查运行性能\r\n\r\n配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。\r\n\r\n打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。performance 的具体使用方法请用搜索引擎搜索一下，毕竟篇幅有限。\r\n\r\n通过检查加载和运行性能，相信你对网站性能已经有了大概了解。所以这时候要做的事情，就是使用上述 23 条建议尽情地去优化你的网站，加油！\r\n\r\n参考资料：\r\n\r\n- [performance.timing.navigationStart](https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/navigationStart)\r\n\r\n其他参考资料\r\n\r\n- 高性能网站建设指南\r\n- Web性能权威指南\r\n- 高性能JavaScript\r\n- [高效前端：Web高效编程与优化实践](https://book.douban.com/subject/30170670/)\r\n\r\n## 五、强缓存与协商缓存\r\n\r\n### 浏览器缓存\r\n\r\n当浏览器去请求某个文件的时候，服务端就在response header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制\r\n\r\n#### 缓存优点\r\n\r\n1. 减少了不必要的数据传输,节省带宽\r\n2. 减少服务器的负担,提升网站性能\r\n3. 加快了客户端加载网页的速度\r\n4. 用户体验友好\r\n\r\n#### 缓存缺点\r\n\r\n资源如果有更改,会导致客户端不及时更新就会造成用户获取信息滞后\r\n\r\n#### 缓存流程\r\n\r\n浏览器第一次请求时\r\n\r\n![浏览器缓存第一次请求](https://user-images.githubusercontent.com/8088864/125554789-a7d7d647-b89f-4c84-a326-5af87e6782f6.png)\r\n\r\n浏览器后续在进行请求时\r\n\r\n![浏览器缓存再次请求](https://user-images.githubusercontent.com/8088864/125554810-255dcfd2-a1f0-4e09-a329-56bacdee6d22.png)\r\n\r\n从上图可以知道,浏览器缓存包括两种类型,即强缓存(本地缓存)和协商缓存,浏览器在第一次请求发生后,再次请求时\r\n\r\n- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（`cache-control`和`expires`信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信。\r\n\r\n请求头信息\r\n\r\n```\r\nAccept: xxx\r\nAccept-Encoding: gzip,deflate\r\nAccept-Language: zh-cn\r\nConnection: keep-alive\r\nHost: xxx\r\nReferer: xxx\r\nUser-Agent: xxx\r\n```\r\n\r\n来自缓存的响应头的信息\r\n\r\n```\r\nAccept-Ranges: bytes\r\nCache-Control: max-age= xxxx\r\nContent-Encoding: gzip\r\nContent-length: 3333\r\nContent-Type: application/javascript\r\nDate: xxx\r\nExpires: xxx\r\nLast-Modified: xxx\r\nServer: 服务器\r\n```\r\n\r\n- 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（`Last-Modified`/`If-Modified-Since`和`Etag`/`If-None-Match`），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。\r\n\r\n强缓存与协商缓存的区别，可以用下表来进行描述：\r\n\r\n|  | 获取资源形式 | 状态码 | 发送请求到服务器 |\r\n| ---- | ---- | ---- | ---- |\r\n| **强缓存** | 从缓存取 | 200（from cache） | 否，直接从缓存取 |\r\n| **协商缓存** | 从缓存取 |  304（not modified） | 是，正如其名，通过服务器来告知缓存是否可用 |\r\n\r\n### 强缓存相关的header字段\r\n\r\n强缓存上面已经介绍了，直接从缓存中获取资源而不经过服务器；与强缓存相关的header字段有两个：\r\n\r\n1. **expires**: 这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如**Mon, 10 Jun 2015 21:31:12 GMT**，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。\r\n2. **cache-control：max-age=number**: 这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值：\r\n\r\n- **no-cache**: 不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。\r\n- **no-store**: 直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\r\n- **public**: 可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。\r\n- **private**: 只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。\r\n\r\n**注意：如果cache-control与expires同时存在的话，cache-control的优先级高于expires。**\r\n\r\n### 协商缓存相关的header字段\r\n\r\n协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（`Last-Modified`或者`Etag`），则后续请求则会带上对应的请求字段（`If-Modified-Since`或者`If-None-Match`），若响应头没有`Last-Modified`或者`Etag`字段，则请求头也不会有对应的字段。\r\n\r\n#### 1. Last-Modified/If-Modified-Since\r\n\r\n二者的值都是GMT格式的时间字符串，具体过程：\r\n\r\n- 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上`Last-Modified`的header，这个header表示这个资源在服务器上的最后修改时间\r\n\r\n- 浏览器再次跟服务器请求这个资源时，在request的header上加上`If-Modified-Since`的header，这个header的值就是上一次请求时返回的Last-Modified的值\r\n\r\n- 服务器再次收到资源请求时，根据浏览器传过来`If-Modified-Since`和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回`304 Not Modified`，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回`304 Not Modified`的响应时，response header中不会再添加`Last-Modified`的header，因为既然资源没有变化，那么`Last-Modified`也就不会改变，这是服务器返回304时的response header\r\n\r\n- 浏览器收到304的响应后，就会从缓存中加载资源\r\n\r\n- 如果协商缓存没有命中，浏览器直接从服务器加载资源时，`Last-Modified`的Header在重新加载的时候会被更新，下次请求时，`If-Modified-Since`会启用上次返回的`Last-Modified`值\r\n\r\n#### 2. Etag/If-None-Match\r\n\r\n这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与**Last-Modified/If-Modified-Since**类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\r\n\r\n### 既生Last-Modified何生Etag\r\n\r\n你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：\r\n\r\n- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；\r\n\r\n- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\r\n\r\n- 某些服务器不能精确的得到文件的最后修改时间。\r\n\r\n这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。\r\n\r\n**注意: Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。**\r\n\r\n### 用户的行为对缓存的影响\r\n\r\n| 用户操作 | Expires/Cache-Control | Last-Modified/ETag |\r\n| ---- | ---- | ---- |\r\n| 地址栏回车 | 有效 | 有效 |\r\n| 页面链接条状 | 有效 | 有效 |\r\n| 新开窗口 | 有效 | 有效 |\r\n| 前进后退 | 有效 | 有效 |\r\n| F5刷新 | 无效 | 有效 |\r\n| Ctrl + F5强制刷新 | 无效 | 无效 |\r\n\r\n### 强缓存如何重新加载缓存缓存过的资源\r\n\r\n使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？\r\n\r\n**通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。**\r\n\r\n``` html\r\n\u003clink rel=\"stylesheet\" href=\"a.css?a=1.0\" /\u003e\r\n...\r\n\u003cdiv class=\"app\"\u003eapp\u003c/div\u003e\r\n```\r\n\r\n这样每次文件改变后就会生成新的query值，这样query值不同，也就是页面引用的资源路径不同了，之前缓存过的资源就被浏览器忽略了，因为资源请求的路径变了。\r\n\r\n## 六、HTTP 各版本特点与区别\r\n\r\nHTTP协议到现在为止总共经历了3个版本的演化，第一个HTTP协议诞生于1989年3月。\r\n\r\n| 版本 | 功能 | 备注 |\r\n| ---- | ---- | ---- |\r\n| HTTP 0.9 | 仅支持 Get \u003cbr /\u003e 仅能访问 HTML 格式资源 | 简单单一 |\r\n| HTTP 1.0 | 新增POST，DELETE，PUT，HEADER等方式 \u003cbr /\u003e  增加请求头和响应头概念，指定协议版本号，携带其他元信息（状态码、权限、缓存、内容编码）\u003cbr /\u003e  扩展传输内容格式（图片、音视频、二进制等都可以传输） | 存活时间短 |\r\n| HTTP 1.1 | 长连接：新增 Connection 字段,可以通过keep-alive保持长连接 \u003cbr /\u003e 管道化：一次连接就形成一次管道，管道内进行多次有序响应。允许服务端发生多次请求，但是响应按序返回 \u003cbr /\u003e 缓存处理：新增 cache-control \u003cbr /\u003e 断点续传 \u003cbr /\u003e 状态码增加 | 当前主流版本号 \u003cbr /\u003e 存在Header 重复问题 |\r\n| HTTP 2.0 | 二进制分帧：数据体和头信息可以都是二进制，统称帧 \u003cbr /\u003e 多路复用与数据流：能同时发送和响应多个请求，通过数据流来传输 \u003cbr /\u003e 头部压缩：对 Header 进行压缩,避免重复浪费 \u003cbr /\u003e 服务器推送：服务器可以向客户端主动发送资源 | 2005发布 |\r\n\r\n### 1、HTTP 0.9\r\n\r\nHTTP 0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP 0.9协议只支持一种内容，即纯文本。不过网页仍然支持用HTML语言格式化，同时无法插入图片。\r\n\r\nHTTP 0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。由此可见，HTTP协议的无状态特点在其第一个版本0.9中已经成型。一次HTTP 0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。\r\n\r\n### 2、HTTP 1.0\r\n\r\nHTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用。相对于HTTP 0.9 增加了如下主要特性：\r\n\r\n- 请求与响应支持头域\r\n- 响应对象以一个响应状态行开始\r\n- 响应对象不只限于超文本\r\n- 开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法\r\n- （短连接）每一个请求建立一个TCP连接，请求完成后立马断开连接。这将会导致2个问题：连接无法复用，head of line blocking。连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类请求影响较大。head of line blocking会导致带宽无法被充分利用，以及后续健康请求被阻塞。\r\n\r\n### 3、HTTP 1.1\r\n\r\nHTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 。HTTP 1.1是目前主流的HTTP协议版本，因此这里就多花一些笔墨介绍一下HTTP 1.1的特性。\r\n\r\nHTTP 1.1引入了许多关键性能优化：keepalive连接，chunked编码传输，字节范围请求，请求流水线等\r\n\r\n#### Persistent Connection（keepalive连接）\r\n\r\n允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，以便未来的HTTP请求重用现在的连接，直到客户端或服务器端决定将其关闭为止。在HTTP1.0中使用长连接需要添加请求头 `Connection: Keep-Alive`，而在HTTP 1.1 所有的连接默认都是长连接，除非特殊声明不支持（ HTTP请求报文首部加上`Connection: close` ）。服务器端按照FIFO原则来处理不同的Request。\r\n\r\n![长连接(keepalive连接)](https://user-images.githubusercontent.com/8088864/125572282-1b48362e-ed29-42a1-9882-3710ab106b76.jpg)\r\n\r\n#### chunked编码传输\r\n\r\n该编码将实体分块传送并逐块标明长度，直到长度为0块表示传输结束，这在实体长度未知时特别有用(比如由数据库动态产生的数据)\r\n\r\n#### 字节范围请求\r\n\r\nHTTP1.1支持传送内容的一部分。比方说，当客户端已经有内容的一部分，为了节省带宽，可以只向服务器请求一部分。该功能通过在请求消息中引入了range头域来实现，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码206（Partial Content）\r\n\r\n#### 断点续传\r\n\r\nHeader 字段\r\n\r\n服务端\r\n\r\nAccept-Ranges:表示服务器支持断点续传，并且数据传输已字节为单位\r\n\r\nEtag:资源的唯一 tag 后端自定义，验证文件是否修改过。修改过就重新重头传输\r\n\r\nLast-Modified:文件上次修改时间\r\n\r\nContent-Range:返回数据范围\r\n\r\n客户端\r\n\r\nIf-Range:服务器给的 Etag 值\r\n\r\nRange:请求的数据范围\r\n\r\nIf-Modified-Since: 将服务器响应的 Last-Modified 保存， 下次发送可以携带，后台接受判断文件是否修改，没有可以返回 304状态码，叫客户端使用缓存数据，避免重复发出资源。\r\n\r\n流程\r\n\r\n![断点续传](https://user-images.githubusercontent.com/8088864/125573335-f1eda73b-ad4f-470a-808f-caa393e38b2e.png)\r\n\r\n**注意：断点续传后台返回状态码为 206。**\r\n\r\n#### Pipelining（请求流水线）\r\n\r\n#### 其他特性\r\n\r\n另外，HTTP 1.1还新增了如下特性：\r\n\r\n- 请求消息和响应消息都支持Host头域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。因此，Host头的引入就很有必要了。\r\n\r\n- 新增了一批Request method：HTTP1.1增加了OPTIONS, PUT, DELETE, TRACE, CONNECT方法\r\n\r\n- 缓存处理：HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。\r\n\r\n### 4、HTTP 2.0\r\n\r\nHTTP 2.0是下一代HTTP协议。主要特点有：\r\n\r\n#### 二进制分帧\r\n\r\nHTTP 2.0最大的特点：不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段，等等这些核心概念上一如往常，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。\r\n\r\n![二进制分帧](https://user-images.githubusercontent.com/8088864/125574741-7645e5f9-3476-44f3-94eb-4a3aaebce2ae.jpg)\r\n\r\n#### 多路复用\r\n\r\nHTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。\r\n\r\n通过单一的 HTTP2.0连接连续发起多重请求-响应消息，即客户端和服务器可以同时发送多个请求和响应，而不用顺序一一对应。\r\n\r\n每个数据流以HTTP消息的形式发送，HTTP消息被分为独立的帧，然后由一或多个帧组成，这些帧可以乱序发送，接收端根据这些帧的标识符号和首部将信息重新组装起来。\r\n\r\n默认什么情况下使用同一个连接\r\n\r\n- 同一个域名下的资源\r\n- 不同域名但是满足两个条件：1）解析到同一个 IP；2）使用同一个证书\r\n\r\n#### 头部压缩\r\n\r\n当一个客户端向相同服务器请求许多资源时，像来自同一个网页的图像，将会有大量的请求看上去几乎同样的，这就需要压缩技术对付这种几乎相同的信息。\r\n\r\n由于头信息使用文本，没有压缩，请求时候会来回重复传递，造成流量浪费。\r\n\r\n参考[HTTP2头部压缩技术介绍](https://imququ.com/post/header-compression-in-http2.html)\r\n\r\n头部压缩需要支持 HTTP2的浏览器和服务器之间：\r\n\r\n- 维护一份相同的静态字典（包含常见的头部名称，以及常见的头部名称与值的组合）\r\n- 维护一份相同的动态字典，动态添加内容（即实际的 Header 值）\r\n- 支持基于静态哈夫曼码表的哈夫曼编码（uffman Coding）\r\n\r\n原理图：\r\n\r\n![http头部压缩原理](https://user-images.githubusercontent.com/8088864/125578550-82fd62aa-eb21-4813-87d1-19904e1b42fc.png)\r\n\r\n总结： 通过映射表，传递对应编码和值来达到压缩。\r\n\r\n#### 随时复位\r\n\r\nHTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。\r\n\r\n#### 服务器端推流\r\n\r\nServer Push。客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。\r\n\r\n#### 优先权和依赖\r\n\r\n每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。\r\n\r\n## 七、队头阻塞以及解决办法\r\n\r\n### 前言\r\n\r\n通常我们提到队头阻塞，指的可能是TCP协议中的队头阻塞，但是HTTP1.1中也有一个类似TCP队头阻塞的问题，下面各自介绍一下。\r\n\r\n### TCP队头阻塞\r\n\r\n队头阻塞（head-of-line blocking）发生在一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止。该后续分节的延迟递送确保接收应用进程能够按照发送端的发送顺序接收数据。这种为了达到完全有序而引入的延迟机制非常有用，但也有不利之处。\r\n\r\n假设在单个TCP连接上发送语义独立的消息，比如说服务器可能发送3幅不同的图像供Web浏览器显示。为了营造这几幅图像在用户屏幕上并行显示的效果，服务器先发送第一幅图像的一个断片，再发送第二幅图像的一个断片，然后再发送第三幅图像的一个断片；服务器重复这个过程，直到这3幅图像全部成功地发送到浏览器为止。\r\n\r\n要是第一幅图像的某个断片内容的TCP分节丢失了，客户端将保持已到达的不按序的所有数据，直到丢失的分节重传成功。这样不仅延缓了第一幅图像数据的递送，也延缓了第二幅和第三幅图像数据的递送。\r\n\r\n### HTTP队头阻塞\r\n\r\n上面用浏览器请求图片资源举例子，但实际上HTTP自身也有类似TCP队头阻塞的情况。要介绍HTTP队头阻塞，就需要先讲讲HTTP的管道化（pipelining）。\r\n\r\n#### HTTP管道化是什么\r\n\r\nHTTP1.1 允许在持久连接上可选的使用请求管道。这是相对于keep-alive连接的又一性能优化。在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。\r\n\r\n非管道化与管道化的区别示意图\r\n\r\n![HTTP非管道化与管道化](https://user-images.githubusercontent.com/8088864/125586316-36604fa7-fcc1-453b-9ae3-4c84b39690bd.png)\r\n\r\n#### HTTP管道化产生的背景\r\n\r\n在一般情况下，HTTP遵守“请求-响应”的模式，也就是客户端每次发送一个请求到服务端，服务端返回响应。这种模式非常容易理解，但是效率并不是那么高，为了提高速度和效率，人们做了很多尝试：\r\n\r\n- 最简单的情况下，服务端一旦返回响应后就会把对应的连接关闭，客户端的多个请求实际上是串行发送的。\r\n- 除此之外，客户端可以选择同时创建多个连接，在多个连接上并行的发送不同请求。但是创建更多连接也带来了更多的消耗，当前大部分浏览器都会限制对同一个域名的连接数。\r\n- 从HTTP1.0开始增加了持久连接的概念（HTTP1.0的Keep-Alive和HTTP1.1的persistent），可以使HTTP能够复用已经创建好的连接。客户端在收到服务端响应后，可以复用上次的连接发送下一个请求，而不用重新建立连接。\r\n- 现代浏览器大多采用并行连接与持久连接共用的方式提高访问速度，对每个域名建立并行地少量持久连接。\r\n- 而在持久连接的基础上，HTTP1.1进一步地支持在持久连接上使用管道化（pipelining）特性。管道化允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，借此来减少等待时间提高吞吐；如果多个请求能在同一个TCP分节发送的话，还能提高网络利用率。但是因为HTTP管道化本身可能会导致队头阻塞的问题，以及一些其他的原因，现代浏览器默认都关闭了管道化。\r\n\r\n#### HTTP管道化的限制\r\n\r\n1. 管道化要求服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。\r\n2. 客户端需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。\r\n3. 只有幂等的请求才能进行管道化，也就是只有GET和HEAD请求才能管道化，否则可能会出现意料之外的结果\r\n\r\n#### HTTP管道化引起的请求队头阻塞\r\n\r\n前面提到HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。\r\n\r\n### 如何解决队头阻塞\r\n\r\n#### 如何解决HTTP队头阻塞\r\n\r\n对于HTTP1.1中管道化导致的请求/响应级别的队头阻塞，可以使用HTTP2解决。HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。\r\n\r\n当然，即使使用HTTP2，如果HTTP2底层使用的是TCP协议，仍可能出现TCP队头阻塞。\r\n\r\n#### 如何解决TCP队头阻塞\r\n\r\nTCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。\r\n\r\n比如google推出的QUIC协议，在某种程度上可以说避免了TCP中的队头阻塞，因为它根本不使用TCP协议，而是在UDP协议的基础上实现了可靠传输。而UDP是面向数据报的协议，数据报之间不会有阻塞约束。\r\n\r\n此外还有一个SCTP（流控制传输协议），它是和TCP、UDP在同一层次的传输协议。SCTP的多流特性也可以尽可能的避免队头阻塞的情况。\r\n\r\n### 总结\r\n\r\n从TCP队头阻塞和HTTP队头阻塞的原因我们可以看到，出现队头阻塞的原因有两个：\r\n\r\n  1. 独立的消息数据都在一个链路上传输，也就是有一个“队列”。比如TCP只有一个流，多个HTTP请求共用一个TCP连接\r\n  2. 队列上传输的数据有严格的顺序约束。比如TCP要求数据严格按照序号顺序，HTTP管道化要求响应严格按照请求顺序返回\r\n\r\n所以要避免队头阻塞，就需要从以上两个方面出发，比如quic协议不使用TCP协议而是使用UDP协议，SCTP协议支持一个连接上存在多个数据流等等。\r\n\r\n## 八、QUIC\r\n\r\nQUIC（Quick UDP Internet Connection）是谷歌制定的一种互联网传输层协议，它基于UDP传输层协议，同时兼具TCP、TLS、HTTP/2等协议的可靠性与安全性，可以有效减少连接与传输延迟，更好地应对当前传输层与应用层的挑战。\r\n\r\n### QUIC的由来：为什么是UDP而非TCP？\r\n\r\nUDP和TCP都属于传输层协议。TCP是面向连接的，更强调的是传输的可靠性，通过TCP连接传送的数据，无差错，不丢失，不重复，按序到达，但是因为TCP在传递数据之前会有三次握手来建立连接，所以效率低、占用系统的CPU、内存等硬件资源较高；而UDP的无连接的（即发送数据之前不需要建立连接），只需要知道对方地址即可发送数据，具有较好的实时性，工作效率比TCP高，占用系统资源比TCP少，但是在数据传递时，如果网络质量不好，就会很容易丢包。\r\n\r\n我们知道，大部分Web平台的数据传输都基于TCP协议。实际上，TCP在设计之初，网络环境复杂、丢包率高、网速差，所以TCP可以完美解决可靠性的问题。而如今的网络环境和网速都已经取得了巨大的改善，网络传输可靠性已经不再是棘手的问题。另外，TCP还有一个很大的问题是更新非常困难。这是因为：TCP网络协议栈的实现依赖于系统内核更新，一旦系统内核更新，终端设备、中间设备的系统更新都会非常缓慢，迭代需要花费几年甚至十几年的时间，这显然跟不上当今互联网的发展速度。所以现在解法就是，抛弃TCP而使用UDP，来实现低延迟的传输需求。\r\n\r\n![QUIC is very similar to TCP TLS HTTP 2 0 implemented on UDP](https://user-images.githubusercontent.com/8088864/125581409-742f54c2-93aa-4d3a-919e-d3710b318361.jpg)\r\n\r\n为了结合两者优点，谷歌公司推出了QUIC，它的升级不依赖于系统内核，只需要Client和Server端更新到指定版本。如此一来，基于UDP的QUIC就能月更甚至周更，很好的解决了TCP部署和更新的困难，更灵活地实现部署和更新。\r\n\r\n### 为什么要用QUIC？\r\n\r\n#### 1. 建连延迟低\r\n\r\n网民传统TCP三次握手+TLS1~2RTT握手+http数据，基于TCP的HTTPS一次建连至少需要2~3个RTT，而QUIC基于UDP，完整握手只需要1RTT乃至0RTT，可以显著降低延迟。\r\n\r\n![QUIC握手](https://user-images.githubusercontent.com/8088864/125584078-81044014-9ed7-47ba-93a4-24623b716b07.jpg)\r\n\r\n#### 2. 安全又可靠\r\n\r\nQUIC具备TCP、TLS、HTTPS/2等协议的安全、可靠性的特点，通过提供安全功能（如身份验证和加密）来实现加密传输，这些功能由传输协议本身的更高层协议（如TLS）来实现。\r\n\r\n#### 3. 改造灵活\r\n\r\nQUIC在应用程序层面就能实现不同的拥塞控制算法，不需要操作系统和内核支持，这相比于传统的TCP协议改造灵活性更好。\r\n\r\n#### 4. 改进的拥塞控制\r\n\r\nQUIC主要实现了TCP的慢启动、拥塞避免、快重传、快恢复。在这些拥塞控制算法的基础上改进，例如单调递增的 Packet Number，解决了重传的二义性，确保RTT准确性，减少重传次数。\r\n\r\n#### 5. 无队头阻塞的多路复用\r\n\r\nHTTP2实现了多路复用，可以在一条TCP流上并发多个HTTP请求，但基于TCP的HTTP2在传输层却有个问题，TCP无法识别不同的HTTP2流，实际收数据仍是一个队列，当后发的流先收到时，会因前面的流未到达而被阻塞。QUIC一个connection可以复用传输多个stream，每个stream之间都是独立的，一个stream的丢包不会影响到其他stream的接收和处理。\r\n\r\n![QUIC特点](https://user-images.githubusercontent.com/8088864/125585210-a874fcb0-87ab-46a5-b254-825c78034943.jpg)\r\n\r\n综上所述，QUIC具有众多优点，它融合了UDP协议的速度、性能与TCP的安全与可靠，大大优化了互联网传输体验。\r\n\r\n作为提升终端用户访问效率的CDN服务，其节点之间存在大量数据互通，节点之间的网络连接、传输架构等因素都会对CDN服务质量产生影响。而将QUIC应用在CDN系统中，CDN用户开启QUIC功能后，系统将遵循QUIC协议进行用户IP请求处理，既能满足安全传输的需求，也能提升传输效率。\r\n\r\n### QUIC对客户端的要求\r\n\r\n- 如果您使用Chrome浏览器，则只支持QUIC协议Q43版本。当前阿里云CDN的QUIC协议是Q39版本，不支持直接对阿里云CDN发起QUIC请求。\r\n- 如果您使用自研App，则App必须集成支持QUIC协议的网络库，例如：lsquic-client或cronet网络库。\r\n\r\n### QUIC应用场景\r\n\r\n1. 图片小文件：明显降低文件下载总耗时，提升效率\r\n2. 视频点播：提升首屏秒开率，降低卡顿率，提升用户观看体验\r\n3. 动态请求：适用于动态请求，提升访问速度，如网页登录、交易等交互体验提升\r\n4. 弱网环境：在丢包和网络延迟严重的情况下仍可提供可用的服务，并优化卡顿率、请求失败率、秒开率、提高连接成功率等传输指标\r\n5. 大并发连接：连接可靠性强，支持页面资源数较多、并发连接数较多情况下的访问速率提升\r\n6. 加密连接：具备安全、可靠的传输性能\r\n\r\n## 九、WebRTC的优缺点\r\n\r\n目前几乎所有主流浏览器都支持了 WebRTC，越来越多的公司正在使用 WebRTC 并且将其加到自己的应用程序中。在浏览器端，依赖于浏览器获取音视频的能力，以及强大的网页上的渲染能力，就能够为高清的通信体验打下基础。同时，相比移动端来说，屏幕比较大，视窗选择也比较灵活。\r\n\r\n### 优点\r\n\r\n1. 方便。对于用户来说，在WebRTC出现之前想要进行实时通信就需要安装插件和客户端，但是对于很多用户来说，插件的下载、软件的安装和更新这些操作是复杂而且容易出现问题的，现在WebRTC技术内置于浏览器中，用户不需要使用任何插件或者软件就能通过浏览器来实现实时通信。对于开发者来说，在Google将WebRTC开源之前，浏览器之间实现通信的技术是掌握在大企业手中，这项技术的开发是一个很困难的任务，现在开发者使用简单的HTML标签和JavaScript API就能够实现Web音/视频通信的功能。\r\n\r\n2. 免费。虽然WebRTC技术已经较为成熟，其集成了最佳的音/视频引擎，十分先进的codec，但是Google对于这些技术不收取任何费用。\r\n\r\n3. 强大的打洞能力。WebRTC技术包含了使用STUN、ICE、TURN、RTP-over-TCP的关键NAT和防火墙穿透技术，并支持代理。\r\n\r\n### 缺点\r\n\r\n1. 缺乏服务器方案的设计和部署。\r\n\r\n2. 传输质量难以保证。WebRTC的传输设计基于P2P，难以保障传输质量，优化手段也有限，只能做一些端到端的优化，难以应对复杂的互联网环境。比如对跨地区、跨运营商、低带宽、高丢包等场景下的传输质量基本是靠天吃饭，而这恰恰是国内互联网应用的典型场景。\r\n\r\n3. WebRTC比较适合一对一的单聊，虽然功能上可以扩展实现群聊，但是没有针对群聊，特别是超大群聊进行任何优化。\r\n\r\n4. 设备端适配，如回声、录音失败等问题层出不穷。这一点在安卓设备上尤为突出。由于安卓设备厂商众多，每个厂商都会在标准的安卓框架上进行定制化，导致很多可用性问题（访问麦克风失败）和质量问题（如回声、啸叫）。\r\n\r\n5. 对Native开发支持不够。WebRTC顾名思义，主要面向Web应用，虽然也可以用于Native开发，但是由于涉及到的领域知识（音视频采集、处理、编解码、实时传输等）较多，整个框架设计比较复杂，API粒度也比较细，导致连工程项目的编译都不是一件容易的事。\r\n\r\n## 十、EventSource和轮询的优缺点\r\n\r\n### EventSource\r\n\r\n#### 简介\r\n\r\nEventSource 是服务器推送的一个网络事件接口。一个EventSource实例会对HTTP服务开启一个持久化的连接，以text/event-stream 格式发送事件, 会一直保持开启直到被要求关闭。\r\n\r\n一旦连接开启，来自服务端传入的消息会以事件的形式分发至你代码中。如果接收消息中有一个事件字段，触发的事件与事件字段的值相同。如果没有事件字段存在，则将触发通用事件。\r\n\r\n与 WebSockets,不同的是，服务端推送是单向的。数据信息被单向从服务端到客户端分发. 当不需要以消息形式将数据从客户端发送到服务器时，这使它们成为绝佳的选择。例如，对于处理社交媒体状态更新，新闻提要或将数据传递到客户端存储机制（如IndexedDB或Web存储）之类的，EventSource无疑是一个有效方案。\r\n\r\n- `EventSource`（Server-sent events）简称SSE用于向服务端发送事件，它是基于http协议的单向通讯技术，以`text/event-stream`格式接受事件，如果不关闭会一直处于连接状态，直到调用`EventSource.close()`方法才能关闭连接；\r\n\r\n- `EvenSource`本质上也就是`XHR-streaming`只不过浏览器给它提供了标准的API封装和协议。\r\n\r\n- 由于`EventSource`是单向通讯，所以只能用来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。\r\n\r\n- `EventSource`虽然不支持双向通讯，但是在功能设计上他也有一些优点比如可以自动重连接,event IDs,以及发送随机事件的等功能\r\n\r\n`EventSource`案例浏览器端代码如下所示:\r\n\r\n``` js\r\n// 实例化 EventSource 参数是服务端监听的路由\r\nvar source = new EventSource('sse.php');\r\n\r\nsource.onopen = function (event) { // 与服务器连接成功回调\r\n  console.log('成功与服务器连接');\r\n}\r\n\r\n// 监听从服务器发送来的所有没有指定事件类型的消息(没有event字段的消息)\r\nsource.onmessage = function (event) { // 监听未命名事件\r\n  console.log('未命名事件', event.data);\r\n}\r\n\r\nsource.onerror = function (error) { // 监听错误\r\n  console.log('错误');\r\n}\r\n\r\n// 监听指定类型的事件（可以监听多个）\r\nsource.addEventListener(\"myEve\", function (event) {\r\n  console.log(\"myEve\", event.data)\r\n})\r\n```\r\n\r\n#### EventSource规范字段\r\n\r\n- **event**: 事件类型，如果指定了该字段，则在客户端接收到该条消息时，会在当前的EventSource对象上触发一个事件，事件类型就是该字段的字段值，你可以使用addEventListener()方法在当前EventSource对象上监听任意类型的命名事件，如果该条消息没有event字段，则会触发onmessage属性上的事件处理函数。\r\n- **data**: 消息的数据字段，如果该消息包含多个data字段，则客户端会用换行符把他们连接成一个字符串来处理\r\n- **id**: 事件ID，会成为当前EventSource对象的内部属性“最后一个事件ID”的属性值；\r\n- **retry**: 一个整数值，指定了重新连接的时间（单位为毫秒），如果该字段不是整数，则会被忽略。\r\n\r\n#### EventSource属性\r\n\r\n- **EventSource.onerror**: 是一个 EventHandler，当发生错误时被调用，并且在此对象上派发 error 事件。\r\n- **EventSource.onmessage**: 是一个 EventHandler，当收到一个 message事件，即消息来自源头时被调用。\r\n- **EventSource.onopen**: 是一个 EventHandler，当收到一个 open 事件，即连接刚打开时被调用。\r\n- **EventSource.readyState**(只读): 一个 unsigned short 值，代表连接状态。可能值是CONNECTING (0), OPEN (1), 或者 CLOSED (2)。\r\n- **EventSource.url**(只读): 一个DOMString，代表源头的URL。\r\n\r\n#### EventSource 通讯过程\r\n\r\n![EventSource通讯过程](https://user-images.githubusercontent.com/8088864/125590756-ffd10207-83de-4166-a8b5-9fc848c191cc.png)\r\n\r\n#### 缺点\r\n\r\n1. 因为是服务器-\u003e客户端的，所以它不能处理客户端请求流\r\n2. 因为是明确指定用于传输UTF-8数据的，所以对于传输二进制流是低效率的，即使你转为base64的话，反而增加带宽的负载，得不偿失。\r\n\r\n### 轮询\r\n\r\n#### 短轮询(Polling)\r\n\r\n是一种简单粗暴，同样也是一种效率低下的实现“实时”通讯方案，这种方案的原理就是定期向服务器发送请求，主动拉取最新的消息队列。\r\n\r\n客户端代码：\r\n\r\n``` js\r\nfunction Polling() {\r\n  fetch(url).then(data =\u003e {\r\n    // somthing\r\n  }).catch(err =\u003e {\r\n    console.error(err);\r\n  });\r\n}\r\n\r\n//每5s执行一次\r\nsetInterval(polling, 5000);\r\n```\r\n\r\n![短轮询流程](https://user-images.githubusercontent.com/8088864/125591641-814c4239-47e3-41da-ad9e-a0c7e64dfe72.png)\r\n\r\n这种轮询方式比较适合服务器信息定期更新的场景，如天气预报股票行情等，每隔一段时间会进行更新，且轮询间隔的服务器更新频率保持一致是比较理想的方式，但很多多时候会因网络或者服务器出现阻塞早场事件间隔不一致。\r\n\r\n优点：\r\n\r\n- 可以看到实现非常简单，它的兼容性也比较好的只要支持http协议就可以用这种方式实现\r\n\r\n缺点：\r\n\r\n- 资源浪费: 比如轮询的间隔小于服务器信息跟新频率，会浪费很多HTTP请求，消耗宝贵的CPU时间和带宽。\r\n\r\n- 容易导致请求轰炸: 例如当服务器负载比较高时，第一个请求还没有处理完，这时第三、第四个请求接踵而来，无用的额外请求对服务器端进行了轰炸。\r\n\r\n#### 长轮询(Long Polling)\r\n\r\n这是一种优化的轮询方式，称为长轮询，sockjs就是使用的这种轮询方式，长轮询值的是浏览器发送一个请求到服务器，服务器只有在有可用的新数据时才会响应。\r\n\r\n客户端代码:\r\n\r\n``` js\r\nfunction LongPolling() {\r\n    fetch(url).then(data =\u003e {\r\n        LongPolling();\r\n    }).catch(err =\u003e {\r\n        LongPolling();\r\n        console.log(err);\r\n    });\r\n}\r\nLongPolling();\r\n```\r\n\r\n![长轮询流程](https://user-images.githubusercontent.com/8088864/125592542-e5c7fb6b-18b8-434f-a4ee-f986684dcbbf.png)\r\n\r\n客户端向服务器发送一个消息获取请求时，服务器会将当前的消息队列返回给客户端，然后关闭连接。当消息队列为空的时，服务器不会立即关闭连接，而是等待指定的时间间隔，如果在这个时间间隔内没有新的消息，则由客户端主动超时关闭连接。\r\n\r\n相比Polling，客户端的轮询请求只有在上一个请求连接关闭后才会重新发起。这就解决了Polling的请求轰炸问题。服务器可以控制的请求时序，因为在服务器未响应之前，客户端不会发送额为的请求。\r\n\r\n优点:\r\n\r\n- 长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。\r\n\r\n缺点:\r\n\r\n- 连接挂起也会导致资源的浪费。\r\n\r\n### EventSource VS 轮询\r\n\r\n|  | 轮询(Polling) | 长轮询(Long-Polling) | EventSource |\r\n| ---- | ---- | ---- | ---- |\r\n| 通信协议 | http | http | http |\r\n| 触发方式 | client(客户端) | client(客户端) | client、server(客户端、服务端) |\r\n| 优点 | 兼容性好容错性强，实现简单 | 比短轮询节约f服务器资源 | 实现简便，开发成本低 |\r\n| 缺点 | 安全性差，占较多的内存资源与请求数量，容易对服务器造成压力，请求时间间隔容易导致不一致 | 安全性差，占较多的内存资源与请求数，请求时间间隔容易导致不一致 | 只适用高级浏览器，老版本的浏览器不兼容 |\r\n| 延迟 | 非实时，延迟取决于请求间隔 | 非实时，延迟取决于请求间隔 | 非实时，默认3秒延迟，延迟可自定义 |\r\n\r\n### 总结\r\n\r\n通过对上面两种对通讯技术比较，可以从不同的角度考虑；\r\n\r\n- 兼容性: 短轮询 \u003e 长轮询 \u003e EventSource\r\n- 性能: EvenSource \u003e 长轮询 \u003e 短轮询\r\n- 服务端推送: EventSource \u003e 长连接 （短轮询基本不考虑）\r\n\r\n## 十一、WebSocket 是什么原理？为什么可以实现持久连接？\r\n\r\n### WebSocket 机制\r\n\r\n以下简要介绍一下WebSocket的原理及运行机制。\r\n\r\nWebSocket是HTML5下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与HTTP一样通过已建立的TCP连接来传输数据，但是它和HTTP最大不同是：\r\n\r\n- WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；\r\n- WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。\r\n\r\n传统HTTP客户端与服务器请求响应模式如下图所示：\r\n\r\n![传统HTTP客户端与服务器请求响应模型](https://user-images.githubusercontent.com/8088864/125600810-db0eaedf-6a66-4d71-b9c6-1a5d891a7b86.jpg)\r\n\r\nWebSocket模式客户端与服务器请求响应模式如下图：\r\n\r\n![WebSocket模式客户端与服务器请求响应模式](https://user-images.githubusercontent.com/8088864/125600954-0e796b1d-dd3a-482c-ab83-0d43f1abf610.jpg)\r\n\r\n上图对比可以看出，相对于传统HTTP每次请求-响应都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。\r\n\r\n相比HTTP长连接，WebSocket有以下特点：\r\n\r\n- 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。\r\n- HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）。此外还有 multiplexing、不同的URL可以复用同一个WebSocket连接等功能。这些都是HTTP长连接不能做到的。\r\n\r\n### WebSocket协议的原理\r\n\r\n与http协议一样，WebSocket协议也需要通过已建立的TCP连接来传输数据。具体实现上是通过http协议建立通道，然后在此基础上用真正的WebSocket协议进行通信，所以WebSocket协议和http协议是有一定的交叉关系的。\r\n\r\n![WebSocket协议原理流程图](https://user-images.githubusercontent.com/8088864/125603352-ba55e8bd-f554-4ef1-8c0c-add611f63023.jpg)\r\n\r\n下面是WebSocket协议请求头：\r\n\r\n![WebSocket协议请求头](https://user-images.githubusercontent.com/8088864/125603469-ef8dfb8e-988a-4bc6-a041-487f697cb72a.jpg)\r\n\r\n其中请求头中重要的字段：\r\n\r\n``` request header\r\nConnection:Upgrade\r\n\r\nUpgrade:websocket\r\n\r\nSec-WebSocket-Extensions:permessage-deflate; client_max_window_bits\r\n\r\nSec-WebSocket-Key:mg8LvEqrB2vLpyCNnCJV3Q==\r\n\r\nSec-WebSocket-Version:13\r\n```\r\n\r\n1. Connection和Upgrade字段告诉服务器，客户端发起的是WebSocket协议请求\r\n2. Sec-WebSocket-Extensions表示客户端想要表达的协议级的扩展\r\n3. Sec-WebSocket-Key是一个Base64编码值，由浏览器随机生成\r\n4. Sec-WebSocket-Version表明客户端所使用的协议版本\r\n\r\n而得到的响应头中重要的字段：\r\n\r\n``` response header\r\nConnection:Upgrade\r\n\r\nUpgrade:websocket\r\n\r\nSec-WebSocket-Accept:AYtwtwampsFjE0lu3kFQrmOCzLQ=\r\n```\r\n\r\n1. Connection和Upgrade字段与请求头中的作用相同\r\n\r\n2. Sec-WebSocket-Accept表明服务器接受了客户端的请求\r\n\r\n``` response header\r\nStatus Code:101 Switching Protocols\r\n```\r\n\r\n并且http请求完成后响应的状态码为101，表示切换了协议，说明WebSocket协议通过http协议来建立运输层的TCP连接，之后便与http协议无关了。\r\n\r\n### WebSocket协议的优缺点\r\n\r\n优点：\r\n\r\n- WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的\r\n- 服务器可以向客户端推送消息了\r\n\r\n缺点：\r\n\r\n- 少部分浏览器不支持，浏览器支持的程度与方式有区别\r\n\r\nWebSocket协议的应用场景\r\n\r\n- 即时聊天通信\r\n- 多玩家游戏\r\n- 在线协同编辑/编辑\r\n- 实时数据流的拉取与推送\r\n- 体育/游戏实况\r\n- 实时地图位置\r\n\r\n一个使用WebSocket应用于视频的业务思路如下：\r\n\r\n- 使用心跳维护websocket链路，探测客户端端的网红/主播是否在线\r\n- 设置负载均衡7层的proxy_read_timeout默认为60s\r\n- 设置心跳为50s，即可长期保持Websocket不断开\r\n\r\n## 十二、Sass\r\n\r\nSass (英文全称：Syntactically Awesome Stylesheets) 是一个最初由 Hampton Catlin 设计并由 Natalie Weizenbaum 开发的层叠样式表语言。\r\n\r\nSass 是一个 CSS 预处理器。\r\n\r\nSass 是 CSS 扩展语言，可以帮助我们减少 CSS 重复的代码，节省开发时间。\r\n\r\nSass 完全兼容所有版本的 CSS。\r\n\r\nSass 扩展了 CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。\r\n\r\nSass 生成良好格式化的 CSS 代码，易于组织和维护。\r\n\r\nSass 文件后缀为 `.scss`。\r\n\r\n浏览器并不支持 Sass 代码。因此，你需要使用一个 Sass 预处理器将 Sass 代码转换为 CSS 代码。\r\n\r\n## 十三、三栏弹性布局的5种方法(绝对定位、圣杯、双飞翼、flex、grid)\r\n\r\n### 需求\r\n\r\n用css实现三栏布局，html结构代码如下，顺序不能变（main优先渲染），可以适当加元素，同时要求left宽度200px，right宽度300px，main宽度自适应。\r\n\r\n``` html\r\n\u003cdiv class=\"container\"\u003e\r\n  \u003cdiv class=\"main\"\u003emain 宽度自适应\u003c/div\u003e\r\n  \u003cdiv class=\"left\"\u003eleft 宽200px\u003c/div\u003e\r\n  \u003cdiv class=\"right\"\u003eright 宽300px\u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n![三栏布局](https://user-images.githubusercontent.com/8088864/125612523-d7b144ff-a0a3-4522-ad8b-c2a7179198c2.gif)\r\n\r\n### 5种具体实现和优缺点比较\r\n\r\n#### 1. 绝对定位布局\r\n\r\n原始的布局方法\r\n\r\n- 原理：container为相对定位并设置左右padding为left和right的宽度，left\\right绝对定位在左右两侧，main不用设置。\r\n\r\n- 优点：兼容好、原理简单\r\n\r\n- 缺点：left和right都为绝对定位，高度不能撑开container\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003e绝对定位布局\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cstyle\u003e\r\n  .container {\r\n    color: #fff;\r\n    position: relative;\r\n    padding: 0 300px 0 200px;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    top: 0;\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    position: absolute;\r\n    width: 200px;\r\n    background: blue;\r\n    left: 0;\r\n  }\r\n\r\n  .right {\r\n    position: absolute;\r\n    width: 300px;\r\n    background: red;\r\n    right: 0;\r\n  }\r\n\r\n  .main {\r\n    background: green;\r\n  }\r\n\u003c/style\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"container\"\u003e\r\n    \u003cdiv class=\"main\"\u003emain 宽度自适应\u003c/div\u003e\r\n    \u003cdiv class=\"left\"\u003eleft 宽200px\u003c/div\u003e\r\n    \u003cdiv class=\"right\"\u003eright 宽300px\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n#### 2. 圣杯布局\r\n\r\n圣杯布局方法\r\n\r\n- 原理：container设置左右padding为left和right的宽度，left\\right\\main 浮动，left\\right相对定位并设置left、right、margin-left来偏移位置，main宽100%。\r\n- 优点：兼容好\r\n- 缺点：原理复制，left/right/main高度自适应情况下3者不能高度一致。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003e圣杯布局\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cstyle\u003e\r\n  .container {\r\n    color: #fff;\r\n    overflow: hidden;\r\n    padding: 0 300px 0 200px;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    float: left;\r\n    position: relative;\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    width: 200px;\r\n    background: blue;\r\n    margin-left: -100%;\r\n    left: -200px;\r\n  }\r\n\r\n  .right {\r\n    width: 300px;\r\n    background: red;\r\n    margin-left: -300px;\r\n    right: -300px;\r\n  }\r\n\r\n  .main {\r\n    width: 100%;\r\n    background: green;\r\n  }\r\n\u003c/style\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"container\"\u003e\r\n    \u003cdiv class=\"main\"\u003emain 宽度自适应\u003c/div\u003e\r\n    \u003cdiv class=\"left\"\u003eleft 宽200px\u003c/div\u003e\r\n    \u003cdiv class=\"right\"\u003eright 宽300px\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n#### 3. 双飞翼布局\r\n\r\n圣杯布局改进方法\r\n\r\n- 原理：left\\right\\main 浮动，left\\right设置margin-left来偏移位置，main宽100%，main出入content，并设置content的左右边距为left\\right宽度\r\n- 优点：兼容好，原理简单\r\n- 缺点：left/right/main高度自适应情况下3者不能高度一致。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003e双飞翼布局\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cstyle\u003e\r\n  .container {\r\n    color: #fff;\r\n    overflow: hidden;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    float: left;\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    width: 200px;\r\n    background: blue;\r\n    margin-left: -100%;\r\n  }\r\n\r\n  .right {\r\n    width: 300px;\r\n    background: red;\r\n    margin-left: -300px;\r\n  }\r\n\r\n  .main {\r\n    width: 100%;\r\n    background: green;\r\n  }\r\n\r\n  .content {\r\n    margin: 0 300px 0 200px;\r\n  }\r\n\u003c/style\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"container\"\u003e\r\n    \u003cdiv class=\"main\"\u003e\r\n      \u003cdiv class=\"content\"\u003e\r\n        main 宽度自适应\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"left\"\u003eleft 宽200px\u003c/div\u003e\r\n    \u003cdiv class=\"right\"\u003eright 宽300px\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n#### 4. flex布局\r\n\r\ncss3新布局方式\r\n\r\n- 原理：container设置`display:flex`，left设置`order:-1`排在最前面，main设置`flex-grow:1`自适应宽度\r\n- 优点：原理简单，代码简洁，left/right/main高度自适应情况下3者能高度一致\r\n- 缺点：兼容性不够好，ie10+，chrome20+，正式使用要加各种前缀（-webkit--ms-）\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n  \u003cmeta charset=\"UTF-8\"\u003e\r\n  \u003ctitle\u003eflex布局\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cstyle\u003e\r\n  .container {\r\n    color: #fff;\r\n    display: flex;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    order: -1;\r\n    width: 200px;\r\n    background: blue;\r\n  }\r\n\r\n  .right {\r\n    width: 300px;\r\n    background: red;\r\n  }\r\n\r\n  .main {\r\n    flex-grow: 1;\r\n    background: green;\r\n  }\r\n\u003c/style\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"container\"\u003e\r\n    \u003cdiv class=\"main\"\u003emain 宽度自适应\u003c/div\u003e\r\n    \u003cdiv class=\"left\"\u003eleft 宽200px\u003c/div\u003e\r\n    \u003cdiv class=\"right\"\u003eright 宽300px\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n#### 5. grid布局\r\n\r\ncss3新布局方式\r\n\r\n- 原理：container设置`display:grid` 和 `grid-template-columns:200px auto 300px`，left设置`order: -1`排在最前面\r\n- 优点：原理简单，代码简洁，left/right/main高度自适应情况下3者能高度一致\r\n- 缺点：兼容性较差，ie10+，Chrome57+，正式使用要加各种前缀（-webkit--ms-）\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003egrid布局\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cstyle\u003e\r\n  .container {\r\n    color: #fff;\r\n    display: grid;\r\n    grid-template-columns: 200px auto 300px;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    order: -1;\r\n    background: blue;\r\n  }\r\n\r\n  .right {\r\n    background: red;\r\n  }\r\n\r\n  .main {\r\n    background: green;\r\n  }\r\n\u003c/style\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"container\"\u003e\r\n    \u003cdiv class=\"main\"\u003emain 宽度自适应\u003c/div\u003e\r\n    \u003cdiv class=\"left\"\u003eleft 宽200px\u003c/div\u003e\r\n    \u003cdiv class=\"right\"\u003eright 宽300px\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n## 十四、浅析CSS里的BFC和IFC的用法\r\n\r\n### BFC简介\r\n\r\n所谓的 Formatting Context(格式化上下文), 它是 W3C CSS2.1 规范中的一个概念。\r\n\r\n- 格式化上下文(FC)是页面中的一块渲染区域，并且有一套渲染规则。\r\n- 格式化上下文(FC)决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\r\n\r\nBlock Formatting Context (BFC，块级格式化上下文)，就是一个块级元素的渲染显示规则。通俗一点讲，可以把 BFC 理解为一个封闭的大箱子，容器里面的子元素不会影响到外面的元素，反之也如此。\r\n\r\nBFC的布局规则如下：\r\n\r\n1. 内部的盒子会在垂直方向，一个个地放置；\r\n2. BFC是页面上的一个隔离的独立容器；\r\n3. 属于同一个BFC的 两个相邻Box的 上下margin会发生重叠；\r\n4. 计算BFC的高度时，浮动元素也参与计算；\r\n5. 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；\r\n6. BFC的区域不会与float重叠。\r\n\r\n那么如何触发 BFC 呢？只要元素满足下面任一条件即可触发 BFC 特性：\r\n\r\n- body 根元素；\r\n- 浮动元素：float 不为none的属性值；\r\n- 绝对定位元素：position (absolute、fixed)；\r\n- display为： inline-block、table-cells、flex；\r\n- overflow 除了visible以外的值 (hidden、auto、scroll)。\r\n\r\n### BFC的特性及应用\r\n\r\n#### 同一个 BFC下外边距 会发生折叠\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n  .p {\r\n    width: 200px;\r\n    height: 50px;\r\n    margin: 50px 0;\r\n    background-color: red;\r\n  }\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"p\"\u003e\u003c/div\u003e\r\n  \u003cdiv class=\"p\"\u003e\u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n效果如下所示:\r\n\r\n![同一个 BFC 下两个相邻的普通流中的块元素垂直方向上的 margin会折叠](https://user-images.githubusercontent.com/8088864/125714340-57813f51-5cad-4844-9247-2ba5cc04ac8d.jpg)\r\n\r\n根据BFC规则的第3条：\r\n\r\n盒子垂直方向的距离由margin决定，\r\n\r\n属于 同一个BFC的 + 两个相邻Box的 + 上下margin 会发生重叠。\r\n\r\n上文的例子 之所以发生外边距折叠，是因为他们 同属于 body这个根元素， 所以我们需要让 它们 不属于同一个BFC，就能避免外边距折叠：\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n  .wrap {\r\n    overflow: hidden;\r\n  }\r\n\r\n  .p {\r\n    width: 200px;\r\n    height: 50px;\r\n    margin: 50px 0;\r\n    background-color: red;\r\n  }\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"p\"\u003e\u003c/div\u003e\r\n  \u003cdiv class=\"wrap\"\u003e\r\n    \u003cdiv class=\"p\"\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n效果如下所示:\r\n\r\n![利用 BFC 下可以避免两个相邻的块元素垂直方向上的 margin折叠](https://user-images.githubusercontent.com/8088864/125714635-3ff51432-6415-40df-938d-c4c2fe654ca2.jpg)\r\n\r\n#### BFC可以包含浮动的元素(清除浮动)\r\n\r\n正常情况下，浮动的元素会脱离普通文档流，所以下面的代码里：\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n  .wrap {\r\n    border: 1px solid #000;\r\n  }\r\n\r\n  .p {\r\n    width: 200px;\r\n    height: 50px;\r\n    background-color: #eee;\r\n    float: left;\r\n  }\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"wrap\"\u003e\r\n    \u003cdiv class=\"p\"\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n外层的div会无法包含 内部浮动的div。\r\n\r\n效果如下所示:\r\n\r\n![外层的div会无法包含内部浮动的div](https://user-images.githubusercontent.com/8088864/125714940-1de23469-a365-47f4-82ab-3a89fea5441b.jpg)\r\n\r\n但如果我们 触发外部容器的BFC，根据BFC规范中的第4条：计算BFC的高度时，浮动元素也参与计算，那么外部div容器就可以包裹着浮动元素，所以只要把代码修改如下：\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n  .wrap {\r\n    border: 1px solid #000;\r\n    overflow: hidden;\r\n  }\r\n\r\n  .p {\r\n    width: 200px;\r\n    height: 50px;\r\n    background-color: #eee;\r\n    float: left;\r\n  }\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"wrap\"\u003e\r\n    \u003cdiv class=\"p\"\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n效果如下所示:\r\n\r\n![利用BFC外层的div会包含内部浮动的div](https://user-images.githubusercontent.com/8088864/125715066-4a11c8a9-caef-4258-acfb-87e3cc8b8302.jpg)\r\n\r\n#### BFC可以阻止元素被浮动元素覆盖\r\n\r\n正常情况下，浮动的元素会脱离普通文档流，会覆盖着普通文档流的元素上。所以下面的代码里：\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n.aside {\r\n  width: 100px;\r\n  height: 150px;\r\n  float: left;\r\n  background: black;\r\n}\r\n\r\n.main {\r\n  width: 300px;\r\n  height: 200px;\r\n  background-color: red;\r\n}\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"aside\"\u003e\u003c/div\u003e\r\n  \u003cdiv class=\"main\"\u003e\u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n效果如下所示:\r\n\r\n![浮动的元素会脱离普通文档流，会覆盖着普通文档流的元素上](https://user-images.githubusercontent.com/8088864/125716169-ccf5e6b4-f51e-431e-8aff-0b8e753b88a8.png)\r\n\r\n\r\n之所以是这样，是因为上文的 规则5： 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；\r\n\r\n所以要想改变效果，使其互补干扰，就得利用规则6 ：BFC的区域不会与float重叠，让 \\\u003cdiv class=\"main\"\u003e 也能触发BFC的性质。\r\n\r\n将代码改成下列所示:\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n.aside {\r\n  width: 100px;\r\n  height: 150px;\r\n  float: left;\r\n  background: black;\r\n}\r\n\r\n.main {\r\n  width: 300px;\r\n  height: 200px;\r\n  background-color: red;\r\n  overflow: hidden;\r\n}\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"aside\"\u003e\u003c/div\u003e\r\n  \u003cdiv class=\"main\"\u003e\u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n效果如下所示：\r\n\r\n![利用BFC可以阻止元素被浮动元素覆盖](https://user-images.githubusercontent.com/8088864/125716325-7b9fe487-9b6e-4d35-b8b7-33839bb9ebce.png)\r\n\r\n通过这种方法，就能 用来实现 两列的自适应布局。\r\n\r\n### 简要介绍IFC\r\n\r\n1. 框会从包含块的顶部开始，一个接一个地水平摆放。\r\n\r\n2. 摆放这些框时，它们在水平方向的 内外边距+边框 所占用的空间都会被考虑；\r\n    在垂直方向上，这些框可能会以不同形式来对齐；\r\n    水平的margin、padding、border有效，垂直无效，不能指定宽高。\r\n\r\n3. 行框的宽度是 由包含块和存在的浮动来决定;\r\n  行框的高度 由行高来决定。\r\n\r\n## 十五、浅析CSS的性能优化：transform与position区别、硬件加速工作原理及注意事项、强制使用GPU渲染的友好CSS属性\r\n\r\n在网上看到一个这样的问题： transform与position:absolute 有什么区别？查阅资料后发现这道题目其实不简单，涉及到重排、重绘、硬件加速等网页优化的知识。\r\n\r\n### 问题背景\r\n\r\n过去几年，我们常常会听说硬件加速给移动端带来了巨大的体验提升，但是即使对于很多经验丰富的开发者来说，恐怕对其背后的工作原理也是模棱两可，更不要合理地将其运用到网页的动画效果中了。\r\n\r\n#### 1. position + top/left 的效果\r\n\r\n下面让我们来看一个动画效果，在该动画中包含了几个堆叠在一起的球并让它们沿相同路径移动。最简单的方式就是实时调整它们的 left 和 top 属性，使用 css 动画实现。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n  html,\r\n  body {\r\n    width: 100%;\r\n    height: 100%;\r\n  }\r\n\r\n  .ball-running {\r\n    animation: run-around 4s infinite;\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: red;\r\n    position: absolute;\r\n  }\r\n\r\n  @keyframes run-around {\r\n    0%: {\r\n      top: 0;\r\n      left: 0;\r\n    }\r\n    25% {\r\n      top: 0;\r\n      left: 200px;\r\n    }\r\n    50% {\r\n      top: 200px;\r\n      left: 200px;\r\n    }\r\n    75% {\r\n      top: 200px;\r\n      left: 0;\r\n    }\r\n  }\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"ball-running\"\u003e\u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n在运行的时候，即使是在电脑浏览器上也会隐约觉得动画的运行并不流畅，动画有些停顿的感觉，更不要提在移动端达到 60fps 的流畅效果了。这是因为top和left的改变会触发浏览器的 reflow 和 repaint ，整个动画过程都在不断触发浏览器的重新渲染，这个过程是很影响性能的。\r\n\r\n#### 2. transform 的效果\r\n\r\n为了解决这个问题，我们使用 transform 中的 translate() 来替换 top 和 left ，重写一下这个动画效果。\r\n\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chead\u003e\r\n\u003cstyle\u003e\r\n  html,\r\n  body {\r\n    width: 100%;\r\n    height: 100%;\r\n  }\r\n\r\n  .ball-running {\r\n    animation: run-around 4s infinite;\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: red;\r\n  }\r\n\r\n  @keyframes run-around {\r\n    0%: {\r\n      transform: translate(0, 0);\r\n    }\r\n    25% {\r\n      transform: translate(200px, 0);\r\n    }\r\n    50% {\r\n      transform: translate(200px, 200px);\r\n    }\r\n    75% {\r\n      transform: translate(0, 200px);\r\n    }\r\n  }\r\n\u003c/style\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n  \u003cdiv class=\"ball-running\"\u003e\u003c/div\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n这时候会发现整个动画效果流畅了很多，在动画移动的过程中也没有发生repaint和reflow。\r\n\r\n那么，为什么 transform 没有触发 repaint 呢？原因就是：transform 动画由GPU控制，支持硬件加速，并不需要软件方面的渲染。\r\n\r\n### 硬件加速工作原理\r\n\r\n浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树，DOM树和CSS结合后形成浏览器构建页面的渲染树，渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理，而图层在GPU中 transform 是不会触发 repaint 的，这一点非常类似3D绘图功能，最终这些使用transform的图层都会使用独立的合成器进程进行处理。\r\n\r\n在我们的示例中，CSS  transform  创建了一个新的复合图层，可以被GPU直接用来执行 transform 操作。在chrome开发者工具中开启“show layer borders”选项后，每个复合图层就会显示一条黄色的边界。示例中的球就处于一个独立的复合图层，移动时的变化也是独立的。\r\n\r\n此时，你也许会问：浏览器什么时候会创建一个独立的复合图层呢？事实上一般是在以下几种情况下：\r\n\r\n  1. 3D 或者 CSS transform\r\n  2. video或canvas标签\r\n  3. CSS filters\r\n  4. 元素覆盖时，比如使用了 z-index 属性\r\n\r\n等一下，上面的示例使用的是 2D transform 而不是 3D transform 啊？这个说法没错，所以在timeline中我们可以看到：动画开始和结束的时候发生了两次 repaint 操作。\r\n\r\n![CSS transform网页的重绘时间轴](https://user-images.githubusercontent.com/8088864/125720131-5776ac63-b267-4699-9cbf-06a86c80689b.png)\r\n\r\n3D 和 2D transform 的区别就在于，浏览器在页面渲染前为3D动画创建独立的复合图层，而在运行期间为2D动画创建。\r\n\r\n动画开始时，生成新的复合图层并加载为GPU的纹理用于初始化 repaint，然后由GPU的复合器操纵整个动画的执行，最后当动画结束时，再次执行 repaint 操作删除复合图层。\r\n\r\n### 使用 GPU 渲染元素\r\n\r\n#### 能触发GPU渲染的属性\r\n\r\n并不是所有的CSS属性都能触发GPU的硬件加速，实际上只有少数属性可以，比如下面的这些：\r\n\r\n1. transform\r\n2. opacity\r\n3. filter\r\n\r\n#### 强制使用GPU渲染\r\n\r\n为了避免 2D transform 动画在开始和结束时发生的 repaint 操作，我们可以硬编码一些样式来解决这个问题：\r\n\r\n``` css\r\n.exam1 {\r\n  transform: translateZ(0);\r\n}\r\n\r\n.exam2 {\r\n  transform: rotateZ(360deg);\r\n}\r\n```\r\n\r\n这段代码的作用就是让浏览器执行 3D transform，浏览器通过该样式创建了一个独立图层，图层中的动画则有GPU进行预处理并且触发了硬件加速。\r\n\r\n#### 使用硬件加速需要注意的事项\r\n\r\n使用硬件加速并不是十全十美的事情，比如：\r\n\r\n1. 内存。如果GPU加载了大量的纹理，那么很容易就会发生内存问题，这一点在移动端浏览器上尤为明显，所以，一定要牢记不要让页面的每个元素都使用硬件加速。\r\n2. 使用GPU渲染会影响字体的抗锯齿效果。这是因为GPU和CPU具有不同的渲染机制，即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。\r\n\r\n#### will-change\r\n\r\n浏览器还提出了一个 will-change 属性，该属性允许开发者告知浏览器哪一个属性即将发生变化，从而为浏览器对该属性进行优化提供了时间。下面是一个使用 will-change 的示例\r\n\r\n``` css\r\n.exam3 {\r\n  will-change: transform;\r\n}\r\n```\r\n\r\n缺点在于其兼容性不大好。\r\n\r\n### 总结\r\n\r\n1. transform 会使用 GPU 硬件加速，性能更好；position + top/left 会触发大量的重绘和回流，性能影响较大。\r\n2. 硬件加速的工作原理是创建一个新的复合图层，然后使用合成线程进行渲染。\r\n3. 3D 动画 与 2D 动画的区别；2D动画会在动画开始和动画结束时触发2次重新渲染。\r\n4. 使用GPU可以优化动画效果，但是不要滥用，会有内存问题。\r\n5. 理解强制触发硬件加速的 transform 技巧，使用对GPU友好的CSS属性。\r\n\r\n## 十六、深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调\r\n\r\n### 前言\r\n\r\n关于 Event Loop 的文章很多，但是有很多只是在讲「宏任务」、「微任务」，我先提出几个问题：\r\n\r\n1. 每一轮 Event Loop 都会伴随着渲染吗？\r\n2. requestAnimationFrame 在哪个阶段执行，在渲染前还是后？在 microTask 的前还是后？\r\n3. requestIdleCallback 在哪个阶段执行？如何去执行？在渲染前还是后？在 microTask 的前还是后？\r\n4. resize、scroll 这些事件是何时去派发的。\r\n\r\n这些问题并不是刻意想刁难你，如果你不知道这些，那你可能并不能在遇到一个动画需求的时候合理的选择 requestAnimationFrame，你可能在做一些需求的时候想到了 requestIdleCallback，但是你不知道它运行的时机，只是胆战心惊的去用它，祈祷不要出线上 bug。\r\n\r\n这也是本文想要从规范解读入手，深挖底层的动机之一。本文会酌情从规范中排除掉一些比较晦涩难懂，或者和主流程不太相关的概念。更详细的版本也可以直接去读这个规范，不过比较费时费力。\r\n\r\n### 事件循环\r\n\r\n我们先依据HTML 官方规范从浏览器的事件循环讲起，因为剩下的 API 都在这个循环中进行，它是浏览器调度任务的基础。\r\n\r\n#### 定义\r\n\r\n为了协调事件，用户交互，脚本，渲染，网络任务等，浏览器必须使用本节中描述的事件循环。\r\n\r\n#### 流程\r\n\r\n1. 从任务队列中取出一个宏任务并执行。\r\n\r\n2. 检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。\r\n\r\n3. 进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）\r\n\r\n  - 浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。\r\n  - 如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。\r\n  - 如果满足以下条件，也会跳过渲染：\r\n\r\n    1. 浏览器判断更新渲染不会带来视觉上的改变。\r\n    2. map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。\r\n\r\n4. 如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行：\r\n  This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates. 有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 microTask的执行，而不会穿插屏幕渲染相关的流程（比如requestAnimationFrame，下面会写一个例子）。\r\n\r\n5. 对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 `resize` 方法。\r\n\r\n6. 对于需要渲染的文档，如果页面发生了滚动，执行 `scroll` 方法。\r\n\r\n7. 对于需要渲染的文档，执行帧动画回调，也就是 `requestAnimationFrame` 的回调。（后文会详解）\r\n\r\n8. 对于需要渲染的文档， 执行 `IntersectionObserver` 的回调。\r\n\r\n9. 对于需要渲染的文档，**重新渲染**绘制用户界面。\r\n\r\n10. 判断 `task队列`和`microTask队列`是否都为空，如果是的话，则进行 `Idle` 空闲周期的算法，判断是否要执行 `requestIdleCallback` 的回调函数。（后文会详解）\r\n\r\n对于 `resize` 和 `scroll` 来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据CSSOM 规范所讲，浏览器会保存一个 `pending scroll event targets`，等到事件循环中的 `scroll` 这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。`resize` 也是同理。\r\n可以在这个流程中仔细看一下「宏任务」、「微任务」、「渲染」之间的关系。\r\n多任务队列\r\n\r\n#### 多任务队列\r\n\r\ntask 队列并不是我们想象中的那样只有一个，根据规范里的描述：\r\n\r\nAn event loop has one or more task queues. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.\r\n\r\n事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：\r\n\r\n1. 鼠标和键盘事件\r\n2. 其他的一些 Task\r\n\r\n览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他 Task，并且保证不会“饿死”它们。\r\n\r\n这个规范也导致 Vue 2.0.0-rc.7 这个版本 `nextTick` 采用了从微任务 `MutationObserver` 更换成宏任务 `postMessage` 而导致了一个 [Issue](https://github.com/vuejs/vue/issues/3771#issuecomment-249692588)。\r\n目前由于一些“未知”的原因，`jsfiddle` 的案例打不开了。简单描述一下就是采用了 `task` 实现的 `nextTick`，在用户持续滚动的情况下 `nextTick` 任务被延后了很久才去执行，导致动画跟不上滚动了。\r\n\r\n迫于无奈，尤大还是改回了 `microTask` 去实现 `nextTick`，当然目前来说 `promise.then` 微任务已经比较稳定了，并且 Chrome 也已经实现了 `queueMicroTask` 这个官方 API。不久的未来，我们想要调用微任务队列的话，也可以节省掉实例化 `Promise` 在开销了。\r\n\r\n从这个 Issue 的例子中我们可以看出，稍微去深入了解一下规范还是比较有好处的，以免在遇到这种比较复杂的 Bug 的时候一脸懵逼。\r\n\r\n#### requestAnimationFrame\r\n\r\n在解读规范的过程中，我们发现 `requestAnimationFrame` 的回调有两个特征：\r\n\r\n1. 在重新渲染前调用。\r\n2. 很可能在宏任务之后不调用。\r\n\r\n我们来分析一下，为什么要在重新渲染前去调用？因为 `rAF` 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。\r\n\r\n`rAF`在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout的例子来对比。\r\n\r\n##### 闪烁动画\r\n\r\n假设我们现在想要快速的让屏幕上闪烁 红、蓝两种颜色，保证用户可以观察到，如果我们用 `setTimeout` 来写，并且带着我们长期的误解「宏任务之间一定会伴随着浏览器绘制」，那么你会得到一个预料之外的结果。\r\n\r\n``` js\r\nsetTimeout(() =\u003e {\r\n  document.body.style.background = \"red\";\r\n  setTimeout(() =\u003e {\r\n    document.body.style.background = \"blue\";\r\n  });\r\n});\r\n```\r\n\r\n![setTimeout闪烁动画](https://user-images.githubusercontent.com/8088864/125749050-c757f81e-6482-4262-a0d4-c455eb78d4f4.gif)\r\n\r\n以看出这个结果是非常不可控的，如果这两个 `Task` 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。\r\n\r\n如果你把延时调整到 17ms 那么重绘的概率会大很多，毕竟这个是一般情况下 60fps 的一个指标。但是也会出现很多不绘制的情况，所以并不稳定。\r\n如果你依赖这个 API 来做动画，那么就很可能会造成「掉帧」。\r\n\r\n接下来我们换成 rAF 试试？我们用一个递归函数来模拟 10 次颜色变化的动画。\r\n\r\n``` js\r\nlet i = 10;\r\nlet req = () =\u003e {\r\n  i--;\r\n  requestAnimationFrame(() =\u003e {\r\n    document.body.style.background = \"red\";\r\n    requestAnimationFrame(() =\u003e {\r\n      document.body.style.background = \"blue\";\r\n      if (i \u003e 0) {\r\n        req();\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nreq();\r\n```\r\n\r\n这里由于颜色变化太快，gif 录制软件没办法截出这么高帧率的颜色变换，所以各位可以放到浏览器中自己执行一下试试，我这边直接抛结论，浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来，可以看下 performance 面板记录的表现：\r\n\r\n![requestAnimationFrame闪烁动画](https://user-images.githubusercontent.com/8088864/125750295-ab491df6-c612-4add-b2fe-8819fcf47ef1.png)\r\n\r\n##### 定时器合并\r\n\r\n在第一节解读规范的时候，第 4 点中提到了，定时器宏任务可能会直接跳过渲染。\r\n\r\n按照一些常规的理解来说，宏任务之间理应穿插渲染，而定时器任务就是一个典型的宏任务，看一下以下的代码：\r\n\r\n``` js\r\nsetTimeout(() =\u003e {\r\n  console.log(\"sto1\")\r\n  requestAnimationFrame(() =\u003e console.log(\"rAF1\"))\r\n})\r\nsetTimeout(() =\u003e {\r\n  console.log(\"sto2\")\r\n  requestAnimationFrame(() =\u003e console.log(\"rAF2\"))\r\n})\r\n\r\nqueueMicrotask(() =\u003e console.log(\"mic1\"))\r\nqueueMicrotask(() =\u003e console.log(\"mic2\"))\r\n```\r\n\r\n从直觉上来看，顺序是不是应该是：\r\n\r\n``` text\r\nmic1\r\nmic2\r\nsto1\r\nrAF1\r\nsto2\r\nrAF2\r\n```\r\n\r\n呢？也就是每一个宏任务之后都紧跟着一次渲染。\r\n\r\n实际上不会，浏览器会合并这两个定时器任务：\r\n\r\n``` text\r\nmic1\r\nmic2\r\nsto1\r\nsto2\r\nrAF1\r\nrAF2\r\n```\r\n\r\n#### requestIdleCallback\r\n\r\n#### 草案解读\r\n\r\n我们都知道 `requestIdleCallback` 是浏览器提供给我们的空闲调度算法，关于它的简介可以看 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，意图是让我们把一些计算量较大但是又没那么紧急的任务放到空闲时间去执行。不要去影响浏览器中优先级较高的任务，比如动画绘制、用户输入等等。\r\n\r\nReact 的时间分片渲染就想要用到这个 API，不过目前浏览器支持的不给力，他们是自己去用 postMessage 实现了一套。\r\n\r\n**渲染有序进行**\r\n\r\n首先看一张图，很精确的描述了这个 API 的意图：\r\n\r\n![浏览器渲染有序调度](https://user-images.githubusercontent.com/8088864/125756615-7bec3496-94cc-46ba-9298-5df48b99d2d8.png)\r\n\r\n当然，这种有序的 `浏览器 -\u003e 用户 -\u003e 浏览器 -\u003e 用户` 的调度基于一个前提，就是我们要把任务切分成比较小的片，不能说浏览器把空闲时间让给你了，你去执行一个耗时 10s 的任务，那肯定也会把浏览器给阻塞住的。这就要求我们去读取 `rIC` 提供给你的 `deadline` 里的时间，去动态的安排我们切分的小任务。浏览器信任了你，你也不能辜负它呀。\r\n\r\n**渲染长期空闲**\r\n\r\n![浏览器渲染长期空闲调度](https://user-images.githubusercontent.com/8088864/125756805-79afd49b-e62d-45b9-bb7e-4a4b34eb7bd4.png)\r\n\r\n还有一种情况，也有可能在几帧的时间内浏览器都是空闲的，并没有发生任何影响视图的操作，它也就不需要去绘制页面：\r\n这种情况下为什么还是会有 50ms 的 deadline 呢？是因为浏览器为了提前应对一些可能会突发的用户交互操作，比如用户输入文字。如果给的时间太长了，你的任务把主线程卡住了，那么用户的交互就得不到回应了。50ms 可以确保用户在无感知的延迟下得到回应。\r\n\r\nMDN 文档中的[幕后任务协作调度 API](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)  介绍的比较清楚，来根据里面的概念做个小实验：\r\n\r\n屏幕中间有个红色的方块，把 MDN 文档中[requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)的范例部分的动画代码直接复制过来。\r\n\r\n草案中还提到：\r\n\r\n1. 当浏览器判断这个页面对用户不可见时，这个回调执行的频率可能被降低到 10 秒执行一次，甚至更低。这点在解读 EventLoop 中也有提及。\r\n\r\n2. 如果浏览器的工作比较繁忙的时候，不能保证它会提供空闲时间去执行 rIC 的回调，而且可能会长期的推迟下去。所以如果你需要保证你的任务在一定时间内一定要执行掉，那么你可以给 rIC 传入第二个参数 timeout。\r\n这会强制浏览器不管多忙，都在超过这个时间之后去执行 rIC 的回调函数。所以要谨慎使用，因为它会打断浏览器本身优先级更高的工作。\r\n\r\n3. 最长期限为 50 毫秒，是根据研究得出的，研究表明，人们通常认为 100 毫秒内对用户输入的响应是瞬时的。 将闲置截止期限设置为 50ms 意味着即使在闲置任务开始后立即发生用户输入，浏览器仍然有剩余的 50ms 可以在其中响应用户输入而不会产生用户可察觉的滞后。\r\n\r\n4. 每次调用 timeRemaining() 函数判断是否有剩余时间的时候，如果浏览器判断此时有优先级更高的任务，那么会动态的把这个值设置为 0，否则就是用预先设置好的 deadline - now 去计算。\r\n\r\n5. 这个 timeRemaining() 的计算非常动态，会根据很多因素去决定，所以不要指望这个时间是稳定的。\r\n\r\n#### 动画例子\r\n\r\n**滚动**\r\n\r\n如果我鼠标不做任何动作和交互，直接在控制台通过 rIC 去打印这次空闲任务的剩余时间，一般都稳定维持在 49.xx ms，因为此时浏览器没有什么优先级更高的任务要去处理。\r\n\r\n``` js\r\nrequestIdleCallback((deadline) =\u003e console.log(deadline.timeRemaining()))\r\n```\r\n\r\n![requetIdleCallback的timeRemaining时间1](https://user-images.githubusercontent.com/8088864/125778161-1e903c20-19a8-4340-83e9-af15ff16078a.gif)\r\n\r\n而如果我不停的滚动浏览器，不断的触发浏览器的重新绘制的话，这个时间就变的非常不稳定了。\r\n\r\n![requetIdleCallback的timeRemaining时间2](https://user-images.githubusercontent.com/8088864/125778195-dc9bc852-60e6-475d-a50e-441707e793ff.gif)\r\n\r\n通过这个例子，你可以更加有体感的感受到什么样叫做「繁忙」，什么样叫做「空闲」。\r\n\r\n\r\n**动画**\r\n\r\n这个动画的例子很简单，就是利用rAF在每帧渲染前的回调中把方块的位置向右移动 10px。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\" /\u003e\r\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    \u003c/style\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n    \u003cdiv id=\"SomeElementYouWantToAnimate\"\u003e\u003c/div\u003e\r\n    \u003cscript\u003e\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        if (progress \u003c 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) =\u003e {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      });\r\n    \u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n注意在最后我加了一个 requestIdleCallback 的函数，回调里会 alert('rIC')，来看一下演示效果：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画](https://user-images.githubusercontent.com/8088864/125778813-19d6dde2-2b12-4754-bd4c-deba1209d3e6.gif)\r\n\r\nalert 在最开始的时候就执行了，为什么会这样呢一下，想一下「空闲」的概念，我们每一帧仅仅是把 left 的值移动了一下，做了这一个简单的渲染，没有占满空闲时间，所以可能在最开始的时候，浏览器就找到机会去调用 rIC 的回调函数了。\r\n\r\n我们简单的修改一下 step 函数，在里面加一个很重的任务，1000 次循环打印。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\" /\u003e\r\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    \u003c/style\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n    \u003cdiv id=\"SomeElementYouWantToAnimate\"\u003e\u003c/div\u003e\r\n    \u003cscript\u003e\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        let i = 1000;\r\n        while (i \u003e 0) {\r\n          console.log(\"i\", i);\r\n          i--;\r\n        }\r\n        if (progress \u003c 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) =\u003e {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      });\r\n    \u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n再来看一下它的表现：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画很忙](https://user-images.githubusercontent.com/8088864/125779688-be382539-51e0-4462-afee-ddb5db99b2bb.gif)\r\n\r\n其实和我们预期的一样，由于浏览器的每一帧都\"太忙了\",导致它真的就无视我们的 rIC 函数了。\r\n\r\n如果给 rIC 函数加一个 timeout 呢：\r\n\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\" /\u003e\r\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\r\n    \u003ctitle\u003eDocument\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    \u003c/style\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n    \u003cdiv id=\"SomeElementYouWantToAnimate\"\u003e\u003c/div\u003e\r\n    \u003cscript\u003e\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        let i = 1000;\r\n        while (i \u003e 0) {\r\n          console.log(\"i\", i);\r\n          i--;\r\n        }\r\n        if (progress \u003c 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) =\u003e {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      }, { timeout: 500 });\r\n    \u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n效果如下：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画很忙再加上timeout](https://user-images.githubusercontent.com/8088864/125779998-cf9201d8-707b-4d99-aece-9e40c4f7b2a2.gif)\r\n\r\n浏览器会在大概 500ms 的时候，不管有多忙，都去强制执行 `rIC` 函数，这个机制可以防止我们的空闲任务被“饿死”。\r\n\r\n### 总结\r\n\r\n通过本文的学习过程，我自己也打破了很多对于 Event Loop 以及 rAF、rIC 函数的固有错误认知，通过本文我们可以整理出以下的几个关键点。\r\n\r\n1. 事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行。\r\n2. 决定浏览器视图是否渲染的因素很多，浏览器是非常聪明的。\r\n3. requestAnimationFrame在重新渲染屏幕之前执行，非常适合用来做动画。\r\n4. requestIdleCallback在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，如果你一定要它在某个时间内执行，请使用 timeout参数。\r\n5. resize和scroll事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上。\r\n\r\n## 十七、React Fiber架构中，迭代器和requestIdleCallback结合的优势\r\n\r\n### requestIdleCallback API\r\n\r\nrequestIdleCallback 是浏览器提供的 Web API，它是 React Fiber 中用到的核心 API。\r\n\r\n#### API 介绍\r\n\r\n[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 利用浏览器的空余时间执行任务，如果浏览器没有空余时间，可以随时终止这些任务。\r\n\r\n这样可以实现如果有更高优先级的任务要执行时，当前执行的任务可以被终止，优先执行高级别的任务。\r\n\r\n原理是该方法将 在浏览器的空闲时段内调用的函数 排队。\r\n\r\n这样使得开发者能够在主事件循环上 执行后台和低优先级的任务，而不会影响 像动画和用户交互 这些关键的延迟触发的事件。\r\n\r\n这里的“延迟”指的是大量计算导致运行时间较长。\r\n\r\n#### 浏览器空余时间\r\n\r\n页面是一帧一帧绘制出来的，当每秒绘制的帧数达到 60 时，页面时流畅的，小于这个值时，用户会感觉到卡顿。\r\n\r\n1秒60帧意思是1秒中60张画面在切换。\r\n\r\n当帧数低于人眼的捕捉频率（有说24帧或30帧，考虑到视觉残留现象，这个数值可能会更低）时，人脑会识别这是几张图片在切换，也就是静态的。\r\n\r\n当帧数高于人眼的捕捉频率，人脑会认为画面是连续的，也就是动态的动画。\r\n\r\n帧数越高画面就看起来更流畅。\r\n\r\n1秒60帧（大约 1000/60 ≈ 16ms 切换一个画面）差不多是人眼能识别卡顿的分界线。\r\n\r\n如果每一帧执行的时间小于 16 ms，就说明浏览器有空余时间。\r\n\r\n一帧时间内浏览器要做的事情包括：脚本执行、样式计算、布局、重绘、合成等。\r\n\r\n如果某一项内容执行时间过长，浏览器会推迟渲染，造成丢帧卡顿，就没有剩余时间。\r\n\r\n#### 应用场景\r\n\r\n比如现在有一项计算任务，这项任务需要花费比较长的时间(例如超过16ms）去执行。\r\n\r\n在执行任务的过程当中，浏览器的主线程会被一直占用。\r\n\r\n在主线程被占用的过程中，浏览器是被阻塞的，并不能执行其他的任务。\r\n\r\n如果此时用户想要操作页面，比如向下滑动页面查看其它内容，浏览器是不能响应用户的操作的，给用户的感觉就是页面卡死了，体验非常差。\r\n\r\n**如何解决呢？**\r\n\r\n可以将这项任务注册到 `requestIdleCallback` 中，利用浏览器的空余时间执行它。\r\n\r\n当用户操作页面时，就是**优先级比较高的任务**被执行时，此时计算任务会被终止，优先响应用户的操作，这样用户就不会感觉页面发生卡顿了。\r\n\r\n当高优先级的任务执行完成后，再继续执行计算任务。\r\n\r\n`requestIdleCallback` 的作用就是利用浏览器的空余时间执行这些需要大量计算的任务，当空余时间结束，会中断计算任务，执行高优先级的任务，以达到不阻塞主线程任务（例如浏览器 UI 渲染）的目的。\r\n\r\n#### 使用方式\r\n\r\n``` js\r\nvar handle = window.requestIdleCallback(callback[, options])\r\n```\r\n\r\n- callback：一个在空闲时间即将被调用的回调函数\r\n    - 该函数接收一个形参：IdleDeadline，它提供一个方法和一个属性：\r\n      - 方法：timeRemaining()\r\n        - 用于获取浏览器空闲期的剩余时间，也就是空余时间\r\n          - 返回值是毫秒数\r\n          - 如果闲置期结束，则返回 0\r\n        - 根据时间的多少可以来决定是否要执行任务\r\n      - 属性：didTimeout(Boolean，只读)\r\n        - 表示是否是上一次空闲期因为超时而没有执行的回调函数\r\n        - 超时时间由 requestIdleCallback 的参数options.timeout 定义\r\n- options：可选配置，目前只有一个配置项\r\n  - timeout：超时时间，如果设置了超时时间并超时，回调函数还没有被调用，则会在下一次空闲期强制被调用\r\n\r\n#### 功能体验\r\n\r\n页面中有两个按钮和一个 DIV，点击第一个按钮执行一项昂贵的计算，使其长期占用主线程，当计算任务执行的时候去点击第二个按钮更改页面中 DIV 的背景颜色。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\" /\u003e\r\n    \u003ctitle\u003erequestIdleCallback\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n      #box {\r\n        background: palegoldenrod;\r\n        padding: 20px;\r\n        margin-bottom: 10px;\r\n      }\r\n    \u003c/style\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n    \u003cdiv id=\"box\"\u003eplayground\u003c/div\u003e\r\n    \u003cbutton id=\"btn1\"\u003e执行计算任务\u003c/button\u003e\r\n    \u003cbutton id=\"btn2\"\u003e更改背景颜色\u003c/button\u003e\r\n\r\n    \u003cscript\u003e\r\n      var box = document.querySelector('#box');\r\n      var btn1 = document.querySelector('#btn1');\r\n      var btn2 = document.querySelector('#btn2');\r\n      var number = 100000000;\r\n      var value = 0;\r\n\r\n      function calc() {\r\n        while (number \u003e 0) {\r\n          value = Math.random() \u003c 0.5 ? Math.random() : Math.random();\r\n          number--;\r\n        }\r\n      }\r\n\r\n      btn1.onclick = function () {\r\n        calc();\r\n      }\r\n\r\n      btn2.onclick = function () {\r\n        console.log(number); // 0：计算任务执行完\r\n        box.style.background = 'palegreen';\r\n      }\r\n    \u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n![requestIdleCallback功能体验1](https://user-images.githubusercontent.com/8088864/125783134-1435e780-a620-4cbf-b8c3-c04fccd4b145.png)\r\n\r\n使用 requestIdleCallback可以完美解决这个卡顿问题：\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\" /\u003e\r\n    \u003ctitle\u003erequestIdleCallback\u003c/title\u003e\r\n    \u003cstyle\u003e\r\n      #box {\r\n        background: palegoldenrod;\r\n        padding: 20px;\r\n        margin-bottom: 10px;\r\n      }\r\n    \u003c/style\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n    \u003cdiv id=\"box\"\u003eplayground\u003c/div\u003e\r\n    \u003cbutton id=\"btn1\"\u003e执行计算任务\u003c/button\u003e\r\n    \u003cbutton id=\"btn2\"\u003e更改背景颜色\u003c/button\u003e\r\n\r\n    \u003cscript\u003e\r\n      var box = document.querySelector('#box');\r\n      var btn1 = document.querySelector('#btn1');\r\n      var btn2 = document.querySelector('#btn2');\r\n      var number = 100000000;\r\n      var value = 0;\r\n\r\n      function calc(IdleDeadline) {\r\n        while (number \u003e 0 \u0026\u0026 IdleDeadline.timeRemaining() \u003e 1) {\r\n          value = Math.random() \u003c 0.5 ? Math.random() : Math.random();\r\n          number--;\r\n        }\r\n\r\n        if (number \u003e 0) {\r\n          requestIdleCallback(calc);\r\n        } else {\r\n          console.log('计算结束');\r\n        }\r\n      }\r\n\r\n      btn1.onclick = function () {\r\n        requestIdleCallback(calc);\r\n      }\r\n\r\n      btn2.onclick = function () {\r\n        console.log(number); // 0：计算任务执行完\r\n        box.style.background = 'palegreen';\r\n      }\r\n    \u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n![requestIdleCallback功能体验2](https://user-images.githubusercontent.com/8088864/125783529-12c4da73-fe20-4757-b858-169f381efce4.png)\r\n\r\n- 浏览器在空余时间执行 calc 函数\r\n- 当空余时间小于 1ms 时，跳出while循环\r\n- calc 根据 number 判断计算任务是否执行完成，如果没有完成，则继续注册新的空闲期的任务\r\n- 当 btn2 点击事件触发，会等到当前空闲期任务执行完后执行“更改背景颜色”的任务\r\n- “更改背景颜色”任务执行完成后，继续进入空闲期，执行后面的任务\r\n\r\n由此可见，所谓执行优先级更高的任务，是手动将计算任务拆分到浏览器的空闲期，以实现每次进入空闲期之前优先执行主线程的任务。\r\n\r\n### Fiber 出现的目的\r\n\r\nFiber 其实是 React 16 新的 DOM 比对算法的名字，旧的 DOM 比对算法的名字是 Stack。\r\n\r\n#### React 16之前的版本存在的问题\r\n\r\nReact 16之前的版本对比更新 VirtualDOM 的过程是采用**循环加递归**实现的。\r\n\r\n这种对比方式有一个问题，就是一旦任务开始进行旧无法中断（由于递归需要一层一层的进入，一层一层的退出，所以过程不能中断）。\r\n\r\n如果应用中组件数量庞大，主线程被长期占用，直到整棵 VirtualDOM 树对比更新完成之后主线程才能被释放，主线程才能执行其它任务。\r\n\r\n这就会导致一些用户交互、动画等任务无法立即得到执行，页面就会产生卡顿，非常影响用户的体验。\r\n\r\n因为递归利用的 **JavaScript 自身的执行栈**，所以旧版 DOM 比对的算法称为 **Stack(堆栈)**。\r\n\r\n**核心问题：递归无法中断，执行重任务耗时长，JavaScript 又是单线程的，无法同时执行其它任务，导致在绘制页面的过程当中不能执行其它任务，比如元素动画、用户交互等任务必须延后，给用户的感觉就是页面变得卡顿，用户体验差。**\r\n\r\n### Stack 算法模拟\r\n\r\n模拟 React 16 之前将虚拟 DOM 转化成真实 DOM 的递归算法：\r\n\r\n``` jsx\r\n// 要渲染的 jsx\r\nconst jsx = (\r\n  \u003cdiv id=\"a1\"\u003e\r\n    \u003cdiv id=\"b1\"\u003e\r\n      \u003cdiv id=\"c1\"\u003e\u003c/div\u003e\r\n      \u003cdiv id=\"c2\"\u003e\u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv id=\"b2\"\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n)\r\n```\r\n\r\njsx 会被 Babel 转化成 `React.createElement()` 的调用，最终返回一个虚拟 DOM 对象：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nconst jsx = /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"a1\"\r\n}, /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"b1\"\r\n}, /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"c1\"\r\n}), /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"c2\"\r\n})), /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"b2\"\r\n}));\r\n```\r\n\r\n去掉一些属性，打印结果：\r\n\r\n``` js\r\nconst jsx = {\r\n  type: 'div',\r\n  props: {\r\n    id: 'a1',\r\n    children: [\r\n      {\r\n        type: 'div',\r\n        props: {\r\n          id: 'b1',\r\n          children: [\r\n            {\r\n              type: 'div',\r\n              props: {\r\n                id: 'c1'\r\n              }\r\n            },\r\n            {\r\n              type: 'div',\r\n              props: {\r\n                id: 'c2'\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      {\r\n        type: 'div',\r\n        props: {\r\n          id: 'b2'\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n递归转化真实 DOM：\r\n\r\n``` js\r\nconst jsx = {...}\r\nfunction render(vdom, container) {\r\n  // 创建元素\r\n  const element = document.createElement(vdom.type);\r\n  // 为元素添加属性\r\n  Object.keys(vdom.props)\r\n    .filter(prop =\u003e prop !== 'children')\r\n    .forEach(prop =\u003e (element[prop] = vdom.props[prop]));\r\n  // 递归创建子元素\r\n  if (Array.isArray(vdom.props.children)) {\r\n    vdom.props.children.forEach(child =\u003e render(child, element));\r\n  }\r\n  // 将元素添加到页面中\r\n  container.appendChild(element);\r\n}\r\n\r\nrender(jsx, document.getElementById('root'));\r\n```\r\n\r\nDOM 更新就是在上面递归的过程中加入了 Virtual DOM 对比的过程。\r\n\r\n可以看到递归是无法中断的。\r\n\r\n### React 16 解决方案 - Fiber\r\n\r\n1. 利用浏览器空余时间执行任务，拒绝长时间占用主线程\r\n  - 在新版本的 React 版本中，使用了 requestIdleCallback API\r\n  - 利用浏览器空余时间执行 VirtualDOM 比对任务，也就表示 VirtualDOM 比对不会长期占用主线程\r\n  - 如果有高优先级的任务要执行，就会暂时终止 VirtualDOM 的比对过程，先去执行高优先级的任务\r\n  - 高优先级任务执行完成，再回来继续执行 VirtualDOM 比对任务\r\n  - 这样页面就不会出现卡顿现象\r\n2. 放弃递归，只采用循环，因为循环可以被中断\r\n  - 由于递归必须一层一层进入，一层一层退出，所以过程无法中断\r\n  - 所以要实现任务的终止再继续，就必须放弃递归，只采用循环的方式执行比对的过程\r\n  - 因为循环是可以终止的，只需要将循环的条件保存下来，下一次任务就可以从中断的地方执行了\r\n3. 任务拆分，将任务拆分成一个个的小任务\r\n  - 如果任务要实现终止再继续，任务的单元就必须要小\r\n  - 这样任务即使没有执行完就被终止，重新执行任务的代价就会小很多\r\n  - 所以要进行任务的拆分，将一个大的任务拆分成一个个小的任务\r\n  - VirtualDOM 比对任务如何拆分？\r\n    - 以前将整棵 VirtualDOM 树的比对看作一个任务\r\n    - 现在将树中每一个节点的比对看作一个任务\r\n\r\n新版 React 的解决方案核心就是第 1 点，第 2、3 点都是为了实现第 1 点而存在的，\r\n\r\nFiber 翻译过来是“纤维”，意思就是执行任务的颗粒度变得细腻，像纤维一样。\r\n\r\n可以通过这个 [Demo](https://claudiopro.github.io/react-fiber-vs-stack-demo/) 查看 Stack 算法 和 Fiber 算法的效果区别。\r\n\r\n### 实现思路\r\n\r\n在 Fiber 方案中，为了实现任务的终止再继续，DOM 对比算法被拆分成了两阶段：\r\n\r\n1. render 阶段（可中断）\r\n  - VirtualDOM 的比对，构建 Fiber 对象，构建链表\r\n\r\n2. commit 阶段（不可中断）\r\n  - 根据构建的链表进行 DOM 操作\r\n\r\n过程就是：\r\n\r\n1. 在使用 React 编写用户界面的时候仍然使用 JSX 语法\r\n2. Babel 会将 JSX 语法转换成 `React.createElement()` 方法的调用\r\n3. `React.createElement()` 方法调用后会返回 VirtualDOM 对象\r\n4. 接下来就可以执行第一个阶段了：**构建 Fiber 对象**\r\n  - 采用循环的方式从 VirtualDOM 对象中，找到每一个内部的 VirtualDOM 对象\r\n  - 为每一个 VirtualDOM 对象构建 Fiber 对象\r\n  - Fiber 对象也是 JavaScript 对象，它是从 VirtualDOM 对象衍化来的，它除了 type、props、children以外还存储了更多节点的信息，其中包含的一个核心信息是：当前节点要进行的操作，例如删除、更新、新增\r\n  - 在构建 Fiber 的过程中还要构建链表\r\n5. 接着进行第二阶段的操作：**执行 DOM 操作**\r\n\r\n总结：\r\n\r\n- DOM 初始渲染：`根据 VirtualDOM --\u003e 创建 Fiber 对象 及 构建链表 --\u003e 将 Fiber 对象存储的操作应用到真实 DOM 中`\r\n- DOM 更新操作：`newFiber(重新获取所有 Fiber 对象) --\u003e newFiber vs oldFiber(获取旧的 Fiber 对象，进行比对) 将差异操作追加到链表 --\u003e 将 Fiber 对象应用到真实 DOM 中`\r\n\r\n### 什么是 Fiber\r\n\r\nFiber 有两层含义：\r\n\r\n- Fiber 是一个执行单元\r\n- Fiber 是一种数据结构\r\n\r\n#### 执行单元\r\n\r\n在 React 16 之前，将 Virtual DOM 树整体看成一个任务进行递归处理，任务整体庞大执行耗时且不能中断。\r\n\r\n在 React 16，将整个任务拆分成一个个小的任务进行处理，每个小的任务指的就是一个 Fiber 节点的构建。\r\n\r\n任务会在浏览器的空闲时间被执行，每个单元执行完成后，React 都会检查是否还有空余时间，如果有就交还主线程的控制权。\r\n\r\n![React Fiber 执行单元流程图](https://user-images.githubusercontent.com/8088864/125878368-317a2c5c-8b16-4877-981c-3883075423bc.png)\r\n\r\n#### 数据结构\r\n\r\nFiber 是一种数据机构，支撑 Fiber 构建任务的运转。\r\n\r\nFiber 其实就是 JavaScript 对象，对象中存储了当前节点的父节点、第一个子节点、下一个兄弟节点，以便在构建链表和执行 DOM 操作的时候知道它们的关系。\r\n\r\n在 render 阶段的时候，React 会从上（root）向下，再从下向上构建所有节点对应的 Fiber 对象，在从下向上的同时还会构建链表，最后将链头存储到 Root Fiber。\r\n\r\n- 从上向下\r\n  - 从 Root 节点开始构建，优先构建子节点\r\n\r\n- 从下向上\r\n  - 如果当前节点没有子节点，就会构建下一个兄弟节点\r\n  - 如果当前节点没有子节点，也没有下一个兄弟节点，就会返回父节点，构建父节点的兄弟节点\r\n  - 如果父节点的下一个兄弟节点有子节点，就继续向下构建\r\n  - 如果父节点没有下一个兄弟节点，就继续向上查找\r\n\r\n在第二阶段的时候，通过链表结构的属性（child、sibling、parent）准确构建出完整的 DOM 节点树，从而才能将 DOM 对象追加到页面当中。\r\n\r\n``` js\r\n// Fiber 对象\r\n{\r\n  type // 节点类型（元素、文本、组件）（具体的类型）\r\n  props // 节点属性（props中包含children属性，标识当前节点的子级 VirtualDOM）\r\n  stateNode // 节点的真实 DOM 对象 | 类组件实例对象 | 函数组件的定义方法\r\n  tag // 节点标记（对具体类型的分类 host_root[顶级节点root] || host_component[普通DOM节点] || class_component[类组件] || function_component[函数组件]）\r\n  effectTag // 当前 Fiber 在 commit 阶段需要被执行的副作用类型/操作（新增、删除、修改）\r\n  nextEffect // 单链表用来快速查找下一个 sideEffect\r\n  lastEffect // 存储最新副作用，用于构建链表的 nextEffect\r\n  firstEffect // 存储第一个要执行的副作用，用于向 root 传递第一个要操作的 DOM\r\n  parent // 当前 Fiber 的父级 Fiber（React 中是 `return`）\r\n  child // 当前 Fiber 的第一个子级 Fiber\r\n  sibling // 当前 Fiber 的下一个兄弟 Fiber\r\n  alternate // 当前节点对应的旧 Fiber 的备份，用于新旧 Fiber 比对\r\n}\r\n```\r\n\r\n以上面的示例为例：\r\n\r\n``` jsx\r\n\u003cdiv id=\"a1\"\u003e\r\n  \u003cdiv id=\"b1\"\u003e\r\n    \u003cdiv id=\"c1\"\u003e\u003c/div\u003e\r\n    \u003cdiv id=\"c2\"\u003e\u003c/div\u003e\r\n  \u003c/div\u003e\r\n  \u003cdiv id=\"b2\"\u003e\u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n![React Fiber 数据结构](https://user-images.githubusercontent.com/8088864/125878754-89f402ab-cb4b-466a-bef3-c6f20b9e10f8.png)\r\n\r\n``` js\r\n// B1 的 Fiber 对象包含这几个属性：\r\n{\r\n  child: C1_Fiber,\r\n  sibling: B2_Fiber,\r\n  parent: A1_Fiber\r\n}\r\n```\r\n\r\n## 十八、canvas\r\n\r\nCanvas API 提供了一个通过JavaScript 和 HTML的`\u003ccanvas\u003e`元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。\r\n\r\nCanvas API主要聚焦于2D图形。而同样使用`\u003ccanvas\u003e`元素的 WebGL API 则用于绘制硬件加速的2D和3D图形。\r\n\r\n### 标签\r\n\r\n``` html\r\n\u003ccanvas width=\"600\" height=\"400\" id=\"canvas\"\u003e\u003c/canvas\u003e\r\n```\r\n\r\n不给宽高的话默认是300+150\r\n\r\n### 怎么用\r\n\r\n``` js\r\n// 拿到canvas\r\nvar canvas = document.getElementById(\"canvas\");\r\n// 创建画图工具\r\nvar context = canvas.getContext(\"2d\");\r\n```\r\n\r\n### 相关的api及用法\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml\u003e\r\n\u003cbody\u003e\r\n\r\n\u003ccanvas id=\"myCanvas\" width=\"600\" height=\"500\" style=\"border:1px solid #d3d3d3;\"\u003e\r\n  Your browser does not support the HTML5 canvas tag.\r\n\u003c/canvas\u003e\r\n\r\n\u003cscript\u003e\r\n\r\nvar canvas = document.getElementById(\"myCanvas\");\r\nvar context = canvas.getContext(\"2d\");\r\n\r\n// 画线\r\ncontext.moveTo(100, 100);\r\ncontext.lineTo(300, 100);\r\ncontext.lineTo(300, 200);\r\n\r\n// 画第二条线\r\n// 画第二条线\r\ncontext.moveTo(100, 300);\r\ncontext.lineTo(300, 300);\r\n\r\n// 最后要描边才会出效果\r\ncontext.stroke();\r\n\r\n// 创建一张新的玻璃纸\r\ncontext.beginPath();\r\n// 画第三条线\r\ncontext.moveTo(400, 100);\r\ncontext.lineTo(400, 300);\r\ncontext.lineTo(500, 300);\r\ncontext.lineTo(500, 200);\r\n\r\n// 只要执行stroke，都会玻璃纸上的图形重复印刷一次\r\ncontext.stroke();\r\n\r\n// 填充\r\ncontext.fill();\r\ncontext.fillStyle = \"gray\";\r\n\r\n// 设置描边色\r\ncontext.strokeStyle = \"red\"; // 颜色的写法和css写法是一样的\r\ncontext.stroke();\r\n\r\n//填充\r\n//设置填充色\r\ncontext.fillStyle = \"yellowgreen\";\r\ncontext.fill();\r\n\r\n//把路径闭合\r\ncontext.closePath();\r\n\r\n//设置线条的粗细， 不需要加px\r\ncontext.lineWidth = 15;\r\n//线条的头部的设置\r\ncontext.lineCap = \"round\"; //默认是butt， 记住round\r\n\u003c/script\u003e\r\n\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n效果如下所示:\r\n\r\n![Canvas LineTo 效果图](https://user-images.githubusercontent.com/8088864/125880740-1d667e65-6511-4fd1-96a2-c697fa62aba3.png)\r\n\r\n#### 画矩形\r\n\r\n``` js\r\n// 直接传入 x， y， width， height， 就可以绘制一个矩形\r\n// 画在玻璃纸上\r\n\r\ncontext.rect(100, 100, 200, 200);\r\ncontext.strokeStyle = \"red\";\r\ncontext.stroke();\r\ncontext.fillStyle = \"yellow\";\r\ncontext.fill();\r\n```\r\n\r\n``` js\r\n// 直接创建一个填充的矩形\r\n// 创建玻璃纸， 画矩形路径， 填充， 把玻璃纸销毁\r\ncontext.fillRect(100, 100, 200, 200);\r\n\r\n// 黄色的边不会显示，是因为上面那一句，画完之后，就把玻璃纸销毁了\r\ncontext.strokeStyle = \"yellow\";\r\ncontext.stroke();\r\n// 如果放在fillRect上面就可以实现\r\n```\r\n\r\n#### 圆形绘制\r\n\r\n``` js\r\n// x轴是0度开始\r\n// x, y: 圆心位置；radius： 半径的长度; startRadian, endRadian 代表的是起始弧度和结束弧度；dircetion代表的圆形的路径的方向，默认是顺时针（是否逆时针， 默认值是false），如果传true就是逆时针,最后一个参数是可以不传的， 默认就是顺时针\r\n\r\n// context.arc(x, y, radius, startRadian, endRadian, direction);\r\n\r\n// 从31度的地方，画到81度的地方\r\ncontext.arc(300, 200, 100, 31/180*Math.PI, 81/180*Math.PI);\r\n\r\ncontext.strokeStyle = \"yellow\";\r\ncontext.stroke();\r\n\r\ncontext.fillStyle = \"red\";\r\ncontext.fill();\r\n```\r\n\r\n#### 画飞镖转盘\r\n\r\n``` js\r\nfor (var i = 0; i \u003c 10; i++) {\r\n    context.moveTo(320+i*20,200);\r\n    // i % 2代表是奇数还是偶数， 偶数就逆时针， 奇数就顺时针\r\n    context.arc(300, 200, 20 + i * 20, 0, 2*Math.PI, i%2==0);\r\n}\r\ncontext.fillStyle = \"green\";\r\ncontext.fill();\r\ncontext.stroke();\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas arc 画飞镖转盘](https://user-images.githubusercontent.com/8088864/125925307-9fdd88ec-8569-412d-9245-37aceca560ba.png)\r\n\r\n#### 线性渐变\r\n\r\n``` js\r\n// 1. 需要创建出一个渐变对象\r\n//    var gradient = context.createLinearGradient(100, 100, 300, 100);\r\n// 参数代表哪个点到哪个点，这里写的是左上角到右下角的意思\r\nvar gradient = context.createLinearGradient(100, 100, 300, 380);\r\n\r\n// 2. 添加渐变颜色\r\ngradient.addColorStop(0, \"red\");\r\ngradient.addColorStop(0.5, \"hotpink\");\r\ngradient.addColorStop(1, \"yellowgreen\");\r\n\r\n// 3. 将渐变对象设为填充色\r\ncontext.fillStyle = gradient;\r\n\r\n// 4. 画一个矩形\r\ncontext.fillRect(100, 100, 200, 280);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas createLinearGradient 线性渐变](https://user-images.githubusercontent.com/8088864/125925678-c260361c-11cb-44cd-86f9-86156ea7033e.png)\r\n\r\n#### 径向渐变\r\n\r\n``` js\r\n// 1. 创建渐变对象\r\n// 内圆\r\nvar c1 = {x: 260, y: 160, r: 0};\r\n// 外圆\r\nvar c2 = {x: 300, y: 200, r: 120};\r\n\r\nvar gradient = context.createRadialGradient(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);\r\ngradient.addColorStop(0, \"red\");\r\ngradient.addColorStop(0.3, \"yellow\");\r\ngradient.addColorStop(0.6, \"green\");\r\ngradient.addColorStop(1, \"orange\");\r\n\r\n// 2. 把渐变对象设为填充色\r\ncontext.fillStyle = gradient;\r\n\r\n// 3. 画圆并填充\r\n// 内圆的部分是用0的位置填充的; 内圆的边到外圆的边所发生的渐变叫， 径向渐变\r\ncontext.arc(c2.x, c2.y, c2.r, 0, 2*Math.PI);\r\ncontext.fill();\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas createRadialGradient 径向渐变](https://user-images.githubusercontent.com/8088864/125926105-f8d0128c-fc71-4278-9c10-580d9dbf4d3c.png)\r\n\r\n#### 径向渐变画球\r\n\r\n``` js\r\n//1. 创建一个径向渐变\r\nvar c1 = {x: 240, y: 160, r: 0};\r\nvar c2 = {x: 300, y: 200, r: 120};\r\n\r\nvar gradient = context.createRadialGradient(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);\r\ngradient.addColorStop(1, \"gray\");\r\ngradient.addColorStop(0, \"lightgray\");\r\n\r\n//2. 将渐变对象设为填充色\r\ncontext.fillStyle = gradient;\r\n\r\n//3. 画圆并填充\r\ncontext.arc(c2.x, c2.y, c2.r, 0, 2*Math.PI);\r\ncontext.fill();\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas createRadialGradient 径向渐变画球](https://user-images.githubusercontent.com/8088864/125926450-19a90cf2-1049-4d2c-a47d-1f22fad0cd58.png)\r\n\r\n#### 径向渐变画彩虹\r\n\r\n``` js\r\n//实现彩虹，给里面的圆一个半径80是关键\r\nvar c1 = {x: 300, y: 200, r: 80};\r\nvar c2 = {x: 300, y: 200, r: 150};\r\nvar gradient = context.createRadialGradient(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);\r\ngradient.addColorStop(1, \"red\");\r\ngradient.addColorStop(6/7, \"orange\");\r\ngradient.addColorStop(5/7, \"yellow\");\r\ngradient.addColorStop(4/7, \"green\");\r\ngradient.addColorStop(3/7, \"cyan\");\r\ngradient.addColorStop(2/7, \"skyblue\");\r\ngradient.addColorStop(1/7, \"purple\");\r\ngradient.addColorStop(0, \"white\");\r\n\r\n//设为填充色\r\ncontext.fillStyle = gradient;\r\n\r\n//画圆并填充\r\ncontext.arc(c2.x, c2.y, c2.r, 0, 2*Math.PI);\r\ncontext.fill();\r\n\r\n//遮挡下半部分\r\ncontext.fillStyle = \"white\";\r\ncontext.fillRect(0, 200, 600, 200);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas createRadialGradient 径向渐变画彩虹](https://user-images.githubusercontent.com/8088864/125926965-02866a67-5dd9-4be1-84f3-b0589696e7f7.png)\r\n\r\n#### 阴影效果\r\n\r\n``` js\r\n//和css3相比， 阴影只能设一个， 不能设内阴影\r\n//水平偏移， 垂直的偏移， 模糊程度， 阴影的颜色\r\n\r\n//设置阴影的参数\r\ncontext.shadowOffsetX = 10;\r\ncontext.shadowOffsetY = 10;\r\ncontext.shadowBlur = 10;\r\ncontext.shadowColor = \"yellowgreen\";\r\n\r\n//画一个矩形\r\ncontext.fillStyle = \"red\";\r\ncontext.fillRect(100, 100, 300, 200);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas shadow 阴影效果](https://user-images.githubusercontent.com/8088864/125927364-e91bafb3-7e90-4173-bd39-4ee8ae7da746.png)\r\n\r\n#### 绘制文字api\r\n\r\n``` js\r\n//绘制文字\r\n//text就是要绘制的文字， x， y就是从什么地方开始绘制\r\n//context.strokeText(\"text\", x, y)\r\n\r\ncontext.font = \"60px 微软雅黑\";\r\n//context.strokeText(\"hello, world\", 100, 100);\r\ncontext.fillText(\"hello, world\", 100, 100);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas fillText 绘制文字](https://user-images.githubusercontent.com/8088864/125927573-fdaa09b5-93d7-4990-86ee-2fa9a453eab5.png)\r\n\r\n#### 文字对齐方式\r\n\r\n``` js\r\n//默认在left\r\n//关键api：context.textAlign = \"left\";\r\ncontext.textAlign = \"left\";\r\ncontext.fillText(\"left\", 300, 120);\r\n\r\ncontext.textAlign = \"center\";\r\ncontext.fillText(\"center\", 300, 190);\r\n\r\ncontext.textAlign = \"right\";\r\ncontext.fillText(\"right\", 300, 260);\r\n\r\n// 文字出现在canvas的右上方\r\n// 1. 先设置right\r\n// 2. 给canvas.width,0即可\r\ncontext.font = \"60px 微软雅黑\";\r\ncontext.textAlign = \"right\";\r\ncontext.textBaseline = \"top\";\r\ncontext.fillText(\"hello, world\", canvas.width, 0);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas fillText 水平对齐方式](https://user-images.githubusercontent.com/8088864/125934392-abf31a1e-2b7e-429f-90cc-8cef9fd516d0.png)\r\n\r\n\r\n#### 垂直方向\r\n\r\n``` js\r\n//默认是top\r\n//关键api：context.textBaseline = \"top\";\r\n\r\ncontext.fillText(\"default\", 50, 200);\r\n\r\ncontext.textBaseline = \"top\";\r\ncontext.fillText(\"top\", 150, 200);\r\n\r\ncontext.textBaseline = \"middle\";\r\ncontext.fillText(\"middle\", 251, 200);\r\n\r\ncontext.textBaseline = \"bottom\";\r\ncontext.fillText(\"bottom\", 400, 200);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas fillText 垂直对齐方式](https://user-images.githubusercontent.com/8088864/125935099-d0a918b3-25e8-4150-bd86-053a5e5cfa98.png)\r\n\r\n#### 图片的绘制\r\n\r\n3参模式： 将img从x, y的地方开始绘制， 图片有多大，就绘制多大，超出canvas的部分就不显示了\r\n\r\n``` js\r\n//context.drawImage(img, x, y)\r\n\r\nvar image = new Image();\r\nimage.src = \"./img/gls.jpg\";\r\n\r\n//必须要等到图片加载出来，才能进行绘制的操作\r\nimage.onload = function () {\r\n  context.drawImage(image, 100, 200);\r\n}\r\n```\r\n\r\n5参模式（缩放模式）, 就是将图片显示在画布上的某一块区域（x, y, w, h）,如果这个区域的宽高和图片不一至，会被压缩或放大\r\n\r\n``` js\r\nvar image = new Image();\r\nimage.src = \"./img/gls.jpg\";\r\n\r\nimage.onload = function () {\r\n  context.drawImage(image, 100, 100, 100, 100);\r\n}\r\n```\r\n\r\n图片绘制的9参模式， 就是把原图（img）中的某一块（imagex，imagey，imagew，imageh）截取出来， 显示在画布的某个区域(canvasx, canvasy, canvasw, canvash)\r\n\r\n``` js\r\n//理解关键：\r\n//（imagex，imagey，imagew，imageh）\r\n//(canvasx, canvasy, canvasw, canvash)\r\n\r\nvar image = new Image();\r\nimage.src = \"./img/gls.jpg\";\r\nimage.onload = function () {\r\n  /*\r\n    参数的解释：\r\n    image： 就是大图片本身\r\n    中间的四个参数， 代表从图片的150， 0的位置，截取 150 * 200的一块区域\r\n    后面的四个参数， 将刚才截取的小图， 显示画布上 100， 100， 150， 200的这个区域\r\n  */\r\n  context.drawImage(image, 150, 0, 150, 200, 100, 100, 150, 200);\r\n}\r\n```\r\n\r\n## 十九、WebWorker和postMessage\r\n\r\n### 概述\r\n\r\nJavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。\r\n\r\nWeb Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\r\n\r\nWorker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。\r\n\r\nWeb Worker 有以下几个使用注意点。\r\n\r\n#### （1）同源限制\r\n\r\n分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。\r\n\r\n#### （2）DOM 限制\r\n\r\nWorker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。\r\n\r\n#### （3）通信联系\r\n\r\nWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。(postMessage)\r\n\r\n#### （4）脚本限制\r\n\r\nWorker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。\r\n\r\n#### （5）文件限制\r\n\r\nWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。\r\n\r\n### 基本用法\r\n\r\n#### 主线程\r\n\r\n主线程采用`new`命令，调用`Worker()`构造函数，新建一个 `Worker` 线程。\r\n\r\n``` js\r\nvar worker = new Worker('work.js');\r\n```\r\n\r\n`Worker()`构造函数的参数是一个脚本文件，该文件就是 `Worker` 线程所要执行的任务。由于 `Worker` 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），`Worker` 就会默默地失败。\r\n\r\n然后，主线程调用`worker.postMessage()`方法，向 `Worker` 发消息。\r\n\r\n``` js\r\nworker.postMessage('Hello World');\r\nworker.postMessage({method: 'echo', args: ['Work']});\r\n// worker.postMessage() 方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。\r\n```\r\n\r\n接着，主线程通过`worker.onmessage`指定监听函数，接收子线程发回来的消息。\r\n\r\n``` js\r\nworker.onmessage = function (event) {\r\n  console.log('Received message ' + event.data);\r\n  doSomething();\r\n}\r\n\r\nfunction doSomething() {\r\n  // 执行任务\r\n  worker.postMessage('Work done!');\r\n}\r\n```\r\n\r\n上面代码中，事件对象的data属性可以获取 `Worker` 发来的数据。\r\n\r\n`Worker` 完成任务以后，主线程就可以把它关掉。\r\n\r\n``` js\r\nworker.terminate();\r\n```\r\n\r\n#### Worker 线程\r\n\r\n`Worker` 线程内部需要有一个监听函数，监听`message`事件。\r\n\r\n``` js\r\nself.addEventListener('message', function (e) {\r\n  self.postMessage('You said: ' + e.data);\r\n}, false);\r\n```\r\n\r\n上面代码中，`self`代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。\r\n\r\n```js\r\n// 写法一\r\nthis.addEventListener('message', function (e) {\r\n  this.postMessage('You said: ' + e.data);\r\n}, false);\r\n\r\n// 写法二\r\naddEventListener('message', function (e) {\r\n  postMessage('You said: ' + e.data);\r\n}, false);\r\n```\r\n\r\n除了使用`self.addEventListener()`指定监听函数，也可以使用`self.onmessage`指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。`self.postMessage()`方法用来向主线程发送消息。\r\n\r\n根据主线程发来的数据，`Worker` 线程可以调用不同的方法，下面是一个例子。\r\n\r\n``` js\r\nself.addEventListener('message', function (e) {\r\n  var data = e.data;\r\n  switch (data.cmd) {\r\n    case 'start':\r\n      self.postMessage('WORKER STARTED: ' + data.msg);\r\n      break;\r\n    case 'stop':\r\n      self.postMessage('WORKER STOPPED: ' + data.msg);\r\n      self.close(); // Terminates the worker.\r\n      break;\r\n    default:\r\n      self.postMessage('Unknown command: ' + data.msg);\r\n  };\r\n}, false);\r\n```\r\n\r\n上面代码中，`self.close()`用于在 Worker 内部关闭自身。\r\n\r\n#### Worker 加载脚本\r\n\r\nWorker 内部如果要加载其他脚本，有一个专门的方法`importScripts()`。\r\n\r\n``` js\r\nimportScripts('script1.js');\r\n```\r\n\r\n该方法可以同时加载多个脚本。\r\n\r\n``` js\r\nimportScripts('script1.js', 'script2.js');\r\n```\r\n\r\n#### Worker 错误处理\r\n\r\n主线程可以监听 `Worker` 是否发生错误。如果发生错误，`Worker` 会触发主线程的error事件。\r\n\r\n``` js\r\nworker.onerror(function (event) {\r\n  console.log([\r\n    'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message\r\n  ].join(''));\r\n});\r\n\r\n// 或者\r\nworker.addEventListener('error', function (event) {\r\n  // ...\r\n});\r\n```\r\n\r\n`Worker` 内部也可以监听error事件。\r\n\r\n#### 关闭 Worker\r\n\r\n使用完毕，为了节省系统资源，必须关闭 Worker。\r\n\r\n``` js\r\n// 主线程\r\nworker.terminate();\r\n\r\n// Worker 线程\r\nself.close();\r\n```\r\n\r\n### 数据通信\r\n\r\n前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。\r\n\r\n主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。\r\n\r\n``` js\r\n// 主线程\r\nvar uInt8Array = new Uint8Array(new ArrayBuffer(10));\r\nfor (var i = 0; i \u003c uInt8Array.length; ++i) {\r\n  uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]\r\n}\r\nworker.postMessage(uInt8Array);\r\n\r\n// Worker 线程\r\nself.onmessage = function (e) {\r\n  var uInt8Array = e.data;\r\n  postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString());\r\n  postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);\r\n};\r\n```\r\n\r\n但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。\r\n\r\n如果要直接转移数据的控制权，就要使用下面的写法。\r\n\r\n``` js\r\n// Transferable Objects 格式\r\nworker.postMessage(arrayBuffer, [arrayBuffer]);\r\n\r\n// 例子\r\nvar ab = new ArrayBuffer(1);\r\nworker.postMessage(ab, [ab]);\r\n```\r\n\r\n### 同页面的 Web Worker\r\n\r\n通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n  \u003cbody\u003e\r\n    \u003cscript id=\"worker\" type=\"app/worker\"\u003e\r\n      addEventListener('message', function () {\r\n        postMessage('some message');\r\n      }, false);\r\n    \u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n上面是一段嵌入网页的脚本，注意必须指定`\u003cscript\u003e`标签的type属性是一个浏览器不认识的值，上例是`app/worker`。\r\n\r\n然后，读取这一段嵌入页面的脚本，用 Worker 来处理。\r\n\r\n``` js\r\nvar blob = new Blob([document.querySelector('#worker').textContent]);\r\nvar url = window.URL.createObjectURL(blob);\r\nvar worker = new Worker(url);\r\n\r\nworker.onmessage = function (e) {\r\n  // e.data === 'some message'\r\n};\r\n```\r\n\r\n上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。\r\n\r\n### Worker 线程完成轮询\r\n\r\n有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。\r\n\r\n``` js\r\nfunction createWorker(f) {\r\n  var blob = new Blob(['(' + f.toString() +')()']);\r\n  var url = window.URL.createObjectURL(blob);\r\n  var worker = new Worker(url);\r\n  return worker;\r\n}\r\n\r\nvar pollingWorker = createWorker(function (e) {\r\n  var cache;\r\n\r\n  function compare(new, old) { ... };\r\n\r\n  setInterval(function () {\r\n    fetch('/my-api-endpoint').then(function (res) {\r\n      var data = res.json();\r\n\r\n      if (!compare(data, cache)) {\r\n        cache = data;\r\n        self.postMessage(data);\r\n      }\r\n    })\r\n  }, 1000)\r\n});\r\n\r\npollingWorker.onmessage = function () {\r\n  // render data\r\n}\r\n\r\npollingWorker.postMessage('init');\r\n```\r\n\r\n上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。\r\n\r\n### Worker 新建 Worker\r\n\r\nWorker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。\r\n\r\n主线程代码如下。\r\n\r\n``` js\r\nvar worker = new Worker('worker.js');\r\nworker.onmessage = function (event) {\r\n  document.getElementById('result').textContent = event.data;\r\n};\r\n```\r\n\r\nWorker 线程代码如下。\r\n\r\n``` js\r\n// worker.js\r\n\r\n// settings\r\nvar num_workers = 10;\r\nvar items_per_worker = 1000000;\r\n\r\n// start the workers\r\nvar result = 0;\r\nvar pending_workers = num_workers;\r\nfor (var i = 0; i \u003c num_workers; i += 1) {\r\n  var worker = new Worker('core.js');\r\n  worker.postMessage(i * items_per_worker);\r\n  worker.postMessage((i + 1) * items_per_worker);\r\n  worker.onmessage = storeResult;\r\n}\r\n\r\n// handle the results\r\nfunction storeResult(event) {\r\n  result += event.data;\r\n  pending_workers -= 1;\r\n  if (pending_workers \u003c= 0)\r\n    postMessage(result); // finished!\r\n}\r\n```\r\n\r\n上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。\r\n\r\n``` js\r\n// core.js\r\nvar start;\r\nonmessage = getStart;\r\nfunction getStart(event) {\r\n  start = event.data;\r\n  onmessage = getEnd;\r\n}\r\n\r\nvar end;\r\nfunction getEnd(event) {\r\n  end = event.data;\r\n  onmessage = null;\r\n  work();\r\n}\r\n\r\nfunction work() {\r\n  var result = 0;\r\n  for (var i = start; i \u003c end; i += 1) {\r\n    // perform some complex calculation here\r\n    result += 1;\r\n  }\r\n  postMessage(result);\r\n  close();\r\n}\r\n```\r\n\r\n### API\r\n\r\n#### 主线程\r\n\r\n浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。\r\n\r\n``` js\r\nvar myWorker = new Worker(jsUrl, options);\r\n```\r\n\r\nWorker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。\r\n\r\n``` js\r\n// 主线程\r\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\r\n\r\n// Worker 线程\r\nself.name // myWorker\r\n```\r\n\r\nWorker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。\r\n\r\n- Worker.onerror：指定 error 事件的监听函数。\r\n- Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。\r\n- Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\r\n- Worker.postMessage()：向 Worker 线程发送消息。\r\n- Worker.terminate()：立即终止 Worker 线程。\r\n\r\n#### Worker 线程\r\n\r\nWeb Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。\r\n\r\nWorker 线程有一些自己的全局属性和方法。\r\n\r\n- self.name： Worker 的名字。该属性只读，由构造函数指定。\r\n- self.onmessage：指定message事件的监听函数。\r\n- self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\r\n- self.close()：关闭 Worker 线程。\r\n- self.postMessage()：向产生这个 Worker 线程发送消息。\r\n- self.importScripts()：加载 JS 脚本。\r\n\r\n## 二十、OffscreenCanvas 离屏Canvas — 使用Web Worker提高你的Canvas运行速度\r\n\r\nOffscreenCanvas提供了一个可以脱离屏幕渲染的canvas对象。\r\n\r\n有了离屏Canvas，你可以不用在你的主线程中绘制图像了！\r\n\r\nCanvas 是一个非常受欢迎的表现方式，同时也是WebGL的入口。它能绘制图形，图片，展示动画，甚至是处理视频内容。它经常被用来在富媒体web应用中创建炫酷的用户界面或者是制作在线（web）游戏。\r\n\r\n它是非常灵活的，这意味着绘制在Canvas的内容可以被编程。JavaScript就提供了Canvas的系列API。这些给了Canvas非常好的灵活度。\r\n\r\n但同时，在一些现代化的web站点，脚本解析运行是实现流畅用户反馈的最大的问题之一。因为Canvas计算和渲染和用户操作响应都发生在同一个线程中，在动画中（有时候很耗时）的计算操作将会导致App卡顿，降低用户体验。\r\n\r\n幸运的是, [OffscreenCanvas](https://developer.mozilla.org/zh-CN/docs/Web/API/OffscreenCanvas) 离屏Canvas可以非常棒的解决这个麻烦！\r\n\r\n到目前为止，Canvas的绘制功能都与`\u003ccanvas\u003e`标签绑定在一起，这意味着Canvas API和DOM是耦合的。而OffscreenCanvas，正如它的名字一样，通过将Canvas移出屏幕来解耦了DOM和Canvas API。\r\n\r\n由于这种解耦，OffscreenCanvas的渲染与DOM完全分离了开来，并且比普通Canvas速度提升了一些，而这只是因为两者（Canvas和DOM）之间没有同步。但更重要的是，将两者分离后，Canvas将可以在Web Worker中使用，即使在Web Worker中没有DOM。这给Canvas提供了更多的可能性。\r\n\r\n### 兼容性\r\n\r\n这是一个实验中的功能\r\n此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。\r\n\r\n支持浏览器如下图所示：\r\n\r\n![OffscreenCanvas兼容性](https://user-images.githubusercontent.com/8088864/126027990-d476b78e-e6c9-4438-998d-7ccc4ae79f8b.png)\r\n\r\n### 在Worker中使用OffscreenCanvas\r\n\r\n它在窗口环境和web worker环境均有效。\r\n\r\n[Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API) 是一个Web版的线程——它允许你在幕后运行你的代码。将你的一部分代码放到Worker中可以给你的主线程更多的空闲时间，这可以提高你的用户体验度。就像其没有DOM一样，直到现在，在Worker中都没有Canvas API。\r\n\r\n而OffscreenCanvas并不依赖DOM，所以在Worker中Canvas API可以被某种方法来代替。下面是我在Worker中用OffscreenCanvas来计算渐变颜色的：\r\n\r\n``` js\r\n// file: worker.js\r\n\r\nfunction getGradientColor(percent) {\r\n    const canvas = new OffscreenCanvas(100, 1);\r\n    const ctx = canvas.getContext('2d');\r\n    const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);\r\n    gradient.addColorStop(0, 'red');\r\n    gradient.addColorStop(1, 'blue');\r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(0, 0, ctx.canvas.width, 1);\r\n    const imgd = ctx.getImageData(0, 0, ctx.canvas.width, 1);\r\n    const colors = imgd.data.slice(percent * 4, percent * 4 + 4);\r\n    return `rgba(${colors[0]}, ${colors[1]}, ${colors[2]}, ${colors[3]})`;\r\n}\r\n\r\ngetGradientColor(40);  // rgba(152, 0, 104, 255)\r\n```\r\n\r\n### 不要阻塞主线程\r\n\r\n当我们将大量的计算移到Worker中运行时，可以释放主线程上的资源，这很有意思。我们可以使用transferControlToOffscreen 方法将常规的Canvas映射到OffscreenCanvas实例上。之后所有应用于OffscreenCanvas的操作将自动呈现在在源Canvas上。\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml\u003e\r\n\u003cbody\u003e\r\n\u003ccanvas id=\"myCanvas\" width=\"600\" height=\"500\" style=\"border:1px solid #d3d3d3;\"\u003e\r\n  Your browser does not support the HTML5 canvas tag.\r\n\u003c/canvas\u003e\r\n\u003cscript\u003e\r\nvar canvas = document.getElementById(\"myCanvas\");\r\n// var context = canvas.getContext(\"2d\");\r\n\r\n// // 画线\r\n// context.moveTo(100, 100);\r\n// context.lineTo(300, 100);\r\n// context.lineTo(300, 200);\r\n\r\n// // 画第二条线\r\n// // 画第二条线\r\n// context.moveTo(100, 300);\r\n// context.lineTo(300, 300);\r\n\r\n// // 最后要描边才会出效果\r\n// context.stroke();\r\n\r\n// // 创建一张新的玻璃纸\r\n// context.beginPath();\r\n// // 画第三条线\r\n// context.moveTo(400, 100);\r\n// context.lineTo(400, 300);\r\n// context.lineTo(500, 300);\r\n// context.lineTo(500, 200);\r\n\r\n// // 只要执行stroke，都会玻璃纸上的图形重复印刷一次\r\n// context.stroke();\r\n\r\n// // 填充\r\n// context.fill();\r\n// context.fillStyle = \"gray\";\r\n\r\n// // 设置描边色\r\n// context.strokeStyle = \"red\"; // 颜色的写法和css写法是一样的\r\n// context.stroke();\r\n\r\n// //填充\r\n// //设置填充色\r\n// context.fillStyle = \"yellowgreen\";\r\n// context.fill();\r\n\r\n// //把路径闭合\r\n// context.closePath();\r\n\r\n// //设置线条的粗细， 不需要加px\r\n// context.lineWidth = 15;\r\n// //线条的头部的设置\r\n// context.lineCap = \"round\"; //默认是butt， 记住round\r\n\r\n// 注: 如果将canvas转化成离屏canvas时，就不能使用原canvas的cantext来绘制图案，否则会报错，已经绘制了的canvas不同通过transferControlToOffscreen转换成OffscreenCanvas\r\n// Uncaught DOMException: Failed to execute 'transferControlToOffscreen' on 'HTMLCanvasElement': Cannot transfer control from a canvas that has a rendering context.\r\nconst offscreen = canvas.transferControlToOffscreen();\r\nconst worker = new Worker('worker.js');\r\nworker.postMessage({ canvas: offscreen }, [offscreen]);\r\n\u003c/script\u003e\r\n\u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\nOffscreenCanvas 是可转移的，除了将其指定为传递信息中的字段之一以外，还需要将其作为postMessage（传递信息给Worker的方法）中的第二个参数传递出去，以便可以在Worker线程的context（上下文）中使用它。\r\n\r\n``` js\r\n// worker.js\r\n\r\nself.onmessage = function (event) {\r\n  // 获取传送过来的离屏Canvas(OffscreenCanvas)\r\n  var canvas = event.data.canvas;\r\n  var context = canvas.getContext('2d');\r\n\r\n  // 画一个曲径球体\r\n  var c1 = {x: 240, y: 160, r: 0};\r\n  var c2 = {x: 300, y: 200, r: 120};\r\n\r\n  var gradient = context.createRadialGradient(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);\r\n  gradient.addColorStop(1, \"gray\");\r\n  gradient.addColorStop(0, \"lightgray\");\r\n\r\n  //2. 将渐变对象设为填充色\r\n  context.fillStyle = gradient;\r\n\r\n  //3. 画圆并填充\r\n  context.arc(c2.x, c2.y, c2.r, 0, 2*Math.PI);\r\n  context.fill();\r\n}\r\n```\r\n\r\n效果如下所示:\r\n\r\n![WebWorker中OffscreenCanvas绘制径向渐变画球](https://user-images.githubusercontent.com/8088864/126027866-d78a65fc-8f0f-4a7e-9adf-7eb09a03b956.png)\r\n\r\n任务繁忙的主线程也不会影响在Worker上运行的动画。所以即使主线程非常繁忙，你也可以通过此功能来避免掉帧并保证流畅的动画\r\n\r\n### WebRTC的YUV媒体流数据的离屏渲染\r\n\r\n从 WebRTC 中拿到的是 YUV 的原始视频流，将原始的 YUV 视频帧直接转发过来，通过第三方库直接在 Cavans 上渲染。\r\n\r\n可以使用[yuv-canvas](https://github.com/brion/yuv-canvas)和[yuv-buffer](https://github.com/brion/yuv-buffer)第三方库来渲染YUV的原始视频流。\r\n\r\n主进程render.js\r\n\r\n``` js\r\n\"use strict\";\r\nexports.__esModule = true;\r\nvar isEqual = require('lodash.isequal');\r\nvar YUVBuffer = require('yuv-buffer');\r\nvar YUVCanvas = require('yuv-canvas');\r\nvar Renderer = /** @class */ (function () {\r\n    function Renderer(workSource) {\r\n        var _this = this;\r\n        this._sendCanvas = function () {\r\n            _this.canvasSent = true;\r\n            _this.worker \u0026\u0026 _this.worker.postMessage({\r\n                type: 'constructor',\r\n                data: {\r\n                    canvas: _this.offCanvas,\r\n                    id: (_this.element \u0026\u0026 _this.element.id) || (Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2))\r\n                }\r\n            }, [_this.offCanvas]);\r\n        };\r\n        /**\r\n         * 判断使用渲染的方式\r\n         */\r\n        this._checkRendererWay = function () {\r\n            if (_this.workerReady \u0026\u0026 _this.worker \u0026\u0026 _this.offCanvas \u0026\u0026 _this.enableWorker) {\r\n                return 'worker';\r\n            }\r\n            else {\r\n                return 'software';\r\n            }\r\n        };\r\n        // workerCanvas渲染\r\n        this._workDrawFrame = function (width, height, yUint8Array, uUint8Array, vUint8Array) {\r\n            if (_this.canvasWrapper \u0026\u0026 _this.canvasWrapper.style.display !== 'none') {\r\n                _this.canvasWrapper.style.display = 'none';\r\n            }\r\n            if (_this.workerCanvasWrapper \u0026\u0026 _this.workerCanvasWrapper.style.display === 'none') {\r\n                _this.workerCanvasWrapper.style.display = 'flex';\r\n            }\r\n            _this.worker \u0026\u0026 _this.worker.postMessage({\r\n                type: 'drawFrame',\r\n                data: {\r\n                    width: width,\r\n                    height: height,\r\n                    yUint8Array: yUint8Array,\r\n                    uUint8Array: uUint8Array,\r\n                    vUint8Array: vUint8Array\r\n                }\r\n            }, [yUint8Array, uUint8Array, vUint8Array]);\r\n        };\r\n        // 实际渲染Canvas\r\n        this._softwareDrawFrame = function (width, height, yUint8Array, uUint8Array, vUint8Array) {\r\n            if (_this.workerCanvasWrapper \u0026\u0026 _this.workerCanvasWrapper.style.display !== 'none') {\r\n                _this.workerCanvasWrapper.style.display = 'none';\r\n            }\r\n            if (_this.canvasWrapper \u0026\u0026 _this.canvasWrapper.style.display === 'none') {\r\n                _this.canvasWrapper.style.display = 'flex';\r\n            }\r\n            var format = YUVBuffer.format({\r\n                width: width,\r\n                height: height,\r\n                chromaWidth: width / 2,\r\n                chromaHeight: height / 2\r\n            });\r\n            var y = YUVBuffer.lumaPlane(format, yUint8Array);\r\n            var u = YUVBuffer.chromaPlane(format, uUint8Array);\r\n            var v = YUVBuffer.chromaPlane(format, vUint8Array);\r\n            var frame = YUVBuffer.frame(format, y, u, v);\r\n            _this.yuv.drawFrame(frame);\r\n        };\r\n        this.cacheCanvasOpts = {};\r\n        this.yuv = {};\r\n        this.ready = false;\r\n        this.contentMode = 0;\r\n        this.container = {};\r\n        this.canvasWrapper;\r\n        this.canvas = {};\r\n        this.element = {};\r\n        this.offCanvas = {};\r\n        this.enableWorker = !!workSource;\r\n        if (this.enableWorker) {\r\n            this.worker = new Worker(workSource);\r\n            this.workerReady = false;\r\n            this.canvasSent = false;\r\n            this.worker.onerror = function (evt) {\r\n                console.error('[WorkerRenderer]: the renderer worker catch error: ', evt);\r\n                _this.workerReady = false;\r\n                _this.enableWorker = false;\r\n            };\r\n            this.worker.onmessage = function (evt) {\r\n                var data = evt.data;\r\n                switch (data.type) {\r\n                    case 'ready': {\r\n                        console.log('[WorkerRenderer]: the renderer worker was ready');\r\n                        _this.workerReady = true;\r\n                        if (_this.offCanvas) {\r\n                            _this._sendCanvas();\r\n                        }\r\n                        break;\r\n                    }\r\n                    case 'exited': {\r\n                        console.log('[WorkerRenderer]: the renderer worker was exited');\r\n                        _this.workerReady = false;\r\n                        _this.enableWorker = false;\r\n                        break;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    }\r\n    Renderer.prototype._calcZoom = function (vertical, contentMode, width, height, clientWidth, clientHeight) {\r\n        if (vertical === void 0) { vertical = false; }\r\n        if (contentMode === void 0) { contentMode = 0; }\r\n        var localRatio = clientWidth / clientHeight;\r\n        var tempRatio = width / height;\r\n        if (isNaN(localRatio) || isNaN(tempRatio)) {\r\n            return 1;\r\n        }\r\n        if (!contentMode) {\r\n            if (vertical) {\r\n                return localRatio \u003e tempRatio ?\r\n                    clientHeight / height : clientWidth / width;\r\n            }\r\n            else {\r\n                return localRatio \u003c tempRatio ?\r\n                    clientHeight / height : clientWidth / width;\r\n            }\r\n        }\r\n        else {\r\n            if (vertical) {\r\n                return localRatio \u003c tempRatio ?\r\n                    clientHeight / height : clientWidth / width;\r\n            }\r\n            else {\r\n                return localRatio \u003e tempRatio ?\r\n                    clientHeight / height : clientWidth / width;\r\n            }\r\n        }\r\n    };\r\n    Renderer.prototype.getBindingElement = function () {\r\n        return this.element;\r\n    };\r\n    Renderer.prototype.bind = function (element) {\r\n        // record element\r\n        this.element = element;\r\n        // create container\r\n        var container = document.createElement('div');\r\n        container.className += ' video-canvas-container';\r\n        Object.assign(container.style, {\r\n            width: '100%',\r\n            height: '100%',\r\n            display: 'flex',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n            position: 'relative'\r\n        });\r\n        this.container = container;\r\n        element \u0026\u0026 element.appendChild(this.container);\r\n        // 创建两个canvas，一个在主线程中渲染，如果web worker中的离屏canvas渲染进程出错了，还可以切换到主进程的canvas进行渲染\r\n        var canvasWrapper = document.createElement('div');\r\n        canvasWrapper.className += ' video-canvas-wrapper canvas-renderer';\r\n        Object.assign(canvasWrapper.style, {\r\n            width: '100%',\r\n            height: '100%',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n            position: 'absolute',\r\n            left: '0px',\r\n            right: '0px',\r\n            display: 'none'\r\n        });\r\n        this.canvasWrapper = canvasWrapper;\r\n        this.container.appendChild(this.canvasWrapper);\r\n        var workerCanvasWrapper = document.createElement('div');\r\n        workerCanvasWrapper.className += ' video-canvas-wrapper webworker-renderer';\r\n        Object.assign(workerCanvasWrapper.style, {\r\n            width: '100%',\r\n            height: '100%',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n            position: 'absolute',\r\n            left: '0px',\r\n            right: '0px',\r\n            display: 'none'\r\n        });\r\n        this.workerCanvasWrapper = workerCanvasWrapper;\r\n        this.container.appendChild(this.workerCanvasWrapper);\r\n        // create canvas\r\n        this.canvas = document.createElement('canvas');\r\n        this.workerCanvas = document.createElement('canvas');\r\n        this.canvasWrapper.appendChild(this.canvas);\r\n        this.workerCanvasWrapper.appendChild(this.workerCanvas);\r\n        // 创建 OffscreenCanvas 对象\r\n        this.offCanvas = this.workerCanvas.transferControlToOffscreen();\r\n        if (!this.canvasSent \u0026\u0026 this.offCanvas \u0026\u0026 this.worker \u0026\u0026 this.workerReady) {\r\n            this._sendCanvas();\r\n        }\r\n        this.yuv = YUVCanvas.attach(this.canvas, { webGL: false });\r\n    };\r\n    Renderer.prototype.unbind = function () {\r\n        this.canvasWrapper \u0026\u0026 this.canvasWrapper.removeChild(this.canvas);\r\n        this.workerCanvasWrapper \u0026\u0026 this.workerCanvasWrapper.removeChild(this.workerCanvas);\r\n        this.container \u0026\u0026 this.container.removeChild(this.canvasWrapper);\r\n        this.container \u0026\u0026 this.container.removeChild(this.workerCanvasWrapper);\r\n        this.element \u0026\u0026 this.element.removeChild(this.container);\r\n        this.worker \u0026\u0026 this.worker.terminate();\r\n        this.workerReady = false;\r\n        this.canvasSent = false;\r\n        this.yuv = null;\r\n        this.container = null;\r\n        this.workerCanvasWrapper = null;\r\n        this.canvasWrapper = null;\r\n        this.element = null;\r\n        this.canvas = null;\r\n        this.workerCanvas = null;\r\n        this.offCanvas = null;\r\n        this.worker = null;\r\n    };\r\n    Renderer.prototype.refreshCanvas = function () {\r\n        // Not implemented for software renderer\r\n    };\r\n    Renderer.prototype.updateCanvas = function (options) {\r\n        if (options === void 0) { options = {\r\n            width: 0,\r\n            height: 0,\r\n            rotation: 0,\r\n            mirrorView: false,\r\n            contentMode: 0,\r\n            clientWidth: 0,\r\n            clientHeight: 0\r\n        }; }\r\n        // check if display options changed\r\n        if (isEqual(this.cacheCanvasOpts, options)) {\r\n            return;\r\n        }\r\n        this.cacheCanvasOpts = Object.assign({}, options);\r\n        // check for rotation\r\n        if (options.rotation === 0 || options.rotation === 180) {\r\n            this.canvas.width = options.width;\r\n            this.canvas.height = options.height;\r\n            // canvas 调用 transferControlToOffscreen 方法后无法修改canvas的宽度和高度，只允许修改canvas的style属性\r\n            this.workerCanvas.style.width = options.width + \"px\";\r\n            this.workerCanvas.style.height = options.height + \"px\";\r\n        }\r\n        else if (options.rotation === 90 || options.rotation === 270) {\r\n            this.canvas.height = options.width;\r\n            this.canvas.width = options.height;\r\n            this.workerCanvas.style.height = options.width + \"px\";\r\n            this.workerCanvas.style.width = options.height + \"px\";\r\n        }\r\n        else {\r\n            throw new Error('Invalid value for rotation. Only support 0, 90, 180, 270');\r\n        }\r\n        var transformItems = [];\r\n        transformItems.push(\"rotateZ(\" + options.rotation + \"deg)\");\r\n        var scale = this._calcZoom(options.rotation === 90 || options.rotation === 270, options.contentMode, options.width, options.height, options.clientWidth, options.clientHeight);\r\n        // transformItems.push(`scale(${scale})`)\r\n        this.canvas.style.zoom = scale;\r\n        this.workerCanvas.style.zoom = scale;\r\n        // check for mirror\r\n        if (options.mirrorView) {\r\n            // this.canvas.style.transform = 'rotateY(180deg)';\r\n            transformItems.push('rotateY(180deg)');\r\n        }\r\n        if (transformItems.length \u003e 0) {\r\n            var transform = \"\" + transformItems.join(' ');\r\n            this.canvas.style.transform = transform;\r\n            this.workerCanvas.style.transform = transform;\r\n        }\r\n    };\r\n    Renderer.prototype.drawFrame = function (imageData) {\r\n        if (!this.ready) {\r\n            this.ready = true;\r\n        }\r\n        var dv = new DataView(imageData.header);\r\n        // let format = dv.getUint8(0);\r\n        var mirror = dv.getUint8(1);\r\n        var contentWidth = dv.getUint16(2);\r\n        var contentHeight = dv.getUint16(4);\r\n        var left = dv.getUint16(6);\r\n        var top = dv.getUint16(8);\r\n        var right = dv.getUint16(10);\r\n        var bottom = dv.getUint16(12);\r\n        var rotation = dv.getUint16(14);\r\n        // let ts = dv.getUint32(16);\r\n        var width = contentWidth + left + right;\r\n        var height = contentHeight + top + bottom;\r\n        this.updateCanvas({\r\n            width: width, height: height, rotation: rotation,\r\n            mirrorView: !!mirror,\r\n            contentMode: this.contentMode,\r\n            clientWidth: this.container \u0026\u0026 this.container.clientWidth,\r\n            clientHeight: this.container \u0026\u0026 this.container.clientHeight\r\n        });\r\n        if (this._checkRendererWay() === 'software') {\r\n            // 实际渲染canvas\r\n            this._softwareDrawFrame(width, height, imageData.yUint8Array, imageData.uUint8Array, imageData.vUint8Array);\r\n        }\r\n        else {\r\n            this._workDrawFrame(width, height, imageData.yUint8Array, imageData.uUint8Array, imageData.vUint8Array);\r\n        }\r\n    };\r\n    /**\r\n     * 清空整个Canvas面板\r\n     *\r\n     * @memberof Renderer\r\n     */\r\n    Renderer.prototype.clearFrame = function () {\r\n        if (this._checkRendererWay() === 'software') {\r\n            this.yuv \u0026\u0026 this.yuv.clear();\r\n        }\r\n        else {\r\n            this.worker \u0026\u0026 this.worker.postMessage({\r\n                type: 'clearFrame'\r\n            });\r\n        }\r\n    };\r\n    Renderer.prototype.setContentMode = function (mode) {\r\n        if (mode === void 0) { mode = 0; }\r\n        this.contentMode = mode;\r\n    };\r\n    return Renderer;\r\n}());\r\n\r\nexports[\"default\"] = Renderer;\r\n```\r\n\r\n渲染Worker的代码如下所示:\r\n\r\n``` js\r\n// render worker\r\n\r\n(function() {\r\n  const dateFormat = function(date, formatter = 'YYYY-MM-DD hh:mm:ss SSS') {\r\n    if (!date) {\r\n      return date;\r\n    }\r\n\r\n    let time;\r\n\r\n    try {\r\n      time = new Date(date);\r\n    } catch (e) {\r\n      return date;\r\n    }\r\n\r\n    const oDate = {\r\n      Y: time.getFullYear(),\r\n      M: time.getMonth() + 1,\r\n      D: time.getDate(),\r\n      h: time.getHours(),\r\n      m: time.getMinutes(),\r\n      s: time.getSeconds(),\r\n      S: time.getMilliseconds()\r\n    };\r\n\r\n    return formatter.replace(/(Y|M|D|h|m|s|S)+/g, (res, key) =\u003e {\r\n      let len = 2;\r\n\r\n      switch (res.length) {\r\n        case 1:\r\n          len = res.slice(1, 0) === 'Y' ? 4 : 2;\r\n          break;\r\n        case 2:\r\n          len = 2;\r\n          break;\r\n        case 3:\r\n          len = 3;\r\n          break;\r\n        case 4:\r\n          len = 4;\r\n          break;\r\n        default:\r\n          len = 2;\r\n      }\r\n      return (`0${oDate[key]}`).slice(-len);\r\n    });\r\n  }\r\n\r\n  let yuv;\r\n\r\n  try {\r\n    importScripts('./yuv-buffer/yuv-buffer.js');\r\n    importScripts('./yuv-canvas/shaders.js');\r\n    importScripts('./yuv-canvas/depower.js');\r\n    importScripts('./yuv-canvas/YCbCr.js');\r\n    importScripts('./yuv-canvas/FrameSink.js');\r\n    importScripts('./yuv-canvas/SoftwareFrameSink.js');\r\n    importScripts('./yuv-canvas/WebGLFrameSink.js');\r\n    importScripts('./yuv-canvas/yuv-canvas.js');\r\n\r\n    self.addEventListener('message', function (e) {\r\n      const data = e.data;\r\n      switch (data.type) {\r\n        case 'constructor':\r\n          console.log(`${dateFormat(new Date())} RENDER_WORKER [INFO]: received canvas: `, data.data.canvas, data.data.id);\r\n          yuv = YUVCanvas.attach(data.data.canvas, { webGL: false });\r\n          break;\r\n        case 'drawFrame':\r\n          // 考虑是否使用requestAnimationFrame进行渲染，控制每一帧显示的频率\r\n          const width = data.data.width;\r\n          const height = data.data.height;\r\n          const yUint8Array = data.data.yUint8Array;\r\n          const uUint8Array = data.data.uUint8Array;\r\n          const vUint8Array = data.data.vUint8Array;\r\n          const format = YUVBuffer.format({\r\n            width: width,\r\n            height: height,\r\n            chromaWidth: width / 2,\r\n            chromaHeight: height / 2\r\n          });\r\n          const y = YUVBuffer.lumaPlane(format, yUint8Array);\r\n          const u = YUVBuffer.chromaPlane(format, uUint8Array);\r\n          const v = YUVBuffer.chromaPlane(format, vUint8Array);\r\n          const frame = YUVBuffer.frame(format, y, u, v);\r\n          yuv \u0026\u0026 yuv.drawFrame(frame);\r\n          break;\r\n        case 'clearFrame': {\r\n          yuv \u0026\u0026 yuv.clear(frame);\r\n          break;\r\n        }\r\n        default:\r\n          console.log(`${dateFormat(new Date())} RENDER_WORKER [INFO]: [RendererWorker]: Unknown message: `, data);\r\n      };\r\n    }, false);\r\n\r\n    self.postMessage({\r\n      type: 'ready',\r\n    });\r\n  } catch (error) {\r\n    self.postMessage({\r\n      type: 'exited',\r\n    });\r\n\r\n    console.log(`${dateFormat(new Date())} RENDER_WORKER [INFO]: [RendererWorker]: catch error`, error);\r\n  }\r\n})();\r\n\r\n```\r\n\r\n### 总结\r\n\r\n如果你对图像绘画使用得非常多，OffscreenCanvas可以有效的提高你APP的性能。它使得Worker可以处理canvas的渲染绘制，让你的APP更好地利用了多核系统。\r\n\r\nOffscreenCanvas在Chrome 69中已经不需要开启flag（实验性功能）就可以使用了。它也正在被 Firefox 实现。由于其API与普通canvas元素非常相似，所以你可以轻松地对其进行特征检测并循序渐进地使用它，而不会破坏现有的APP或库的运行逻辑。OffscreenCanvas在任何涉及到图形计算以及动画表现且与DOM关系并不密切（即依赖DOM API不多）的情况下，它都具有性能优势。\r\n\r\n## 二十一、Vue与React Virtual DOM对比\r\n\r\n### 相同点\r\n\r\n1. vue和react都采用了虚拟dom算法，以最小化更新真实DOM，从而减小不必要的性能损耗。\r\n\r\n2. 按颗粒度分为tree diff, component diff, element diff。 tree diff 比较同层级dom节点，进行增、删、移操作。如果遇到component元素， 就会重新tree diff流程。\r\n\r\n### 不同点\r\n\r\n#### dom的更新策略不同\r\n\r\nreact 会自顶向下全diff。\r\n\r\nvue 会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\r\n\r\n1. 在react中，当状态发生改变时，组件树就会自顶向下的全diff, 重新render页面， 重新生成新的虚拟dom tree, 新旧dom tree进行比较， 进行patch打补丁方式，局部跟新dom. 所以react为了避免父组件跟新而引起不必要的子组件更新， 可以在shouldComponentUpdate做逻辑判断，减少没必要的render， 以及重新生成虚拟dom，做差量对比过程。\r\n\r\n2. 在 vue中， 通过Object.defineProperty 把这些 data 属性 全部转为 getter/setter。同时watcher实例对象会在组件渲染时，将属性记录为dep, 当dep 项中的 setter被调用时，通知watch重新计算，使得关联组件更新。\r\n\r\nDiff 算法借助元素的 Key 判断元素是新增、删除、修改，从而减少不必要的元素重渲染。\r\n\r\n### 建议\r\n\r\n1. 基于tree diff\r\n\r\n  - 开发组件时，注意保持DOM结构的稳定；即尽可能少地动态操作DOM结构，尤其是移动操作。\r\n  - 当节点数过大或者页面更新次数过多时，页面卡顿的现象会比较明显。这时可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。\r\n\r\n2. 基于component diff\r\n\r\n  - 注意使用 shouldComponentUpdate() 来减少组件不必要的更新。\r\n  - 对于类似的结构应该尽量封装成组件，既减少代码量，又能减少component diff的性能消耗。\r\n\r\n3. 基于element diff：\r\n\r\n  - 对于列表结构，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响渲染性能。\r\n  - 循环渲染的必须加上key值，唯一标识节点。\r\n\r\n## 二十二、Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？\r\n\r\n在我看来，渐进式代表的含义是：主张最少。\r\n\r\n每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。\r\n\r\n比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：\r\n\r\n- 必须使用它的模块机制\r\n- 必须使用它的依赖注入\r\n- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）\r\n\r\n所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。\r\n\r\n比如React，它也有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。\r\n\r\n你当然可以只用React的视图层，但几乎没有人这么用，为什么呢，因为你用了它，就会觉得其他东西都很别扭，于是你要引入Flux，Redux，Mobx之中的一个，于是你除了Redux，还要看saga，于是你要纠结业务开发过程中每个东西有没有副作用，纯不纯，甚至你连这个都可能不能忍：\r\n\r\n``` js\r\nconst getData = () =\u003e {\r\n  // 如果不存在，就在缓存中创建一个并返回\r\n  // 如果存在，就从缓存中拿\r\n}\r\n```\r\n\r\n因为你要纠结它有外部依赖，同样是不加参数调用，连续两次的结果是不一样的，于是不纯。\r\n\r\n为什么我一直不认同在中后台项目中使用React，原因就在这里，我反对的是整个业务应用的函数式倾向，很多人都是看到有很多好用的React组件，就会倾向于把它引入，然后，你知道怎么把自己的业务映射到函数式的那套理念上吗？\r\n\r\n函数式编程，无副作用，写出来的代码没有bug，这是真理没错，但是有两个问题需要考虑：\r\n\r\n1. JS本身，有太多特性与纯函数式的主张不适配，这一点，题叶能说得更多\r\n2. 业务系统里面的实体关系，如何组织业务逻辑，几十年来积累了无数的基于设计模式的场景经验，有太多的东西可以模仿，但是，没有人给你总结那么多如何把你的厚重业务映射到函数式理念的经验，这个地方很考验综合水平的，真的每个人都有能力去做这种映射吗？\r\n\r\n函数式编程无bug的根本就在于要把业务逻辑完全都依照这套理念搞好，你看看自己公司做中后台的员工，他们熟悉的是什么？是基于传统OO设计模式的这套东西，他们以为拿着你们给的组件库就得到了一切，但是可能还要被灌输函数式编程的一整套东西，而且又没人告诉他们在业务场景下，如何规划业务模型、组织代码，还要求快速开发，怎么能快起来？\r\n\r\n所以我真是心疼这些人，他们要的只是组件库，却不得不把业务逻辑的思考方式也作转换，这个事情没有一两年时间洗脑，根本洗不到能开发业务的程度。\r\n\r\n没有好组件库的时候，大家痛点在视图层，有了基于React的组件化，把原先没那么痛的业务逻辑部分搞得也痛起来了，原先大家按照设计模式教的东西，照猫画虎还能继续开发了，学了一套新理念之后，都不知道怎么写代码了，怎么写都怀疑自己不对，可怕。\r\n\r\n我宁可支持Angular也不支持React的原因也就在此，Angular至少在业务逻辑这块没有软主张，能够跟OO设计模式那套东西配合得很好。我面对过很多商务场景，都是前端很厚重的东西，不仅仅是管理控制台这种，这类东西里面，业务逻辑的占比要比视图大挺多的，如何组织这些东西，目前几个主流技术栈都没有解决方案，要靠业务架构师去摆平。\r\n\r\n如果你的场景不是这么厚重的，只是简单管理控制台，那当我没说好了。\r\n\r\n框架是不能解决业务问题的，只能作为工具，放在合适的人手里，合适的场景下。\r\n\r\n现在我要说说为什么我这么支持Vue了，没什么，可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。\r\n\r\n渐进式的含义，我的理解是：没有多做职责之外的事。\r\n\r\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 一、Event Loop","### 宏队列和微队列","### 浏览器中的Event Loop","### NodeJs中的Event Loop","## 二、Fetch API使用的常见问题及其解决办法","### Fetch 兼容性问题","### fetch默认不携带cookie","### fetch请求对某些错误http状态不会reject","### fetch不支持超时timeout处理","### fetch不支持JSONP","### fetch不支持progress事件","### fetch跨域问题","## 三、原型链和继承","### 函数与对象的关系","### 函数与原型的关系","### 原型和实例的关系","### 原型链","### 6种继承方法","#### 第一种: 原型链继承","#### 第二种: 构造函数继承","#### 第三种: 组合继承","#### 第四种: 原型式继承","#### 第五种: 寄生继承","#### 第六种: 寄生组合继承","#### 第七种: ES6 Class类和extends关键字","## 四、前端性能优化","### 1. 减少 HTTP 请求","### 2. 使用 HTTP2","#### 解析速度快","#### 多路复用","#### 首部压缩","#### 优先级","#### 流量控制","#### 服务器推送","### 3. 使用服务端渲染","#### 客户端渲染过程","#### 服务端渲染过程","### 4. 静态资源使用 CDN","#### CDN 原理","### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部","### 6. 使用字体图标 iconfont 代替图片图标","#### 压缩字体文件","### 7. 善用缓存，不重复加载相同的资源","### 8. 压缩文件","### 9. 图片优化","#### (1). 图片延迟加载","#### (2). 响应式图片","#### (3). 调整图片大小","#### (4). 降低图片质量","#### (5). 尽可能利用 CSS3 效果代替图片","#### (6). 使用 webp 格式的图片","### 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码","#### 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载","#### 提取第三方库","#### 减少 ES6 转为 ES5 的冗余代码","### 11. 减少重绘重排","#### 重排","#### 重绘","### 12. 使用事件委托","### 13. 注意程序的局部性","### 14. if-else 对比 switch","### 15. 查找表","### 16. 避免页面卡顿","### 17. 使用 requestAnimationFrame 来实现视觉变化","### 18. 使用 Web Workers","### 19. 使用位操作","#### 取模","#### 取整","#### 位掩码","### 20. 不要覆盖原生方法","### 21. 降低 CSS 选择器的复杂性","#### (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取","#### (2). CSS 选择器优先级","### 22. 使用 flexbox 而不是较早的布局模型","### 23. 使用 transform 和 opacity 属性更改来实现动画","### 24. 合理使用规则，避免过度优化","#### 检查加载性能","#### 检查运行性能","## 五、强缓存与协商缓存","### 浏览器缓存","#### 缓存优点","#### 缓存缺点","#### 缓存流程","### 强缓存相关的header字段","### 协商缓存相关的header字段","#### 1. Last-Modified/If-Modified-Since","#### 2. Etag/If-None-Match","### 既生Last-Modified何生Etag","### 用户的行为对缓存的影响","### 强缓存如何重新加载缓存缓存过的资源","## 六、HTTP 各版本特点与区别","### 1、HTTP 0.9","### 2、HTTP 1.0","### 3、HTTP 1.1","#### Persistent Connection（keepalive连接）","#### chunked编码传输","#### 字节范围请求","#### 断点续传","#### Pipelining（请求流水线）","#### 其他特性","### 4、HTTP 2.0","#### 二进制分帧","#### 多路复用","#### 头部压缩","#### 随时复位","#### 服务器端推流","#### 优先权和依赖","## 七、队头阻塞以及解决办法","### 前言","### TCP队头阻塞","### HTTP队头阻塞","#### HTTP管道化是什么","#### HTTP管道化产生的背景","#### HTTP管道化的限制","#### HTTP管道化引起的请求队头阻塞","### 如何解决队头阻塞","#### 如何解决HTTP队头阻塞","#### 如何解决TCP队头阻塞","### 总结","## 八、QUIC","### QUIC的由来：为什么是UDP而非TCP？","### 为什么要用QUIC？","#### 1. 建连延迟低","#### 2. 安全又可靠","#### 3. 改造灵活","#### 4. 改进的拥塞控制","#### 5. 无队头阻塞的多路复用","### QUIC对客户端的要求","### QUIC应用场景","## 九、WebRTC的优缺点","### 优点","### 缺点","## 十、EventSource和轮询的优缺点","### EventSource","#### 简介","#### EventSource规范字段","#### EventSource属性","#### EventSource 通讯过程","#### 缺点","### 轮询","#### 短轮询(Polling)","#### 长轮询(Long Polling)","### EventSource VS 轮询","### 总结","## 十一、WebSocket 是什么原理？为什么可以实现持久连接？","### WebSocket 机制","### WebSocket协议的原理","### WebSocket协议的优缺点","## 十二、Sass","## 十三、三栏弹性布局的5种方法(绝对定位、圣杯、双飞翼、flex、grid)","### 需求","### 5种具体实现和优缺点比较","#### 1. 绝对定位布局","#### 2. 圣杯布局","#### 3. 双飞翼布局","#### 4. flex布局","#### 5. grid布局","## 十四、浅析CSS里的BFC和IFC的用法","### BFC简介","### BFC的特性及应用","#### 同一个 BFC下外边距 会发生折叠","#### BFC可以包含浮动的元素(清除浮动)","#### BFC可以阻止元素被浮动元素覆盖","### 简要介绍IFC","## 十五、浅析CSS的性能优化：transform与position区别、硬件加速工作原理及注意事项、强制使用GPU渲染的友好CSS属性","### 问题背景","#### 1. position + top/left 的效果","#### 2. transform 的效果","### 硬件加速工作原理","### 使用 GPU 渲染元素","#### 能触发GPU渲染的属性","#### 强制使用GPU渲染","#### 使用硬件加速需要注意的事项","#### will-change","### 总结","## 十六、深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调","### 前言","### 事件循环","#### 定义","#### 流程","#### 多任务队列","#### requestAnimationFrame","##### 闪烁动画","##### 定时器合并","#### requestIdleCallback","#### 草案解读","#### 动画例子","### 总结","## 十七、React Fiber架构中，迭代器和requestIdleCallback结合的优势","### requestIdleCallback API","#### API 介绍","#### 浏览器空余时间","#### 应用场景","#### 使用方式","#### 功能体验","### Fiber 出现的目的","#### React 16之前的版本存在的问题","### Stack 算法模拟","### React 16 解决方案 - Fiber","### 实现思路","### 什么是 Fiber","#### 执行单元","#### 数据结构","## 十八、canvas","### 标签","### 怎么用","### 相关的api及用法","#### 画矩形","#### 圆形绘制","#### 画飞镖转盘","#### 线性渐变","#### 径向渐变","#### 径向渐变画球","#### 径向渐变画彩虹","#### 阴影效果","#### 绘制文字api","#### 文字对齐方式","#### 垂直方向","#### 图片的绘制","## 十九、WebWorker和postMessage","### 概述","#### （1）同源限制","#### （2）DOM 限制","#### （3）通信联系","#### （4）脚本限制","#### （5）文件限制","### 基本用法","#### 主线程","#### Worker 线程","#### Worker 加载脚本","#### Worker 错误处理","#### 关闭 Worker","### 数据通信","### 同页面的 Web Worker","### Worker 线程完成轮询","### Worker 新建 Worker","### API","#### 主线程","#### Worker 线程","## 二十、OffscreenCanvas 离屏Canvas — 使用Web Worker提高你的Canvas运行速度","### 兼容性","### 在Worker中使用OffscreenCanvas","### 不要阻塞主线程","### WebRTC的YUV媒体流数据的离屏渲染","### 总结","## 二十一、Vue与React Virtual DOM对比","### 相同点","### 不同点","#### dom的更新策略不同","### 建议","## 二十二、Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？"]},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"54"},"buildId":"LqJKClp1oY6FcMMGt_JyX","assetPrefix":"/toolbox-frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>