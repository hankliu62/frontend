<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端小工具</title><link rel="icon" href="/frontend/favicon.ico"/><meta name="description" content="卡鲁秋的前端工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋,Hank,HankLiu"/><meta name="author" content="Hank.Liu"/><meta name="next-head-count" content="7"/><link rel="stylesheet" href="/frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/frontend/_next/static/css/48e12760546808a2.css" as="style"/><link rel="stylesheet" href="/frontend/_next/static/css/48e12760546808a2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/frontend/_next/static/chunks/webpack-eb44c437bf7e459b.js" defer=""></script><script src="/frontend/_next/static/chunks/framework-0e8d27528ba61906.js" defer=""></script><script src="/frontend/_next/static/chunks/main-d236bc00457e5dc2.js" defer=""></script><script src="/frontend/_next/static/chunks/pages/_app-bc774d0c387ddf39.js" defer=""></script><script src="/frontend/_next/static/chunks/4853-4e02ebf21637e379.js" defer=""></script><script src="/frontend/_next/static/chunks/3239-4699acf95684b42e.js" defer=""></script><script src="/frontend/_next/static/chunks/1664-e769dc1505626ddd.js" defer=""></script><script src="/frontend/_next/static/chunks/pages/articles/%5Bid%5D-15cbf11aeca29499.js" defer=""></script><script src="/frontend/_next/static/_KMMPskFwjkQ1wkakKC3o/_buildManifest.js" defer=""></script><script src="/frontend/_next/static/_KMMPskFwjkQ1wkakKC3o/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1 overflow-x-hidden"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-1okl62o"><div class="ant-card-body"><article><div class="mx-auto mb-[36px] max-w-[1045px] px-[30px] lg:mb-[52px] lg:flex lg:px-0"><div id="banner" class="media-wrapper image-media-wrapper w-full overflow-hidden rounded-[8px] border-[1px] border-solid border-[#1D2129] lg:ml-0 lg:h-[320px] lg:w-[500px]"><div class="hidden before"></div><div class="hidden after"></div><div class="scale-103 h-full w-full border-[8px] border-solid border-white lg:scale-100 cover-wrapper"><img class="h-full w-full rounded-md object-cover cover" src="/frontend/dashboard/images/banner.png" alt=""/></div></div><div class="mt-[60px] overflow-hidden lg:ml-[32px] lg:mt-0 lg:flex-1"><h1 class="leading-130 montserrat-bold mb-[9px] text-[36px] font-medium text-[#1D2129] lg:mb-[8px]">Web安全之 XSS 攻击</h1><div class="mb-[9px] flex whitespace-nowrap lg:mb-[10px]"><div class="leading-120 cursor-pointer truncate text-[24px] font-normal text-[#1D2129] underline-offset-2 hover:underline lg:text-[20px]" aria-hidden="true"># VOL.<!-- -->630</div><div class="leading-120 ml-[48px] text-[24px] font-normal text-[#1D2129] lg:ml-[32px] lg:text-[20px]">2024/04/01</div></div><div class="mb-[12px] flex flex-wrap lg:mb-0"><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">blog</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">network</div></div><div class="my-[30px] hidden w-[213px] border border-[#1D2129] lg:mb-[20px] lg:mt-[8px] lg:block"></div><div class="lg:rounded-0 rounded-[12px] bg-white/30 p-[36px] lg:flex lg:bg-transparent lg:p-0"><div class="float-left h-[118px] w-[118px] lg:float-none lg:h-[112px] lg:w-[112px]"><img src="https://avatars.githubusercontent.com/u/8088864?v=4" class="h-full w-full rounded-[8px] object-cover lg:rounded-[12px]" alt=""/></div><div class="lg:ml-[32px] lg:flex-1 lg:overflow-hidden"><div class="mb-[10px] flex h-[118px] flex-col justify-center pl-[36px] lg:h-auto lg:flex-row lg:items-center lg:justify-between lg:pl-0"><div class="leading-130 montserrat-bold mb-[12px] w-full truncate text-[30px] font-medium text-[#1D2129] lg:mb-0 lg:flex-1 lg:text-[24px]">hankliu62</div><a class="leading-170 ml-0 whitespace-pre-wrap text-[20px] font-normal !text-[#1D2129] !underline hover:!text-[#1D2129] hover:!underline focus:!text-[#1D2129] lg:ml-[5px] lg:text-[14px]" href="https://github.com/hankliu62" target="_blank" rel="noreferrer">TA的个人名片</a></div><div class="leading-170 text-[20px] font-normal text-[#4E5969] lg:text-[14px]">HankLiu前端开发工程师，精通前端，涉猎后端，对前端有着浓厚的兴趣，希望能够在前端这条路上一直走下去。努力去听风的声音，不必在意风的方向。</div></div></div></div></div><div class="ant-divider css-1okl62o ant-divider-horizontal !mt-0 !border-[#bfc3c7]" role="separator"></div><section><div><div class="ant-skeleton ant-skeleton-active css-1okl62o"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-1okl62o"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="## Web安全之 XSS 攻击

### 简介
**XSS，全称跨站脚本攻击（Cross-Site Scripting）**，是一种网络安全漏洞攻击，指攻击者在网页中嵌入恶意脚本，当其他用户浏览该网页时，恶意脚本就会在其浏览器上执行，从而达到攻击者窃取用户信息、破坏数据、篡改网页内容、在用户浏览器上执行非法任务等目的。

### 分类

`XSS`攻击分为三种类型：

- **反射型XSS（Reflected XSS）**：攻击者将恶意脚本嵌入到URL地址中，当其他用户访问这个URL时，恶意脚本就会在其浏览器中执行。这种攻击方式需要用户主动点击含有恶意脚本的链接才会触发。

- **存储型XSS（Stored XSS）**：攻击者将恶意脚本存储到被攻击的网站数据库中，当其他用户访问网站时，恶意脚本会从数据库中取出并在用户浏览器中执行。这种攻击方式不需要用户主动点击链接，只要用户浏览被攻击的网站就可能被攻击。

- **DOM型XSS（DOM-based XSS）**：攻击者通过修改页面的DOM结构，注入恶意脚本，当其他用户浏览该页面时，恶意脚本会在用户浏览器中执行。这种攻击方式也不需要用户主动点击链接，只需要用户浏览被修改的页面就可能被攻击。

### 案例

#### 反射型XSS

在`Node.js`中，一个反射型`XSS`攻击的案例可能涉及一个web应用，该应用没有正确地处理或转义用户输入的数据，并将其直接插入到HTML响应中。攻击者可以构造一个包含恶意脚本的URL，当其他用户访问这个URL时，恶意脚本会在用户的浏览器中执行。

以下是一个简单的`Node.js`反射型`XSS`攻击的案例：

``` javascript
const express = require(&#x27;express&#x27;);
const app = express();
app.use(express.static(&#x27;public&#x27;));

app.get(&#x27;/profile&#x27;, (req, res) =&gt; {
  // 假设用户可以通过URL参数传递他们的名字
  const username = req.query.username;

  // 没有对用户输入进行任何处理或转义
  const html = `&lt;html&gt;
                &lt;body&gt;
                  &lt;h1&gt;Welcome, ${username}!&lt;/h1&gt;
                &lt;/body&gt;
              &lt;/html&gt;`;

  res.send(html);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server is running on port ${PORT}`);
});
```

在这个例子中，我们创建了一个简单的`Express`应用，其中有一个`/profile`路由，该路由从URL的查询参数中获取用户名（`username`）。然后，我们将这个用户名嵌入到一个`HTML`字符串中，并将其作为响应发送回客户端。

攻击者可以构造一个包含恶意脚本的URL，如：

```
http://example.com/profile?username=&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;
```

当用户访问这个`URL`时，浏览器会接收到包含恶意脚本的`HTML`响应，并执行该脚本，从而触发`XSS`攻击。

为了防止反射型`XSS`攻击，开发者应该对用户输入进行适当的过滤和转义。在这个案例中，可以使用如`escape-html`这样的库来转义`HTML`特殊字符：

``` javascript
const escapeHtml = require(&#x27;escape-html&#x27;);

app.get(&#x27;/profile&#x27;, (req, res) =&gt; {
  const username = req.query.username;

  // 转义用户输入中的HTML特殊字符
  const escapedUsername = escapeHtml(username);

  const html = `&lt;html&gt;
                &lt;body&gt;
                  &lt;h1&gt;Welcome, ${escapedUsername}!&lt;/h1&gt;
                &lt;/body&gt;
              &lt;/html&gt;`;

  res.send(html);
});
```

通过转义用户输入，恶意脚本将不会被浏览器执行，从而防止了`XSS`攻击。此外，开发者还应该使用内容安全策略（`CSP`）等额外安全措施来增强应用的安全性。

&lt;!-- more --&gt;

#### 存储型XSS
在`存储型XSS（Persistent XSS）`攻击中，恶意脚本被用户提交并存储到服务器端的数据库中。当其他用户访问包含这些恶意脚本的页面时，脚本会在用户的浏览器上执行。下面是一个简单的`Node.js`存储型XSS案例，我们将使用`Express`框架和`MongoDB`数据库。

首先，确保你已经安装了以下依赖：

``` bash
npm install express body-parser mongoose
```

然后，你可以创建一个简单的`Express`应用，并设置一个`MongoDB`数据库来存储评论。

```javascript
const express = require(&#x27;express&#x27;);
const bodyParser = require(&#x27;body-parser&#x27;);
const mongoose = require(&#x27;mongoose&#x27;);

const app = express();

// 连接到MongoDB数据库
mongoose.connect(&#x27;mongodb://localhost/xss-example&#x27;, { useNewUrlParser: true, useUnifiedTopology: true });

// 定义评论模型
const Comment = mongoose.model(&#x27;Comment&#x27;, new mongoose.Schema({
  content: String
}));

// 使用body-parser中间件来解析请求体
app.use(bodyParser.urlencoded({ extended: true }));

// 路由：添加评论
app.post(&#x27;/comment&#x27;, async (req, res) =&gt; {
  try {
    // 创建新的评论并保存到数据库
    const newComment = new Comment({ content: req.body.content });
    await newComment.save();
    res.send(&#x27;Comment added successfully!&#x27;);
  } catch (error) {
    console.error(error);
    res.status(500).send(&#x27;An error occurred while saving the comment.&#x27;);
  }
});

// 路由：显示所有评论
app.get(&#x27;/comments&#x27;, async (req, res) =&gt; {
  try {
    // 从数据库中获取所有评论
    const comments = await Comment.find({});

    // 渲染评论列表的HTML
    const html = renderComments(comments);
    res.send(html);
  } catch (error) {
    console.error(error);
    res.status(500).send(&#x27;An error occurred while fetching the comments.&#x27;);
  }
});

// 渲染评论列表的HTML
function renderComments(comments) {
  let html = &#x27;&lt;html&gt;&lt;body&gt;&#x27;;
  comments.forEach(comment =&gt; {
    // 这里没有对评论内容进行转义，这会导致存储型XSS漏洞
    html += `&lt;div&gt;${comment.content}&lt;/div&gt;`;
  });
  html += &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;;
  return html;
}

// 启动服务器
const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server is running on port ${PORT}`);
});
```
在这个案例中，我们定义了一个`Comment`模型，用于在`MongoDB`数据库中存储评论。`/comment`路由接受`POST`请求，将用户提交的评论保存到数据库中。`/comments`路由则负责从数据库中检索所有评论，并将它们渲染为HTML页面。

重要提示：在这个案例的`renderComments`函数中，我们没有对评论内容进行任何形式的转义或过滤。这意味着如果用户在评论中输入了恶意脚本，它将被直接插入到`HTML`页面中，并在其他用户查看该页面时执行。这就是`存储型XSS`攻击的核心。

为了防止`存储型XSS`攻击，你应该对所有的用户输入进行适当的转义或过滤。在`Express`应用中，你可以使用如`express-sanitized`和`helmet`这样的中间件来设置一些基本的`HTTP`头，以增加安全性。另外，使用模板引擎（如`ejs`、`pug`等）也可以帮助你更安全地渲染用户输入的数据，因为这些模板引擎通常会自动转义特殊字符。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。

#### DOM型XSS
在`React`应用程序中，`DOM型XSS`（跨站脚本）攻击通常发生在直接将用户输入嵌入到`JSX`中而没有进行适当的转义或过滤时。`React`本身不会自动转义用户输入，因此开发者需要确保在渲染用户输入之前进行适当的处理。下面是一个简单的`React`应用案例，展示了如果不正确地处理用户输入，可能会导致的`DOM型XSS`攻击：

首先，创建一个简单的`React`组件，它将接收一个名为`username`的属性，并将其直接渲染到页面上：

```jsx
import React from &#x27;react&#x27;;

function UserProfile({ username }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {username}!&lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default UserProfile;
```

然后，在父组件中使用这个`UserProfile`组件，并假设从某个地方（例如URL参数、数据库或用户输入）获取`username`：

``` jsx
import React from &#x27;react&#x27;;
import UserProfile from &#x27;./UserProfile&#x27;;

function App() {
  // 假设这是从某个不安全的来源获取的用户名
  const username = &quot;Alice &lt;img src=&#x27;https://example.com/x.png&#x27; onerror=&#x27;alert(\&quot;XSS\&quot;)&#x27; /&gt;&quot;;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;UserProfile username={username} /&gt;
    &lt;/div&gt;
  );
}

export default App;
```

在这个案例中，如果`username`包含了恶意的`HTML`和`JavaScript`代码，那么这段代码将会被执行，导致`XSS`攻击。

为了防止这种攻击，你应该在渲染用户输入之前使用某种方法对其进行转义，以确保它不会被浏览器解析为`HTML`或`JavaScript`代码。在`React`中，你可以使用内置的`dangerouslySetInnerHTML`属性配合适当的转义函数来安全地渲染`HTML`内容。然而，这通常不是推荐的做法，因为它可能会引入其他安全风险。

更好的做法是使用库如`react-dom-purify`来清理用户输入中的潜在恶意代码。下面是如何使用`react-dom-purify`来防止`XSS`攻击的例子：

首先，安装`react-dom-purify`：

``` bash
npm install react-dom-purify
```

然后，在你的`React`组件中使用它：

``` jsx
import React from &#x27;react&#x27;;
import DOMPurify from &#x27;react-dom-purify&#x27;;

function UserProfile({ username }) {
  // 使用DOMPurify来清理用户输入中的潜在恶意代码
  const safeUsername = DOMPurify.sanitize(username);

  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {safeUsername}!&lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default UserProfile;
```

在这个修改后的例子中，即使`username`包含了恶意的`HTML`和`JavaScript`代码，`DOMPurify.sanitize`函数也会将其清理掉，确保它们不会被浏览器执行。

总之，为了防止`DOM型XSS`攻击，你应该始终确保在将用户输入渲染到React组件之前对其进行适当的转义或清理。

#### ejs 模板引擎

例如，如果你使用`ejs`作为模板引擎，你可以这样渲染评论：

```ejs
&lt;body&gt;
  &lt;% comments.forEach(function(comment) { %&gt;
    &lt;div&gt;&lt;%= comment.content %&gt;&lt;/div&gt;
  &lt;% }); %&gt;
&lt;/body&gt;
```

在这个例子中，`&lt;%= comment.content %&gt;`会自动转义`comment.content`中的特殊字符，从而防止`XSS`攻击。

为了防止反射型和`存储型XSS`攻击，开发者应该对用户输入的数据进行适当的验证、过滤和转义。在`Node.js`中，可以使用诸如`express-sanitized`和`helmet`等中间件来增强应用的安全性。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。

#### express-sanitized 中间件
`express-sanitized` 是一个 `Express.js` 的中间件，用于帮助防止跨站脚本（`XSS`）攻击。它通过提供一组函数来清理和转义用户输入的数据，从而减少潜在的安全风险。然而，需要注意的是，`express-sanitized` 本身并不提供全面的 `XSS` 保护。它应当与其他安全措施（如内容安全策略（`CSP`）、`HTTP` 头设置等）一起使用。

下面是一个简单的 `Node.js` 案例，演示了如何使用 `express-sanitized` 中间件来防止反射型 `XSS` 攻击：

首先，你需要安装 `express` 和 `express-sanitized`：

```bash
npm install express express-sanitized
```
然后，你可以创建一个简单的 Express 应用，并使用 express-sanitized 来清理用户输入的数据：

``` javascript
const express = require(&#x27;express&#x27;);
const sanitized = require(&#x27;express-sanitized&#x27;);
const app = express();

// 使用 express-sanitized 中间件
app.use(sanitized());

// 一个简单的 GET 路由，接收用户输入并反射回去
app.get(&#x27;/reflect&#x27;, (req, res) =&gt; {
  // 假设我们从 URL 参数中获取用户输入
  const userInput = req.query.message;

  // 使用 express-sanitized 的 sanitize 函数来清理用户输入
  const cleanedInput = sanitized.sanitize(userInput);

  // 将清理后的用户输入嵌入到 HTML 中
  const html = `
    &lt;html&gt;
      &lt;body&gt;
        &lt;h1&gt;Welcome, ${cleanedInput}!&lt;/h1&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  `;

  res.send(html);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server is running on port ${PORT}`);
});
```

在这个例子中，我们定义了一个 `/reflect` 路由，该路由从 `URL` 参数 `message` 中获取用户输入。然后，我们使用 `express-sanitized` 的 sanit`ize 函数来清理用户输入，该函数会移除或转义潜在的恶意脚本标签。最后，我们将清理后的用户输入嵌入到 `HTML` 响应中。

然而，需要注意的是，仅仅依赖 `express-sanitized` 是不够的。你应该始终遵循最佳实践，如使用模板引擎（如 `Pug`、`EJS` 等）来自动处理 `HTML` 转义，设置适当的 `HTTP` 头（如 `X-XSS-Protection` 和 `Content-Security-Policy`），并且对用户输入进行严格的验证和过滤。

另外，`express-sanitized` 可能不是最新的或最广泛使用的 `XSS` 防护中间件。对于更全面的 `XSS` 防护，你可以考虑使用 `helmet` 中间件，它提供了多种增强 `Express` 应用安全性的功能，包括 `XSS` 防护。

#### helmet 中间件

`helmet` 是一个 `Express.js` 的中间件，用于设置各种 `HTTP` 头来帮助预防一些已知的 `web` 漏洞，包括跨站脚本攻击（XSS）和数据泄露等。尽管 `helmet` 本身并不能完全防止 `XSS` 攻击，但它可以通过设置某些 `HTTP` 头来减少攻击面。

下面是一个使用 `helmet` 中间件来增强 `Express.js` 应用安全性的简单案例：

首先，你需要安装 `express` 和 `helmet`：

``` bash
npm install express helmet
```

然后，创建一个 `Express` 应用并引入 `helmet` 中间件：

``` javascript
const express = require(&#x27;express&#x27;);
const helmet = require(&#x27;helmet&#x27;);

const app = express();

// 使用 helmet 中间件
app.use(helmet());

// 一个简单的 GET 路由
app.get(&#x27;/&#x27;, (req, res) =&gt; {
  res.send(&#x27;Hello, World!&#x27;);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server is running on port ${PORT}`);
});
```

在上面的代码中，`helmet()` 函数是一个方便的快捷方式，用于启用多个安全头。这些头包括：

- `content-security-policy`：帮助检测和缓解某些类型的攻击，包括跨站脚本和数据注入攻击。
- `x-dns-prefetch-control`：控制浏览器是否应该执行 `DNS` 预取。
- `x-frame-options`：指示浏览器是否应该允许页面被嵌入到 `&lt;iframe&gt;`、`&lt;frame&gt;`、`&lt;embed&gt;` 或 `&lt;object&gt;` 元素中。
- `x-content-type-options`：防止浏览器猜测响应的 `MIME` 类型。
- `x-xss-protection`：启用浏览器的反射型 `XSS` 保护。
- `x-permitted-cross-domain-policies`：限制 `Adobe Flash Player` 的跨域策略文件的使用。
- `referrer-policy`：控制浏览器在发送 `HTTP` 引用头时如何生成和发送引用信息。

请注意，尽管 `helmet` 提供了这些保护措施，但它们并不是万无一失的。特别是 `content-security-policy` 头，它允许你明确指定哪些内容是安全的，是防止 `XSS` 攻击的重要工具。你需要根据你的应用程序的具体需求来配置它。

此外，你还需要确保应用程序的其他部分（如模板引擎、用户输入验证等）也采取了适当的安全措施。`helmet` 只能作为安全策略的一部分，而不能单独依赖它来完全防止 `XSS` 攻击。

### 预防措施

为了防范`XSS`攻击，可以采取以下措施：

1. 对用户输入的数据进行过滤和转义，防止恶意脚本的注入。
2. 使用`HTTPOnly`属性设置Cookie，防止攻击者通过`XSS`攻击窃取用户信息。
3. 使用 `CSP` 内容安全策略（`Content-Security-Policy`）限制网站中能够执行的脚本，防止恶意脚本的执行。
4. 使用最新的Web安全技术和框架，如`React`、`Vue`等，它们提供了内置的`XSS`防护措施。
5. 定期对网站进行安全漏洞扫描和测试，及时发现和修复`XSS`漏洞。" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/frontend/articles/630#web%E5%AE%89%E5%85%A8%E4%B9%8B-xss-%E6%94%BB%E5%87%BB--###-%E7%AE%80%E4%BB%8B-**xss%E5%85%A8%E7%A7%B0%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBcross-site-scripting**%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E6%8C%87%E6%94%BB%E5%87%BB%E8%80%85%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%B5%8C%E5%85%A5%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%BD%93%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E8%AF%A5%E7%BD%91%E9%A1%B5%E6%97%B6%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%B0%B1%E4%BC%9A%E5%9C%A8%E5%85%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E6%89%A7%E8%A1%8C%E4%BB%8E%E8%80%8C%E8%BE%BE%E5%88%B0%E6%94%BB%E5%87%BB%E8%80%85%E7%AA%83%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%A0%B4%E5%9D%8F%E6%95%B0%E6%8D%AE%E7%AF%A1%E6%94%B9%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E5%9C%A8%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E6%89%A7%E8%A1%8C%E9%9D%9E%E6%B3%95%E4%BB%BB%E5%8A%A1%E7%AD%89%E7%9B%AE%E7%9A%84--###-%E5%88%86%E7%B1%BB--%60xss%60%E6%94%BB%E5%87%BB%E5%88%86%E4%B8%BA%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B----**%E5%8F%8D%E5%B0%84%E5%9E%8Bxssreflected-xss**%E6%94%BB%E5%87%BB%E8%80%85%E5%B0%86%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%B5%8C%E5%85%A5%E5%88%B0url%E5%9C%B0%E5%9D%80%E4%B8%AD%E5%BD%93%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AAurl%E6%97%B6%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%B0%B1%E4%BC%9A%E5%9C%A8%E5%85%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E9%9C%80%E8%A6%81%E7%94%A8%E6%88%B7%E4%B8%BB%E5%8A%A8%E7%82%B9%E5%87%BB%E5%90%AB%E6%9C%89%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9A%84%E9%93%BE%E6%8E%A5%E6%89%8D%E4%BC%9A%E8%A7%A6%E5%8F%91----**%E5%AD%98%E5%82%A8%E5%9E%8Bxssstored-xss**%E6%94%BB%E5%87%BB%E8%80%85%E5%B0%86%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%AD%98%E5%82%A8%E5%88%B0%E8%A2%AB%E6%94%BB%E5%87%BB%E7%9A%84%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%BD%93%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E6%97%B6%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E4%BC%9A%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%8F%96%E5%87%BA%E5%B9%B6%E5%9C%A8%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E4%B8%8D%E9%9C%80%E8%A6%81%E7%94%A8%E6%88%B7%E4%B8%BB%E5%8A%A8%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5%E5%8F%AA%E8%A6%81%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E8%A2%AB%E6%94%BB%E5%87%BB%E7%9A%84%E7%BD%91%E7%AB%99%E5%B0%B1%E5%8F%AF%E8%83%BD%E8%A2%AB%E6%94%BB%E5%87%BB----**dom%E5%9E%8Bxssdom-based-xss**%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E9%A1%B5%E9%9D%A2%E7%9A%84dom%E7%BB%93%E6%9E%84%E6%B3%A8%E5%85%A5%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%BD%93%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E8%AF%A5%E9%A1%B5%E9%9D%A2%E6%97%B6%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E4%BC%9A%E5%9C%A8%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E4%B9%9F%E4%B8%8D%E9%9C%80%E8%A6%81%E7%94%A8%E6%88%B7%E4%B8%BB%E5%8A%A8%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5%E5%8F%AA%E9%9C%80%E8%A6%81%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E8%A2%AB%E4%BF%AE%E6%94%B9%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%B0%B1%E5%8F%AF%E8%83%BD%E8%A2%AB%E6%94%BB%E5%87%BB--###-%E6%A1%88%E4%BE%8B--####-%E5%8F%8D%E5%B0%84%E5%9E%8Bxss--%E5%9C%A8%60node.js%60%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%8F%8D%E5%B0%84%E5%9E%8B%60xss%60%E6%94%BB%E5%87%BB%E7%9A%84%E6%A1%88%E4%BE%8B%E5%8F%AF%E8%83%BD%E6%B6%89%E5%8F%8A%E4%B8%80%E4%B8%AAweb%E5%BA%94%E7%94%A8%E8%AF%A5%E5%BA%94%E7%94%A8%E6%B2%A1%E6%9C%89%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%A4%84%E7%90%86%E6%88%96%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%B0%86%E5%85%B6%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E5%88%B0html%E5%93%8D%E5%BA%94%E4%B8%AD%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9A%84url%E5%BD%93%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AAurl%E6%97%B6%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E4%BC%9A%E5%9C%A8%E7%94%A8%E6%88%B7%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C--%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%60node.js%60%E5%8F%8D%E5%B0%84%E5%9E%8B%60xss%60%E6%94%BB%E5%87%BB%E7%9A%84%E6%A1%88%E4%BE%8B--%60%60%60-javascript-const-express-=-require(&#x27;express&#x27;);-const-app-=-express();-app.use(express.static(&#x27;public&#x27;));--app.get(&#x27;/profile&#x27;,-(req,-res)-=%3E-{---/-%E5%81%87%E8%AE%BE%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87url%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%BB%96%E4%BB%AC%E7%9A%84%E5%90%8D%E5%AD%97---const-username-=-req.query.username;----/-%E6%B2%A1%E6%9C%89%E5%AF%B9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E4%BB%BB%E4%BD%95%E5%A4%84%E7%90%86%E6%88%96%E8%BD%AC%E4%B9%89---const-html-=-%60%3Chtml%3E-----------------%3Cbody%3E-------------------%3Ch1%3Ewelcome,-${username}!%3C/h1%3E-----------------%3C/body%3E---------------%3C/html%3E%60;----res.send(html);-});--const-port-=-process.env.port-||-3000;-app.listen(port,-()-=%3E-{---console.log(%60server-is-running-on-port-${port}%60);-});-%60%60%60--%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%B8%AD%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%60express%60%E5%BA%94%E7%94%A8%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%60/profile%60%E8%B7%AF%E7%94%B1%E8%AF%A5%E8%B7%AF%E7%94%B1%E4%BB%8Eurl%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%90%8D%60username%60%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E5%B0%86%E8%BF%99%E4%B8%AA%E7%94%A8%E6%88%B7%E5%90%8D%E5%B5%8C%E5%85%A5%E5%88%B0%E4%B8%80%E4%B8%AA%60html%60%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BD%9C%E4%B8%BA%E5%93%8D%E5%BA%94%E5%8F%91%E9%80%81%E5%9B%9E%E5%AE%A2%E6%88%B7%E7%AB%AF--%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9A%84url%E5%A6%82--%60%60%60-http:/example.com/profile?username=%3Cscript%3Ealert(&#x27;xss&#x27;);%3C/script%3E-%60%60%60--%E5%BD%93%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%60url%60%E6%97%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E6%8E%A5%E6%94%B6%E5%88%B0%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9A%84%60html%60%E5%93%8D%E5%BA%94%E5%B9%B6%E6%89%A7%E8%A1%8C%E8%AF%A5%E8%84%9A%E6%9C%AC%E4%BB%8E%E8%80%8C%E8%A7%A6%E5%8F%91%60xss%60%E6%94%BB%E5%87%BB--%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%9E%8B%60xss%60%E6%94%BB%E5%87%BB%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E5%AF%B9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E8%BF%87%E6%BB%A4%E5%92%8C%E8%BD%AC%E4%B9%89%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%A1%88%E4%BE%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A6%82%60escape-html%60%E8%BF%99%E6%A0%B7%E7%9A%84%E5%BA%93%E6%9D%A5%E8%BD%AC%E4%B9%89%60html%60%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6--%60%60%60-javascript-const-escapehtml-=-require(&#x27;escape-html&#x27;);--app.get(&#x27;/profile&#x27;,-(req,-res)-=%3E-{---const-username-=-req.query.username;----//-%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%AD%E7%9A%84html%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6---const-escapedusername-=-escapehtml(username);----const-html-=-%60%3Chtml%3E-----------------%3Cbody%3E-------------------%3Ch1%3Ewelcome,-${escapedusername}!%3C/h1%3E-----------------%3C/body%3E---------------%3C/html%3E%60;----res.send(html);-});-%60%60%60--%E9%80%9A%E8%BF%87%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A7%E8%A1%8C%E4%BB%8E%E8%80%8C%E9%98%B2%E6%AD%A2%E4%BA%86%60xss%60%E6%94%BB%E5%87%BB%E6%AD%A4%E5%A4%96%E5%BC%80%E5%8F%91%E8%80%85%E8%BF%98%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%60csp%60%E7%AD%89%E9%A2%9D%E5%A4%96%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD%E6%9D%A5%E5%A2%9E%E5%BC%BA%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7--%3C!---more---%3E--####-%E5%AD%98%E5%82%A8%E5%9E%8Bxss-%E5%9C%A8%60%E5%AD%98%E5%82%A8%E5%9E%8Bxsspersistent-xss%60%E6%94%BB%E5%87%BB%E4%B8%AD%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E8%A2%AB%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E5%B9%B6%E5%AD%98%E5%82%A8%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%BD%93%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E5%8C%85%E5%90%AB%E8%BF%99%E4%BA%9B%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%97%B6%E8%84%9A%E6%9C%AC%E4%BC%9A%E5%9C%A8%E7%94%A8%E6%88%B7%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%60node.js%60%E5%AD%98%E5%82%A8%E5%9E%8Bxss%E6%A1%88%E4%BE%8B%E6%88%91%E4%BB%AC%E5%B0%86%E4%BD%BF%E7%94%A8%60express%60%E6%A1%86%E6%9E%B6%E5%92%8C%60mongodb%60%E6%95%B0%E6%8D%AE%E5%BA%93--%E9%A6%96%E5%85%88%E7%A1%AE%E4%BF%9D%E4%BD%A0%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E4%BA%86%E4%BB%A5%E4%B8%8B%E4%BE%9D%E8%B5%96--%60%60%60-bash-npm-install-express-body-parser-mongoose-%60%60%60--%E7%84%B6%E5%90%8E%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%60express%60%E5%BA%94%E7%94%A8%E5%B9%B6%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%60mongodb%60%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%A5%E5%AD%98%E5%82%A8%E8%AF%84%E8%AE%BA--%60%60%60javascript-const-express-=-require(&#x27;express&#x27;);-const-bodyparser-=-require(&#x27;body-parser&#x27;);-const-mongoose-=-require(&#x27;mongoose&#x27;);--const-app-=-express();--//-%E8%BF%9E%E6%8E%A5%E5%88%B0mongodb%E6%95%B0%E6%8D%AE%E5%BA%93-mongoose.connect(&#x27;mongodb://localhost/xss-example&#x27;,-{-usenewurlparser:-true,-useunifiedtopology:-true-});--//-%E5%AE%9A%E4%B9%89%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9E%8B-const-comment-=-mongoose.model(&#x27;comment&#x27;,-new-mongoose.schema({---content:-string-}));--//-%E4%BD%BF%E7%94%A8body-parser%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82%E4%BD%93-app.use(bodyparser.urlencoded({-extended:-true-}));--//-%E8%B7%AF%E7%94%B1%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA-app.post(&#x27;/comment&#x27;,-async-(req,-res)-=%3E-{---try-{-----//-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%AF%84%E8%AE%BA%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93-----const-newcomment-=-new-comment({-content:-req.body.content-});-----await-newcomment.save();-----res.send(&#x27;comment-added-successfully!&#x27;);---}-catch-(error)-{-----console.error(error);-----res.status(500).send(&#x27;an-error-occurred-while-saving-the-comment.&#x27;);---}-});--//-%E8%B7%AF%E7%94%B1%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA-app.get(&#x27;/comments&#x27;,-async-(req,-res)-=%3E-{---try-{-----//-%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA-----const-comments-=-await-comment.find({});------//-%E6%B8%B2%E6%9F%93%E8%AF%84%E8%AE%BA%E5%88%97%E8%A1%A8%E7%9A%84html-----const-html-=-rendercomments(comments);-----res.send(html);---}-catch-(error)-{-----console.error(error);-----res.status(500).send(&#x27;an-error-occurred-while-fetching-the-comments.&#x27;);---}-});--//-%E6%B8%B2%E6%9F%93%E8%AF%84%E8%AE%BA%E5%88%97%E8%A1%A8%E7%9A%84html-function-rendercomments(comments)-{---let-html-=-&#x27;%3Chtml%3E%3Cbody%3E&#x27;;---comments.foreach(comment-=%3E-{-----//-%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89%E5%AF%B9%E8%AF%84%E8%AE%BA%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89%E8%BF%99%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%AD%98%E5%82%A8%E5%9E%8Bxss%E6%BC%8F%E6%B4%9E-----html-+=-%60%3Cdiv%3E${comment.content}%3C/div%3E%60;---});---html-+=-&#x27;%3C/body%3E%3C/html%3E&#x27;;---return-html;-}--//-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8-const-port-=-process.env.port-||-3000;-app.listen(port,-()-=%3E-{---console.log(%60server-is-running-on-port-${port}%60);-});-%60%60%60-%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%A1%88%E4%BE%8B%E4%B8%AD%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%60comment%60%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E5%9C%A8%60mongodb%60%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E8%AF%84%E8%AE%BA%60/comment%60%E8%B7%AF%E7%94%B1%E6%8E%A5%E5%8F%97%60post%60%E8%AF%B7%E6%B1%82%E5%B0%86%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AF%84%E8%AE%BA%E4%BF%9D%E5%AD%98%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%60/comments%60%E8%B7%AF%E7%94%B1%E5%88%99%E8%B4%9F%E8%B4%A3%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%A3%80%E7%B4%A2%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA%E5%B9%B6%E5%B0%86%E5%AE%83%E4%BB%AC%E6%B8%B2%E6%9F%93%E4%B8%BAhtml%E9%A1%B5%E9%9D%A2--%E9%87%8D%E8%A6%81%E6%8F%90%E7%A4%BA%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%60rendercomments%60%E5%87%BD%E6%95%B0%E4%B8%AD%E6%88%91%E4%BB%AC%E6%B2%A1%E6%9C%89%E5%AF%B9%E8%AF%84%E8%AE%BA%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E4%BB%BB%E4%BD%95%E5%BD%A2%E5%BC%8F%E7%9A%84%E8%BD%AC%E4%B9%89%E6%88%96%E8%BF%87%E6%BB%A4%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E5%9C%A8%E8%AF%84%E8%AE%BA%E4%B8%AD%E8%BE%93%E5%85%A5%E4%BA%86%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%AE%83%E5%B0%86%E8%A2%AB%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E5%88%B0%60html%60%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%B9%B6%E5%9C%A8%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E6%9F%A5%E7%9C%8B%E8%AF%A5%E9%A1%B5%E9%9D%A2%E6%97%B6%E6%89%A7%E8%A1%8C%E8%BF%99%E5%B0%B1%E6%98%AF%60%E5%AD%98%E5%82%A8%E5%9E%8Bxss%60%E6%94%BB%E5%87%BB%E7%9A%84%E6%A0%B8%E5%BF%83--%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%60%E5%AD%98%E5%82%A8%E5%9E%8Bxss%60%E6%94%BB%E5%87%BB%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%AF%B9%E6%89%80%E6%9C%89%E7%9A%84%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E8%BD%AC%E4%B9%89%E6%88%96%E8%BF%87%E6%BB%A4%E5%9C%A8%60express%60%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A6%82%60express-sanitized%60%E5%92%8C%60helmet%60%E8%BF%99%E6%A0%B7%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9A%84%60http%60%E5%A4%B4%E4%BB%A5%E5%A2%9E%E5%8A%A0%E5%AE%89%E5%85%A8%E6%80%A7%E5%8F%A6%E5%A4%96%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%A6%82%60ejs%60%60pug%60%E7%AD%89%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E4%BD%A0%E6%9B%B4%E5%AE%89%E5%85%A8%E5%9C%B0%E6%B8%B2%E6%9F%93%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9B%A0%E4%B8%BA%E8%BF%99%E4%BA%9B%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E9%80%9A%E5%B8%B8%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%AD%A4%E5%A4%96%E5%AF%B9%E4%BA%8E%60%E5%AD%98%E5%82%A8%E5%9E%8Bxss%60%E8%BF%98%E9%9C%80%E8%A6%81%E7%A1%AE%E4%BF%9D%E5%9C%A8%E5%B0%86%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E5%88%B0%60html%60%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E8%BD%AC%E4%B9%89%E5%A4%84%E7%90%86--####-dom%E5%9E%8Bxss-%E5%9C%A8%60react%60%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%60dom%E5%9E%8Bxss%60%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E9%80%9A%E5%B8%B8%E5%8F%91%E7%94%9F%E5%9C%A8%E7%9B%B4%E6%8E%A5%E5%B0%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%B5%8C%E5%85%A5%E5%88%B0%60jsx%60%E4%B8%AD%E8%80%8C%E6%B2%A1%E6%9C%89%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E8%BD%AC%E4%B9%89%E6%88%96%E8%BF%87%E6%BB%A4%E6%97%B6%60react%60%E6%9C%AC%E8%BA%AB%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%9B%A0%E6%AD%A4%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E7%A1%AE%E4%BF%9D%E5%9C%A8%E6%B8%B2%E6%9F%93%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%60react%60%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%E5%B1%95%E7%A4%BA%E4%BA%86%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%60dom%E5%9E%8Bxss%60%E6%94%BB%E5%87%BB--%E9%A6%96%E5%85%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%60react%60%E7%BB%84%E4%BB%B6%E5%AE%83%E5%B0%86%E6%8E%A5%E6%94%B6%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA%60username%60%E7%9A%84%E5%B1%9E%E6%80%A7%E5%B9%B6%E5%B0%86%E5%85%B6%E7%9B%B4%E6%8E%A5%E6%B8%B2%E6%9F%93%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%B8%8A--%60%60%60jsx-import-react-from-&#x27;react&#x27;;--function-userprofile({-username-})-{---return-(-----%3Cdiv%3E-------%3Ch1%3Ewelcome,-{username}!%3C/h1%3E-----%3C/div%3E---);-}--export-default-userprofile;-%60%60%60--%E7%84%B6%E5%90%8E%E5%9C%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%60userprofile%60%E7%BB%84%E4%BB%B6%E5%B9%B6%E5%81%87%E8%AE%BE%E4%BB%8E%E6%9F%90%E4%B8%AA%E5%9C%B0%E6%96%B9%E4%BE%8B%E5%A6%82url%E5%8F%82%E6%95%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%88%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%8E%B7%E5%8F%96%60username%60--%60%60%60-jsx-import-react-from-&#x27;react&#x27;;-import-userprofile-from-&#x27;./userprofile&#x27;;--function-app()-{---//-%E5%81%87%E8%AE%BE%E8%BF%99%E6%98%AF%E4%BB%8E%E6%9F%90%E4%B8%AA%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%9D%A5%E6%BA%90%E8%8E%B7%E5%8F%96%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D---const-username-=-%22alice-%3Cimg-src=&#x27;https://example.com/x.png&#x27;-onerror=&#x27;alert(\%22xss\%22)&#x27;-/%3E%22;----return-(-----%3Cdiv-classname=%22app%22%3E-------%3Cuserprofile-username={username}-/%3E-----%3C/div%3E---);-}--export-default-app;-%60%60%60--%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%A1%88%E4%BE%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%60username%60%E5%8C%85%E5%90%AB%E4%BA%86%E6%81%B6%E6%84%8F%E7%9A%84%60html%60%E5%92%8C%60javascript%60%E4%BB%A3%E7%A0%81%E9%82%A3%E4%B9%88%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%B0%86%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%E5%AF%BC%E8%87%B4%60xss%60%E6%94%BB%E5%87%BB--%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%9C%A8%E6%B8%B2%E6%9F%93%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B9%8B%E5%89%8D%E4%BD%BF%E7%94%A8%E6%9F%90%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E8%BD%AC%E4%B9%89%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%AE%83%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E4%B8%BA%60html%60%E6%88%96%60javascript%60%E4%BB%A3%E7%A0%81%E5%9C%A8%60react%60%E4%B8%AD%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E7%9A%84%60dangerouslysetinnerhtml%60%E5%B1%9E%E6%80%A7%E9%85%8D%E5%90%88%E9%80%82%E5%BD%93%E7%9A%84%E8%BD%AC%E4%B9%89%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AE%89%E5%85%A8%E5%9C%B0%E6%B8%B2%E6%9F%93%60html%60%E5%86%85%E5%AE%B9%E7%84%B6%E8%80%8C%E8%BF%99%E9%80%9A%E5%B8%B8%E4%B8%8D%E6%98%AF%E6%8E%A8%E8%8D%90%E7%9A%84%E5%81%9A%E6%B3%95%E5%9B%A0%E4%B8%BA%E5%AE%83%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9--%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%81%9A%E6%B3%95%E6%98%AF%E4%BD%BF%E7%94%A8%E5%BA%93%E5%A6%82%60react-dom-purify%60%E6%9D%A5%E6%B8%85%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%AD%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E4%B8%8B%E9%9D%A2%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%60react-dom-purify%60%E6%9D%A5%E9%98%B2%E6%AD%A2%60xss%60%E6%94%BB%E5%87%BB%E7%9A%84%E4%BE%8B%E5%AD%90--%E9%A6%96%E5%85%88%E5%AE%89%E8%A3%85%60react-dom-purify%60--%60%60%60-bash-npm-install-react-dom-purify-%60%60%60--%E7%84%B6%E5%90%8E%E5%9C%A8%E4%BD%A0%E7%9A%84%60react%60%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%83--%60%60%60-jsx-import-react-from-&#x27;react&#x27;;-import-dompurify-from-&#x27;react-dom-purify&#x27;;--function-userprofile({-username-})-{---//-%E4%BD%BF%E7%94%A8dompurify%E6%9D%A5%E6%B8%85%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%AD%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81---const-safeusername-=-dompurify.sanitize(username);----return-(-----%3Cdiv%3E-------%3Ch1%3Ewelcome,-{safeusername}!%3C/h1%3E-----%3C/div%3E---);-}--export-default-userprofile;-%60%60%60--%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E4%BE%8B%E5%AD%90%E4%B8%AD%E5%8D%B3%E4%BD%BF%60username%60%E5%8C%85%E5%90%AB%E4%BA%86%E6%81%B6%E6%84%8F%E7%9A%84%60html%60%E5%92%8C%60javascript%60%E4%BB%A3%E7%A0%81%60dompurify.sanitize%60%E5%87%BD%E6%95%B0%E4%B9%9F%E4%BC%9A%E5%B0%86%E5%85%B6%E6%B8%85%E7%90%86%E6%8E%89%E7%A1%AE%E4%BF%9D%E5%AE%83%E4%BB%AC%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A7%E8%A1%8C--%E6%80%BB%E4%B9%8B%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%60dom%E5%9E%8Bxss%60%E6%94%BB%E5%87%BB%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%A7%8B%E7%BB%88%E7%A1%AE%E4%BF%9D%E5%9C%A8%E5%B0%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E6%B8%B2%E6%9F%93%E5%88%B0react%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%89%8D%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E8%BD%AC%E4%B9%89%E6%88%96%E6%B8%85%E7%90%86--####-ejs-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E--%E4%BE%8B%E5%A6%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%BD%BF%E7%94%A8%60ejs%60%E4%BD%9C%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E6%B8%B2%E6%9F%93%E8%AF%84%E8%AE%BA--%60%60%60ejs-%3Cbody%3E---%3C%-comments.foreach(function(comment)-{-%%3E-----%3Cdiv%3E%3C%=-comment.content-%%3E%3C/div%3E---%3C%-});-%%3E-%3C/body%3E-%60%60%60--%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%B8%AD%60%3C%=-comment.content-%%3E%60%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B9%89%60comment.content%60%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E4%BB%8E%E8%80%8C%E9%98%B2%E6%AD%A2%60xss%60%E6%94%BB%E5%87%BB--%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%9E%8B%E5%92%8C%60%E5%AD%98%E5%82%A8%E5%9E%8Bxss%60%E6%94%BB%E5%87%BB%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E5%AF%B9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E9%AA%8C%E8%AF%81%E8%BF%87%E6%BB%A4%E5%92%8C%E8%BD%AC%E4%B9%89%E5%9C%A8%60node.js%60%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%AF%B8%E5%A6%82%60express-sanitized%60%E5%92%8C%60helmet%60%E7%AD%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E5%A2%9E%E5%BC%BA%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%AD%A4%E5%A4%96%E5%AF%B9%E4%BA%8E%60%E5%AD%98%E5%82%A8%E5%9E%8Bxss%60%E8%BF%98%E9%9C%80%E8%A6%81%E7%A1%AE%E4%BF%9D%E5%9C%A8%E5%B0%86%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E5%88%B0%60html%60%E4%B9%8B%E5%89%8D%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E8%BD%AC%E4%B9%89%E5%A4%84%E7%90%86--####-express-sanitized-%E4%B8%AD%E9%97%B4%E4%BB%B6-%60express-sanitized%60-%E6%98%AF%E4%B8%80%E4%B8%AA-%60express.js%60-%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%94%A8%E4%BA%8E%E5%B8%AE%E5%8A%A9%E9%98%B2%E6%AD%A2%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%60xss%60%E6%94%BB%E5%87%BB%E5%AE%83%E9%80%9A%E8%BF%87%E6%8F%90%E4%BE%9B%E4%B8%80%E7%BB%84%E5%87%BD%E6%95%B0%E6%9D%A5%E6%B8%85%E7%90%86%E5%92%8C%E8%BD%AC%E4%B9%89%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%8E%E8%80%8C%E5%87%8F%E5%B0%91%E6%BD%9C%E5%9C%A8%E7%9A%84%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%E7%84%B6%E8%80%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%60express-sanitized%60-%E6%9C%AC%E8%BA%AB%E5%B9%B6%E4%B8%8D%E6%8F%90%E4%BE%9B%E5%85%A8%E9%9D%A2%E7%9A%84-%60xss%60-%E4%BF%9D%E6%8A%A4%E5%AE%83%E5%BA%94%E5%BD%93%E4%B8%8E%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD%E5%A6%82%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%60csp%60%60http%60-%E5%A4%B4%E8%AE%BE%E7%BD%AE%E7%AD%89%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8--%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-%60node.js%60-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%E4%BA%86%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-%60express-sanitized%60-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%9E%8B-%60xss%60-%E6%94%BB%E5%87%BB--%E9%A6%96%E5%85%88%E4%BD%A0%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85-%60express%60-%E5%92%8C-%60express-sanitized%60--%60%60%60bash-npm-install-express-express-sanitized-%60%60%60-%E7%84%B6%E5%90%8E%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-express-%E5%BA%94%E7%94%A8%E5%B9%B6%E4%BD%BF%E7%94%A8-express-sanitized-%E6%9D%A5%E6%B8%85%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE--%60%60%60-javascript-const-express-=-require(&#x27;express&#x27;);-const-sanitized-=-require(&#x27;express-sanitized&#x27;);-const-app-=-express();--//-%E4%BD%BF%E7%94%A8-express-sanitized-%E4%B8%AD%E9%97%B4%E4%BB%B6-app.use(sanitized());--//-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-get-%E8%B7%AF%E7%94%B1%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%B9%B6%E5%8F%8D%E5%B0%84%E5%9B%9E%E5%8E%BB-app.get(&#x27;/reflect&#x27;,-(req,-res)-=%3E-{---//-%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E4%BB%8E-url-%E5%8F%82%E6%95%B0%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5---const-userinput-=-req.query.message;----//-%E4%BD%BF%E7%94%A8-express-sanitized-%E7%9A%84-sanitize-%E5%87%BD%E6%95%B0%E6%9D%A5%E6%B8%85%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5---const-cleanedinput-=-sanitized.sanitize(userinput);----//-%E5%B0%86%E6%B8%85%E7%90%86%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%B5%8C%E5%85%A5%E5%88%B0-html-%E4%B8%AD---const-html-=-%60-----%3Chtml%3E-------%3Cbody%3E---------%3Ch1%3Ewelcome,-${cleanedinput}!%3C/h1%3E-------%3C/body%3E-----%3C/html%3E---%60;----res.send(html);-});--const-port-=-process.env.port-||-3000;-app.listen(port,-()-=%3E-{---console.log(%60server-is-running-on-port-${port}%60);-});-%60%60%60--%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%B8%AD%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA-%60/reflect%60-%E8%B7%AF%E7%94%B1%E8%AF%A5%E8%B7%AF%E7%94%B1%E4%BB%8E-%60url%60-%E5%8F%82%E6%95%B0-%60message%60-%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8-%60express-sanitized%60-%E7%9A%84-sanit%60ize-%E5%87%BD%E6%95%B0%E6%9D%A5%E6%B8%85%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BC%9A%E7%A7%BB%E9%99%A4%E6%88%96%E8%BD%AC%E4%B9%89%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E6%A0%87%E7%AD%BE%E6%9C%80%E5%90%8E%E6%88%91%E4%BB%AC%E5%B0%86%E6%B8%85%E7%90%86%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%B5%8C%E5%85%A5%E5%88%B0-%60html%60-%E5%93%8D%E5%BA%94%E4%B8%AD--%E7%84%B6%E8%80%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%E4%BB%85%E4%BB%85%E4%BE%9D%E8%B5%96-%60express-sanitized%60-%E6%98%AF%E4%B8%8D%E5%A4%9F%E7%9A%84%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%A7%8B%E7%BB%88%E9%81%B5%E5%BE%AA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%A6%82%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%A6%82-%60pug%60%60ejs%60-%E7%AD%89%E6%9D%A5%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86-%60html%60-%E8%BD%AC%E4%B9%89%E8%AE%BE%E7%BD%AE%E9%80%82%E5%BD%93%E7%9A%84-%60http%60-%E5%A4%B4%E5%A6%82-%60x-xss-protection%60-%E5%92%8C-%60content-security-policy%60%E5%B9%B6%E4%B8%94%E5%AF%B9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E4%B8%A5%E6%A0%BC%E7%9A%84%E9%AA%8C%E8%AF%81%E5%92%8C%E8%BF%87%E6%BB%A4--%E5%8F%A6%E5%A4%96%60express-sanitized%60-%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%AF%E6%9C%80%E6%96%B0%E7%9A%84%E6%88%96%E6%9C%80%E5%B9%BF%E6%B3%9B%E4%BD%BF%E7%94%A8%E7%9A%84-%60xss%60-%E9%98%B2%E6%8A%A4%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E4%BA%8E%E6%9B%B4%E5%85%A8%E9%9D%A2%E7%9A%84-%60xss%60-%E9%98%B2%E6%8A%A4%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8-%60helmet%60-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%83%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%9A%E7%A7%8D%E5%A2%9E%E5%BC%BA-%60express%60-%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8C%85%E6%8B%AC-%60xss%60-%E9%98%B2%E6%8A%A4--####-helmet-%E4%B8%AD%E9%97%B4%E4%BB%B6--%60helmet%60-%E6%98%AF%E4%B8%80%E4%B8%AA-%60express.js%60-%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%94%A8%E4%BA%8E%E8%AE%BE%E7%BD%AE%E5%90%84%E7%A7%8D-%60http%60-%E5%A4%B4%E6%9D%A5%E5%B8%AE%E5%8A%A9%E9%A2%84%E9%98%B2%E4%B8%80%E4%BA%9B%E5%B7%B2%E7%9F%A5%E7%9A%84-%60web%60-%E6%BC%8F%E6%B4%9E%E5%8C%85%E6%8B%AC%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E7%AD%89%E5%B0%BD%E7%AE%A1-%60helmet%60-%E6%9C%AC%E8%BA%AB%E5%B9%B6%E4%B8%8D%E8%83%BD%E5%AE%8C%E5%85%A8%E9%98%B2%E6%AD%A2-%60xss%60-%E6%94%BB%E5%87%BB%E4%BD%86%E5%AE%83%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E6%9F%90%E4%BA%9B-%60http%60-%E5%A4%B4%E6%9D%A5%E5%87%8F%E5%B0%91%E6%94%BB%E5%87%BB%E9%9D%A2--%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8-%60helmet%60-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E5%A2%9E%E5%BC%BA-%60express.js%60-%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B--%E9%A6%96%E5%85%88%E4%BD%A0%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85-%60express%60-%E5%92%8C-%60helmet%60--%60%60%60-bash-npm-install-express-helmet-%60%60%60--%E7%84%B6%E5%90%8E%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-%60express%60-%E5%BA%94%E7%94%A8%E5%B9%B6%E5%BC%95%E5%85%A5-%60helmet%60-%E4%B8%AD%E9%97%B4%E4%BB%B6--%60%60%60-javascript-const-express-=-require(&#x27;express&#x27;);-const-helmet-=-require(&#x27;helmet&#x27;);--const-app-=-express();--//-%E4%BD%BF%E7%94%A8-helmet-%E4%B8%AD%E9%97%B4%E4%BB%B6-app.use(helmet());--//-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-get-%E8%B7%AF%E7%94%B1-app.get(&#x27;/&#x27;,-(req,-res)-=%3E-{---res.send(&#x27;hello,-world!&#x27;);-});--const-port-=-process.env.port-||-3000;-app.listen(port,-()-=%3E-{---console.log(%60server-is-running-on-port-${port}%60);-});-%60%60%60--%E5%9C%A8%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%60helmet()%60-%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B9%E4%BE%BF%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E7%94%A8%E4%BA%8E%E5%90%AF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%AE%89%E5%85%A8%E5%A4%B4%E8%BF%99%E4%BA%9B%E5%A4%B4%E5%8C%85%E6%8B%AC----%60content-security-policy%60%E5%B8%AE%E5%8A%A9%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BC%93%E8%A7%A3%E6%9F%90%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%94%BB%E5%87%BB%E5%8C%85%E6%8B%AC%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB---%60x-dns-prefetch-control%60%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E6%89%A7%E8%A1%8C-%60dns%60-%E9%A2%84%E5%8F%96---%60x-frame-options%60%E6%8C%87%E7%A4%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E5%85%81%E8%AE%B8%E9%A1%B5%E9%9D%A2%E8%A2%AB%E5%B5%8C%E5%85%A5%E5%88%B0-%60%3Ciframe%3E%60%60%3Cframe%3E%60%60%3Cembed%3E%60-%E6%88%96-%60%3Cobject%3E%60-%E5%85%83%E7%B4%A0%E4%B8%AD---%60x-content-type-options%60%E9%98%B2%E6%AD%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8C%9C%E6%B5%8B%E5%93%8D%E5%BA%94%E7%9A%84-%60mime%60-%E7%B1%BB%E5%9E%8B---%60x-xss-protection%60%E5%90%AF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8F%8D%E5%B0%84%E5%9E%8B-%60xss%60-%E4%BF%9D%E6%8A%A4---%60x-permitted-cross-domain-policies%60%E9%99%90%E5%88%B6-%60adobe-flash-player%60-%E7%9A%84%E8%B7%A8%E5%9F%9F%E7%AD%96%E7%95%A5%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8---%60referrer-policy%60%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A8%E5%8F%91%E9%80%81-%60http%60-%E5%BC%95%E7%94%A8%E5%A4%B4%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%92%8C%E5%8F%91%E9%80%81%E5%BC%95%E7%94%A8%E4%BF%A1%E6%81%AF--%E8%AF%B7%E6%B3%A8%E6%84%8F%E5%B0%BD%E7%AE%A1-%60helmet%60-%E6%8F%90%E4%BE%9B%E4%BA%86%E8%BF%99%E4%BA%9B%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD%E4%BD%86%E5%AE%83%E4%BB%AC%E5%B9%B6%E4%B8%8D%E6%98%AF%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1%E7%9A%84%E7%89%B9%E5%88%AB%E6%98%AF-%60content-security-policy%60-%E5%A4%B4%E5%AE%83%E5%85%81%E8%AE%B8%E4%BD%A0%E6%98%8E%E7%A1%AE%E6%8C%87%E5%AE%9A%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%E6%98%AF%E9%98%B2%E6%AD%A2-%60xss%60-%E6%94%BB%E5%87%BB%E7%9A%84%E9%87%8D%E8%A6%81%E5%B7%A5%E5%85%B7%E4%BD%A0%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%B7%E4%BD%93%E9%9C%80%E6%B1%82%E6%9D%A5%E9%85%8D%E7%BD%AE%E5%AE%83--%E6%AD%A4%E5%A4%96%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%E7%A1%AE%E4%BF%9D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86%E5%A6%82%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%E7%AD%89%E4%B9%9F%E9%87%87%E5%8F%96%E4%BA%86%E9%80%82%E5%BD%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD%60helmet%60-%E5%8F%AA%E8%83%BD%E4%BD%9C%E4%B8%BA%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E8%80%8C%E4%B8%8D%E8%83%BD%E5%8D%95%E7%8B%AC%E4%BE%9D%E8%B5%96%E5%AE%83%E6%9D%A5%E5%AE%8C%E5%85%A8%E9%98%B2%E6%AD%A2-%60xss%60-%E6%94%BB%E5%87%BB--###-%E9%A2%84%E9%98%B2%E6%8E%AA%E6%96%BD--%E4%B8%BA%E4%BA%86%E9%98%B2%E8%8C%83%60xss%60%E6%94%BB%E5%87%BB%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E4%BB%A5%E4%B8%8B%E6%8E%AA%E6%96%BD--1.-%E5%AF%B9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%E5%92%8C%E8%BD%AC%E4%B9%89%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9A%84%E6%B3%A8%E5%85%A5-2.-%E4%BD%BF%E7%94%A8%60httponly%60%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AEcookie%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87%60xss%60%E6%94%BB%E5%87%BB%E7%AA%83%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF-3.-%E4%BD%BF%E7%94%A8-%60csp%60-%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%60content-security-policy%60%E9%99%90%E5%88%B6%E7%BD%91%E7%AB%99%E4%B8%AD%E8%83%BD%E5%A4%9F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C-4.-%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84web%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%92%8C%E6%A1%86%E6%9E%B6%E5%A6%82%60react%60%60vue%60%E7%AD%89%E5%AE%83%E4%BB%AC%E6%8F%90%E4%BE%9B%E4%BA%86%E5%86%85%E7%BD%AE%E7%9A%84%60xss%60%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD-5.-%E5%AE%9A%E6%9C%9F%E5%AF%B9%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%92%8C%E6%B5%8B%E8%AF%95%E5%8F%8A%E6%97%B6%E5%8F%91%E7%8E%B0%E5%92%8C%E4%BF%AE%E5%A4%8D%60xss%60%E6%BC%8F%E6%B4%9E"><div class="truncate" style="padding-left:16px">Web安全之 XSS 攻击

### 简介
**XSS，全称跨站脚本攻击（Cross-Site Scripting）**，是一种网络安全漏洞攻击，指攻击者在网页中嵌入恶意脚本，当其他用户浏览该网页时，恶意脚本就会在其浏览器上执行，从而达到攻击者窃取用户信息、破坏数据、篡改网页内容、在用户浏览器上执行非法任务等目的。

### 分类

`XSS`攻击分为三种类型：

- **反射型XSS（Reflected XSS）**：攻击者将恶意脚本嵌入到URL地址中，当其他用户访问这个URL时，恶意脚本就会在其浏览器中执行。这种攻击方式需要用户主动点击含有恶意脚本的链接才会触发。

- **存储型XSS（Stored XSS）**：攻击者将恶意脚本存储到被攻击的网站数据库中，当其他用户访问网站时，恶意脚本会从数据库中取出并在用户浏览器中执行。这种攻击方式不需要用户主动点击链接，只要用户浏览被攻击的网站就可能被攻击。

- **DOM型XSS（DOM-based XSS）**：攻击者通过修改页面的DOM结构，注入恶意脚本，当其他用户浏览该页面时，恶意脚本会在用户浏览器中执行。这种攻击方式也不需要用户主动点击链接，只需要用户浏览被修改的页面就可能被攻击。

### 案例

#### 反射型XSS

在`Node.js`中，一个反射型`XSS`攻击的案例可能涉及一个web应用，该应用没有正确地处理或转义用户输入的数据，并将其直接插入到HTML响应中。攻击者可以构造一个包含恶意脚本的URL，当其他用户访问这个URL时，恶意脚本会在用户的浏览器中执行。

以下是一个简单的`Node.js`反射型`XSS`攻击的案例：

``` javascript
const express = require(&#x27;express&#x27;);
const app = express();
app.use(express.static(&#x27;public&#x27;));

app.get(&#x27;/profile&#x27;, (req, res) =&gt; {
  // 假设用户可以通过URL参数传递他们的名字
  const username = req.query.username;

  // 没有对用户输入进行任何处理或转义
  const html = `&lt;html&gt;
                &lt;body&gt;
                  &lt;h1&gt;Welcome, ${username}!&lt;/h1&gt;
                &lt;/body&gt;
              &lt;/html&gt;`;

  res.send(html);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server is running on port ${PORT}`);
});
```

在这个例子中，我们创建了一个简单的`Express`应用，其中有一个`/profile`路由，该路由从URL的查询参数中获取用户名（`username`）。然后，我们将这个用户名嵌入到一个`HTML`字符串中，并将其作为响应发送回客户端。

攻击者可以构造一个包含恶意脚本的URL，如：

```
http://example.com/profile?username=&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;
```

当用户访问这个`URL`时，浏览器会接收到包含恶意脚本的`HTML`响应，并执行该脚本，从而触发`XSS`攻击。

为了防止反射型`XSS`攻击，开发者应该对用户输入进行适当的过滤和转义。在这个案例中，可以使用如`escape-html`这样的库来转义`HTML`特殊字符：

``` javascript
const escapeHtml = require(&#x27;escape-html&#x27;);

app.get(&#x27;/profile&#x27;, (req, res) =&gt; {
  const username = req.query.username;

  // 转义用户输入中的HTML特殊字符
  const escapedUsername = escapeHtml(username);

  const html = `&lt;html&gt;
                &lt;body&gt;
                  &lt;h1&gt;Welcome, ${escapedUsername}!&lt;/h1&gt;
                &lt;/body&gt;
              &lt;/html&gt;`;

  res.send(html);
});
```

通过转义用户输入，恶意脚本将不会被浏览器执行，从而防止了`XSS`攻击。此外，开发者还应该使用内容安全策略（`CSP`）等额外安全措施来增强应用的安全性。

&lt;!-- more --&gt;

#### 存储型XSS
在`存储型XSS（Persistent XSS）`攻击中，恶意脚本被用户提交并存储到服务器端的数据库中。当其他用户访问包含这些恶意脚本的页面时，脚本会在用户的浏览器上执行。下面是一个简单的`Node.js`存储型XSS案例，我们将使用`Express`框架和`MongoDB`数据库。

首先，确保你已经安装了以下依赖：

``` bash
npm install express body-parser mongoose
```

然后，你可以创建一个简单的`Express`应用，并设置一个`MongoDB`数据库来存储评论。

```javascript
const express = require(&#x27;express&#x27;);
const bodyParser = require(&#x27;body-parser&#x27;);
const mongoose = require(&#x27;mongoose&#x27;);

const app = express();

// 连接到MongoDB数据库
mongoose.connect(&#x27;mongodb://localhost/xss-example&#x27;, { useNewUrlParser: true, useUnifiedTopology: true });

// 定义评论模型
const Comment = mongoose.model(&#x27;Comment&#x27;, new mongoose.Schema({
  content: String
}));

// 使用body-parser中间件来解析请求体
app.use(bodyParser.urlencoded({ extended: true }));

// 路由：添加评论
app.post(&#x27;/comment&#x27;, async (req, res) =&gt; {
  try {
    // 创建新的评论并保存到数据库
    const newComment = new Comment({ content: req.body.content });
    await newComment.save();
    res.send(&#x27;Comment added successfully!&#x27;);
  } catch (error) {
    console.error(error);
    res.status(500).send(&#x27;An error occurred while saving the comment.&#x27;);
  }
});

// 路由：显示所有评论
app.get(&#x27;/comments&#x27;, async (req, res) =&gt; {
  try {
    // 从数据库中获取所有评论
    const comments = await Comment.find({});

    // 渲染评论列表的HTML
    const html = renderComments(comments);
    res.send(html);
  } catch (error) {
    console.error(error);
    res.status(500).send(&#x27;An error occurred while fetching the comments.&#x27;);
  }
});

// 渲染评论列表的HTML
function renderComments(comments) {
  let html = &#x27;&lt;html&gt;&lt;body&gt;&#x27;;
  comments.forEach(comment =&gt; {
    // 这里没有对评论内容进行转义，这会导致存储型XSS漏洞
    html += `&lt;div&gt;${comment.content}&lt;/div&gt;`;
  });
  html += &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;;
  return html;
}

// 启动服务器
const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server is running on port ${PORT}`);
});
```
在这个案例中，我们定义了一个`Comment`模型，用于在`MongoDB`数据库中存储评论。`/comment`路由接受`POST`请求，将用户提交的评论保存到数据库中。`/comments`路由则负责从数据库中检索所有评论，并将它们渲染为HTML页面。

重要提示：在这个案例的`renderComments`函数中，我们没有对评论内容进行任何形式的转义或过滤。这意味着如果用户在评论中输入了恶意脚本，它将被直接插入到`HTML`页面中，并在其他用户查看该页面时执行。这就是`存储型XSS`攻击的核心。

为了防止`存储型XSS`攻击，你应该对所有的用户输入进行适当的转义或过滤。在`Express`应用中，你可以使用如`express-sanitized`和`helmet`这样的中间件来设置一些基本的`HTTP`头，以增加安全性。另外，使用模板引擎（如`ejs`、`pug`等）也可以帮助你更安全地渲染用户输入的数据，因为这些模板引擎通常会自动转义特殊字符。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。

#### DOM型XSS
在`React`应用程序中，`DOM型XSS`（跨站脚本）攻击通常发生在直接将用户输入嵌入到`JSX`中而没有进行适当的转义或过滤时。`React`本身不会自动转义用户输入，因此开发者需要确保在渲染用户输入之前进行适当的处理。下面是一个简单的`React`应用案例，展示了如果不正确地处理用户输入，可能会导致的`DOM型XSS`攻击：

首先，创建一个简单的`React`组件，它将接收一个名为`username`的属性，并将其直接渲染到页面上：

```jsx
import React from &#x27;react&#x27;;

function UserProfile({ username }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {username}!&lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default UserProfile;
```

然后，在父组件中使用这个`UserProfile`组件，并假设从某个地方（例如URL参数、数据库或用户输入）获取`username`：

``` jsx
import React from &#x27;react&#x27;;
import UserProfile from &#x27;./UserProfile&#x27;;

function App() {
  // 假设这是从某个不安全的来源获取的用户名
  const username = &quot;Alice &lt;img src=&#x27;https://example.com/x.png&#x27; onerror=&#x27;alert(\&quot;XSS\&quot;)&#x27; /&gt;&quot;;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;UserProfile username={username} /&gt;
    &lt;/div&gt;
  );
}

export default App;
```

在这个案例中，如果`username`包含了恶意的`HTML`和`JavaScript`代码，那么这段代码将会被执行，导致`XSS`攻击。

为了防止这种攻击，你应该在渲染用户输入之前使用某种方法对其进行转义，以确保它不会被浏览器解析为`HTML`或`JavaScript`代码。在`React`中，你可以使用内置的`dangerouslySetInnerHTML`属性配合适当的转义函数来安全地渲染`HTML`内容。然而，这通常不是推荐的做法，因为它可能会引入其他安全风险。

更好的做法是使用库如`react-dom-purify`来清理用户输入中的潜在恶意代码。下面是如何使用`react-dom-purify`来防止`XSS`攻击的例子：

首先，安装`react-dom-purify`：

``` bash
npm install react-dom-purify
```

然后，在你的`React`组件中使用它：

``` jsx
import React from &#x27;react&#x27;;
import DOMPurify from &#x27;react-dom-purify&#x27;;

function UserProfile({ username }) {
  // 使用DOMPurify来清理用户输入中的潜在恶意代码
  const safeUsername = DOMPurify.sanitize(username);

  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {safeUsername}!&lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default UserProfile;
```

在这个修改后的例子中，即使`username`包含了恶意的`HTML`和`JavaScript`代码，`DOMPurify.sanitize`函数也会将其清理掉，确保它们不会被浏览器执行。

总之，为了防止`DOM型XSS`攻击，你应该始终确保在将用户输入渲染到React组件之前对其进行适当的转义或清理。

#### ejs 模板引擎

例如，如果你使用`ejs`作为模板引擎，你可以这样渲染评论：

```ejs
&lt;body&gt;
  &lt;% comments.forEach(function(comment) { %&gt;
    &lt;div&gt;&lt;%= comment.content %&gt;&lt;/div&gt;
  &lt;% }); %&gt;
&lt;/body&gt;
```

在这个例子中，`&lt;%= comment.content %&gt;`会自动转义`comment.content`中的特殊字符，从而防止`XSS`攻击。

为了防止反射型和`存储型XSS`攻击，开发者应该对用户输入的数据进行适当的验证、过滤和转义。在`Node.js`中，可以使用诸如`express-sanitized`和`helmet`等中间件来增强应用的安全性。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。

#### express-sanitized 中间件
`express-sanitized` 是一个 `Express.js` 的中间件，用于帮助防止跨站脚本（`XSS`）攻击。它通过提供一组函数来清理和转义用户输入的数据，从而减少潜在的安全风险。然而，需要注意的是，`express-sanitized` 本身并不提供全面的 `XSS` 保护。它应当与其他安全措施（如内容安全策略（`CSP`）、`HTTP` 头设置等）一起使用。

下面是一个简单的 `Node.js` 案例，演示了如何使用 `express-sanitized` 中间件来防止反射型 `XSS` 攻击：

首先，你需要安装 `express` 和 `express-sanitized`：

```bash
npm install express express-sanitized
```
然后，你可以创建一个简单的 Express 应用，并使用 express-sanitized 来清理用户输入的数据：

``` javascript
const express = require(&#x27;express&#x27;);
const sanitized = require(&#x27;express-sanitized&#x27;);
const app = express();

// 使用 express-sanitized 中间件
app.use(sanitized());

// 一个简单的 GET 路由，接收用户输入并反射回去
app.get(&#x27;/reflect&#x27;, (req, res) =&gt; {
  // 假设我们从 URL 参数中获取用户输入
  const userInput = req.query.message;

  // 使用 express-sanitized 的 sanitize 函数来清理用户输入
  const cleanedInput = sanitized.sanitize(userInput);

  // 将清理后的用户输入嵌入到 HTML 中
  const html = `
    &lt;html&gt;
      &lt;body&gt;
        &lt;h1&gt;Welcome, ${cleanedInput}!&lt;/h1&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  `;

  res.send(html);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server is running on port ${PORT}`);
});
```

在这个例子中，我们定义了一个 `/reflect` 路由，该路由从 `URL` 参数 `message` 中获取用户输入。然后，我们使用 `express-sanitized` 的 sanit`ize 函数来清理用户输入，该函数会移除或转义潜在的恶意脚本标签。最后，我们将清理后的用户输入嵌入到 `HTML` 响应中。

然而，需要注意的是，仅仅依赖 `express-sanitized` 是不够的。你应该始终遵循最佳实践，如使用模板引擎（如 `Pug`、`EJS` 等）来自动处理 `HTML` 转义，设置适当的 `HTTP` 头（如 `X-XSS-Protection` 和 `Content-Security-Policy`），并且对用户输入进行严格的验证和过滤。

另外，`express-sanitized` 可能不是最新的或最广泛使用的 `XSS` 防护中间件。对于更全面的 `XSS` 防护，你可以考虑使用 `helmet` 中间件，它提供了多种增强 `Express` 应用安全性的功能，包括 `XSS` 防护。

#### helmet 中间件

`helmet` 是一个 `Express.js` 的中间件，用于设置各种 `HTTP` 头来帮助预防一些已知的 `web` 漏洞，包括跨站脚本攻击（XSS）和数据泄露等。尽管 `helmet` 本身并不能完全防止 `XSS` 攻击，但它可以通过设置某些 `HTTP` 头来减少攻击面。

下面是一个使用 `helmet` 中间件来增强 `Express.js` 应用安全性的简单案例：

首先，你需要安装 `express` 和 `helmet`：

``` bash
npm install express helmet
```

然后，创建一个 `Express` 应用并引入 `helmet` 中间件：

``` javascript
const express = require(&#x27;express&#x27;);
const helmet = require(&#x27;helmet&#x27;);

const app = express();

// 使用 helmet 中间件
app.use(helmet());

// 一个简单的 GET 路由
app.get(&#x27;/&#x27;, (req, res) =&gt; {
  res.send(&#x27;Hello, World!&#x27;);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server is running on port ${PORT}`);
});
```

在上面的代码中，`helmet()` 函数是一个方便的快捷方式，用于启用多个安全头。这些头包括：

- `content-security-policy`：帮助检测和缓解某些类型的攻击，包括跨站脚本和数据注入攻击。
- `x-dns-prefetch-control`：控制浏览器是否应该执行 `DNS` 预取。
- `x-frame-options`：指示浏览器是否应该允许页面被嵌入到 `&lt;iframe&gt;`、`&lt;frame&gt;`、`&lt;embed&gt;` 或 `&lt;object&gt;` 元素中。
- `x-content-type-options`：防止浏览器猜测响应的 `MIME` 类型。
- `x-xss-protection`：启用浏览器的反射型 `XSS` 保护。
- `x-permitted-cross-domain-policies`：限制 `Adobe Flash Player` 的跨域策略文件的使用。
- `referrer-policy`：控制浏览器在发送 `HTTP` 引用头时如何生成和发送引用信息。

请注意，尽管 `helmet` 提供了这些保护措施，但它们并不是万无一失的。特别是 `content-security-policy` 头，它允许你明确指定哪些内容是安全的，是防止 `XSS` 攻击的重要工具。你需要根据你的应用程序的具体需求来配置它。

此外，你还需要确保应用程序的其他部分（如模板引擎、用户输入验证等）也采取了适当的安全措施。`helmet` 只能作为安全策略的一部分，而不能单独依赖它来完全防止 `XSS` 攻击。

### 预防措施

为了防范`XSS`攻击，可以采取以下措施：

1. 对用户输入的数据进行过滤和转义，防止恶意脚本的注入。
2. 使用`HTTPOnly`属性设置Cookie，防止攻击者通过`XSS`攻击窃取用户信息。
3. 使用 `CSP` 内容安全策略（`Content-Security-Policy`）限制网站中能够执行的脚本，防止恶意脚本的执行。
4. 使用最新的Web安全技术和框架，如`React`、`Vue`等，它们提供了内置的`XSS`防护措施。
5. 定期对网站进行安全漏洞扫描和测试，及时发现和修复`XSS`漏洞。</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/630","id":2218770981,"node_id":"I_kwDOBiJZIc6EP8Il","number":630,"title":"Web安全之 XSS 攻击","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536825198,"node_id":"LA_kwDOBiJZIc8AAAABhaAJbg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/network","name":"network","color":"D613F5","default":false,"description":"分类-网络相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-04-01T18:01:11Z","updated_at":"2024-04-01T18:01:12Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## Web安全之 XSS 攻击\n\n### 简介\n**XSS，全称跨站脚本攻击（Cross-Site Scripting）**，是一种网络安全漏洞攻击，指攻击者在网页中嵌入恶意脚本，当其他用户浏览该网页时，恶意脚本就会在其浏览器上执行，从而达到攻击者窃取用户信息、破坏数据、篡改网页内容、在用户浏览器上执行非法任务等目的。\n\n### 分类\n\n`XSS`攻击分为三种类型：\n\n- **反射型XSS（Reflected XSS）**：攻击者将恶意脚本嵌入到URL地址中，当其他用户访问这个URL时，恶意脚本就会在其浏览器中执行。这种攻击方式需要用户主动点击含有恶意脚本的链接才会触发。\n\n- **存储型XSS（Stored XSS）**：攻击者将恶意脚本存储到被攻击的网站数据库中，当其他用户访问网站时，恶意脚本会从数据库中取出并在用户浏览器中执行。这种攻击方式不需要用户主动点击链接，只要用户浏览被攻击的网站就可能被攻击。\n\n- **DOM型XSS（DOM-based XSS）**：攻击者通过修改页面的DOM结构，注入恶意脚本，当其他用户浏览该页面时，恶意脚本会在用户浏览器中执行。这种攻击方式也不需要用户主动点击链接，只需要用户浏览被修改的页面就可能被攻击。\n\n### 案例\n\n#### 反射型XSS\n\n在`Node.js`中，一个反射型`XSS`攻击的案例可能涉及一个web应用，该应用没有正确地处理或转义用户输入的数据，并将其直接插入到HTML响应中。攻击者可以构造一个包含恶意脚本的URL，当其他用户访问这个URL时，恶意脚本会在用户的浏览器中执行。\n\n以下是一个简单的`Node.js`反射型`XSS`攻击的案例：\n\n``` javascript\nconst express = require('express');\nconst app = express();\napp.use(express.static('public'));\n\napp.get('/profile', (req, res) =\u003e {\n  // 假设用户可以通过URL参数传递他们的名字\n  const username = req.query.username;\n\n  // 没有对用户输入进行任何处理或转义\n  const html = `\u003chtml\u003e\n                \u003cbody\u003e\n                  \u003ch1\u003eWelcome, ${username}!\u003c/h1\u003e\n                \u003c/body\u003e\n              \u003c/html\u003e`;\n\n  res.send(html);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在这个例子中，我们创建了一个简单的`Express`应用，其中有一个`/profile`路由，该路由从URL的查询参数中获取用户名（`username`）。然后，我们将这个用户名嵌入到一个`HTML`字符串中，并将其作为响应发送回客户端。\n\n攻击者可以构造一个包含恶意脚本的URL，如：\n\n```\nhttp://example.com/profile?username=\u003cscript\u003ealert('XSS');\u003c/script\u003e\n```\n\n当用户访问这个`URL`时，浏览器会接收到包含恶意脚本的`HTML`响应，并执行该脚本，从而触发`XSS`攻击。\n\n为了防止反射型`XSS`攻击，开发者应该对用户输入进行适当的过滤和转义。在这个案例中，可以使用如`escape-html`这样的库来转义`HTML`特殊字符：\n\n``` javascript\nconst escapeHtml = require('escape-html');\n\napp.get('/profile', (req, res) =\u003e {\n  const username = req.query.username;\n\n  // 转义用户输入中的HTML特殊字符\n  const escapedUsername = escapeHtml(username);\n\n  const html = `\u003chtml\u003e\n                \u003cbody\u003e\n                  \u003ch1\u003eWelcome, ${escapedUsername}!\u003c/h1\u003e\n                \u003c/body\u003e\n              \u003c/html\u003e`;\n\n  res.send(html);\n});\n```\n\n通过转义用户输入，恶意脚本将不会被浏览器执行，从而防止了`XSS`攻击。此外，开发者还应该使用内容安全策略（`CSP`）等额外安全措施来增强应用的安全性。\n\n\u003c!-- more --\u003e\n\n#### 存储型XSS\n在`存储型XSS（Persistent XSS）`攻击中，恶意脚本被用户提交并存储到服务器端的数据库中。当其他用户访问包含这些恶意脚本的页面时，脚本会在用户的浏览器上执行。下面是一个简单的`Node.js`存储型XSS案例，我们将使用`Express`框架和`MongoDB`数据库。\n\n首先，确保你已经安装了以下依赖：\n\n``` bash\nnpm install express body-parser mongoose\n```\n\n然后，你可以创建一个简单的`Express`应用，并设置一个`MongoDB`数据库来存储评论。\n\n```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst mongoose = require('mongoose');\n\nconst app = express();\n\n// 连接到MongoDB数据库\nmongoose.connect('mongodb://localhost/xss-example', { useNewUrlParser: true, useUnifiedTopology: true });\n\n// 定义评论模型\nconst Comment = mongoose.model('Comment', new mongoose.Schema({\n  content: String\n}));\n\n// 使用body-parser中间件来解析请求体\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 路由：添加评论\napp.post('/comment', async (req, res) =\u003e {\n  try {\n    // 创建新的评论并保存到数据库\n    const newComment = new Comment({ content: req.body.content });\n    await newComment.save();\n    res.send('Comment added successfully!');\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('An error occurred while saving the comment.');\n  }\n});\n\n// 路由：显示所有评论\napp.get('/comments', async (req, res) =\u003e {\n  try {\n    // 从数据库中获取所有评论\n    const comments = await Comment.find({});\n\n    // 渲染评论列表的HTML\n    const html = renderComments(comments);\n    res.send(html);\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('An error occurred while fetching the comments.');\n  }\n});\n\n// 渲染评论列表的HTML\nfunction renderComments(comments) {\n  let html = '\u003chtml\u003e\u003cbody\u003e';\n  comments.forEach(comment =\u003e {\n    // 这里没有对评论内容进行转义，这会导致存储型XSS漏洞\n    html += `\u003cdiv\u003e${comment.content}\u003c/div\u003e`;\n  });\n  html += '\u003c/body\u003e\u003c/html\u003e';\n  return html;\n}\n\n// 启动服务器\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n在这个案例中，我们定义了一个`Comment`模型，用于在`MongoDB`数据库中存储评论。`/comment`路由接受`POST`请求，将用户提交的评论保存到数据库中。`/comments`路由则负责从数据库中检索所有评论，并将它们渲染为HTML页面。\n\n重要提示：在这个案例的`renderComments`函数中，我们没有对评论内容进行任何形式的转义或过滤。这意味着如果用户在评论中输入了恶意脚本，它将被直接插入到`HTML`页面中，并在其他用户查看该页面时执行。这就是`存储型XSS`攻击的核心。\n\n为了防止`存储型XSS`攻击，你应该对所有的用户输入进行适当的转义或过滤。在`Express`应用中，你可以使用如`express-sanitized`和`helmet`这样的中间件来设置一些基本的`HTTP`头，以增加安全性。另外，使用模板引擎（如`ejs`、`pug`等）也可以帮助你更安全地渲染用户输入的数据，因为这些模板引擎通常会自动转义特殊字符。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。\n\n#### DOM型XSS\n在`React`应用程序中，`DOM型XSS`（跨站脚本）攻击通常发生在直接将用户输入嵌入到`JSX`中而没有进行适当的转义或过滤时。`React`本身不会自动转义用户输入，因此开发者需要确保在渲染用户输入之前进行适当的处理。下面是一个简单的`React`应用案例，展示了如果不正确地处理用户输入，可能会导致的`DOM型XSS`攻击：\n\n首先，创建一个简单的`React`组件，它将接收一个名为`username`的属性，并将其直接渲染到页面上：\n\n```jsx\nimport React from 'react';\n\nfunction UserProfile({ username }) {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eWelcome, {username}!\u003c/h1\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default UserProfile;\n```\n\n然后，在父组件中使用这个`UserProfile`组件，并假设从某个地方（例如URL参数、数据库或用户输入）获取`username`：\n\n``` jsx\nimport React from 'react';\nimport UserProfile from './UserProfile';\n\nfunction App() {\n  // 假设这是从某个不安全的来源获取的用户名\n  const username = \"Alice \u003cimg src='https://example.com/x.png' onerror='alert(\\\"XSS\\\")' /\u003e\";\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cUserProfile username={username} /\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n在这个案例中，如果`username`包含了恶意的`HTML`和`JavaScript`代码，那么这段代码将会被执行，导致`XSS`攻击。\n\n为了防止这种攻击，你应该在渲染用户输入之前使用某种方法对其进行转义，以确保它不会被浏览器解析为`HTML`或`JavaScript`代码。在`React`中，你可以使用内置的`dangerouslySetInnerHTML`属性配合适当的转义函数来安全地渲染`HTML`内容。然而，这通常不是推荐的做法，因为它可能会引入其他安全风险。\n\n更好的做法是使用库如`react-dom-purify`来清理用户输入中的潜在恶意代码。下面是如何使用`react-dom-purify`来防止`XSS`攻击的例子：\n\n首先，安装`react-dom-purify`：\n\n``` bash\nnpm install react-dom-purify\n```\n\n然后，在你的`React`组件中使用它：\n\n``` jsx\nimport React from 'react';\nimport DOMPurify from 'react-dom-purify';\n\nfunction UserProfile({ username }) {\n  // 使用DOMPurify来清理用户输入中的潜在恶意代码\n  const safeUsername = DOMPurify.sanitize(username);\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eWelcome, {safeUsername}!\u003c/h1\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default UserProfile;\n```\n\n在这个修改后的例子中，即使`username`包含了恶意的`HTML`和`JavaScript`代码，`DOMPurify.sanitize`函数也会将其清理掉，确保它们不会被浏览器执行。\n\n总之，为了防止`DOM型XSS`攻击，你应该始终确保在将用户输入渲染到React组件之前对其进行适当的转义或清理。\n\n#### ejs 模板引擎\n\n例如，如果你使用`ejs`作为模板引擎，你可以这样渲染评论：\n\n```ejs\n\u003cbody\u003e\n  \u003c% comments.forEach(function(comment) { %\u003e\n    \u003cdiv\u003e\u003c%= comment.content %\u003e\u003c/div\u003e\n  \u003c% }); %\u003e\n\u003c/body\u003e\n```\n\n在这个例子中，`\u003c%= comment.content %\u003e`会自动转义`comment.content`中的特殊字符，从而防止`XSS`攻击。\n\n为了防止反射型和`存储型XSS`攻击，开发者应该对用户输入的数据进行适当的验证、过滤和转义。在`Node.js`中，可以使用诸如`express-sanitized`和`helmet`等中间件来增强应用的安全性。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。\n\n#### express-sanitized 中间件\n`express-sanitized` 是一个 `Express.js` 的中间件，用于帮助防止跨站脚本（`XSS`）攻击。它通过提供一组函数来清理和转义用户输入的数据，从而减少潜在的安全风险。然而，需要注意的是，`express-sanitized` 本身并不提供全面的 `XSS` 保护。它应当与其他安全措施（如内容安全策略（`CSP`）、`HTTP` 头设置等）一起使用。\n\n下面是一个简单的 `Node.js` 案例，演示了如何使用 `express-sanitized` 中间件来防止反射型 `XSS` 攻击：\n\n首先，你需要安装 `express` 和 `express-sanitized`：\n\n```bash\nnpm install express express-sanitized\n```\n然后，你可以创建一个简单的 Express 应用，并使用 express-sanitized 来清理用户输入的数据：\n\n``` javascript\nconst express = require('express');\nconst sanitized = require('express-sanitized');\nconst app = express();\n\n// 使用 express-sanitized 中间件\napp.use(sanitized());\n\n// 一个简单的 GET 路由，接收用户输入并反射回去\napp.get('/reflect', (req, res) =\u003e {\n  // 假设我们从 URL 参数中获取用户输入\n  const userInput = req.query.message;\n\n  // 使用 express-sanitized 的 sanitize 函数来清理用户输入\n  const cleanedInput = sanitized.sanitize(userInput);\n\n  // 将清理后的用户输入嵌入到 HTML 中\n  const html = `\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003ch1\u003eWelcome, ${cleanedInput}!\u003c/h1\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  `;\n\n  res.send(html);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在这个例子中，我们定义了一个 `/reflect` 路由，该路由从 `URL` 参数 `message` 中获取用户输入。然后，我们使用 `express-sanitized` 的 sanit`ize 函数来清理用户输入，该函数会移除或转义潜在的恶意脚本标签。最后，我们将清理后的用户输入嵌入到 `HTML` 响应中。\n\n然而，需要注意的是，仅仅依赖 `express-sanitized` 是不够的。你应该始终遵循最佳实践，如使用模板引擎（如 `Pug`、`EJS` 等）来自动处理 `HTML` 转义，设置适当的 `HTTP` 头（如 `X-XSS-Protection` 和 `Content-Security-Policy`），并且对用户输入进行严格的验证和过滤。\n\n另外，`express-sanitized` 可能不是最新的或最广泛使用的 `XSS` 防护中间件。对于更全面的 `XSS` 防护，你可以考虑使用 `helmet` 中间件，它提供了多种增强 `Express` 应用安全性的功能，包括 `XSS` 防护。\n\n#### helmet 中间件\n\n`helmet` 是一个 `Express.js` 的中间件，用于设置各种 `HTTP` 头来帮助预防一些已知的 `web` 漏洞，包括跨站脚本攻击（XSS）和数据泄露等。尽管 `helmet` 本身并不能完全防止 `XSS` 攻击，但它可以通过设置某些 `HTTP` 头来减少攻击面。\n\n下面是一个使用 `helmet` 中间件来增强 `Express.js` 应用安全性的简单案例：\n\n首先，你需要安装 `express` 和 `helmet`：\n\n``` bash\nnpm install express helmet\n```\n\n然后，创建一个 `Express` 应用并引入 `helmet` 中间件：\n\n``` javascript\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// 使用 helmet 中间件\napp.use(helmet());\n\n// 一个简单的 GET 路由\napp.get('/', (req, res) =\u003e {\n  res.send('Hello, World!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在上面的代码中，`helmet()` 函数是一个方便的快捷方式，用于启用多个安全头。这些头包括：\n\n- `content-security-policy`：帮助检测和缓解某些类型的攻击，包括跨站脚本和数据注入攻击。\n- `x-dns-prefetch-control`：控制浏览器是否应该执行 `DNS` 预取。\n- `x-frame-options`：指示浏览器是否应该允许页面被嵌入到 `\u003ciframe\u003e`、`\u003cframe\u003e`、`\u003cembed\u003e` 或 `\u003cobject\u003e` 元素中。\n- `x-content-type-options`：防止浏览器猜测响应的 `MIME` 类型。\n- `x-xss-protection`：启用浏览器的反射型 `XSS` 保护。\n- `x-permitted-cross-domain-policies`：限制 `Adobe Flash Player` 的跨域策略文件的使用。\n- `referrer-policy`：控制浏览器在发送 `HTTP` 引用头时如何生成和发送引用信息。\n\n请注意，尽管 `helmet` 提供了这些保护措施，但它们并不是万无一失的。特别是 `content-security-policy` 头，它允许你明确指定哪些内容是安全的，是防止 `XSS` 攻击的重要工具。你需要根据你的应用程序的具体需求来配置它。\n\n此外，你还需要确保应用程序的其他部分（如模板引擎、用户输入验证等）也采取了适当的安全措施。`helmet` 只能作为安全策略的一部分，而不能单独依赖它来完全防止 `XSS` 攻击。\n\n### 预防措施\n\n为了防范`XSS`攻击，可以采取以下措施：\n\n1. 对用户输入的数据进行过滤和转义，防止恶意脚本的注入。\n2. 使用`HTTPOnly`属性设置Cookie，防止攻击者通过`XSS`攻击窃取用户信息。\n3. 使用 `CSP` 内容安全策略（`Content-Security-Policy`）限制网站中能够执行的脚本，防止恶意脚本的执行。\n4. 使用最新的Web安全技术和框架，如`React`、`Vue`等，它们提供了内置的`XSS`防护措施。\n5. 定期对网站进行安全漏洞扫描和测试，及时发现和修复`XSS`漏洞。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## Web安全之 XSS 攻击\n\n### 简介\n**XSS，全称跨站脚本攻击（Cross-Site Scripting）**，是一种网络安全漏洞攻击，指攻击者在网页中嵌入恶意脚本，当其他用户浏览该网页时，恶意脚本就会在其浏览器上执行，从而达到攻击者窃取用户信息、破坏数据、篡改网页内容、在用户浏览器上执行非法任务等目的。\n\n### 分类\n\n`XSS`攻击分为三种类型：\n\n- **反射型XSS（Reflected XSS）**：攻击者将恶意脚本嵌入到URL地址中，当其他用户访问这个URL时，恶意脚本就会在其浏览器中执行。这种攻击方式需要用户主动点击含有恶意脚本的链接才会触发。\n\n- **存储型XSS（Stored XSS）**：攻击者将恶意脚本存储到被攻击的网站数据库中，当其他用户访问网站时，恶意脚本会从数据库中取出并在用户浏览器中执行。这种攻击方式不需要用户主动点击链接，只要用户浏览被攻击的网站就可能被攻击。\n\n- **DOM型XSS（DOM-based XSS）**：攻击者通过修改页面的DOM结构，注入恶意脚本，当其他用户浏览该页面时，恶意脚本会在用户浏览器中执行。这种攻击方式也不需要用户主动点击链接，只需要用户浏览被修改的页面就可能被攻击。\n\n### 案例\n\n#### 反射型XSS\n\n在`Node.js`中，一个反射型`XSS`攻击的案例可能涉及一个web应用，该应用没有正确地处理或转义用户输入的数据，并将其直接插入到HTML响应中。攻击者可以构造一个包含恶意脚本的URL，当其他用户访问这个URL时，恶意脚本会在用户的浏览器中执行。\n\n以下是一个简单的`Node.js`反射型`XSS`攻击的案例：\n\n``` javascript\nconst express = require('express');\nconst app = express();\napp.use(express.static('public'));\n\napp.get('/profile', (req, res) =\u003e {\n  // 假设用户可以通过URL参数传递他们的名字\n  const username = req.query.username;\n\n  // 没有对用户输入进行任何处理或转义\n  const html = `\u003chtml\u003e\n                \u003cbody\u003e\n                  \u003ch1\u003eWelcome, ${username}!\u003c/h1\u003e\n                \u003c/body\u003e\n              \u003c/html\u003e`;\n\n  res.send(html);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在这个例子中，我们创建了一个简单的`Express`应用，其中有一个`/profile`路由，该路由从URL的查询参数中获取用户名（`username`）。然后，我们将这个用户名嵌入到一个`HTML`字符串中，并将其作为响应发送回客户端。\n\n攻击者可以构造一个包含恶意脚本的URL，如：\n\n```\nhttp://example.com/profile?username=\u003cscript\u003ealert('XSS');\u003c/script\u003e\n```\n\n当用户访问这个`URL`时，浏览器会接收到包含恶意脚本的`HTML`响应，并执行该脚本，从而触发`XSS`攻击。\n\n为了防止反射型`XSS`攻击，开发者应该对用户输入进行适当的过滤和转义。在这个案例中，可以使用如`escape-html`这样的库来转义`HTML`特殊字符：\n\n``` javascript\nconst escapeHtml = require('escape-html');\n\napp.get('/profile', (req, res) =\u003e {\n  const username = req.query.username;\n\n  // 转义用户输入中的HTML特殊字符\n  const escapedUsername = escapeHtml(username);\n\n  const html = `\u003chtml\u003e\n                \u003cbody\u003e\n                  \u003ch1\u003eWelcome, ${escapedUsername}!\u003c/h1\u003e\n                \u003c/body\u003e\n              \u003c/html\u003e`;\n\n  res.send(html);\n});\n```\n\n通过转义用户输入，恶意脚本将不会被浏览器执行，从而防止了`XSS`攻击。此外，开发者还应该使用内容安全策略（`CSP`）等额外安全措施来增强应用的安全性。\n\n\u003c!-- more --\u003e\n\n#### 存储型XSS\n在`存储型XSS（Persistent XSS）`攻击中，恶意脚本被用户提交并存储到服务器端的数据库中。当其他用户访问包含这些恶意脚本的页面时，脚本会在用户的浏览器上执行。下面是一个简单的`Node.js`存储型XSS案例，我们将使用`Express`框架和`MongoDB`数据库。\n\n首先，确保你已经安装了以下依赖：\n\n``` bash\nnpm install express body-parser mongoose\n```\n\n然后，你可以创建一个简单的`Express`应用，并设置一个`MongoDB`数据库来存储评论。\n\n```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst mongoose = require('mongoose');\n\nconst app = express();\n\n// 连接到MongoDB数据库\nmongoose.connect('mongodb://localhost/xss-example', { useNewUrlParser: true, useUnifiedTopology: true });\n\n// 定义评论模型\nconst Comment = mongoose.model('Comment', new mongoose.Schema({\n  content: String\n}));\n\n// 使用body-parser中间件来解析请求体\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 路由：添加评论\napp.post('/comment', async (req, res) =\u003e {\n  try {\n    // 创建新的评论并保存到数据库\n    const newComment = new Comment({ content: req.body.content });\n    await newComment.save();\n    res.send('Comment added successfully!');\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('An error occurred while saving the comment.');\n  }\n});\n\n// 路由：显示所有评论\napp.get('/comments', async (req, res) =\u003e {\n  try {\n    // 从数据库中获取所有评论\n    const comments = await Comment.find({});\n\n    // 渲染评论列表的HTML\n    const html = renderComments(comments);\n    res.send(html);\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('An error occurred while fetching the comments.');\n  }\n});\n\n// 渲染评论列表的HTML\nfunction renderComments(comments) {\n  let html = '\u003chtml\u003e\u003cbody\u003e';\n  comments.forEach(comment =\u003e {\n    // 这里没有对评论内容进行转义，这会导致存储型XSS漏洞\n    html += `\u003cdiv\u003e${comment.content}\u003c/div\u003e`;\n  });\n  html += '\u003c/body\u003e\u003c/html\u003e';\n  return html;\n}\n\n// 启动服务器\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n在这个案例中，我们定义了一个`Comment`模型，用于在`MongoDB`数据库中存储评论。`/comment`路由接受`POST`请求，将用户提交的评论保存到数据库中。`/comments`路由则负责从数据库中检索所有评论，并将它们渲染为HTML页面。\n\n重要提示：在这个案例的`renderComments`函数中，我们没有对评论内容进行任何形式的转义或过滤。这意味着如果用户在评论中输入了恶意脚本，它将被直接插入到`HTML`页面中，并在其他用户查看该页面时执行。这就是`存储型XSS`攻击的核心。\n\n为了防止`存储型XSS`攻击，你应该对所有的用户输入进行适当的转义或过滤。在`Express`应用中，你可以使用如`express-sanitized`和`helmet`这样的中间件来设置一些基本的`HTTP`头，以增加安全性。另外，使用模板引擎（如`ejs`、`pug`等）也可以帮助你更安全地渲染用户输入的数据，因为这些模板引擎通常会自动转义特殊字符。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。\n\n#### DOM型XSS\n在`React`应用程序中，`DOM型XSS`（跨站脚本）攻击通常发生在直接将用户输入嵌入到`JSX`中而没有进行适当的转义或过滤时。`React`本身不会自动转义用户输入，因此开发者需要确保在渲染用户输入之前进行适当的处理。下面是一个简单的`React`应用案例，展示了如果不正确地处理用户输入，可能会导致的`DOM型XSS`攻击：\n\n首先，创建一个简单的`React`组件，它将接收一个名为`username`的属性，并将其直接渲染到页面上：\n\n```jsx\nimport React from 'react';\n\nfunction UserProfile({ username }) {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eWelcome, {username}!\u003c/h1\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default UserProfile;\n```\n\n然后，在父组件中使用这个`UserProfile`组件，并假设从某个地方（例如URL参数、数据库或用户输入）获取`username`：\n\n``` jsx\nimport React from 'react';\nimport UserProfile from './UserProfile';\n\nfunction App() {\n  // 假设这是从某个不安全的来源获取的用户名\n  const username = \"Alice \u003cimg src='https://example.com/x.png' onerror='alert(\\\"XSS\\\")' /\u003e\";\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cUserProfile username={username} /\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n在这个案例中，如果`username`包含了恶意的`HTML`和`JavaScript`代码，那么这段代码将会被执行，导致`XSS`攻击。\n\n为了防止这种攻击，你应该在渲染用户输入之前使用某种方法对其进行转义，以确保它不会被浏览器解析为`HTML`或`JavaScript`代码。在`React`中，你可以使用内置的`dangerouslySetInnerHTML`属性配合适当的转义函数来安全地渲染`HTML`内容。然而，这通常不是推荐的做法，因为它可能会引入其他安全风险。\n\n更好的做法是使用库如`react-dom-purify`来清理用户输入中的潜在恶意代码。下面是如何使用`react-dom-purify`来防止`XSS`攻击的例子：\n\n首先，安装`react-dom-purify`：\n\n``` bash\nnpm install react-dom-purify\n```\n\n然后，在你的`React`组件中使用它：\n\n``` jsx\nimport React from 'react';\nimport DOMPurify from 'react-dom-purify';\n\nfunction UserProfile({ username }) {\n  // 使用DOMPurify来清理用户输入中的潜在恶意代码\n  const safeUsername = DOMPurify.sanitize(username);\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eWelcome, {safeUsername}!\u003c/h1\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default UserProfile;\n```\n\n在这个修改后的例子中，即使`username`包含了恶意的`HTML`和`JavaScript`代码，`DOMPurify.sanitize`函数也会将其清理掉，确保它们不会被浏览器执行。\n\n总之，为了防止`DOM型XSS`攻击，你应该始终确保在将用户输入渲染到React组件之前对其进行适当的转义或清理。\n\n#### ejs 模板引擎\n\n例如，如果你使用`ejs`作为模板引擎，你可以这样渲染评论：\n\n```ejs\n\u003cbody\u003e\n  \u003c% comments.forEach(function(comment) { %\u003e\n    \u003cdiv\u003e\u003c%= comment.content %\u003e\u003c/div\u003e\n  \u003c% }); %\u003e\n\u003c/body\u003e\n```\n\n在这个例子中，`\u003c%= comment.content %\u003e`会自动转义`comment.content`中的特殊字符，从而防止`XSS`攻击。\n\n为了防止反射型和`存储型XSS`攻击，开发者应该对用户输入的数据进行适当的验证、过滤和转义。在`Node.js`中，可以使用诸如`express-sanitized`和`helmet`等中间件来增强应用的安全性。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。\n\n#### express-sanitized 中间件\n`express-sanitized` 是一个 `Express.js` 的中间件，用于帮助防止跨站脚本（`XSS`）攻击。它通过提供一组函数来清理和转义用户输入的数据，从而减少潜在的安全风险。然而，需要注意的是，`express-sanitized` 本身并不提供全面的 `XSS` 保护。它应当与其他安全措施（如内容安全策略（`CSP`）、`HTTP` 头设置等）一起使用。\n\n下面是一个简单的 `Node.js` 案例，演示了如何使用 `express-sanitized` 中间件来防止反射型 `XSS` 攻击：\n\n首先，你需要安装 `express` 和 `express-sanitized`：\n\n```bash\nnpm install express express-sanitized\n```\n然后，你可以创建一个简单的 Express 应用，并使用 express-sanitized 来清理用户输入的数据：\n\n``` javascript\nconst express = require('express');\nconst sanitized = require('express-sanitized');\nconst app = express();\n\n// 使用 express-sanitized 中间件\napp.use(sanitized());\n\n// 一个简单的 GET 路由，接收用户输入并反射回去\napp.get('/reflect', (req, res) =\u003e {\n  // 假设我们从 URL 参数中获取用户输入\n  const userInput = req.query.message;\n\n  // 使用 express-sanitized 的 sanitize 函数来清理用户输入\n  const cleanedInput = sanitized.sanitize(userInput);\n\n  // 将清理后的用户输入嵌入到 HTML 中\n  const html = `\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003ch1\u003eWelcome, ${cleanedInput}!\u003c/h1\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  `;\n\n  res.send(html);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在这个例子中，我们定义了一个 `/reflect` 路由，该路由从 `URL` 参数 `message` 中获取用户输入。然后，我们使用 `express-sanitized` 的 sanit`ize 函数来清理用户输入，该函数会移除或转义潜在的恶意脚本标签。最后，我们将清理后的用户输入嵌入到 `HTML` 响应中。\n\n然而，需要注意的是，仅仅依赖 `express-sanitized` 是不够的。你应该始终遵循最佳实践，如使用模板引擎（如 `Pug`、`EJS` 等）来自动处理 `HTML` 转义，设置适当的 `HTTP` 头（如 `X-XSS-Protection` 和 `Content-Security-Policy`），并且对用户输入进行严格的验证和过滤。\n\n另外，`express-sanitized` 可能不是最新的或最广泛使用的 `XSS` 防护中间件。对于更全面的 `XSS` 防护，你可以考虑使用 `helmet` 中间件，它提供了多种增强 `Express` 应用安全性的功能，包括 `XSS` 防护。\n\n#### helmet 中间件\n\n`helmet` 是一个 `Express.js` 的中间件，用于设置各种 `HTTP` 头来帮助预防一些已知的 `web` 漏洞，包括跨站脚本攻击（XSS）和数据泄露等。尽管 `helmet` 本身并不能完全防止 `XSS` 攻击，但它可以通过设置某些 `HTTP` 头来减少攻击面。\n\n下面是一个使用 `helmet` 中间件来增强 `Express.js` 应用安全性的简单案例：\n\n首先，你需要安装 `express` 和 `helmet`：\n\n``` bash\nnpm install express helmet\n```\n\n然后，创建一个 `Express` 应用并引入 `helmet` 中间件：\n\n``` javascript\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// 使用 helmet 中间件\napp.use(helmet());\n\n// 一个简单的 GET 路由\napp.get('/', (req, res) =\u003e {\n  res.send('Hello, World!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在上面的代码中，`helmet()` 函数是一个方便的快捷方式，用于启用多个安全头。这些头包括：\n\n- `content-security-policy`：帮助检测和缓解某些类型的攻击，包括跨站脚本和数据注入攻击。\n- `x-dns-prefetch-control`：控制浏览器是否应该执行 `DNS` 预取。\n- `x-frame-options`：指示浏览器是否应该允许页面被嵌入到 `\u003ciframe\u003e`、`\u003cframe\u003e`、`\u003cembed\u003e` 或 `\u003cobject\u003e` 元素中。\n- `x-content-type-options`：防止浏览器猜测响应的 `MIME` 类型。\n- `x-xss-protection`：启用浏览器的反射型 `XSS` 保护。\n- `x-permitted-cross-domain-policies`：限制 `Adobe Flash Player` 的跨域策略文件的使用。\n- `referrer-policy`：控制浏览器在发送 `HTTP` 引用头时如何生成和发送引用信息。\n\n请注意，尽管 `helmet` 提供了这些保护措施，但它们并不是万无一失的。特别是 `content-security-policy` 头，它允许你明确指定哪些内容是安全的，是防止 `XSS` 攻击的重要工具。你需要根据你的应用程序的具体需求来配置它。\n\n此外，你还需要确保应用程序的其他部分（如模板引擎、用户输入验证等）也采取了适当的安全措施。`helmet` 只能作为安全策略的一部分，而不能单独依赖它来完全防止 `XSS` 攻击。\n\n### 预防措施\n\n为了防范`XSS`攻击，可以采取以下措施：\n\n1. 对用户输入的数据进行过滤和转义，防止恶意脚本的注入。\n2. 使用`HTTPOnly`属性设置Cookie，防止攻击者通过`XSS`攻击窃取用户信息。\n3. 使用 `CSP` 内容安全策略（`Content-Security-Policy`）限制网站中能够执行的脚本，防止恶意脚本的执行。\n4. 使用最新的Web安全技术和框架，如`React`、`Vue`等，它们提供了内置的`XSS`防护措施。\n5. 定期对网站进行安全漏洞扫描和测试，及时发现和修复`XSS`漏洞。"]},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"630"},"buildId":"_KMMPskFwjkQ1wkakKC3o","assetPrefix":"/frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>