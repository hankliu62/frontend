<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>前端小技术集合 - H.L Frontend</title><link rel="icon" href="/frontend/favicon.ico"/><meta name="description" content="H.L Frontend，前端技术和工具网站，提供了一系列实用的前端开发工具和功能，技术网站汇总，旨在帮助开发者更加高效地进行前端开发。"/><meta name="keywords" content="前端工具,前端开发,前端开发工具,前端开发工具集合,toolbox,frontend,卡鲁秋,Hank,HankLiu"/><meta name="author" content="Hank.Liu"/><meta name="copyright" content="卡鲁秋"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="next-head-count" content="9"/><link rel="stylesheet" href="/frontend/styles/animate.css/@4.1.1/animate.css"/><link rel="preload" href="/frontend/_next/static/css/48e12760546808a2.css" as="style"/><link rel="stylesheet" href="/frontend/_next/static/css/48e12760546808a2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/frontend/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/frontend/_next/static/chunks/webpack-eb44c437bf7e459b.js" defer=""></script><script src="/frontend/_next/static/chunks/framework-0e8d27528ba61906.js" defer=""></script><script src="/frontend/_next/static/chunks/main-d236bc00457e5dc2.js" defer=""></script><script src="/frontend/_next/static/chunks/pages/_app-d90534c1986642b8.js" defer=""></script><script src="/frontend/_next/static/chunks/4853-4e02ebf21637e379.js" defer=""></script><script src="/frontend/_next/static/chunks/3239-4699acf95684b42e.js" defer=""></script><script src="/frontend/_next/static/chunks/1664-e769dc1505626ddd.js" defer=""></script><script src="/frontend/_next/static/chunks/pages/articles/%5Bid%5D-15cbf11aeca29499.js" defer=""></script><script src="/frontend/_next/static/sU2iERWyzsgD586oQgu3i/_buildManifest.js" defer=""></script><script src="/frontend/_next/static/sU2iERWyzsgD586oQgu3i/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="flex h-full flex-1 flex-col" style="position:relative"><div class="flex space-x-6 bg-white p-6"><div class="flex-1 overflow-x-hidden"><div class="ant-card ant-card-bordered article-card min-h-full !border-[#d9d9d9] css-1okl62o"><div class="ant-card-body"><article><div class="mx-auto mb-[36px] max-w-[1045px] px-[30px] lg:mb-[52px] lg:flex lg:px-0"><div id="banner" class="media-wrapper image-media-wrapper w-full overflow-hidden rounded-[8px] border-[1px] border-solid border-[#1D2129] lg:ml-0 lg:h-[320px] lg:w-[500px]"><div class="hidden before"></div><div class="hidden after"></div><div class="scale-103 h-full w-full border-[8px] border-solid border-white lg:scale-100 cover-wrapper"><img class="h-full w-full rounded-md object-cover cover" src="/frontend/dashboard/images/banner.png" alt=""/></div></div><div class="mt-[60px] overflow-hidden lg:ml-[32px] lg:mt-0 lg:flex-1"><h1 class="leading-130 montserrat-bold mb-[9px] text-[36px] font-medium text-[#1D2129] lg:mb-[8px]">Webpack相关的面试题</h1><div class="mb-[9px] flex whitespace-nowrap lg:mb-[10px]"><div class="leading-120 cursor-pointer truncate text-[24px] font-normal text-[#1D2129] underline-offset-2 hover:underline lg:text-[20px]" aria-hidden="true"># VOL.<!-- -->615</div><div class="leading-120 ml-[48px] text-[24px] font-normal text-[#1D2129] lg:ml-[32px] lg:text-[20px]">2024/02/13</div></div><div class="mb-[12px] flex flex-wrap lg:mb-0"><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">blog</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">webpack</div><div class="leading-150 mb-[12px] mr-[18px] rounded-[30px] border border-solid border-[#1D2129] px-[24px] py-[6px] text-[20px] font-normal text-[#1D2129] lg:mb-[12px] lg:mr-[10px] lg:rounded-[20px] lg:px-[16px] lg:py-[4px] lg:text-[14px]">interview</div></div><div class="my-[30px] hidden w-[213px] border border-[#1D2129] lg:mb-[20px] lg:mt-[8px] lg:block"></div><div class="lg:rounded-0 rounded-[12px] bg-white/30 p-[36px] lg:flex lg:bg-transparent lg:p-0"><div class="float-left h-[118px] w-[118px] lg:float-none lg:h-[112px] lg:w-[112px]"><img src="https://avatars.githubusercontent.com/u/8088864?v=4" class="h-full w-full rounded-[8px] object-cover lg:rounded-[12px]" alt=""/></div><div class="lg:ml-[32px] lg:flex-1 lg:overflow-hidden"><div class="mb-[10px] flex h-[118px] flex-col justify-center pl-[36px] lg:h-auto lg:flex-row lg:items-center lg:justify-between lg:pl-0"><div class="leading-130 montserrat-bold mb-[12px] w-full truncate text-[30px] font-medium text-[#1D2129] lg:mb-0 lg:flex-1 lg:text-[24px]">hankliu62</div><a class="leading-170 ml-0 whitespace-pre-wrap text-[20px] font-normal !text-[#1D2129] !underline hover:!text-[#1D2129] hover:!underline focus:!text-[#1D2129] lg:ml-[5px] lg:text-[14px]" href="https://github.com/hankliu62" target="_blank" rel="noreferrer">TA的个人名片</a></div><div class="leading-170 text-[20px] font-normal text-[#4E5969] lg:text-[14px]">HankLiu前端开发工程师，精通前端，涉猎后端，对前端有着浓厚的兴趣，希望能够在前端这条路上一直走下去。努力去听风的声音，不必在意风的方向。</div></div></div></div></div><div class="ant-divider css-1okl62o ant-divider-horizontal !mt-0 !border-[#bfc3c7]" role="separator"></div><section><div><div class="ant-skeleton ant-skeleton-active css-1okl62o"><div class="ant-skeleton-content"><h3 class="ant-skeleton-title" style="width:38%"></h3><ul class="ant-skeleton-paragraph"><li></li><li></li><li style="width:61%"></li></ul></div></div></div></section></article></div></div></div><div class="w-64 bg-white"><div><div class=""><div class="ant-collapse ant-collapse-icon-position-end question-menus-collapse css-1okl62o"><div class="ant-collapse-item ant-collapse-item-active"><div class="ant-collapse-header" aria-expanded="true" aria-disabled="false" role="button" tabindex="0"><div class="ant-collapse-expand-icon"><span role="img" aria-label="right" class="anticon anticon-right ant-collapse-arrow"><svg viewBox="64 64 896 896" focusable="false" style="-ms-transform:rotate(90deg);transform:rotate(90deg)" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></div><span class="ant-collapse-header-text"><span class="text-base">目录</span></span><div class="ant-collapse-extra"><div class="-mr-2">收起</div></div></div><div class="ant-collapse-content ant-collapse-content-active"><div class="ant-collapse-content-box"><ul class="max-h-[620px] list-none space-y-3 overflow-y-auto text-slate-500 dark:text-slate-400"><li id="## webpack 打包优化的四种方法（多进程打包，多进程压缩，资源 CDN，动态 polyfill）" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base !border-sky-500"><a class="w-full overflow-hidden !text-[#515767] !text-sky-500" href="/frontend/articles/615#webpack-%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%89%93%E5%8C%85%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%8E%8B%E7%BC%A9%E8%B5%84%E6%BA%90-cdn%E5%8A%A8%E6%80%81-polyfill"><div class="truncate" style="padding-left:16px">webpack 打包优化的四种方法（多进程打包，多进程压缩，资源 CDN，动态 polyfill）</div></a></li><li id="### 打包分析" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90"><div class="truncate" style="padding-left:32px">打包分析</div></a></li><li id="#### 1. 速度分析" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#1.-%E9%80%9F%E5%BA%A6%E5%88%86%E6%9E%90"><div class="truncate" style="padding-left:48px">1. 速度分析</div></a></li><li id="#### 2. 体积分析" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#2.-%E4%BD%93%E7%A7%AF%E5%88%86%E6%9E%90"><div class="truncate" style="padding-left:48px">2. 体积分析</div></a></li><li id="### 打包优化" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96"><div class="truncate" style="padding-left:32px">打包优化</div></a></li><li id="#### 1. 多进程多实例构建，资源并行解析" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#1.-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%9E%84%E5%BB%BA%E8%B5%84%E6%BA%90%E5%B9%B6%E8%A1%8C%E8%A7%A3%E6%9E%90"><div class="truncate" style="padding-left:48px">1. 多进程多实例构建，资源并行解析</div></a></li><li id="#### 2. 公用代码提取，使用 CDN 加载" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#2.-%E5%85%AC%E7%94%A8%E4%BB%A3%E7%A0%81%E6%8F%90%E5%8F%96%E4%BD%BF%E7%94%A8-cdn-%E5%8A%A0%E8%BD%BD"><div class="truncate" style="padding-left:48px">2. 公用代码提取，使用 CDN 加载</div></a></li><li id="#### 3. 多进程多实例并行压缩" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#3.-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E5%AE%9E%E4%BE%8B%E5%B9%B6%E8%A1%8C%E5%8E%8B%E7%BC%A9"><div class="truncate" style="padding-left:48px">3. 多进程多实例并行压缩</div></a></li><li id="#### 4. 使用 polyfill 动态服务" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#4.-%E4%BD%BF%E7%94%A8-polyfill-%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1"><div class="truncate" style="padding-left:48px">4. 使用 polyfill 动态服务</div></a></li><li id="## webpack 做过哪些优化，开发效率方面、打包策略方面等等" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack-%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E6%96%B9%E9%9D%A2%E6%89%93%E5%8C%85%E7%AD%96%E7%95%A5%E6%96%B9%E9%9D%A2%E7%AD%89%E7%AD%89"><div class="truncate" style="padding-left:16px">webpack 做过哪些优化，开发效率方面、打包策略方面等等</div></a></li><li id="### 1）优化 Webpack 的构建速度" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#1%E4%BC%98%E5%8C%96-webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><div class="truncate" style="padding-left:32px">1）优化 Webpack 的构建速度</div></a></li><li id="### 2）使用webpack4-优化原因" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#2%E4%BD%BF%E7%94%A8webpack4-%E4%BC%98%E5%8C%96%E5%8E%9F%E5%9B%A0"><div class="truncate" style="padding-left:32px">2）使用webpack4-优化原因</div></a></li><li id="#### noParse" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#noparse"><div class="truncate" style="padding-left:48px">noParse</div></a></li><li id="#### IgnorePlugin" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#ignoreplugin"><div class="truncate" style="padding-left:48px">IgnorePlugin</div></a></li><li id="#### dllPlugin" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#dllplugin"><div class="truncate" style="padding-left:48px">dllPlugin</div></a></li><li id="#### happypack -&gt; thread-loader" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#happypack--%3E-thread-loader"><div class="truncate" style="padding-left:48px">happypack -&gt; thread-loader</div></a></li><li id="#### thread-loader" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#thread-loader"><div class="truncate" style="padding-left:48px">thread-loader</div></a></li><li id="#### 压缩加速——开启多线程压缩" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%8E%8B%E7%BC%A9%E5%8A%A0%E9%80%9F%E2%80%94%E2%80%94%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%8B%E7%BC%A9"><div class="truncate" style="padding-left:48px">压缩加速——开启多线程压缩</div></a></li><li id="### 2）优化 Webpack 的打包体积" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#2%E4%BC%98%E5%8C%96-webpack-%E7%9A%84%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF"><div class="truncate" style="padding-left:32px">2）优化 Webpack 的打包体积</div></a></li><li id="### 3）speed-measure-webpack-plugin" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#3speed-measure-webpack-plugin"><div class="truncate" style="padding-left:32px">3）speed-measure-webpack-plugin</div></a></li><li id="### 4）开发阶段常用的插件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#4%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6"><div class="truncate" style="padding-left:32px">4）开发阶段常用的插件</div></a></li><li id="#### 开启多核压缩" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%BC%80%E5%90%AF%E5%A4%9A%E6%A0%B8%E5%8E%8B%E7%BC%A9"><div class="truncate" style="padding-left:48px">开启多核压缩</div></a></li><li id="#### 监控面板" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E7%9B%91%E6%8E%A7%E9%9D%A2%E6%9D%BF"><div class="truncate" style="padding-left:48px">监控面板</div></a></li><li id="#### 开启一个通知面板" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E9%80%9A%E7%9F%A5%E9%9D%A2%E6%9D%BF"><div class="truncate" style="padding-left:48px">开启一个通知面板</div></a></li><li id="#### 开启打包进度" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%BC%80%E5%90%AF%E6%89%93%E5%8C%85%E8%BF%9B%E5%BA%A6"><div class="truncate" style="padding-left:48px">开启打包进度</div></a></li><li id="#### 开发面板更清晰" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%BC%80%E5%8F%91%E9%9D%A2%E6%9D%BF%E6%9B%B4%E6%B8%85%E6%99%B0"><div class="truncate" style="padding-left:48px">开发面板更清晰</div></a></li><li id="#### 开启窗口的标题" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%BC%80%E5%90%AF%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A0%87%E9%A2%98"><div class="truncate" style="padding-left:48px">开启窗口的标题</div></a></li><li id="#### friendly-errors-webpack-plugin" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#friendly-errors-webpack-plugin"><div class="truncate" style="padding-left:48px">friendly-errors-webpack-plugin</div></a></li><li id="## webpack hash chunkhash contenthash" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack-hash-chunkhash-contenthash"><div class="truncate" style="padding-left:16px">webpack hash chunkhash contenthash</div></a></li><li id="### hash" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#hash"><div class="truncate" style="padding-left:32px">hash</div></a></li><li id="### chunkhash" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#chunkhash"><div class="truncate" style="padding-left:32px">chunkhash</div></a></li><li id="### contenthash" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#contenthash"><div class="truncate" style="padding-left:32px">contenthash</div></a></li><li id="## Tree-Shaking的工作原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#tree-shaking%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">Tree-Shaking的工作原理</div></a></li><li id="### 利用ES6模块特性：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%88%A9%E7%94%A8es6%E6%A8%A1%E5%9D%97%E7%89%B9%E6%80%A7"><div class="truncate" style="padding-left:32px">利用ES6模块特性：</div></a></li><li id="### 代码删除" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BB%A3%E7%A0%81%E5%88%A0%E9%99%A4"><div class="truncate" style="padding-left:32px">代码删除</div></a></li><li id="### 实现原理可以简单的概况：" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E7%9A%84%E6%A6%82%E5%86%B5"><div class="truncate" style="padding-left:32px">实现原理可以简单的概况：</div></a></li><li id="## webpack插件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E6%8F%92%E4%BB%B6"><div class="truncate" style="padding-left:16px">webpack插件</div></a></li><li id="### webpack构建的主要钩子" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E6%9E%84%E5%BB%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E9%92%A9%E5%AD%90"><div class="truncate" style="padding-left:32px">webpack构建的主要钩子</div></a></li><li id="#### Compiler钩子" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#compiler%E9%92%A9%E5%AD%90"><div class="truncate" style="padding-left:48px">Compiler钩子</div></a></li><li id="#### Compilation钩子" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#compilation%E9%92%A9%E5%AD%90"><div class="truncate" style="padding-left:48px">Compilation钩子</div></a></li><li id="## dev-server是怎么跑起来" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#dev-server%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5"><div class="truncate" style="padding-left:16px">dev-server是怎么跑起来</div></a></li><li id="## 使用过webpack里面哪些plugin和loader" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BD%BF%E7%94%A8%E8%BF%87webpack%E9%87%8C%E9%9D%A2%E5%93%AA%E4%BA%9Bplugin%E5%92%8Cloader"><div class="truncate" style="padding-left:16px">使用过webpack里面哪些plugin和loader</div></a></li><li id="## webpack整个生命周期，loader和plugin有什么区别" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E6%95%B4%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9Floader%E5%92%8Cplugin%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><div class="truncate" style="padding-left:16px">webpack整个生命周期，loader和plugin有什么区别</div></a></li><li id="### Loader开发思路" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#loader%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF"><div class="truncate" style="padding-left:32px">Loader开发思路</div></a></li><li id="### Plugin开发思路" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#plugin%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF"><div class="truncate" style="padding-left:32px">Plugin开发思路</div></a></li><li id="## webpack打包的整个过程" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E6%89%93%E5%8C%85%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B"><div class="truncate" style="padding-left:16px">webpack打包的整个过程</div></a></li><li id="## 一般怎么组织CSS（Webpack）" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E7%BB%84%E7%BB%87csswebpack"><div class="truncate" style="padding-left:16px">一般怎么组织CSS（Webpack）</div></a></li><li id="## 如何配置把js、css、html单独打包成一个文件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%8A%8Ajscsshtml%E5%8D%95%E7%8B%AC%E6%89%93%E5%8C%85%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><div class="truncate" style="padding-left:16px">如何配置把js、css、html单独打包成一个文件</div></a></li><li id="## 使用webpack构建时有无做一些自定义操作" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BD%BF%E7%94%A8webpack%E6%9E%84%E5%BB%BA%E6%97%B6%E6%9C%89%E6%97%A0%E5%81%9A%E4%B8%80%E4%BA%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C"><div class="truncate" style="padding-left:16px">使用webpack构建时有无做一些自定义操作</div></a></li><li id="## webpack的热更新是如何做到的？说明其原理？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84%E8%AF%B4%E6%98%8E%E5%85%B6%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:16px">webpack的热更新是如何做到的？说明其原理？</div></a></li><li id="## loader原理，css-loader与style-loader" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#loader%E5%8E%9F%E7%90%86css-loader%E4%B8%8Estyle-loader"><div class="truncate" style="padding-left:16px">loader原理，css-loader与style-loader</div></a></li><li id="## 什么是loader？有哪些常见的loader？怎么配置loader？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BB%80%E4%B9%88%E6%98%AFloader%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84loader%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AEloader"><div class="truncate" style="padding-left:16px">什么是loader？有哪些常见的loader？怎么配置loader？</div></a></li><li id="## 什么是plugin？有哪些常见的plugin？怎么配置plugin？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BB%80%E4%B9%88%E6%98%AFplugin%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84plugin%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AEplugin"><div class="truncate" style="padding-left:16px">什么是plugin？有哪些常见的plugin？怎么配置plugin？</div></a></li><li id="## 什么是文件指纹" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9"><div class="truncate" style="padding-left:16px">什么是文件指纹</div></a></li><li id="## 什么是Source Map？怎么配置？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BB%80%E4%B9%88%E6%98%AFsource-map%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE"><div class="truncate" style="padding-left:16px">什么是Source Map？怎么配置？</div></a></li><li id="### Source Map概念" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#source-map%E6%A6%82%E5%BF%B5"><div class="truncate" style="padding-left:32px">Source Map概念</div></a></li><li id="### Source Map原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#source-map%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:32px">Source Map原理</div></a></li><li id="### 怎么配置Source Map" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AEsource-map"><div class="truncate" style="padding-left:32px">怎么配置Source Map</div></a></li><li id="## 了解过Tree-shaking吗？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BA%86%E8%A7%A3%E8%BF%87tree-shaking%E5%90%97"><div class="truncate" style="padding-left:16px">了解过Tree-shaking吗？</div></a></li><li id="### 概念" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E6%A6%82%E5%BF%B5"><div class="truncate" style="padding-left:32px">概念</div></a></li><li id="### 原理" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E5%8E%9F%E7%90%86"><div class="truncate" style="padding-left:32px">原理</div></a></li><li id="### 配置" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E9%85%8D%E7%BD%AE"><div class="truncate" style="padding-left:32px">配置</div></a></li><li id="## 什么是HMR，原理是什么" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E4%BB%80%E4%B9%88%E6%98%AFhmr%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><div class="truncate" style="padding-left:16px">什么是HMR，原理是什么</div></a></li><li id="## 有没有写过自定义的loader？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E6%9C%89%E6%B2%A1%E6%9C%89%E5%86%99%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84loader"><div class="truncate" style="padding-left:16px">有没有写过自定义的loader？</div></a></li><li id="## 有没有写过自定义的plugin？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E6%9C%89%E6%B2%A1%E6%9C%89%E5%86%99%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84plugin"><div class="truncate" style="padding-left:16px">有没有写过自定义的plugin？</div></a></li><li id="## Webpack打包流程是怎么样的？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><div class="truncate" style="padding-left:16px">Webpack打包流程是怎么样的？</div></a></li><li id="## Webpack事件机制了解吗？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97"><div class="truncate" style="padding-left:16px">Webpack事件机制了解吗？</div></a></li><li id="### Webpack常见的事件" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6"><div class="truncate" style="padding-left:32px">Webpack常见的事件</div></a></li><li id="### Webpack的事件机制" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><div class="truncate" style="padding-left:32px">Webpack的事件机制</div></a></li><li id="## 有了解过Webpack5吗，相比于Webpack4有哪些提升？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87webpack5%E5%90%97%E7%9B%B8%E6%AF%94%E4%BA%8Ewebpack4%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8F%90%E5%8D%87"><div class="truncate" style="padding-left:16px">有了解过Webpack5吗，相比于Webpack4有哪些提升？</div></a></li><li id="## 讲一下你对模块联邦的理解？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E6%A8%A1%E5%9D%97%E8%81%94%E9%82%A6%E7%9A%84%E7%90%86%E8%A7%A3"><div class="truncate" style="padding-left:16px">讲一下你对模块联邦的理解？</div></a></li><li id="## Webpack怎么优化开发环境？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><div class="truncate" style="padding-left:16px">Webpack怎么优化开发环境？</div></a></li><li id="## Webpack怎么优化打包结果？" class="border-0 !border-l-2 border-solid border-transparent pr-[16px] text-base"><a class="w-full overflow-hidden !text-[#515767] !hover:text-slate-600 !dark:hover:text-slate-300" href="/frontend/articles/615#webpack%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E7%BB%93%E6%9E%9C"><div class="truncate" style="padding-left:16px">Webpack怎么优化打包结果？</div></a></li></ul></div></div></div></div></div></div></div></div></div><div style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/615","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/615/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/615/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/615/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/615","id":2131539507,"node_id":"I_kwDOBiJZIc5_DLYz","number":615,"title":"Webpack相关的面试题","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536123165,"node_id":"LA_kwDOBiJZIc8AAAABhZVTHQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/webpack","name":"webpack","color":"923874","default":false,"description":"分类-Webpack相关"},{"id":6552343574,"node_id":"LA_kwDOBiJZIc8AAAABhozUFg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview","name":"interview","color":"79D677","default":false,"description":"分类-面试题相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-13T06:15:51Z","updated_at":"2024-02-13T08:51:38Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"---\r\n\r\ntitle: Webpack相关的面试题\r\n\r\ndate: 2024-02-13 16:51:37\r\n\r\ntag: [blog, interview, webpack]\r\n\r\n---\r\n\r\n## webpack 打包优化的四种方法（多进程打包，多进程压缩，资源 CDN，动态 polyfill）\r\n\r\n### 打包分析\r\n\r\n#### 1. 速度分析\r\n\r\n我们的目的是优化打包速度，那肯定需要一个速度分析插件，此时 `speed-measure-webpack-plugin` 就派上用场了。它的作用如下：\r\n\r\n- 分析整个打包总耗时\r\n- 每个 plugin 和 loader 的耗时情况\r\n\r\n安装插件\r\n\r\n``` shell\r\nnpm install --save-dev speed-measure-webpack-plugin\r\n```\r\n\r\n使用插件\r\n\r\n修改配置webpack.config.js文件\r\n\r\n``` js\r\n// 导入速度分析插件\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\n\r\n// 实例化速度分析插件\r\nconst smp = new SpeedMeasurePlugin();\r\n\r\nconst webpackConfig = smp.wrap({\r\n  entry: {\r\n    // ...\r\n  },\r\n  output: {\r\n    // ...\r\n  },\r\n  resolve: {\r\n    // ...\r\n  },\r\n  module: {\r\n    rules: [\r\n      // ....\r\n    ]\r\n  },\r\n  plugins: [new MyPlugin(), new MyOtherPlugin()],\r\n});\r\n\r\nmodule.exports = webpackConfig;\r\n```\r\n\r\n运行打包命令之后，可以看到，打包总耗时为 `15.48 secs`\r\n\r\n效果如下所示:\r\n\r\n![Webpack优化_speed-measure-webpack-plugin 打包速度](https://user-images.githubusercontent.com/8088864/126053799-541740e0-922b-45c0-949d-6a91fc64f759.png)\r\n\r\n\r\n#### 2. 体积分析\r\n\r\n分析完打包速度之后，接着我们来分析打包之后每个文件以及每个模块对应的体积大小。使用到的插件为 `webpack-bundle-analyzer`，构建完成后会在 8888 端口展示大小。\r\n\r\n安装插件\r\n\r\n``` shell\r\nnpm install --save-dev webpack-bundle-analyzer\r\n```\r\n\r\n使用插件\r\n\r\n修改配置webpack.config.js文件\r\n\r\n``` js\r\n// 导入速度分析插件\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\n\r\n// 导入体积分析插件\r\nconst BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\r\n\r\n// 实例化速度分析插件\r\nconst smp = new SpeedMeasurePlugin();\r\n\r\nconst webpackConfig = smp.wrap({\r\n  entry: {\r\n    // ...\r\n  },\r\n  output: {\r\n    // ...\r\n  },\r\n  resolve: {\r\n    // ...\r\n  },\r\n  module: {\r\n    rules: [\r\n      // ....\r\n    ]\r\n  },\r\n  plugins: [\r\n    // 实例化体积分析插件\r\n    new BundleAnalyzerPlugin(),\r\n    new MyPlugin(),\r\n    new MyOtherPlugin(),\r\n  ],\r\n});\r\n\r\nmodule.exports = webpackConfig;\r\n```\r\n\r\n构建之后可以看到，其中黄色块 `chunk-vendors` 文件占比最大，为 `1.34MB`\r\n\r\n效果如下所示:\r\n\r\n![Webpack优化_webpack-bundle-analyzer 打包体积分析](https://user-images.githubusercontent.com/8088864/126053872-dca114ab-7a88-44ad-8456-6be4a4ce5510.png)\r\n\r\n### 打包优化\r\n\r\n#### 1. 多进程多实例构建，资源并行解析\r\n\r\n多进程构建的方案比较知名的有以下三个：\r\n\r\n- thread-loader (推荐使用这个)\r\n- parallel-webpack\r\n- HappyPack\r\n\r\n这里以 `thread-loader` 为例配置多进程多实例构建\r\n\r\n安装 loader\r\n\r\n``` shell\r\nnpm install --save-dev thread-loader\r\n```\r\n\r\n使用 loader\r\n\r\n修改配置webpack.config.js文件\r\n\r\n``` js\r\nconst path = require(\"path\");\r\n// 导入速度分析插件\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\n\r\n// 实例化速度分析插件\r\nconst smp = new SpeedMeasurePlugin();\r\n\r\nconst webpackConfig = smp.wrap({\r\n  entry: {\r\n    // ...\r\n  },\r\n  output: {\r\n    // ...\r\n  },\r\n  resolve: {\r\n    // ...\r\n  },\r\n  module: {\r\n    rules: [\r\n      rules: [\r\n        {\r\n          test: /\\.js$/,\r\n          include: path.resolve('src'),\r\n          use: [\r\n            'thread-loader',\r\n            // your expensive loader (e.g babel-loader)\r\n          ],\r\n        }\r\n      ]\r\n    ]\r\n  },\r\n  plugins: [\r\n    new MyPlugin(),\r\n    new MyOtherPlugin(),\r\n  ],\r\n});\r\n\r\nmodule.exports = webpackConfig;\r\n```\r\n\r\n#### 2. 公用代码提取，使用 CDN 加载\r\n\r\n以vue.js构建的项目为例，里面很多的第三方库只要不升级对应的版本其内容是不变的，我们可以将这些内用文件不通过webpack打包到模块里面，而是使用CDN加载，例如对于vue，vuex，vue-router，axios，echarts，swiper等第三方库我们可以利用webpack的externals参数来配置，这里我们设定只需要在生产环境中才需要使用。\r\n\r\n这里需要使用 `html-webpack-plugin` 和 `webpack-cdn-plugin` 两个插件\r\n\r\n安装插件\r\n\r\n``` shell\r\nnpm install --save-dev html-webpack-plugin, webpack-cdn-plugin\r\n```\r\n\r\n使用插件\r\n\r\n修改配置webpack.config.js文件\r\n\r\n``` js\r\nconst path = require(\"path\");\r\n// 导入速度分析插件\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\n\r\n// 导入体积分析插件\r\nconst BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\r\n\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\n//判断是否为生产环境\r\nconst isProduction = process.env.NODE_ENV === 'production';\r\n\r\n// 实例化速度分析插件\r\nconst smp = new SpeedMeasurePlugin();\r\n\r\n//定义 CDN 路径，这里采用 bootstrap 的 cdn\r\nconst cdn = {\r\n    css: [\r\n        'https://cdn.bootcss.com/Swiper/4.5.1/css/swiper.min.css'\r\n    ],\r\n    js: [\r\n        'https://cdn.bootcss.com/vue/2.6.10/vue.min.js',\r\n        'https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js',\r\n        'https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js',\r\n        'https://cdn.bootcss.com/axios/0.19.0/axios.min.js',\r\n        'https://cdn.bootcss.com/echarts/4.3.0/echarts.min.js',\r\n        'https://cdn.bootcss.com/Swiper/4.5.1/js/swiper.min.js',\r\n    ]\r\n}\r\n\r\nconst webpackConfig = smp.wrap({\r\n  entry: {\r\n    // ...\r\n  },\r\n  output: {\r\n    // ...\r\n  },\r\n  resolve: {\r\n    // ...\r\n  },\r\n  //生产环境注入 cdn\r\n  externals: isProduction \u0026\u0026 {\r\n    'vue': 'Vue',\r\n    'vuex': 'Vuex',\r\n    'vue-router': 'VueRouter',\r\n    'axios': 'axios',\r\n    'echarts': 'echarts',\r\n    'swiper': 'Swiper'\r\n  } || {},\r\n  module: {\r\n    rules: [\r\n      rules: [\r\n        {\r\n          test: /\\.js$/,\r\n          include: path.resolve('src'),\r\n          use: [\r\n            'thread-loader',\r\n            // your expensive loader (e.g babel-loader)\r\n          ],\r\n        }\r\n      ]\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({ filename: '../index.html' }), // output file relative to output.path\r\n    new WebpackCdnPlugin({\r\n      modules: [\r\n        {\r\n          name: 'vue',\r\n          var: 'Vue',\r\n          path: 'vue.min.js'\r\n        },\r\n        {\r\n          name: 'vuex',\r\n          var: 'Vuex',\r\n          path: 'vuex.min.js'\r\n        }\r\n        {\r\n          name: 'vue-router',\r\n          var: 'VueRouter',\r\n          path: 'vue-router.min.js'\r\n        },\r\n        {\r\n          name: 'axios',\r\n          var: 'axios',\r\n          path: 'axios.min.js'\r\n        }\r\n        {\r\n          name: 'echarts',\r\n          var: 'echarts',\r\n          path: 'echarts.min.js'\r\n        },\r\n        {\r\n          name: 'swiper',\r\n          var: 'Swiper',\r\n          path: 'swiper.min.js'\r\n        },\r\n      ],\r\n      prod: isProduction,\r\n      prodUrl: '//cdn.bootcdn.net/ajax/libs/:name/:version/:path' // =\u003e https://cdn.bootcdn.net/ajax/libs/xxx/xxx/xxx(`:name`,`:version`和`:path`为模板变量)\r\n      publicPath: '/node_modules/dist', // override when prod is false\r\n    }),\r\n    new MyPlugin(),\r\n    new MyOtherPlugin(),\r\n  ],\r\n});\r\n\r\nmodule.exports = webpackConfig;\r\n```\r\n\r\n最终生成的inde.html文件如下所示:\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml\u003e\r\n  \u003chead\u003e\r\n    \u003cmeta charset=\"UTF-8\"\u003e\r\n    \u003ctitle\u003eWebpack App\u003c/title\u003e\r\n    \u003clink href=\"https://cdn.bootcdn.net/ajax/libs/Swiper/6.7.5/swiper-bundle.min.css\" rel=\"stylesheet\"\u003e\r\n  \u003c/head\u003e\r\n  \u003cbody\u003e\r\n  \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.13/vue.min.js\"\u003e\u003c/script\u003e\r\n  \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcdn.net/ajax/libs/vue-router/3.1.3/vue-router.min.js\"\u003e\u003c/script\u003e\r\n  \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcdn.net/ajax/libs/vuex/3.1.1/vuex.min.js\"\u003e\u003c/script\u003e\r\n  \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.19.0/axios.min.js\"\u003e\u003c/script\u003e\r\n  \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcdn.net/ajax/libs/echarts/4.3.0/echarts.min.js\"\u003e\u003c/script\u003e\r\n  \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcdn.net/ajax/libs/Swiper/6.7.5/js/swiper.min.js\"\u003e\u003c/script\u003e\r\n  \u003cscript type=\"text/javascript\" src=\"/assets/app.js\"\u003e\u003c/script\u003e\r\n  \u003c/body\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n#### 3. 多进程多实例并行压缩\r\n\r\n并行压缩主流有以下三种方案\r\n\r\n- 使用 parallel-uglify-plugin 插件\r\n- uglifyjs-webpack-plugin 开启 parallel 参数\r\n- terser-webpack-plugin 开启 parallel 参数 （推荐使用这个，支持 ES6 语法压缩）\r\n\r\n安装插件\r\n\r\n``` shell\r\nnpm install --save-dev terser-webpack-plugin\r\n```\r\n\r\n使用插件\r\n\r\n修改配置webpack.config.js文件\r\n\r\n``` js\r\nconst path = require(\"path\");\r\n// 导入速度分析插件\r\nconst SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\");\r\n\r\n// 导入代码压缩插件\r\nconst TerserPlugin = require(\"terser-webpack-plugin\");\r\n\r\n// 导入体积分析插件\r\nconst BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;\r\n\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\n//判断是否为生产环境\r\nconst isProduction = process.env.NODE_ENV === 'production';\r\n\r\n// 实例化速度分析插件\r\nconst smp = new SpeedMeasurePlugin();\r\n\r\n//定义 CDN 路径，这里采用 bootstrap 的 cdn\r\nconst cdn = {\r\n    css: [\r\n        'https://cdn.bootcss.com/Swiper/4.5.1/css/swiper.min.css'\r\n    ],\r\n    js: [\r\n        'https://cdn.bootcss.com/vue/2.6.10/vue.min.js',\r\n        'https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js',\r\n        'https://cdn.bootcss.com/vuex/3.1.1/vuex.min.js',\r\n        'https://cdn.bootcss.com/axios/0.19.0/axios.min.js',\r\n        'https://cdn.bootcss.com/echarts/4.3.0/echarts.min.js',\r\n        'https://cdn.bootcss.com/Swiper/4.5.1/js/swiper.min.js',\r\n    ]\r\n}\r\n\r\nconst webpackConfig = smp.wrap({\r\n  entry: {\r\n    // ...\r\n  },\r\n  output: {\r\n    // ...\r\n  },\r\n  resolve: {\r\n    // ...\r\n  },\r\n  module: {\r\n    rules: [\r\n      rules: [\r\n        {\r\n          test: /\\.js$/,\r\n          include: path.resolve('src'),\r\n          use: [\r\n            'thread-loader',\r\n            // your expensive loader (e.g babel-loader)\r\n          ],\r\n        }\r\n      ]\r\n    ]\r\n  },\r\n  //生产环境注入 cdn\r\n  externals: isProduction \u0026\u0026 {\r\n    'vue': 'Vue',\r\n    'vuex': 'Vuex',\r\n    'vue-router': 'VueRouter',\r\n    'axios': 'axios',\r\n    'echarts': 'echarts',\r\n    'swiper': 'Swiper'\r\n  } || {},\r\n  optimization: {\r\n    minimizer: [\r\n      new TerserPlugin({\r\n        parallel: 4\r\n      })\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({ filename: '../index.html' }), // output file relative to output.path\r\n    new WebpackCdnPlugin({\r\n      modules: [\r\n        {\r\n          name: 'vue',\r\n          var: 'Vue',\r\n          path: 'vue.min.js'\r\n        },\r\n        {\r\n          name: 'vuex',\r\n          var: 'Vuex',\r\n          path: 'vuex.min.js'\r\n        }\r\n        {\r\n          name: 'vue-router',\r\n          var: 'VueRouter',\r\n          path: 'vue-router.min.js'\r\n        },\r\n        {\r\n          name: 'axios',\r\n          var: 'axios',\r\n          path: 'axios.min.js'\r\n        }\r\n        {\r\n          name: 'echarts',\r\n          var: 'echarts',\r\n          path: 'echarts.min.js'\r\n        },\r\n        {\r\n          name: 'swiper',\r\n          var: 'Swiper',\r\n          path: 'swiper.min.js'\r\n        },\r\n      ],\r\n      prod: isProduction,\r\n      prodUrl: '//cdn.bootcdn.net/ajax/libs/:name/:version/:path' // =\u003e https://cdn.bootcdn.net/ajax/libs/xxx/xxx/xxx(`:name`,`:version`和`:path`为模板变量)\r\n      publicPath: '/node_modules/dist', // override when prod is false\r\n    }),\r\n    new MyPlugin(),\r\n    new MyOtherPlugin(),\r\n  ],\r\n});\r\n\r\nmodule.exports = webpackConfig;\r\n```\r\n\r\n#### 4. 使用 polyfill 动态服务\r\n\r\nPolyfill 可以为旧浏览器提供和标准 API 一样的功能。比如你想要 IE 浏览器实现 Promise 和 fetch 功能，你需要手动引入 es6-promise、whatwg-fetch。而通过 Polyfill.io，你只需要引入一个 JS 文件。\r\n\r\nPolyfill.io 通过分析请求头信息中的 UserAgent 实现自动加载浏览器所需的 polyfills。 Polyfill.io 有一份默认功能列表，包括了最常见的 polyfills：document.querySelector、Element.classList、ES5 新增的 Array 方法、Date.now、ES6 中的 Object.assign、Promise 等。\r\n\r\n动态 `polyfill` 指的是根据不同的浏览器，动态载入需要的 `polyfill`。 `Polyfill.io` 通过尝试使用 `polyfill` 重新创建缺少的功能，可以更轻松地支持不同的浏览器，并且可以大幅度的减少构建体积。\r\n\r\nPolyfill Service 原理\r\n\r\n识别 User Agent，下发不同的 Polyfill\r\n\r\n![Webpack polyfill 服务](https://user-images.githubusercontent.com/8088864/126054825-2e1a0e44-2eb7-4668-b044-de846427e577.png)\r\n\r\n使用方法：\r\n\r\n在 index.html 中引入如下 script 标签\r\n\r\n``` html\r\n\u003c!DOCTYPE html\u003e\r\n\u003chtml lang=\"en\"\u003e\r\n\u003chead\u003e\r\n\u003cmeta charset=\"UTF-8\"\u003e\r\n\u003ctitle\u003eDocument\u003c/title\u003e\r\n\u003c/head\u003e\r\n\u003cbody\u003e\r\n\u003c/body\u003e\r\n\u003cscript src=\"https://cdn.polyfill.io/v2/polyfill.min.js?callback=main\" async defer\u003e\u003c/script\u003e\r\n\u003cscript\u003e\r\nfunction main () {\r\n  var node=document.createElement(\"script\");\r\n  node.src=\"index.js\";\r\n  document.body.appendChild(node);\r\n}\r\n\u003c/script\u003e\r\n\u003c/html\u003e\r\n```\r\n\r\n## webpack 做过哪些优化，开发效率方面、打包策略方面等等\r\n\r\n### 1）优化 Webpack 的构建速度\r\n\r\n- 使用高版本的 Webpack （使用webpack4）\r\n- 多线程/多实例构建：HappyPack(不维护了)、thread-loader\r\n- 缩小打包作用域：\r\n  - exclude/include (确定 loader 规则范围)\r\n  - resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)\r\n  - resolve.extensions 尽可能减少后缀尝试的可能性\r\n  - noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)\r\n  - IgnorePlugin (完全排除模块)\r\n  - 合理使用alias\r\n- 充分利用缓存提升二次构建速度：\r\n  - babel-loader 开启缓存\r\n  - terser-webpack-plugin 开启缓存\r\n  - 使用 cache-loader 或者 hard-source-webpack-plugin\r\n    注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader\r\n- DLL：\r\n  - 使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。\r\n\r\n### 2）使用webpack4-优化原因\r\n\r\n1. V8带来的优化（for of替代forEach、Map和Set替代Object、includes替代indexOf）\r\n2. 默认使用更快的md4 hash算法\r\n3. webpacks AST可以直接从loader传递给AST，减少解析时间\r\n4. 使用字符串方法替代正则表达式\r\n\r\n#### noParse\r\n\r\n- 不去解析某个库内部的依赖关系\r\n- 比如jquery 这个库是独立的， 则不去解析这个库内部依赖的其他的东西\r\n- 在独立库的时候可以使用\r\n\r\n``` js\r\nmodule.exports = {\r\n  module: {\r\n    noParse: /jquery/,\r\n    rules:[]\r\n  }\r\n}\r\n```\r\n\r\n#### IgnorePlugin\r\n\r\n- 忽略掉某些内容 不去解析依赖库内部引用的某些内容\r\n- 从moment中引用 ./locol 则忽略掉\r\n- 如果要用local的话 则必须在项目中必须手动引入 import 'moment/locale/zh-cn'\r\n\r\n``` js\r\nmodule.exports = {\r\n  plugins: [\r\n    new Webpack.IgnorePlugin(/./local/, /moment/),\r\n  ]\r\n}\r\n```\r\n\r\n#### dllPlugin\r\n\r\n- 不会多次打包， 优化打包时间\r\n- 先把依赖的不变的库打包\r\n- 生成 manifest.json文件\r\n- 然后在webpack.config中引入\r\n- webpack.DllPlugin Webpack.DllReferencePlugin\r\n\r\n#### happypack -\u003e thread-loader\r\n\r\n- 大项目的时候开启多线程打包\r\n- 影响前端发布速度的有两个方面，一个是构建，一个就是压缩，把这两个东西优化起来，可以减少很多发布的时间。\r\n\r\n#### thread-loader\r\n\r\nthread-loader 会将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建。\r\n把这个 loader 放置在其他 loader 之前（如下图 example 的位置）， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。\r\n\r\n``` js\r\n// webpack.config.js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        include: path.resolve(\"src\"),\r\n        use: [\r\n          \"thread-loader\",\r\n          // 你的高开销的loader放置在此 (e.g babel-loader)\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。请在高开销的loader中使用，否则效果不佳\r\n\r\n#### 压缩加速——开启多线程压缩\r\n\r\n- 不推荐使用 webpack-paralle-uglify-plugin，项目基本处于没人维护的阶段，issue 没人处理，pr没人合并。\r\n  Webpack 4.0以前：uglifyjs-webpack-plugin，parallel参数\r\n\r\n``` js\r\nmodule.exports = {\r\n  optimization: {\r\n    minimizer: [\r\n      new UglifyJsPlugin({\r\n        parallel: true,\r\n      }),\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n- 推荐使用 terser-webpack-plugin\r\n\r\n``` js\r\nmodule.exports = {\r\n  optimization: {\r\n    minimizer: [\r\n      new TerserPlugin({\r\n        parallel: true   // 多线程\r\n      })\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n### 2）优化 Webpack 的打包体积\r\n\r\n- 压缩代码\r\n  - webpack-paralle-uglify-plugin\r\n  - uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)\r\n  - terser-webpack-plugin 开启 parallel 参数\r\n  - 多进程并行压缩\r\n  - 通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过optimize-css-assets-webpack-plugin插件 开启 cssnano 压缩 CSS。\r\n- 提取页面公共资源\r\n  - 使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中\r\n  - 使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件\r\n  - 基础包分离：将一些基础库放到cdn，比如vue，webpack 配置 external是的vue不打入bundle\r\n- Tree shaking\r\n  - purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)\r\n  - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率\r\n  - 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking\r\n  - 使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码\r\n- Scope hosting\r\n  - 构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hosting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突\r\n  - 必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hosting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法\r\n- 图片压缩\r\n  - 使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)\r\n  - 配置 image-webpack-loader\r\n- 动态Polyfill\r\n  - 建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。(部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)\r\n  - @babel-preset-env 中通过useBuiltIns: 'usage参数来动态加载polyfill。\r\n\r\n### 3）speed-measure-webpack-plugin\r\n\r\n简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。\r\n\r\n### 4）开发阶段常用的插件\r\n\r\n#### 开启多核压缩\r\n\r\n插件：**terser-webpack-plugin**\r\n\r\n``` js\r\nconst TerserPlugin = require('terser-webpack-plugin')\r\nmodule.exports = {\r\n  optimization: {\r\n    minimizer: [\r\n      new TerserPlugin({\r\n        parallel: true,\r\n        terserOptions: {\r\n          ecma: 6,\r\n        },\r\n      }),\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n#### 监控面板\r\n\r\n插件：**speed-measure-webpack-plugin**\r\n\r\n在打包的时候显示出每一个loader,plugin所用的时间，来精准优化\r\n\r\n``` js\r\n// webpack.config.js文件\r\nconst SpeedMeasurePlugin = require('speed-measure-webpack-plugin');\r\nconst smp = new SpeedMeasurePlugin();\r\n//............\r\n// 用smp.warp()包裹一下合并的config\r\nmodule.exports = smp.wrap(merge(_mergeConfig, webpackConfig));\r\n```\r\n\r\n#### 开启一个通知面板\r\n\r\n插件：**webpack-build-notifier**\r\n\r\n``` js\r\n// webpack.config.js文件\r\nconst WebpackBuildNotifierPlugin = require('webpack-build-notifier');\r\nconst webpackConfig= {\r\n  plugins: [\r\n    new WebpackBuildNotifierPlugin({\r\n      title: '我的webpack',\r\n      // logo: path.resolve('./img/favicon.png'),\r\n      suppressSuccess: true\r\n    })\r\n  ]\r\n}\r\n```\r\n\r\n#### 开启打包进度\r\n\r\n插件：**progress-bar-webpack-plugin**\r\n\r\n``` js\r\n// webpack.config.js文件\r\nconst ProgressBarPlugin = require('progress-bar-webpack-plugin');\r\nconst webpackConfig= {\r\n  plugins: [\r\n    new ProgressBarPlugin(),\r\n  ]\r\n}\r\n```\r\n\r\n#### 开发面板更清晰\r\n\r\n插件：**webpack-dashboard**\r\n\r\n``` js\r\n// webpack.config.js文件\r\nconst DashboardPlugin = require('webpack-dashboard/plugin');\r\nconst webpackConfig= {\r\n  plugins: [\r\n    new DashboardPlugin()\r\n  ]\r\n}\r\n```\r\n\r\n``` json\r\n// package.json文件\r\n{\r\n  \"scripts\": {\r\n    \"dev\": \"webpack-dashboard webpack --mode development\",\r\n  },\r\n}\r\n```\r\n\r\n#### 开启窗口的标题\r\n\r\n第三方库: **node-bash-title**\r\n\r\n这个包mac的item用有效果，windows暂时没看到效果\r\n\r\n``` js\r\n// webpack.config.js文件\r\nconst setTitle = require('node-bash-title');\r\nsetTitle('server');\r\n```\r\n\r\n#### friendly-errors-webpack-plugin\r\n\r\n插件：**friendly-errors-webpack-plugin**\r\n\r\n``` js\r\nconst webpackConfig= {\r\n  plugins: [\r\n    new FriendlyErrorsWebpackPlugin({\r\n      compilationSuccessInfo: {\r\n        messages: ['You application is running here http://localhost:3000'],\r\n        notes: ['Some additionnal notes to be displayed unpon successful compilation']\r\n      },\r\n      onErrors: function (severity, errors) {\r\n        // You can listen to errors transformed and prioritized by the plugin\r\n        // severity can be 'error' or 'warning'\r\n      },\r\n      // should the console be cleared between each compilation?\r\n      // default is true\r\n      clearConsole: true,\r\n\r\n      // add formatters and transformers (see below)\r\n      additionalFormatters: [],\r\n      additionalTransformers: []\r\n    }),\r\n  ]\r\n}\r\n```\r\n\r\n## webpack hash chunkhash contenthash\r\n\r\nWebpack里面有三种hash，分别是：hash, chunkhash, contenthash\r\n\r\n我们的浏览器会缓存我们的文件。缓存是把双刃剑，好处是浏览器读取缓存的文件，能带来更佳的用户体验（不需要额外流量，速度更快）；坏处是有时候我们修改了文件内容，但是浏览器依然读取缓存的文件（也就是旧文件），导致用户看到的文件不是最新的。\r\n\r\nhash能够帮助我们缓存已经及时的更新缓存文件。\r\n\r\n### hash\r\n\r\nhash是项目级别的，多个入口文件输出的所有构建的文件是使用同一个hash。\r\n\r\n缺点是假如我只改了其中一个文件，但是所有文件的文件名里面的hash都是一样的。这样会导致本来应该被浏览器缓存的文件，强制要去服务器读取一遍，但是这个文件又和之前的旧文件并没有区别，这样就很不好了。那能不能做到只有改变了文件，hash值才变，而没有改变的文件，文件名里面的hash值就不变呢？答案就是chunkhash。\r\n\r\n### chunkhash\r\n\r\nchunkhash是模块级别的，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成hash值，那么只要我们不改动公共库的代码，就可以保证其hash值不会受影响。\r\n\r\n缺点就是一般我们会将css单独提取到一个文件中，当我们改变依赖的css文件的js文件的时候，依赖他的其它们文件构建的文件的hash值也会发送改变，即使我们的css文件并没有任何的改变，单独提取出来的css文件的hash值也发生了改变。\r\n\r\n### contenthash\r\n\r\ncontenthash是文件级别的。\r\n\r\ncontenthash表示由文件内容产生的hash值，内容不同产生的contenthash值也不一样。在项目中，通常做法是把项目中css都抽离出对应的css文件来加以引用。\r\n\r\n## Tree-Shaking的工作原理\r\n\r\nTree-shaking （树摇）最早是由Rollup实现，是一种采用删除不需要的额外代码的方式优化代码体积的技术，webpack2借鉴了这个特性也增加了tree-shaking的功能。\r\n\r\ntree-shaking 只能在静态modules下工作，在ES6之前我们使用CommonJS规范引入模块，具体采用require()的方式动态引入模块，这个特性可以通过判断条件解决按需记载的优化问题\r\n\r\n是CommonJS规范无法确定在实际运行前需要或者不需要某些模块，所以CommonJS不适合tree-shaking机制。\r\n\r\n在JavaScript模块话方案中，只有ES6的模块方案：import()引入模块的方式采用静态导入，可以采用一次导入所有的依赖包再根据条件判断的方式，获取不需要的包，然后执行删除操作。\r\n\r\nTree-shaking的实现原理\r\n\r\n### 利用ES6模块特性：\r\n\r\n1. 只能作为模块顶层的语句出现\r\n2. import的模块名只能是字符串常量\r\n3. 引入的模块不能再进行修改\r\n\r\n### 代码删除\r\n\r\nuglify：判断程序流，判断变量是否被使用和引用，进而删除代码\r\n\r\n### 实现原理可以简单的概况：\r\n\r\n1. ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块\r\n2. 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码\r\n\r\n注:\r\n\r\n- Tree-shaking不能移除export default方式导出的模块而导入的一个整体的模块，所以应该尽量避免使用export default { A, B, C }导出的方式，而应该替换成 export { A, B, C } 的方式到处\r\n\r\n## webpack插件\r\n\r\n1. 编写一个JavaScript命名函数。\r\n2. 在它的原型上定义一个apply方法。\r\n3. 指定挂载的webpack事件钩子。\r\n4. 处理webpack内部实例的特定数据。\r\n5. 功能完成后调用webpack提供的回调。\r\n\r\n### webpack构建的主要钩子\r\n\r\nCompiler暴露了和webpack整个生命周期相关的钩子\r\n\r\n#### Compiler钩子\r\n\r\n- entryOption: 在 entry 配置项处理过之后，执行插件。\r\n\r\n- afterPlugins: 设置完初始插件之后，执行插件。参数：compiler\r\n\r\n- afterResolvers: resolver 安装完成之后，执行插件。参数：compiler\r\n\r\n- environment: environment 准备好之后，执行插件。\r\n\r\n- afterEnvironment: environment 安装完成之后，执行插件。\r\n\r\n- beforeRun: compiler.run() 执行之前，添加一个钩子。参数：compiler\r\n\r\n- run: 开始读取 records 之前，钩入(hook into) compiler。参数：compiler\r\n\r\n- watchRun: 监听模式下，一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前。参数：compiler\r\n\r\n- watchRun: 监听模式下，一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前。参数：compiler\r\n\r\n- normalModuleFactory: NormalModuleFactory 创建之后，执行插件。参数：normalModuleFactory\r\n\r\n- contextModuleFactory: ContextModuleFactory 创建之后，执行插件。参数：contextModuleFactory\r\n\r\n- beforeCompile: 编译(compilation)参数创建之后，执行插件。参数：compilationParams\r\n\r\n- compile: 一个新的编译(compilation)创建之后，钩入(hook into) compiler。参数：compilationParams\r\n\r\n- thisCompilation: 触发 compilation 事件之前执行（查看下面的 compilation）。参数：compilation\r\n\r\n- compilation: 编译(compilation)创建之后，执行插件。参数：compilation\r\n\r\n- make: 分析模块依赖。参数：compilation\r\n\r\n- afterCompile:\r\n\r\n- shouldEmit: 此时返回 true/false。参数：compilation\r\n\r\n- needAdditionalPass:\r\n\r\n- emit: 生成资源到 output 目录之前。参数：compilation\r\n\r\n- afterEmit: 生成资源到 output 目录之后。参数：compilation\r\n\r\n- done: 编译(compilation)完成。参数：stats\r\n\r\n- failed: 编译(compilation)失败。参数：error\r\n\r\n- invalid: 监听模式下，编译无效时。参数：fileName, changeTime\r\n\r\n- watchClose: 监听模式停止\r\n\r\n#### Compilation钩子\r\n\r\nCompilation暴露了与模块和依赖有关的粒度更小的事件钩子。\r\n\r\n在编译阶段，模块会被加载(loaded)、封存(sealed)、优化(optimized)、分块(chunked)、哈希(hashed)和重新创建(restored)。\r\n\r\n从上面的示例可以看到，compilation是Compiler生命周期中的一个步骤，使用compilation相关钩子的通用写法为:\r\n\r\n- buildModule: 在模块构建开始之前触发。参数：module\r\n\r\n- rebuildModule: 在重新构建一个模块之前触发。参数：module\r\n\r\n...\r\n\r\n- seal: 编译(compilation)停止接收新模块时触发。\r\n\r\n- unseal: 编译(compilation)开始接收新模块时触发。\r\n\r\n...\r\n\r\n- optimize: 优化阶段开始时触发。\r\n\r\n## dev-server是怎么跑起来\r\n\r\nwebpack-dev-server 可以作为命令行工具使用，核心模块依赖是 webpack 和 webpack-dev-middleware。webpack-dev-server 负责启动一个 express 服务器监听客户端请求；实例化 webpack compiler；启动负责推送 webpack 编译信息的 websocket 服务器；负责向 bundle.js 注入和服务端通信用的 websocket 客户端代码和处理逻辑。webpack-dev-middleware 把 webpack compiler 的 outputFileSystem 改为 in-memory fileSystem；启动 webpack watch 编译；处理浏览器发出的静态资源的请求，把 webpack 输出到内存的文件响应给浏览器。\r\n\r\n每次 webpack 编译完成后向客户端广播 ok 消息，客户端收到信息后根据是否开启 hot 模式使用 liveReload 页面级刷新模式或者 hotReload 模块热替换。hotReload 存在失败的情况，失败的情况下会降级使用页面级刷新。\r\n\r\n开启 hot 模式，即启用 HMR 插件。hot 模式会向服务器请求更新过后的模块，然后对模块的父模块进行回溯，对依赖路径进行判断，如果每条依赖路径都配置了模块更新后所需的业务处理回调函数则是 accepted 状态，否则就降级刷新页面。判断 accepted 状态后对旧的缓存模块和父子依赖模块进行替换和删除，然后执行 accept 方法的回调函数，执行新模块代码，引入新模块，执行业务处理代码。\r\n\r\nhttps://blog.csdn.net/LuckyWinty/article/details/109507412\r\n\r\n## 使用过webpack里面哪些plugin和loader\r\n\r\n## webpack整个生命周期，loader和plugin有什么区别\r\n\r\nLoader，直译为\"加载器\"。主要是用来解析和检测对应资源，负责源文件从输入到输出的转换，它专注于实现资源模块加载\r\n\r\nPlugin，直译为\"插件\"。主要是通过webpack内部的钩子机制，在webpack构建的不同阶段执行一些额外的工作，它的插件是一个函数或者是一个包含apply方法的对象，接受一个compile对象，通过webpack的钩子来处理资源\r\n\r\n### Loader开发思路\r\n\r\n- 通过module.exports导出一个函数\r\n\r\n- 该函数默认参数一个参数source(即要处理的资源文件)\r\n\r\n- 在函数体中处理资源(loader里配置响应的loader后)\r\n\r\n- 通过return返回最终打包后的结果(这里返回的结果需为字符串形式)\r\n\r\n### Plugin开发思路\r\n\r\n- 通过钩子机制实现\r\n\r\n- 插件必须是一个函数或包含apply方法的对象\r\n\r\n- 在方法体内通过webpack提供的API获取资源做响应处理\r\n\r\n- 将处理完的资源通过webpack提供的方法返回该资源\r\n\r\n## webpack打包的整个过程\r\n\r\n- 初始化参数：根据用户在命令窗口输入的参数以及 webpack.config.js 文件的配置，得到最后的配置。\r\n- 开始编译：根据上一步得到的最终配置初始化得到一个 compiler 对象，注册所有的插件 plugins，插件开始监听 webpack 构建过程的生命周期的环节（事件），不同的环节会有相应的处理，然后开始执行编译。\r\n- 确定入口：根据 webpack.config.js 文件中的 entry 入口，开始解析文件构建 AST 语法树，找出依赖，递归下去。\r\n- 编译模块：递归过程中，根据文件类型和 loader 配置，调用相应的 loader 对不同的文件做不同的转换处理，再找出该模块依赖的模块，然后递归本步骤，直到项目中依赖的所有模块都经过了本步骤的编译处理。\r\n- 编译过程中，有一系列的插件在不同的环节做相应的事情，比如 UglifyPlugin 会在 loader 转换递归完对结果使用 UglifyJs 压缩覆盖之前的结果；再比如 clean-webpack-plugin ，会在结果输出之前清除 dist 目录等等。\r\n- 完成编译并输出：递归结束后，得到每个文件结果，包含转换后的模块以及他们之间的依赖关系，根据 entry 以及 output 等配置生成代码块 chunk。\r\n- 打包完成：根据 output 输出所有的 chunk 到相应的文件目录。\r\n\r\n## 一般怎么组织CSS（Webpack）\r\n\r\n## 如何配置把js、css、html单独打包成一个文件\r\n\r\n## 使用webpack构建时有无做一些自定义操作\r\n\r\n## webpack的热更新是如何做到的？说明其原理？\r\n\r\n## loader原理，css-loader与style-loader\r\n\r\n1. css-loader 的作用是处理css中的 @import 和 url 这样的外部资源\r\n\r\n2. style-loader 的作用是把样式插入到 DOM中，方法是在head中插入一个style标签，并把样式写入到这个标签的 innerHTML里\r\n\r\nloader的原理\r\n\r\nloader能把源文件翻译成新的结果，一个文件可以链式经过多个loader编译。以处理scss文件为例:\r\n\r\n- sass-loader把scss转成css\r\n\r\n- css-loader找出css中的依赖，压缩资源\r\n\r\n- style-loader把css转换成脚本加载的JavaScript代码\r\n\r\n## 什么是loader？有哪些常见的loader？怎么配置loader？\r\n\r\nWebpack默认只认识JS，对于非JS的文件，比方说样式，图片，文件，json等等，就需要一些工具来帮忙翻译。而loader，就是那个翻译官，可以解析非原生JS的代码或文件。\r\n\r\n常见的Webpack loader有：\r\n\r\n- babel-loader：处理ES6的loader。\r\n- css-loader：处理CSS的loader。\r\n- style-loader：将CSS插入到HTML页面中的\u003cstyle\u003e标签的loader。\r\n- less-loader：处理less的loader。\r\n- file-loader：处理文件的loader。\r\n- url-loader：处理文件的loader，类似于file-loader，但可以将小文件转换为Data URL。\r\n- image-webpack-loader：处理图片的loader。\r\n- eslint-loader：运行ESLint检查的loader。\r\n\r\nloader配置步骤：\r\n\r\n1. npm下载对应的loader。\r\n2. 在module选项里配置rules，每个rule是个对象，用来表示对一个文件的处理规则，test表示要处理的文件，use里可以通过配置多个loader来处理。要注意loader的执行顺序为：从下到上，从右到左。\r\n\r\n``` javascript\r\nmodule.exports = {\r\n  // loader\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          { loader: 'style-loader' },\r\n          {\r\n            loader: 'css-loader',\r\n            options: {\r\n              modules: true,\r\n            },\r\n          },\r\n          { loader: 'sass-loader' },\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n## 什么是plugin？有哪些常见的plugin？怎么配置plugin？\r\n\r\nplugin，即插件。Webpack插件是对Webpack功能的扩展和增强，可以帮助我们在打包过程中自动执行一些额外的操作，例如生成HTML文件、压缩代码、提取CSS等。\r\n\r\n常见的plugin有：\r\n\r\n- HtmlWebpackPlugin：根据模板生成HTML文件，可以自动引入打包后的资源。\r\n- UglifyJsPlugin：压缩JavaScript代码。\r\n- CleanWebpackPlugin：在每次构建前清理输出目录。\r\n- MiniCssExtractPlugin：将CSS代码提取到单独的文件中。\r\n- DefinePlugin：定义全局常量，可以在代码中直接使用。\r\n- CopyWebpackPlugin：将文件复制到输出目录。\r\n- ProvidePlugin：自动加载模块，使其在所有模块中可用。\r\n\r\nplugin配置步骤：\r\n\r\n1. npm下载要用的plugin。\r\n2. 在plugins选项里配置plugin，每个plugin是一个类，new这个类，然后可以根据文档和需求配置option即可。\r\n\r\n``` javascript\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  // ...其他配置\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: './src/index.html'\r\n    })\r\n  ]\r\n}\r\n```\r\n\r\n## 什么是文件指纹\r\n\r\nWebpack的文件指纹是指在打包过程中为每个文件生成唯一的标识符，以便于版本管理和缓存控制。比方说Vue项目打包后生成的css文件和js文件，一般都会有奇奇怪怪的文件名，那就是文件指纹。\r\n\r\n文件指纹的实现原理是根据文件内容生成哈希值，一般是利用Webpack内置的`HashedModuleIdsPlugin`和`MiniCssExtractPlugin`来实现。\r\n\r\n## 什么是Source Map？怎么配置？\r\n\r\n### Source Map概念\r\n\r\n在开发过程中，我们经常需要对编译后的代码进行调试，但是编译后的代码往往很难阅读和理解。Source Map（源映射）是一种文件格式，它可以将编译后的代码映射回源代码。通过使用Source Map，我们可以在浏览器中直接调试源代码，而不需要在编译后的代码中进行调试。\r\n\r\n比如Vue项目，跑在浏览器里的代码其实并不是你写的.Vue文件，而是经过编译后的。可是平时调试的时候，我们写的代码位置却能和浏览器控制台对应上。\r\n\r\n而帮我们做这个事情的，就是Source Map。\r\n\r\n### Source Map原理\r\n\r\nSource Map包含了源代码和编译后的代码之间的映射关系，通常是一个JSON文件，它包含了每行代码的映射信息，例如源文件路径、行号、列号等。当浏览器执行编译后的代码时，它会通过Source Map将执行位置映射回源代码的位置，从而使得开发者可以直接在源代码中进行调试。\r\n\r\n### 怎么配置Source Map\r\n\r\n在Webpack中，可以使用devtool配置选项来生成Source Map。常用的选项有：\r\n\r\n- **eval**：生成每个模块的eval代码，并且模块执行完后，eval代码被执行。这种方式速度很快，但是不适合生产环境。\r\n- **source-map**：生成独立的source-map文件，适合生产环境，但是会增加构建时间和文件大小。\r\n- **cheap-source-map**：生成source-map，但是不包含列信息，适合大型项目。\r\n- **cheap-module-source-map**：生成source-map，同时会将loader的sourcemap也加入进来。\r\n\r\n## 了解过Tree-shaking吗？\r\n\r\n### 概念\r\nTree-shaking又叫摇树优化，是通过静态分析消除JS模块中未使用的代码，减小项目体积。\r\n\r\n### 原理\r\nTree-shaking依赖于ES6的模块机制，因为ES6模块是静态的，编译时就能确定模块的依赖关系。对于非ES6模块的代码或者动态引入的代码，无法被消除掉。\r\n\r\n### 配置\r\nTree-Shaking需要配置optimization选项中的usedExports为true，同时在babel配置中使用babel-preset-env，开启modules选项为false，这样可以保证ES6模块在编译时不会被转换为CommonJS模块。\r\n\r\n## 什么是HMR，原理是什么\r\n\r\nHMR：即热更新，简单说就是在我们写代码保存后不需要手动刷新浏览器，就能直接看到更新后的结果，而且只改变我们更改的那部分内容。\r\n\r\nHMR的原理：将需要更新的模块通过websocket与Webpack Dev Server建立连接，当模块发生变化时，Webpack Dev Server会将新的模块代码推送给浏览器端，浏览器端通过将新代码插入到运行时环境中，来实现实时更新。\r\n\r\n怎么配置HMR：\r\n\r\n1. 在配置文件中添加webpack.HotModuleReplacementPlugin插件。\r\n2. 在webpack-dev-server的配置中添加hot: true，启用热替换。\r\n3. 在entry中添加hot module replacement runtime。\r\n4. 在模块代码中使用module.hot.accept方法，以接受新模块的更新。\r\n\r\nHMR只适用于开发环境，不能用于生产环境，因为HMR需要额外的代码和性能消耗。在生产环境中，应该禁用HMR，使用正常的文件更新机制。\r\n\r\n## 有没有写过自定义的loader？\r\n\r\nloader本质是一个函数，接受源代码作为参数，返回处理后的结果，举个最简单的例子：\r\n\r\n``` javascript\r\nmodule.exports = function(source) {\r\n  return source.toLowerCase();   // 将源代码所有字母转成小写\r\n};\r\n```\r\n\r\n在开发自定义loader时可以借助loader-utils这个工具库，可以通过调用loader-utils中提供的API来获取loader选项、文件路径、查询字符串等信息。\r\n\r\nloader-utils提供的常用API包括：\r\n\r\n- getOptions(loaderContext)：获取Loader的选项，返回一个包含选项信息的对象。\r\n- parseQuery(queryString)：解析查询字符串，返回一个包含解析结果的对象。\r\n- stringifyRequest(loaderContext, request)：将请求转换为字符串，返回一个包含转换结果的字符串。\r\n- getRemainingRequest(loaderContext)：获取请求中的剩余部分，返回一个包含剩余部分的字符串。\r\n- getCurrentRequest(loaderContext)：获取当前请求的完整部分，返回一个包含当前请求的字符串。\r\n\r\n举个例子，我们来写一个可以让使用者自己决定转成大写还是小写的自定义loader：\r\n\r\n``` javascript\r\nconst { getOptions } = require('loader-utils');\r\n\r\nmodule.exports = function(source) {\r\n  const options = getOptions(this);\r\n  const mode = options.mode || 'uppercase';\r\n  if (mode === 'uppercase') {\r\n    return source.toUpperCase();\r\n  } else if (mode === 'lowercase') {\r\n    return source.toLowerCase();\r\n  } else {\r\n    return source;\r\n  }\r\n};\r\n```\r\n\r\n然后在配置时可以通过options属性来为该loader提供选项：\r\n\r\n``` javascript\r\nmodule.exports = {\r\n  // ...\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.txt$/,\r\n        use: [\r\n          {\r\n            loader: 'my-loader',\r\n            options: {\r\n              mode: 'lowercase',\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n## 有没有写过自定义的plugin？\r\n\r\n自定义plugin本质是一个类，这个类实现了apply方法，在apply方法中，通过compiler对象注册一个或多个Webpack生命周期事件的监听器，然后在监听器函数中，实现自定义的逻辑。\r\n\r\n举个简单的例子：\r\n\r\n``` javascript\r\nclass MyPlugin {\r\n  apply(compiler) {\r\n    compiler.hooks.done.tap('MyPlugin', (stats) =\u003e {\r\n      console.log('Bundle is now finished!\\n');\r\n      console.log(stats.toString());\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = MyPlugin;\r\n```\r\n使用这个plugin：\r\n\r\n``` javascript\r\nconst MyPlugin = require('./my-plugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    new MyPlugin(),\r\n  ],\r\n};\r\n```\r\n\r\n当然，一般自定义的plugin不会这么简单，还需要使用一些进阶技巧，比如：\r\n\r\n1. 合理使用Webpack的生命周期事件：\r\nWebpack提供了许多生命周期事件，可以通过这些事件来监听Webpack构建过程中的各个阶段。在编写自定义插件时，需要选择合适的生命周期事件来监听，并在其中执行自定义逻辑。例如，如果需要在Webpack构建完成后输出一份打包报告，可以使用done事件来实现。\r\n\r\n2. 使用Webpack提供的钩子函数：\r\nWebpack提供了一些钩子函数，可以方便地实现一些常见的功能，如资源解析、模块加载等。在编写自定义插件时，可以通过调用这些钩子函数来实现自定义逻辑。例如，如果需要在Webpack解析模块时，修改模块的路径或内容，可以使用normalModuleFactory钩子函数来实现。\r\n\r\n3. 使用Webpack提供的工具函数和API：\r\nWebpack提供了许多工具函数和API，可以帮助开发者更加方便地操作Webpack构建过程中的各种资源。在编写自定义插件时，可以使用这些工具函数和API来实现自定义逻辑。例如，如果需要将某些资源复制到输出目录下，可以使用copy-webpack-plugin插件提供的copyWebpackPlugin函数来实现。\r\n\r\n4. 使用Webpack提供的配置项：\r\nWebpack提供了许多配置项，可以用来控制Webpack的构建行为。在编写自定义插件时，可以通过配置这些选项来实现一些特定的构建需求。例如，如果需要在Webpack打包时生成SourceMap文件，可以使用devtool配置项来实现。\r\n\r\n当然，想要实现能用于生产解决问题的自定义plugin的难度并不小，在后续我也会出相关的课程和专栏，来讲解如何实现真正生产可用的自定义plugin。\r\n\r\n## Webpack打包流程是怎么样的？\r\n\r\n1. 解析配置文件：Webpack会读取项目根目录下的Webpack配置文件，解析其中的配置项，并根据配置项构建打包流程。\r\n2. 解析模块依赖：Webpack会从entry配置中指定的入口文件开始，递归解析模块之间的依赖关系，并构建模块依赖图谱。\r\n3. 加载模块：Webpack会根据模块依赖图谱，加载所有需要打包的模块，通过配置的loader将文件转换成Webpack可识别的模块。\r\n4. 执行插件：Webpack会在打包流程中执行一系列插件，插件可以用于完成各种任务，例如生成HTML文件、压缩代码等等。\r\n5. 输出打包结果：Webpack会将打包后的代码和资源输出到指定的输出目录，可以使用配置项进行相关设置。\r\n6. 监听变化：在开发模式下，Webpack会在代码修改后重新构建打包流程，并将修改后的代码热更新到浏览器中。\r\n\r\n## Webpack事件机制了解吗？\r\n\r\n### Webpack常见的事件\r\n\r\n- before-run: 在Webpack开始执行构建之前触发，可以用于清理上一次构建的临时文件或状态。\r\n- run: 在Webpack开始执行构建时触发。\r\n- before-compile: 在Webpack开始编译代码之前触发，可以用于添加一些额外的编译配置或预处理代码。\r\n- compile: 在Webpack开始编译代码时触发，可以用于监听编译过程或处理编译错误。\r\n- this-compilation: 在创建新的Compilation对象时触发，Compilation对象代表当前编译过程中的所有状态和信息。\r\n- compilation: 在Webpack编译代码期间触发，可以用于监听编译过程或处理编译错误。\r\n- emit: 在Webpack生成输出文件之前触发，可以用于修改输出文件或生成一些附加文件。\r\n- after-emit: 在Webpack生成输出文件后触发，可以用于清理中间文件或执行一些其他操作。\r\n- done: 在Webpack完成构建时触发，可以用于生成构建报告或通知开发者构建结果。\r\n\r\n### Webpack的事件机制\r\nWebpack的事件机制是基于Tapable实现的，Tapable是Webpack事件机制的核心类，它封装了事件的订阅和发布机制。在Webpack中，Compiler对象和Compilation对象都是Tapable类的实例对象。\r\n\r\n## 有了解过Webpack5吗，相比于Webpack4有哪些提升？\r\n\r\nWebpack5相对于Webpack4有以下提升：\r\n\r\n1. 更快的构建速度：Webpack5在构建速度方面进行了大量优化，尤其是在开发模式下，构建速度有了明显提升。\r\n2. Tree Shaking优化：Webpack5进一步改进了Tree Shaking算法，可以更准确地判断哪些代码是无用的，从而更好地优化构建输出的文件大小。\r\n3. 内置的持久化缓存：Webpack5在持久化缓存方面进行了优化，可以缓存每个模块的编译结果，从而加速后续的构建。\r\n4. 支持WebAssembly：Webpack5增加了对WebAssembly的原生支持。\r\n5. 模块联邦（Module Federation）：Webpack5引入了模块联邦的概念，可以实现多个独立的Webpack构建之间的模块共享和远程加载，为微前端架构提供了更好的支持。\r\n\r\n## 讲一下你对模块联邦的理解？\r\n\r\n模块联邦是实现多个项目之间共享代码的机制。\r\n\r\n举个例子，假设我们有一个微前端应用，其中包含了一个商品管理应用和一个订单管理应用，这两个应用都需要使用到同一个UI组件库。\r\n\r\n为了避免重复的代码，我们可以将UI组件库拆分成一个独立的子应用作为模块提供方，然后通过模块联邦的方式在商品管理应用和订单管理应用中动态加载该组件库。\r\n\r\n在模块提供方里配置`ModuleFederationPlugin`：\r\n\r\n``` javascript\r\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    new ModuleFederationPlugin({\r\n      name: 'app1',   // 应用名\r\n      filename: 'remoteEntry.js',\r\n      exposes: {     // 需要共享的模块和对应的路径\r\n        './Button': './src/components/Button',\r\n      },\r\n      shared: ['react', 'react-dom'], // 共享的第三方库\r\n    }),\r\n  ],\r\n};\r\n```\r\n\r\n然后在模块调用方里配置`ModuleFederationPlugin`：\r\n\r\n``` javascript\r\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\r\n\r\nmodule.exports = {\r\n  // ...\r\n  plugins: [\r\n    new ModuleFederationPlugin({\r\n      name: 'app2',  // 调用方应用名\r\n      filename: 'remoteEntry.js',\r\n      remotes: {\r\n        app1: 'app1@http://localhost:3001/remoteEntry.js', // 模块提供方的路径\r\n      },\r\n      shared: ['react', 'react-dom'],  // 共享的第三方库\r\n    }),\r\n  ],\r\n};\r\n```\r\n\r\n## Webpack怎么优化开发环境？\r\n\r\n开发环境常见的问题有：\r\n\r\n1. 启动慢。\r\n2. 编译慢，尤其是当项目变大时，修改一行代码要等好几秒甚至十几秒才能看到效果。\r\n3. 占用内存高，当模块数变多时，项目运行占用内存飙升，导致电脑卡顿，影响开发效率。\r\n\r\n优化措施：\r\n\r\n1. 使用缓存：可以使用Webpack的缓存功能，将打包结果缓存起来以避免重复构建。可以使用cache-loader或hard-source-webpack-plugin等插件来实现缓存。\r\n2. 使用 DllPlugin：DllPlugin 是 Webpack 的一个插件，它可以将一些不经常变动的第三方库预先打包好，然后在开发过程中直接使用。这样可以减少每次构建时对这些库的重复打包，提高构建速度。\r\n3. 配置合适的SourceMap策略：在开发环境下，开启 SourceMap 可以帮助我们快速定位错误和调试代码。但是开启 SourceMap 会降低构建速度，所以需要权衡是否开启。\r\n4. 多线程并行打包：可以使用thread-loader或happypack开启多线程并行构建，但是并不是一定会提升性能，需要结合场景来自行取舍，比较适合单个耗时长的任务。\r\n5. 配置模块解析：Webpack 在模块解析时会搜索 node_modules 目录，这个过程比较耗时。为了减少搜索时间，我们可以使用 resolve.alias 配置选项来告诉 Webpack 直接使用特定的路径来查找模块。\r\n6. 使用新技术，比如Webpack5或者Vite这些性能更好的构建工具。\r\n\r\n## Webpack怎么优化打包结果？\r\n\r\n优化打包结果的核心目标就是让打出来的包体积更小。\r\n\r\n1. 打包体积分析：使用webpack-bundle-analyzer来分析，一般脚手架里直接运行命令行就能生成打包体积图，很方便，然后可以根据包体积能定向优化。\r\n2. 代码压缩：使用UglifyJsPlugin、MiniCssExtractPlugin等插件来对JS代码和CSS代码进行压缩，减小代码体积，实际开发中一般脚手架也会默认有压缩的配置。\r\n3. 使用懒加载：可以使用Webpack的动态导入功能，实现懒加载，在需要时再加载代码块。这可以缩短首屏加载时间，提升体验。\r\n4. 开启gzip：使用compression-webpack-plugin插件，生成额外的gzip静态文件，然后部署时再开启Nginx的gzip即可。\r\n5. 使用splitChunks提取公共代码，在脚手架中一般是默认开启的。\r\n6. 分离第三方库：将第三方库从应用程序代码中分离出来，单独打包，这样可以提高缓存效率并减小应用程序代码的大小。\r\n7. 开启Tree Shaking，对于Vue和React项目，一般是默认开启Tree Shaking的，我们在编写代码时尽量使用ES模块化语法，就可以了。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/615/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/615/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## webpack 打包优化的四种方法（多进程打包，多进程压缩，资源 CDN，动态 polyfill）","### 打包分析","#### 1. 速度分析","#### 2. 体积分析","### 打包优化","#### 1. 多进程多实例构建，资源并行解析","#### 2. 公用代码提取，使用 CDN 加载","#### 3. 多进程多实例并行压缩","#### 4. 使用 polyfill 动态服务","## webpack 做过哪些优化，开发效率方面、打包策略方面等等","### 1）优化 Webpack 的构建速度","### 2）使用webpack4-优化原因","#### noParse","#### IgnorePlugin","#### dllPlugin","#### happypack -\u003e thread-loader","#### thread-loader","#### 压缩加速——开启多线程压缩","### 2）优化 Webpack 的打包体积","### 3）speed-measure-webpack-plugin","### 4）开发阶段常用的插件","#### 开启多核压缩","#### 监控面板","#### 开启一个通知面板","#### 开启打包进度","#### 开发面板更清晰","#### 开启窗口的标题","#### friendly-errors-webpack-plugin","## webpack hash chunkhash contenthash","### hash","### chunkhash","### contenthash","## Tree-Shaking的工作原理","### 利用ES6模块特性：","### 代码删除","### 实现原理可以简单的概况：","## webpack插件","### webpack构建的主要钩子","#### Compiler钩子","#### Compilation钩子","## dev-server是怎么跑起来","## 使用过webpack里面哪些plugin和loader","## webpack整个生命周期，loader和plugin有什么区别","### Loader开发思路","### Plugin开发思路","## webpack打包的整个过程","## 一般怎么组织CSS（Webpack）","## 如何配置把js、css、html单独打包成一个文件","## 使用webpack构建时有无做一些自定义操作","## webpack的热更新是如何做到的？说明其原理？","## loader原理，css-loader与style-loader","## 什么是loader？有哪些常见的loader？怎么配置loader？","## 什么是plugin？有哪些常见的plugin？怎么配置plugin？","## 什么是文件指纹","## 什么是Source Map？怎么配置？","### Source Map概念","### Source Map原理","### 怎么配置Source Map","## 了解过Tree-shaking吗？","### 概念","### 原理","### 配置","## 什么是HMR，原理是什么","## 有没有写过自定义的loader？","## 有没有写过自定义的plugin？","## Webpack打包流程是怎么样的？","## Webpack事件机制了解吗？","### Webpack常见的事件","### Webpack的事件机制","## 有了解过Webpack5吗，相比于Webpack4有哪些提升？","## 讲一下你对模块联邦的理解？","## Webpack怎么优化开发环境？","## Webpack怎么优化打包结果？"]},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"615"},"buildId":"sU2iERWyzsgD586oQgu3i","assetPrefix":"/frontend","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>