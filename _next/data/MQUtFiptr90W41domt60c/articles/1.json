{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/1","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/1/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/1/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/1/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/1","id":256598533,"node_id":"MDU6SXNzdWUyNTY1OTg1MzM=","number":1,"title":"常用的shell命令","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2017-09-11T06:52:08Z","updated_at":"2024-04-01T18:00:43Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 一、SSH到服务器上再执行shell命令\n\n``` shell\n  ssh -t root@192.168.111.111 \\\n    \"sudo cp -rf ${REMOTE_DESTS[$key]#*:}/${NGINX_CONF_FILENAME} /etc/nginx/sites-available/ &&\n    sudo rm -rf ${REMOTE_DESTS[$key]#*:}/${NGINX_CONF_FILENAME} &&\n    sudo ln -sf /etc/nginx/sites-available/${NGINX_CONF_FILENAME} /etc/nginx/sites-enabled/${NGINX_CONF_FILENAME} &&\n    sudo service nginx reload\"\n```\n\n## 二、查看或修改监控文件系统(Inotify)的watch数目\n\n``` shell\n# 设置\nsudo sysctl fs.inotify.max_user_watches=524288\n\n# 查看\nsysctl -a | grep inotify\n```\n\n## 三、查看Ubuntu操作系统位数及版本\n``` shell\n# 查看Ubuntu操作系统位数\n# 方法一: getconf\ngetconf LONG_BIT\n# 64 or 32\n\n# 方法二: uname -a\nuname -a\n# Linux user-3020 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\n# i686表示32位, x86_64表示64位\n\n# 查看Ubuntu操作系统版本\nlsb_release -a\n# Distributor ID:\tUbuntu\n# Description:\tUbuntu 14.04.2 LTS\n# Release:\t14.04\n# Codename:\ttrusty\n```\n\n## 四、动态查看一个文件\n``` shell\ntail -f filename\n```\n\n## 五、sudo操作手动输入密码\n``` shell\necho \"abc123_\" | sudo -S sh -c \"cp /home/user/hosts /etc/hosts\"\n```\n\n## 六、替换变量中字符\n### 第一种方式\n\n``` shell\nCOMMIT_MSG=$(COMMIT_MSG//feat/build) # 将COMMIT_MSG中所有的feat替换成build\n```\n\n### 第二种方式: sed\n\n``` shell\nCOMMIT_MSG=$(echo $COMMIT_MSG | sed 's/^ //g') #去除COMMIT_MSG变量中所有左边的空格\n```\n\n### 第三种方式： tr命令\n*tr命令*可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。\n\n#### 语法\n\n``` shell\ntr(选项)(参数)\n```\n\n#### 选项\n* -c或——complerment：取代所有不属于第一字符集的字符；\n* -d或——delete：删除所有属于第一字符集的字符；\n* -s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；\n* -t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。\n\n#### 参数\n* 字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；\n\n*字符集2：指定要转换成的目标字符集。\n\n#### 实例\n将输入字符由大写转换为小写：\n\n``` shell\necho \"HELLO WORLD\" | tr 'A-Z' 'a-z'\nhello world\n```\n\n'A-Z' 和 'a-z'都是集合，集合是可以自己制定的，例如：'ABD-}'、'bB.,'、'a-de-h'、'a-c0-9'都属于集合，集合里可以使用'\\n'、'\\t'，可以可以使用其他ASCII字符。\n\n更详细的[tr实例](http://man.linuxde.net/tr)\n\n## 七、if指令详解(TODO)\n### 判断文件夹是否存在\n\n``` shell\n# 如果文件夹不存在，创建文件夹\nif [ ! -d \"/myfolder\" ]; then\n  mkdir /myfolder\nfi\n\n# shell判断文件,目录是否存在或者具有权限\n\nfolder=\"/var/www/\"\nfile=\"/var/www/log\"\n\n# -x 参数判断 $folder 是否存在并且是否具有可执行权限\nif [ ! -x \"$folder\"]; then\n  mkdir \"$folder\"\nfi\n\n# -d 参数判断 $folder 是否存在\nif [ ! -d \"$folder\"]; then\n  mkdir \"$folder\"\nfi\n\n# -f 参数判断 $file 是否存在\nif [ ! -f \"$file\" ]; then\n  touch \"$file\"\nfi\n\n# -n 判断一个变量是否有值\nif [ ! -n \"$var\" ]; then\n  echo \"$var is empty\"\n  exit 0\nfi\n\n# 判断两个变量是否相等\nif [ \"$var1\" = \"$var2\" ]; then\n  echo '$var1 eq $var2'\nelse\n  echo '$var1 not eq $var2'\nfi\n```\n## 八、开始行和结束行的内容\n``` shell\n# 文件最后100行\ntail -n 100 file\n\n# 文件开头100行\nhead -n 100 file\n\n# 文件指定开始行和结束行的内容(包头不包尾)\nsed '1,100p' file\n\n# 文件有多少行\nwc -l file\n```\n\n## 九、用来从文件或者变量中提取字段(awk)\nawk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。\n``` shell\necho \"Adam Bor, 34, IndiaKerry Miller, 22, USA\" | awk -F, '{print $1 \",\" $3 }'\n# Adam Bor, IndiaKerry Miller, USA\n```\n这里我们使用，作为字段分割符，同时打印第一个和第三个字段\n\n## 十、输出不换行(echo)\n\necho的参数中, -e表示开启转义, /c表示不换行,脚本如下:\n\n``` shel\n#!/bin/sh\n#filename: 1\necho -e \"please input a value:\\c\"\nread value\n# echo \"what you input is:\" $valuel\n```\n\n脚本2:\n\n``` shell\n#!/bin/sh\n#filename: 1\necho -n \"please input a value:\"\nread value\necho \"what you input is:\" $value\n```\n\n## 十一、字符串大小写不敏感的比较\n通用的方法是将字符串先转换成小写后再比较\n\n``` shell\n#!/bin/bash\n\nxxx=\"Temp\"\nyyy=\"temp\"\n\nx_tmp=$(echo $xxx | tr [A-Z] [a-z])\ny_tmp=$(echo $yyy | tr [A-Z] [a-z])\n\nif [ \"$x_tmp \" = \"$y_tmp \" ]; then\n  echo   \"PASS\"\nelse\n  echo   \"FAIL\"\nfi\n```\n\n## 十二、**&&** 运算符\n\n语法格式：\n``` sh\ncommand1 && command2 [&& command3 ...]\n```\n\n&&左边的命令（命令1）返回真(即返回0，成功被执行）后，&&右边的命令（命令2）才能够被执行；换句话说，“如果这个命令执行成功&&那么执行这个命令”。\n\n1 命令之间使用 && 连接，实现逻辑与的功能。\n2 只有在 && 左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行。\n3 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。\n\n## 十三、**||** 运算符\n\n语法格式:\n\n``` sh\ncommand1 || command2 [|| command3 ...]\n ```\n\n||则与&&相反。如果||左边的命令（命令1）未执行成功，那么就执行||右边的命令（命令2）；或者换句话说，“如果这个命令执行失败了||那么就执行这个命令。\n\n1 命令之间使用 || 连接，实现逻辑或的功能。\n2 只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。\n3 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。\n\n## 十四、判断变量中是否包含某个字符串\n\n3 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。\n``` shell\nstr=\"this is a string\"\n[[ $str =~ \"this\" ]] && echo \"$str contains this\"\n[[ $str =~ \"that\" ]] || echo \"$str does NOT contain that\"\n```\n\n结果为：\nthis is a string contains this\nthis is a string does NOT contains that\n\"[[\" 判断命令和 \"=~\"正则式匹配符号\n\n## 十五、shell中 **[ ]** 和 **[[ ]]** 的区别\nhttp://blog.csdn.net/ysdaniel/article/details/7905818\n\n## 十六、shell中 **''** , **\"\"** 和 **``** 的区别\nhttp://www.cnblogs.com/Skyar/p/5914942.html\n\n## 参考地址：\n[基础语法](http://www.cnblogs.com/xuejie/archive/2013/01/31/2886552.html)\n[echo指令](http://man.linuxde.net/echo)","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/1/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/1/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 一、SSH到服务器上再执行shell命令\n\n``` shell\n  ssh -t root@192.168.111.111 \\\n    \"sudo cp -rf ${REMOTE_DESTS[$key]#*:}/${NGINX_CONF_FILENAME} /etc/nginx/sites-available/ &&\n    sudo rm -rf ${REMOTE_DESTS[$key]#*:}/${NGINX_CONF_FILENAME} &&\n    sudo ln -sf /etc/nginx/sites-available/${NGINX_CONF_FILENAME} /etc/nginx/sites-enabled/${NGINX_CONF_FILENAME} &&\n    sudo service nginx reload\"\n```\n\n## 二、查看或修改监控文件系统(Inotify)的watch数目\n\n``` shell\n# 设置\nsudo sysctl fs.inotify.max_user_watches=524288\n\n# 查看\nsysctl -a | grep inotify\n```\n\n## 三、查看Ubuntu操作系统位数及版本\n``` shell\n# 查看Ubuntu操作系统位数\n# 方法一: getconf\ngetconf LONG_BIT\n# 64 or 32\n\n# 方法二: uname -a\nuname -a\n# Linux user-3020 3.13.0-48-generic #80-Ubuntu SMP Thu Mar 12 11:16:15 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\n# i686表示32位, x86_64表示64位\n\n# 查看Ubuntu操作系统版本\nlsb_release -a\n# Distributor ID:\tUbuntu\n# Description:\tUbuntu 14.04.2 LTS\n# Release:\t14.04\n# Codename:\ttrusty\n```\n\n## 四、动态查看一个文件\n``` shell\ntail -f filename\n```\n\n## 五、sudo操作手动输入密码\n``` shell\necho \"abc123_\" | sudo -S sh -c \"cp /home/user/hosts /etc/hosts\"\n```\n\n## 六、替换变量中字符\n### 第一种方式\n\n``` shell\nCOMMIT_MSG=$(COMMIT_MSG//feat/build) # 将COMMIT_MSG中所有的feat替换成build\n```\n\n### 第二种方式: sed\n\n``` shell\nCOMMIT_MSG=$(echo $COMMIT_MSG | sed 's/^ //g') #去除COMMIT_MSG变量中所有左边的空格\n```\n\n### 第三种方式： tr命令\n*tr命令*可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。\n\n#### 语法\n\n``` shell\ntr(选项)(参数)\n```\n\n#### 选项\n* -c或——complerment：取代所有不属于第一字符集的字符；\n* -d或——delete：删除所有属于第一字符集的字符；\n* -s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；\n* -t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。\n\n#### 参数\n* 字符集1：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”；\n\n*字符集2：指定要转换成的目标字符集。\n\n#### 实例\n将输入字符由大写转换为小写：\n\n``` shell\necho \"HELLO WORLD\" | tr 'A-Z' 'a-z'\nhello world\n```\n\n'A-Z' 和 'a-z'都是集合，集合是可以自己制定的，例如：'ABD-}'、'bB.,'、'a-de-h'、'a-c0-9'都属于集合，集合里可以使用'\\n'、'\\t'，可以可以使用其他ASCII字符。\n\n更详细的[tr实例](http://man.linuxde.net/tr)\n\n## 七、if指令详解(TODO)\n### 判断文件夹是否存在\n\n``` shell\n# 如果文件夹不存在，创建文件夹\nif [ ! -d \"/myfolder\" ]; then\n  mkdir /myfolder\nfi\n\n# shell判断文件,目录是否存在或者具有权限\n\nfolder=\"/var/www/\"\nfile=\"/var/www/log\"\n\n# -x 参数判断 $folder 是否存在并且是否具有可执行权限\nif [ ! -x \"$folder\"]; then\n  mkdir \"$folder\"\nfi\n\n# -d 参数判断 $folder 是否存在\nif [ ! -d \"$folder\"]; then\n  mkdir \"$folder\"\nfi\n\n# -f 参数判断 $file 是否存在\nif [ ! -f \"$file\" ]; then\n  touch \"$file\"\nfi\n\n# -n 判断一个变量是否有值\nif [ ! -n \"$var\" ]; then\n  echo \"$var is empty\"\n  exit 0\nfi\n\n# 判断两个变量是否相等\nif [ \"$var1\" = \"$var2\" ]; then\n  echo '$var1 eq $var2'\nelse\n  echo '$var1 not eq $var2'\nfi\n```\n## 八、开始行和结束行的内容\n``` shell\n# 文件最后100行\ntail -n 100 file\n\n# 文件开头100行\nhead -n 100 file\n\n# 文件指定开始行和结束行的内容(包头不包尾)\nsed '1,100p' file\n\n# 文件有多少行\nwc -l file\n```\n\n## 九、用来从文件或者变量中提取字段(awk)\nawk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。\n``` shell\necho \"Adam Bor, 34, IndiaKerry Miller, 22, USA\" | awk -F, '{print $1 \",\" $3 }'\n# Adam Bor, IndiaKerry Miller, USA\n```\n这里我们使用，作为字段分割符，同时打印第一个和第三个字段\n\n## 十、输出不换行(echo)\n\necho的参数中, -e表示开启转义, /c表示不换行,脚本如下:\n\n``` shel\n#!/bin/sh\n#filename: 1\necho -e \"please input a value:\\c\"\nread value\n# echo \"what you input is:\" $valuel\n```\n\n脚本2:\n\n``` shell\n#!/bin/sh\n#filename: 1\necho -n \"please input a value:\"\nread value\necho \"what you input is:\" $value\n```\n\n## 十一、字符串大小写不敏感的比较\n通用的方法是将字符串先转换成小写后再比较\n\n``` shell\n#!/bin/bash\n\nxxx=\"Temp\"\nyyy=\"temp\"\n\nx_tmp=$(echo $xxx | tr [A-Z] [a-z])\ny_tmp=$(echo $yyy | tr [A-Z] [a-z])\n\nif [ \"$x_tmp \" = \"$y_tmp \" ]; then\n  echo   \"PASS\"\nelse\n  echo   \"FAIL\"\nfi\n```\n\n## 十二、**&&** 运算符\n\n语法格式：\n``` sh\ncommand1 && command2 [&& command3 ...]\n```\n\n&&左边的命令（命令1）返回真(即返回0，成功被执行）后，&&右边的命令（命令2）才能够被执行；换句话说，“如果这个命令执行成功&&那么执行这个命令”。\n\n1 命令之间使用 && 连接，实现逻辑与的功能。\n2 只有在 && 左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行。\n3 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。\n\n## 十三、**||** 运算符\n\n语法格式:\n\n``` sh\ncommand1 || command2 [|| command3 ...]\n ```\n\n||则与&&相反。如果||左边的命令（命令1）未执行成功，那么就执行||右边的命令（命令2）；或者换句话说，“如果这个命令执行失败了||那么就执行这个命令。\n\n1 命令之间使用 || 连接，实现逻辑或的功能。\n2 只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。\n3 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。\n\n## 十四、判断变量中是否包含某个字符串\n\n3 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。\n``` shell\nstr=\"this is a string\"\n[[ $str =~ \"this\" ]] && echo \"$str contains this\"\n[[ $str =~ \"that\" ]] || echo \"$str does NOT contain that\"\n```\n\n结果为：\nthis is a string contains this\nthis is a string does NOT contains that\n\"[[\" 判断命令和 \"=~\"正则式匹配符号\n\n## 十五、shell中 **[ ]** 和 **[[ ]]** 的区别\nhttp://blog.csdn.net/ysdaniel/article/details/7905818\n\n## 十六、shell中 **''** , **\"\"** 和 **``** 的区别\nhttp://www.cnblogs.com/Skyar/p/5914942.html\n\n## 参考地址：\n[基础语法](http://www.cnblogs.com/xuejie/archive/2013/01/31/2886552.html)\n[echo指令](http://man.linuxde.net/echo)"]},"__N_SSG":true}