{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/647","id":2218786056,"node_id":"I_kwDOBiJZIc6EP_0I","number":647,"title":"Webpack Plugin插件机制","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536118829,"node_id":"LA_kwDOBiJZIc8AAAABhZVCLQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/javascript","name":"javascript","color":"383040","default":false,"description":"分类-Javascript相关"},{"id":6536123165,"node_id":"LA_kwDOBiJZIc8AAAABhZVTHQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/webpack","name":"webpack","color":"923874","default":false,"description":"分类-Webpack相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-04-01T18:08:43Z","updated_at":"2024-04-01T18:08:44Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## Webpack Plugin插件机制\n\n### plugin机制出现原因\n\n前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。\n\n那如果我们需要在项目中实现`打包前自动清理上次打包生成的文件`、`将一些文件复制到打包目录中`、`自动生成html文件`、`将打包产物自动上传至服务器`、`将打包后代码进行压缩、拆分`等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。\n\n没错，webpack的plugin机制让webpack有了定制化的能力。\n\n### plugin原理\n\n那具体如何通过plugin机制去实现这些定制化功能呢？\n\n其实是webpack在打包过程中的不同阶段（配置文件读取完成后、打包开始前、打包完成后等阶段）会触发不同的钩子，我们只需要明确要实现的功能应该在哪个阶段，然后将具体实现代码注册为对应钩子的事件即可。\n\n### webpack运行原理\n\n我们在了解这些钩子之前，必须要知道webpack的运行原理。\n\n这是一个简化版的webpack打包过程，当我们执行 `webpack build` 命令后，webpack会先读取配置文件，然后根据配置文件中的配置项去初始化，创建一个 `compiler` 对象，然后调用 `compiler` 对象的 `run` 方法，初始化一个 `compilation` 对象，执行 `compilation` 中的 `build` 方法进行编译，编译完成后，触发 `compiler` 对象的 `done` 钩子，完成打包。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82)\n\n``` js\n//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数\nfunction webpack(webpackOptions) {\n  //第二步：用配置参数对象初始化 `Compiler` 对象\n  const compiler = new Compiler(webpackOptions);\n  //第三步：挂载配置文件中的插件\n const { plugins } = webpackOptions;\n for (let plugin of plugins) {\n   plugin.apply(compiler);\n }\n  return compiler;\n}\n```\n\n``` js\n//Compiler其实是一个类，它是整个编译过程的大管家，而且是单例模式\nclass Compiler {\n  constructor(webpackOptions) {\n   //省略\n  }\n\n  // 第五步：创建compilation对象\n  compile(callback){\n    //虽然webpack只有一个Compiler，但是每次编译都会产出一个新的Compilation，\n    //这里主要是为了考虑到watch模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译\n    //每次编译都会产出一个新的Compilation，代表每次的编译结果\n    let compilation = new Compilation(this.options);\n    compilation.build(callback); //执行compilation的build方法进行编译，编译成功之后执行回调\n  }\n\n  //第四步：执行`Compiler`对象的`run`方法开始执行编译\n  run(callback) {\n    this.hooks.run.call(); //在编译前触发run钩子执行，表示开始启动编译了\n    const onCompiled = () => {\n      // 第七步：当编译成功后会触发done这个钩子执行\n      this.hooks.done.call();\n    };\n    this.compile(onCompiled); //开始编译，成功之后调用onCompiled\n  }\n}\n\n\nclass Compilation {\n  constructor(webpackOptions) {\n    this.options = webpackOptions;\n    this.modules = []; //本次编译所有生成出来的模块\n    this.chunks = []; //本次编译产出的所有代码块，入口模块和依赖的模块打包在一起为代码块\n    this.assets = {}; //本次编译产出的资源文件\n    this.fileDependencies = []; //本次打包涉及到的文件，这里主要是为了实现watch模式下监听文件的变化，文件发生变化后会重新编译\n  }\n\n  //第六步：执行compilation的build方法进行编译\n  build(callback) {\n  //这里开始做编译工作，编译成功执行callback\n\n  // ... 编译过程代码省略\n\n  // 编译完成后，触发callback回调\n  callback()\n  }\n}\n```\n\n<!-- more -->\n\n### compiler 与 compilation\n\n那上面提到的 `compiler` 对象和 `compilation` 对象到底是什么呢？又有什么区别与联系？\n\n- `compiler` 对象包含了webpack的所有配置信息，包括`entry`、`output`、`module`、`plugins`等，`compiler` 对象会在启动webpack时，一次性地初始化创建，它是全局唯一的，可以简单理解为webpack的实例。\n- `compilation` 对象代表一次资源的构建，通过一系列API可以访问/修改本次模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息等，当我们以开发模式运行webpack时，每当检测到一个文件变化，就会创建一个新的 `compilation` 对象，所以 `compilation` 对象也是一次性的，只能用于当前的编译。\n\n**他有以下主要属性：**\n\n- `compilation.modules` 解析后的所有模块\n- `compilation.chunks` 所有的代码分块chunk\n- `compilation.assets` 本次打包生成的所有文件\n- `compilation.hooks` compilation所有的钩子\n\n所以说呢，`compiler` 代表的是整个 webpack 从启动到关闭的生命周期（终端结束，该生命周期结束）， 而 `compilation` 只是代表了一次性的编译过程，如果是watch模式，每次监听到文件变化，都会产生一个新的 `compilation`，所以 `compilation` 代表一次资源的构建，会多次被创建，而 `compiler` 只会被创建一次。\n\n**我们了解了`compiler`和`compilation`对象后，就可以来看一下到底有哪些钩子。**\n\n### compiler钩子\ncompiler有很多钩子[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，介绍几个常用的：\n\n- `environment` SyncHook类型，在编译器准备环境时调用，时机就在配置文件中初始化插件之后。\n- `afterEnvironment` SyncHook类型，当编译器环境设置完成后，在 `environment hook` 后直接调用。\n- `entryOption` SyncBailHook类型，在 `webpack` 选项中的 `entry` 被处理过之后调用。\n- `afterPlugins` SyncHook类型，在插件初始化之后。\n- `afterResolvers` SyncHook类型，`resolver` 设置完成之后触发。\n- `beforeRun` AsyncSeriesHook类型，在开始执行一次构建之前调用，`compiler.run` 方法开始执行后立刻进行调用。\n- `run` AsyncSeriesHook类型，在开始读取 `records` 之前调用。\n- `watchRun` AsyncSeriesHook类型，在监听模式下，一个新的 `compilation` 触发之后，但在 `compilation` 实际开始之前触发。\n- `beforeCompile` AsyncSeriesHook类型，在创建 `compilation` 参数之后执行。\n- `compile` SyncHook类型，`beforeCompile` 之后立即调用，但在一个新的 `compilation` 创建之前。\n- `thisCompilation` SyncHook类型，初始化 `compilation` 时调用，在触发 `compilation` 事件之前调用。\n- `compilation` SyncHook类型，一次新的编译 `compilation` 创建之后触发。\n- `make` AsyncParallelHook类型，`compilation` 结束之前执行，`seal` 之前执行。\n- `afterCompile` AsyncSeriesHook类型，`compilation` 结束和封印之后执行。\n- `shouldEmit` SyncBailHook类型，在输出 `asset` 之前调用。返回一个布尔值，告知是否输出。\n- `emit` AsyncSeriesHook类型，生成资源到 `output` 目录之前触发。\n- `afterEmit` AsyncSeriesHook类型，输出 `asset` 到 `output` 目录之后执行。\n- `done` AsyncSeriesHook类型，`compilation` 编译完成后触发。\n- `failed` SyncHook类型，`compilation` 编译失败后触发。\n\n### compilation钩子\n\ncompilation对象也有很多钩子[官方地址](https://webpack.js.org/api/compilation-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compilation-hooks/)，介绍几个常用的：\n\n- `buildModule` SyncHook类型，模块开始编译前，执行该钩子，可以用于修改模块内容。\n- `succeedModule` SyncHook类型，模块编译成功后，执行该钩子。\n- `finishModules` AsyncSeriesHook类型，所有模块编译完成后，执行该钩子。\n- `moduleAsset` SyncHook类型，一个模块中的一个 asset 被添加到 compilation 时调用。\n- `chunkAsset` SyncHook类型，一个 chunk 中的 asset 被添加到 compilation 时调用。\n- `seal` SyncHook类型，在构建过程封存前触发，允许在最终资源生成之前进行一些操作。\n- `optimize` SyncHook类型，优化阶段开始时触发，可以用于自定义资源优化逻辑。\n- `optimizeAssets` AsyncSeriesHook类型，优化存储在 compilation.assets 中的所有 asset，可以监听和修改资源的优化过程。\n- `afterOptimizeAssets` SyncHook类型，asset 已经优化。\n- `optimizeTree` AsyncSeriesHook类型，在优化依赖树之前触发，允许修改资源树的优化逻辑。\n- `afterOptimizeTree` SyncHook类型，在优化依赖树之后触发，可用于处理优化完成后的资源树。\n- `optimizeChunkAssets` AsyncSeriesHook类型，优化所有 chunk asset，弃用，可使用 processAssets 来代替，可用于自定义块资源的优化逻辑。\n- `processAssets` AsyncSeriesHook类型，asset 处理时触发，可以监听和修改资源的生成。\n- `beforeHash` SyncHook类型，在 compilation 添加哈希（hash）之前。\n- `afterHash` SyncHook类型，在 compilation 添加哈希（hash）之后。\n- `beforeModuleAssets` SyncHook类型，在创建模块 asset 之前执行，可用于在模块资源生成前执行一些操作。\n\n每个钩子都有对应的类型，那这些类型有什么区别呢？\n\n## Tapable\n\n[Tapable](https://github.com/webpack/tapable)是一个提供**事件发布订阅**的工具，通过其提供的一系列钩子，我们可以注册事件，然后在不同的阶段去触发这些注册的事件。 webpack的plugin机制正是基于 Tapable 实现的，在不同编译阶段触发不同的钩子。\n\nTapable 官方文档提供了这九种钩子，也就是我们上面提到的钩子类型：\n\n``` js\nconst {\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  SyncLoopHook,\n  AsyncParallelHook,\n  AsyncParallelBailHook,\n  AsyncSeriesHook,\n  AsyncSeriesBailHook,\n  AsyncSeriesWaterfallHook\n} = require(\"tapable\");\n```\n\n可以看到，这些钩子有两种开头，分别是 `Sync` 和 `Async` ，这两种钩子的区别是： `Sync` 开头的为同步钩子，表示注册的事件函数会同步进行执行；`Async` 开头的为异步钩子，表示注册的事件函数会异步进行执行\n\n同时呢，这些钩子还有三种结尾，分别是`Hook`、`BailHook`、`WaterfallHook`、`LoopHook`，\n\n这三种结尾的区别是如下所示\n\n- `Hook`结尾的为普通钩子，只会按顺序挨个执行注册的事件，不会去管事件函数的返回值是什么。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab)\n\n- `BailHook`结尾的为保险钩子，只要注册的事件函数有一个返回值不为`undefined`，就会停止执行后面的事件函数。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5)\n\n- `WaterfallHook`结尾的为瀑布钩子，注册的事件函数会按顺序执行，每个事件函数的返回值会作为下一个事件函数的参数，只会影响下一个事件函数的第一个参数。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143)\n\n- `LoopHook`结尾的为循环钩子，注册的事件函数会按顺序执行，只要执行的事件返回值非`undefined`，就会立即重头开始执行，直到所有的事件函数都返回`undefined`，这个钩子才会结束。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7)\n\n接下来，我们又发现，异步钩子又是以`AsyncParallel`、`AsyncSeries`开头，这又有什么区别呢？\n\n- `AsyncSeries` 为异步串行钩子，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。\n- `AsyncParallel` 为异步并行钩子，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。\n\n下面我们就来讲一下这些钩子如何去使用。\n\n### Tapable同步钩子\n\n同步钩子只需要调用 `tap` 方法注册事件，然后调用 `call` 方法触发事件即可。\n\n#### 1. SyncHook\n\nSyncHook 是一个同步的、普通类型的 Hook，注册的事件函数会按顺序挨个执行，不会去管事件函数的返回值是什么。\n\n``` js\nconst { SyncHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) => {\n  console.log('事件1执行:', name, age);\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) => {\n  console.log('事件2执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 前端 18\n```\n\n#### 2. SyncBailHook\n\nSyncBailHook 是一个同步的、保险类型的 Hook，意思是只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { SyncBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) => {\n  console.log('事件1执行:', name, age);\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) => {\n  console.log('事件2执行:', name, age);\n  return 'abc'\n});\n\n// 注册事件3\nhook.tap('事件3', (name, age) => {\n  console.log('事件3执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 前端 18\n```\n\n#### 3. SyncWaterfallHook\n\nSyncWaterfallHook 是一个同步的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。\n\n``` js\nconst { SyncWaterfallHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncWaterfallHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) => {\n  console.log('事件1执行:', name, age);\n  return '驿站'\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) => {\n  console.log('事件2执行:', name, age);\n});\n\n// 注册事件3\nhook.tap('事件3', (name, age) => {\n  console.log('事件3执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 驿站 18\n// 事件3执行: 驿站 18\n```\n\n#### 4. SyncLoopHook\n\nSyncLoopHook 是一个同步的、循环类型的 Hook，只要执行的事件函数返回值非undefeind，就会立即重头开始执行，直到所有的事件函数都返回undefined，这个钩子才会结束。\n\n``` js\nconst { SyncLoopHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncLoopHook();\n\nlet count = 5;\n\n// 注册事件1\nhook.tap('事件1', () => {\n  count--;\n  console.log('事件1执行,count为',count);\n  if (count > 3) {\n    return true;\n  }\n});\n\n// 注册事件2\nhook.tap('事件2', () => {\n  count--;\n  console.log('事件2执行,count为',count);\n  if (count > 1) {\n    return true;\n  }\n});\n\n// 注册事件3\nhook.tap('事件3', () => {\n  console.log('事件3执行,count为',count);\n});\n\n// 触发事件\nhook.call();\n\n// 执行结果\n// 事件1执行,count为 4\n// 事件1执行,count为 3\n// 事件2执行,count为 2\n// 事件1执行,count为 1\n// 事件2执行,count为 0\n// 事件3执行,count为 0\n```\n\n### Tapable异步钩子\n\n异步钩子提供三种注册的方法：\n\n- `tap`：以同步方式注册钩子，用 `call` 来触发，跟同步钩子一样，只不过加持了异步的能力，不过多讲解。\n- `tapAsync`: 以异步方式注册钩子，用 `callAsync` 触发，同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成，下面有使用示例。\n- `tapPromise`: 以异步方式注册钩子，用 `promise` 的方式触发,下面有使用示例。\n\n#### 1. AsyncParallelHook\n\nAsyncParallelHook 是一个异步的、并行类型的 Hook，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。\n\n``` js\nconst { AsyncParallelHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncParallelHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) => {\n  console.log('事件2执行:', name, age);\n  // 调用callback，表示该事件执行完毕\n  callback();\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) => {\n  console.log('事件3执行:', name, age);\n  // 调用callback，表示该事件执行完毕\n  callback();\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, () => {\n  // 该钩子注册的所有事件执行完毕后，会执行该回调\n  console.log('该钩子所有事件执行完毕');\n});\n\n// 执行结果\n// 事件2执行: 前端 18\n// 事件3执行: 前端 18\n// 2秒后输出：事件1执行: 前端 18\n// 该钩子所有事件执行完毕\n```\n\n#### 2. AsyncParallelBailHook\n\nAsyncParallelBailHook 是一个异步、并行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { AsyncParallelBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncParallelBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tapPromise('事件1', (name, age) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      console.log('事件1执行:', name, age);\n      resolve('123');\n    }, 2000);\n  })\n});\n\n// 注册事件2\nhook.tapPromise('事件2', (name, age) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      console.log('事件2执行:', name, age);\n      resolve();\n    }, 3000);\n  })\n});\n\n// 注册事件3\nhook.tapPromise('事件3', (name, age, callback) => {\n  return new Promise((resolve) => {\n    console.log('事件3执行:', name, age);\n    resolve();\n  })\n});\n\n// 触发事件，传入实参\nhook.promise('前端', 18).then((res) => {\n  // 该钩子注册的所有事件执行完毕后，会执行该回调\n  console.log('该钩子所有事件执行完毕',res);\n})\n\n// 执行结果\n// 事件3执行: 前端 18\n// 2秒后输出：事件1执行: 前端 18\n// 该钩子所有事件执行完毕123\n```\n\n#### 3. AsyncSeriesHook\n\nAsyncSeriesHook 是一个异步的、串行类型的 Hook，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。\n\n``` js\nconst { AsyncSeriesHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null, '123');\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件2执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) => {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 前端 18\n// 事件1执行: 前端 18\n// 该钩子所有事件执行完毕123\n```\n\n#### 4. AsyncSeriesBailHook\n\nAsyncSeriesBailHook 是一个异步的、串行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { AsyncSeriesBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件2执行:', name, age);\n    callback(null, \"88717\");\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) => {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 前端 18\n// 该钩子所有事件执行完毕88717\n```\n\n#### 5. AsyncSeriesWaterfallHook\n\nAsyncSeriesWaterfallHook 是一个异步的、串行的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。\n\n``` js\nconst { AsyncSeriesWaterfallHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesWaterfallHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null,3);\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件2执行:', name, age);\n    callback(null, 2);\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null, 1);\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) => {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 1 18\n// 事件1执行: 2 18\n// 该钩子所有事件执行完毕3\n```\n\n### 如何自定义plugin\n\n了解Tapable之后，我们就可以学习如何自定义plugin了。\n\nwebpack 插件由以下几部分组成：\n\n- 一个 `JavaScript` 类 一个构造方法，可以接受一个 `options` 对象参数\n- 一个 `apply` 方法，该方法在 `webpack` 装载这个插件的时候被调用，并且会传入 `compiler` 对象\n根据我们的需求，确定要在哪个阶段挂载到哪个钩子上，根据钩子的类型（同步/异步），选择合适的事件注册方式，将需求实现代码注册为事件。\n\n事件回调中具体有哪些参数，需要根据钩子的类型去官网查看[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，这里就不一一列举了。\n\n> 注意 ： webpack4 可以用 plugin方法来注册插件，webpack5之后被取消了。\n> compiler.plugin('emit', function (compilation, cb) {})\n\n``` js\nclass BasicPlugin{\n  // 在构造函数中获取用户给该插件传入的配置项\n  constructor(options){\n    this.options = options;\n  }\n\n  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply(compiler) {\n    // 注册第1个事件, 这个事件名叫什么都无所谓，只是个标示而已\n    compiler.hooks.run.tapAsync('BasicPlugin', (compiler, callback) => {\n      console.log('以异步方式触及 run 钩子。')\n      callback()\n    })\n\n    // 注册第2个事件\n    // 在compiler的compilation钩子上注册一个事件BasicPlugin\n    compiler.hooks.compilation.tap('BasicPlugin', (compilation) => {\n      // 测试compilation对象在模块构建之前能得到什么\n      compilation.hooks.buildModule.tap('BasicPlugin', (data) => {\n          console.log(data);\n      })\n    })\n\n    // 注册第3个事件\n    compiler.hooks.emit.tap('BasicPlugin', (compilation) => {\n      // 业务逻辑代码\n    });\n  }\n}\n\nmodule.exports = BasicPlugin;\n```\n\n``` js\n// webpack.config.js\nconst path = require('path');\nconst BasicPlugin = require('./BasicPlugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  plugins: [\n    new BasicPlugin(),\n  ]\n}\n```\n\n\n### 自定义plugin实战\n\n为了更好的实践，给大家提供3个自定义插件来参考。\n\n#### 1. FileListPlugin\n\n需求：在打包完成后，生成一个`fileList.md`文件，文件内容为打包生成的所有文件名。\n\n```\n# 一共有2个文件\n\n- main.bundle.js\n- index.html\n```\n\n代码实现\n\n``` js\nfunction FileListPlugin (options) {\n  this.options = options || {};\n  this.filename = this.options.filename || 'fileList.md'\n}\n\nFileListPlugin.prototype.apply = function (compiler) {\n  // 1.通过compiler.hooks.emit.tapAsync()来触发生成资源到output目录之前的钩子，且回调函数会有两个参数，一个是compilation，一个是cb回调函数\n  compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, cb) => {\n    // 2.要生成的markdown文件的名称\n    const fileListName = this.filename;\n    // 3.通过compilation.assets获取到所有待生成的文件，这里是获取它的长度\n    let len = Object.keys(compilation.assets).length;\n    // 4.定义markdown文件的内容，也就是先定义一个一级标题，\\n表示的是换行符\n    let content = `# 一共有${len}个文件\\n\\n`;\n    // 5.将每一项文件的名称写入markdown文件内\n    for (let filename in compilation.assets) {\n      content += `- ${filename}\\n`\n    }\n    // 6.给我们即将生成的dist文件夹里添加一个新的资源，资源的名称就是fileListName变量\n    compilation.assets[fileListName] = {\n      // 7.写入资源的内容\n      source: function () {\n        return content;\n      },\n      // 8.指定新资源的大小，用于webpack展示\n      size: function () {\n        return content.length;\n      }\n    }\n    // 9.由于我们使用的是tapAsync异步调用，所以必须执行一个回调函数cb，否则打包后就只会创建一个空的dist文件夹。\n    cb();\n  })\n}\nmodule.exports = FileListPlugin;\nmodule.exports = {\n  new FileListPlugin({\n    filename: 'fileList.md'\n  })\n}\n```\n\n#### 2. CompressAssetsPlugin\n\n需求：每次打包完成后，将打包生成的文件生成一个压缩包。\n\n``` js\nconst JSZip = require('jszip');\nconst { RawSource } = require('webpack-sources');\n/*\n  将本次打包的资源都打包成为一个压缩包\n  需求:获取所有打包后的资源\n*/\n\nconst pluginName = 'CompressAssetsPlugin';\n\nclass CompressAssetsPlugin {\n  constructor({ output }) {\n    this.output = output;\n  }\n\n  apply(compiler) {\n    // AsyncSeriesHook 将 assets 输出到 output 目录之前调用该钩子\n    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) => {\n      // 创建zip对象\n      const zip = new JSZip();\n      // 获取本次打包生成所有的assets资源\n      const assets = compilation.getAssets();\n      // 循环每一个资源\n      assets.forEach(({ name, source }) => {\n        // 调用source()方法获得对应的源代码 这是一个源代码的字符串\n        const sourceCode = source.source();\n        // 往 zip 对象中添加资源名称和源代码内容\n        zip.file(name, sourceCode);\n      });\n      // 调用 zip.generateAsync 生成 zip 压缩包\n      zip.generateAsync({ type: 'nodebuffer' }).then((result) => {\n        // 通过 new RawSource 创建压缩包\n        // 并且同时通过 compilation.emitAsset 方法将生成的 Zip 压缩包输出到 this.output\n        compilation.emitAsset(this.output, new RawSource(result));\n        // 调用 callback 表示本次事件函数结束\n        callback();\n      });\n    });\n  }\n}\n\nmodule.exports = CompressAssetsPlugin;\n```\n\n#### 3. BundleSizeWebpackPlugin\n\n需求：文件超过一定大小时给出警告\n\n``` js\nconst { resolve } = require('path')\nconst fs = require('fs')\n\nclass BundleSizeWebpackPlugin {\n  constructor(options) {\n    this.options = options\n  }\n  apply(compiler) {\n    const { sizeLimit } = this.options\n    console.log('bundle size plugin')\n    // 在编译完成后，执行回调，拿到打包后文件路径，然后读取文件信息获取文件大小，然后定义一些逻辑\n    compiler.hooks.done.tap('BundleSizePlugin', stats => {\n      const { path, filename } = stats.compilation.outputOptions\n      const bundlePath = resolve(path, filename)\n      const { size } = fs.statSync(bundlePath)\n      const bundleSize = size / 1024\n      if (bundleSize < sizeLimit) {\n        console.log(\n          'safe: bundle-size',\n          bundleSize,\n          '\\n size limit: ',\n          sizeLimit\n        )\n      } else {\n        console.warn(\n          'unsafe: bundle-size',\n          bundleSize,\n          '\\n size limit: ',\n          sizeLimit\n        )\n      }\n    })\n  }\n}\n\nmodule.exports = BundleSizeWebpackPlugin\n```\n\n### 常用插件\n\n目前，webpack社区已经有很多成熟的插件了，如果非特殊需求，不用自定义插件。下面介绍几个常用的插件。\n\n#### 1. html-webpack-plugin\n\n`html-webpack-plugin`可以在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中。\n\n``` js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: path.join(__dirname, '/index.html'),\n      minify: {\n        // 压缩HTML文件\n        removeComments: true, // 移除HTML中的注释\n        collapseWhitespace: true, // 删除空白符与换行符\n        minifyCSS: true, // 压缩内联css\n      },\n      inject: true,\n    }),\n  ]\n}\n```\n\n**inject 有四个选项值**\n\n- `true`：默认值，*script* 标签位于 *html* 文件的 *body* 底部\n- `body`：*script* 标签位于 *html* 文件的 *body* 底部（同 *true*）\n- `head`：*script* 标签位于 *head* 标签内\n- `false`：不插入生成的 *js* 文件，只是单纯的生成一个 *html* 文件\n\n#### 2. clean-webpack-plugin\n\n`clean-webpack-plugin` 用于在打包前清理上一次项目生成的 `bundle` 文件，它会根据 `output.path` 自动清理文件夹。\n\n``` js\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.join(__dirname, '/index.html'),\n    }),\n    new CleanWebpackPlugin(), // 所要清理的文件夹名称\n  ]\n}\n```\n\n#### 3. extract-text-webpack-plugin\n\n将css样式从js文件中提取出来最终合成一个css文件，该插件只支持webpack4之前的版本，如果你当前是webpack4及以上版本那么就会报错。\n\n``` js\nconst extractTextPlugin = require('extract-text-webpack-plugin');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: extractTextPlugin.extract({\n          fallback: \"style-loader\",\n          use: \"css-loader\"\n        })\n      }\n    ]\n  },\n  plugins: [\n    new extractTextPlugin({\n      filename: \"[name].css\",\n      allChunks: true\n    })\n  ]\n}\n```\n\n#### 4. mini-css-extract-plugin\n\n该插件与上面的`extract-text-webpack-plugin`的一样，都是将css样式提取出来, 唯一就是用法不同，本插件的webpack4版本之后推荐使用。\n\n``` js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          \"css-loader\"\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: \"css/[name].css\",\n      chunkFilename: \"css/[name].css\"\n    })\n  ]\n}\n```\n\n#### 5. purifycss-webpack\n\n有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。\n\n``` js\nconst path = require('path')\nconst PurifyCssWebpack = require('purifycss-webpack') // 引入PurifyCssWebpack插件\nconst glob = require('glob') // 引入glob模块,用于扫描全部html文件中所引用的css\n\nmodule.exports = merge(common, {\n  plugins: [\n    new PurifyCssWebpack({\n      paths: glob.sync(path.join(__dirname, 'src/*.html')),\n    }),\n  ],\n})\n```\n\n#### 6. optimize-css-assets-webpack-plugin\n\n`optimize-css-assets-webpack-plugin` 用于优化和最小化 css 的插件，它会压缩 css，但是不会像 cssnano 那样移除或合并样式。\n\n``` js\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\") // 压缩css代码\n\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      // 压缩css\n      new OptimizeCSSAssetsPlugin({})\n    ]\n  }\n}\n```\n\n#### 7. DefinePlugin\n\n用于注入全局变量，一般用在环境变量上。无需安装，webpack内置\n\n``` js\nconst Webpack = require(\"webpack\")\nmodule.exports = {\n  plugins: [\n    new Webpack.DefinePlugin({\n      STR: JSON.stringify(\"蛙人\"),\n      \"process.env\": JSON.stringify(\"dev\"),\n      name: \"蛙人\"\n    })\n  ]\n}\n```\n\n#### 8. copy-webpack-plugin\n\n`copy-webpack-plugin` 用于在 webpack 中拷贝文件和文件夹，比如我们需要把一些静态文件拷贝到打包目录，这时候就可以使用这个插件。\n\n``` js\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nmodule.exports = {\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: 'public/js/*.js',\n          to: path.resolve(__dirname, 'dist', 'js'),\n          flatten: true,\n        },\n      ],\n    }),\n  ],\n}\n```\n\n#### 9. imagemin-webpack-plugin\n\n用于压缩图片。\n\n``` js\nconst ImageminPlugin =  require('imagemin-webpack-plugin').default\nmodule.exports = {\n  plugins: [\n    new ImageminPlugin({\n        test: /\\.(jpe?g|png|gif|svg)$/i\n    })\n  ]\n}\n```\n\n\n来源：https://zhuanlan.zhihu.com/p/661670534","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/647/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## Webpack Plugin插件机制\n\n### plugin机制出现原因\n\n前面我们已经知道了，loader机制让webpack拥有了处理除js类型文件以外的能力。\n\n那如果我们需要在项目中实现`打包前自动清理上次打包生成的文件`、`将一些文件复制到打包目录中`、`自动生成html文件`、`将打包产物自动上传至服务器`、`将打包后代码进行压缩、拆分`等一系列定制化功能，此时就必须借助webpack的plugin机制去实现了。\n\n没错，webpack的plugin机制让webpack有了定制化的能力。\n\n### plugin原理\n\n那具体如何通过plugin机制去实现这些定制化功能呢？\n\n其实是webpack在打包过程中的不同阶段（配置文件读取完成后、打包开始前、打包完成后等阶段）会触发不同的钩子，我们只需要明确要实现的功能应该在哪个阶段，然后将具体实现代码注册为对应钩子的事件即可。\n\n### webpack运行原理\n\n我们在了解这些钩子之前，必须要知道webpack的运行原理。\n\n这是一个简化版的webpack打包过程，当我们执行 `webpack build` 命令后，webpack会先读取配置文件，然后根据配置文件中的配置项去初始化，创建一个 `compiler` 对象，然后调用 `compiler` 对象的 `run` 方法，初始化一个 `compilation` 对象，执行 `compilation` 中的 `build` 方法进行编译，编译完成后，触发 `compiler` 对象的 `done` 钩子，完成打包。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/297c753f-6432-4ecc-90f3-474459b5fd82)\n\n``` js\n//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数\nfunction webpack(webpackOptions) {\n  //第二步：用配置参数对象初始化 `Compiler` 对象\n  const compiler = new Compiler(webpackOptions);\n  //第三步：挂载配置文件中的插件\n const { plugins } = webpackOptions;\n for (let plugin of plugins) {\n   plugin.apply(compiler);\n }\n  return compiler;\n}\n```\n\n``` js\n//Compiler其实是一个类，它是整个编译过程的大管家，而且是单例模式\nclass Compiler {\n  constructor(webpackOptions) {\n   //省略\n  }\n\n  // 第五步：创建compilation对象\n  compile(callback){\n    //虽然webpack只有一个Compiler，但是每次编译都会产出一个新的Compilation，\n    //这里主要是为了考虑到watch模式，它会在启动时先编译一次，然后监听文件变化，如果发生变化会重新开始编译\n    //每次编译都会产出一个新的Compilation，代表每次的编译结果\n    let compilation = new Compilation(this.options);\n    compilation.build(callback); //执行compilation的build方法进行编译，编译成功之后执行回调\n  }\n\n  //第四步：执行`Compiler`对象的`run`方法开始执行编译\n  run(callback) {\n    this.hooks.run.call(); //在编译前触发run钩子执行，表示开始启动编译了\n    const onCompiled = () => {\n      // 第七步：当编译成功后会触发done这个钩子执行\n      this.hooks.done.call();\n    };\n    this.compile(onCompiled); //开始编译，成功之后调用onCompiled\n  }\n}\n\n\nclass Compilation {\n  constructor(webpackOptions) {\n    this.options = webpackOptions;\n    this.modules = []; //本次编译所有生成出来的模块\n    this.chunks = []; //本次编译产出的所有代码块，入口模块和依赖的模块打包在一起为代码块\n    this.assets = {}; //本次编译产出的资源文件\n    this.fileDependencies = []; //本次打包涉及到的文件，这里主要是为了实现watch模式下监听文件的变化，文件发生变化后会重新编译\n  }\n\n  //第六步：执行compilation的build方法进行编译\n  build(callback) {\n  //这里开始做编译工作，编译成功执行callback\n\n  // ... 编译过程代码省略\n\n  // 编译完成后，触发callback回调\n  callback()\n  }\n}\n```\n\n<!-- more -->\n\n### compiler 与 compilation\n\n那上面提到的 `compiler` 对象和 `compilation` 对象到底是什么呢？又有什么区别与联系？\n\n- `compiler` 对象包含了webpack的所有配置信息，包括`entry`、`output`、`module`、`plugins`等，`compiler` 对象会在启动webpack时，一次性地初始化创建，它是全局唯一的，可以简单理解为webpack的实例。\n- `compilation` 对象代表一次资源的构建，通过一系列API可以访问/修改本次模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息等，当我们以开发模式运行webpack时，每当检测到一个文件变化，就会创建一个新的 `compilation` 对象，所以 `compilation` 对象也是一次性的，只能用于当前的编译。\n\n**他有以下主要属性：**\n\n- `compilation.modules` 解析后的所有模块\n- `compilation.chunks` 所有的代码分块chunk\n- `compilation.assets` 本次打包生成的所有文件\n- `compilation.hooks` compilation所有的钩子\n\n所以说呢，`compiler` 代表的是整个 webpack 从启动到关闭的生命周期（终端结束，该生命周期结束）， 而 `compilation` 只是代表了一次性的编译过程，如果是watch模式，每次监听到文件变化，都会产生一个新的 `compilation`，所以 `compilation` 代表一次资源的构建，会多次被创建，而 `compiler` 只会被创建一次。\n\n**我们了解了`compiler`和`compilation`对象后，就可以来看一下到底有哪些钩子。**\n\n### compiler钩子\ncompiler有很多钩子[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，介绍几个常用的：\n\n- `environment` SyncHook类型，在编译器准备环境时调用，时机就在配置文件中初始化插件之后。\n- `afterEnvironment` SyncHook类型，当编译器环境设置完成后，在 `environment hook` 后直接调用。\n- `entryOption` SyncBailHook类型，在 `webpack` 选项中的 `entry` 被处理过之后调用。\n- `afterPlugins` SyncHook类型，在插件初始化之后。\n- `afterResolvers` SyncHook类型，`resolver` 设置完成之后触发。\n- `beforeRun` AsyncSeriesHook类型，在开始执行一次构建之前调用，`compiler.run` 方法开始执行后立刻进行调用。\n- `run` AsyncSeriesHook类型，在开始读取 `records` 之前调用。\n- `watchRun` AsyncSeriesHook类型，在监听模式下，一个新的 `compilation` 触发之后，但在 `compilation` 实际开始之前触发。\n- `beforeCompile` AsyncSeriesHook类型，在创建 `compilation` 参数之后执行。\n- `compile` SyncHook类型，`beforeCompile` 之后立即调用，但在一个新的 `compilation` 创建之前。\n- `thisCompilation` SyncHook类型，初始化 `compilation` 时调用，在触发 `compilation` 事件之前调用。\n- `compilation` SyncHook类型，一次新的编译 `compilation` 创建之后触发。\n- `make` AsyncParallelHook类型，`compilation` 结束之前执行，`seal` 之前执行。\n- `afterCompile` AsyncSeriesHook类型，`compilation` 结束和封印之后执行。\n- `shouldEmit` SyncBailHook类型，在输出 `asset` 之前调用。返回一个布尔值，告知是否输出。\n- `emit` AsyncSeriesHook类型，生成资源到 `output` 目录之前触发。\n- `afterEmit` AsyncSeriesHook类型，输出 `asset` 到 `output` 目录之后执行。\n- `done` AsyncSeriesHook类型，`compilation` 编译完成后触发。\n- `failed` SyncHook类型，`compilation` 编译失败后触发。\n\n### compilation钩子\n\ncompilation对象也有很多钩子[官方地址](https://webpack.js.org/api/compilation-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compilation-hooks/)，介绍几个常用的：\n\n- `buildModule` SyncHook类型，模块开始编译前，执行该钩子，可以用于修改模块内容。\n- `succeedModule` SyncHook类型，模块编译成功后，执行该钩子。\n- `finishModules` AsyncSeriesHook类型，所有模块编译完成后，执行该钩子。\n- `moduleAsset` SyncHook类型，一个模块中的一个 asset 被添加到 compilation 时调用。\n- `chunkAsset` SyncHook类型，一个 chunk 中的 asset 被添加到 compilation 时调用。\n- `seal` SyncHook类型，在构建过程封存前触发，允许在最终资源生成之前进行一些操作。\n- `optimize` SyncHook类型，优化阶段开始时触发，可以用于自定义资源优化逻辑。\n- `optimizeAssets` AsyncSeriesHook类型，优化存储在 compilation.assets 中的所有 asset，可以监听和修改资源的优化过程。\n- `afterOptimizeAssets` SyncHook类型，asset 已经优化。\n- `optimizeTree` AsyncSeriesHook类型，在优化依赖树之前触发，允许修改资源树的优化逻辑。\n- `afterOptimizeTree` SyncHook类型，在优化依赖树之后触发，可用于处理优化完成后的资源树。\n- `optimizeChunkAssets` AsyncSeriesHook类型，优化所有 chunk asset，弃用，可使用 processAssets 来代替，可用于自定义块资源的优化逻辑。\n- `processAssets` AsyncSeriesHook类型，asset 处理时触发，可以监听和修改资源的生成。\n- `beforeHash` SyncHook类型，在 compilation 添加哈希（hash）之前。\n- `afterHash` SyncHook类型，在 compilation 添加哈希（hash）之后。\n- `beforeModuleAssets` SyncHook类型，在创建模块 asset 之前执行，可用于在模块资源生成前执行一些操作。\n\n每个钩子都有对应的类型，那这些类型有什么区别呢？\n\n## Tapable\n\n[Tapable](https://github.com/webpack/tapable)是一个提供**事件发布订阅**的工具，通过其提供的一系列钩子，我们可以注册事件，然后在不同的阶段去触发这些注册的事件。 webpack的plugin机制正是基于 Tapable 实现的，在不同编译阶段触发不同的钩子。\n\nTapable 官方文档提供了这九种钩子，也就是我们上面提到的钩子类型：\n\n``` js\nconst {\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  SyncLoopHook,\n  AsyncParallelHook,\n  AsyncParallelBailHook,\n  AsyncSeriesHook,\n  AsyncSeriesBailHook,\n  AsyncSeriesWaterfallHook\n} = require(\"tapable\");\n```\n\n可以看到，这些钩子有两种开头，分别是 `Sync` 和 `Async` ，这两种钩子的区别是： `Sync` 开头的为同步钩子，表示注册的事件函数会同步进行执行；`Async` 开头的为异步钩子，表示注册的事件函数会异步进行执行\n\n同时呢，这些钩子还有三种结尾，分别是`Hook`、`BailHook`、`WaterfallHook`、`LoopHook`，\n\n这三种结尾的区别是如下所示\n\n- `Hook`结尾的为普通钩子，只会按顺序挨个执行注册的事件，不会去管事件函数的返回值是什么。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/dec8ff7b-7561-4d15-b96f-54c6bde1a4ab)\n\n- `BailHook`结尾的为保险钩子，只要注册的事件函数有一个返回值不为`undefined`，就会停止执行后面的事件函数。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/ae6043a5-e389-4c3c-beb7-d56e30bdf1f5)\n\n- `WaterfallHook`结尾的为瀑布钩子，注册的事件函数会按顺序执行，每个事件函数的返回值会作为下一个事件函数的参数，只会影响下一个事件函数的第一个参数。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/8e03fb89-5b75-4100-aeb9-bd35fa261143)\n\n- `LoopHook`结尾的为循环钩子，注册的事件函数会按顺序执行，只要执行的事件返回值非`undefined`，就会立即重头开始执行，直到所有的事件函数都返回`undefined`，这个钩子才会结束。\n\n![image](https://github.com/hankliu62/interview/assets/8088864/c4944703-5add-4ca1-8cb8-34e867b1f2b7)\n\n接下来，我们又发现，异步钩子又是以`AsyncParallel`、`AsyncSeries`开头，这又有什么区别呢？\n\n- `AsyncSeries` 为异步串行钩子，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。\n- `AsyncParallel` 为异步并行钩子，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。\n\n下面我们就来讲一下这些钩子如何去使用。\n\n### Tapable同步钩子\n\n同步钩子只需要调用 `tap` 方法注册事件，然后调用 `call` 方法触发事件即可。\n\n#### 1. SyncHook\n\nSyncHook 是一个同步的、普通类型的 Hook，注册的事件函数会按顺序挨个执行，不会去管事件函数的返回值是什么。\n\n``` js\nconst { SyncHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) => {\n  console.log('事件1执行:', name, age);\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) => {\n  console.log('事件2执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 前端 18\n```\n\n#### 2. SyncBailHook\n\nSyncBailHook 是一个同步的、保险类型的 Hook，意思是只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { SyncBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) => {\n  console.log('事件1执行:', name, age);\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) => {\n  console.log('事件2执行:', name, age);\n  return 'abc'\n});\n\n// 注册事件3\nhook.tap('事件3', (name, age) => {\n  console.log('事件3执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 前端 18\n```\n\n#### 3. SyncWaterfallHook\n\nSyncWaterfallHook 是一个同步的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。\n\n``` js\nconst { SyncWaterfallHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncWaterfallHook(['name', 'age']);\n\n// 注册事件1\nhook.tap('事件1', (name, age) => {\n  console.log('事件1执行:', name, age);\n  return '驿站'\n});\n\n// 注册事件2\nhook.tap('事件2', (name, age) => {\n  console.log('事件2执行:', name, age);\n});\n\n// 注册事件3\nhook.tap('事件3', (name, age) => {\n  console.log('事件3执行:', name, age);\n});\n\n// 触发事件，传入实参\nhook.call('前端', 18);\n\n// 执行结果\n// 事件1执行: 前端 18\n// 事件2执行: 驿站 18\n// 事件3执行: 驿站 18\n```\n\n#### 4. SyncLoopHook\n\nSyncLoopHook 是一个同步的、循环类型的 Hook，只要执行的事件函数返回值非undefeind，就会立即重头开始执行，直到所有的事件函数都返回undefined，这个钩子才会结束。\n\n``` js\nconst { SyncLoopHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new SyncLoopHook();\n\nlet count = 5;\n\n// 注册事件1\nhook.tap('事件1', () => {\n  count--;\n  console.log('事件1执行,count为',count);\n  if (count > 3) {\n    return true;\n  }\n});\n\n// 注册事件2\nhook.tap('事件2', () => {\n  count--;\n  console.log('事件2执行,count为',count);\n  if (count > 1) {\n    return true;\n  }\n});\n\n// 注册事件3\nhook.tap('事件3', () => {\n  console.log('事件3执行,count为',count);\n});\n\n// 触发事件\nhook.call();\n\n// 执行结果\n// 事件1执行,count为 4\n// 事件1执行,count为 3\n// 事件2执行,count为 2\n// 事件1执行,count为 1\n// 事件2执行,count为 0\n// 事件3执行,count为 0\n```\n\n### Tapable异步钩子\n\n异步钩子提供三种注册的方法：\n\n- `tap`：以同步方式注册钩子，用 `call` 来触发，跟同步钩子一样，只不过加持了异步的能力，不过多讲解。\n- `tapAsync`: 以异步方式注册钩子，用 `callAsync` 触发，同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成，下面有使用示例。\n- `tapPromise`: 以异步方式注册钩子，用 `promise` 的方式触发,下面有使用示例。\n\n#### 1. AsyncParallelHook\n\nAsyncParallelHook 是一个异步的、并行类型的 Hook，注册的事件函数会同时执行，不会等待上一个事件函数执行完毕后再执行下一个事件函数。\n\n``` js\nconst { AsyncParallelHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncParallelHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) => {\n  console.log('事件2执行:', name, age);\n  // 调用callback，表示该事件执行完毕\n  callback();\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) => {\n  console.log('事件3执行:', name, age);\n  // 调用callback，表示该事件执行完毕\n  callback();\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, () => {\n  // 该钩子注册的所有事件执行完毕后，会执行该回调\n  console.log('该钩子所有事件执行完毕');\n});\n\n// 执行结果\n// 事件2执行: 前端 18\n// 事件3执行: 前端 18\n// 2秒后输出：事件1执行: 前端 18\n// 该钩子所有事件执行完毕\n```\n\n#### 2. AsyncParallelBailHook\n\nAsyncParallelBailHook 是一个异步、并行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { AsyncParallelBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncParallelBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tapPromise('事件1', (name, age) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      console.log('事件1执行:', name, age);\n      resolve('123');\n    }, 2000);\n  })\n});\n\n// 注册事件2\nhook.tapPromise('事件2', (name, age) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      console.log('事件2执行:', name, age);\n      resolve();\n    }, 3000);\n  })\n});\n\n// 注册事件3\nhook.tapPromise('事件3', (name, age, callback) => {\n  return new Promise((resolve) => {\n    console.log('事件3执行:', name, age);\n    resolve();\n  })\n});\n\n// 触发事件，传入实参\nhook.promise('前端', 18).then((res) => {\n  // 该钩子注册的所有事件执行完毕后，会执行该回调\n  console.log('该钩子所有事件执行完毕',res);\n})\n\n// 执行结果\n// 事件3执行: 前端 18\n// 2秒后输出：事件1执行: 前端 18\n// 该钩子所有事件执行完毕123\n```\n\n#### 3. AsyncSeriesHook\n\nAsyncSeriesHook 是一个异步的、串行类型的 Hook，注册的事件函数会按顺序挨个执行，每个事件函数执行完后，会调用回调函数，然后再执行下一个事件函数。\n\n``` js\nconst { AsyncSeriesHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null, '123');\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件2执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) => {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 前端 18\n// 事件1执行: 前端 18\n// 该钩子所有事件执行完毕123\n```\n\n#### 4. AsyncSeriesBailHook\n\nAsyncSeriesBailHook 是一个异步的、串行的、保险类型的 Hook，只要其中一个有返回了，后面的就不执行了。\n\n``` js\nconst { AsyncSeriesBailHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesBailHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件2执行:', name, age);\n    callback(null, \"88717\");\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback();\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) => {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 前端 18\n// 该钩子所有事件执行完毕88717\n```\n\n#### 5. AsyncSeriesWaterfallHook\n\nAsyncSeriesWaterfallHook 是一个异步的、串行的、瀑布类型的 Hook，上一个的返回值会作为下一个的参数,只会影响下一个事件函数的第一个参数。\n\n``` js\nconst { AsyncSeriesWaterfallHook } = require('tapable');\n\n// 初始化钩子，定义形参\nconst hook = new AsyncSeriesWaterfallHook(['name', 'age']);\n\n// 注册事件1\nhook.tapAsync('事件1', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件1执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null,3);\n  }, 4000);\n});\n\n// 注册事件2\nhook.tapAsync('事件2', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件2执行:', name, age);\n    callback(null, 2);\n  }, 3000);\n});\n\n// 注册事件3\nhook.tapAsync('事件3', (name, age, callback) => {\n  setTimeout(() => {\n    console.log('事件3执行:', name, age);\n    // 调用callback，表示该事件执行完毕\n    callback(null, 1);\n  }, 2000);\n});\n\n// 触发事件，传入实参\nhook.callAsync('前端', 18, (err, result) => {\n  // 最后结束的事件调用的callback会传入两个参数，第一个参数为错误信息，第二个参数为返回值\n  console.log('该钩子所有事件执行完毕',result);\n});\n\n// 执行结果\n// 事件3执行: 前端 18\n// 事件2执行: 1 18\n// 事件1执行: 2 18\n// 该钩子所有事件执行完毕3\n```\n\n### 如何自定义plugin\n\n了解Tapable之后，我们就可以学习如何自定义plugin了。\n\nwebpack 插件由以下几部分组成：\n\n- 一个 `JavaScript` 类 一个构造方法，可以接受一个 `options` 对象参数\n- 一个 `apply` 方法，该方法在 `webpack` 装载这个插件的时候被调用，并且会传入 `compiler` 对象\n根据我们的需求，确定要在哪个阶段挂载到哪个钩子上，根据钩子的类型（同步/异步），选择合适的事件注册方式，将需求实现代码注册为事件。\n\n事件回调中具体有哪些参数，需要根据钩子的类型去官网查看[官方地址](https://webpack.js.org/api/compiler-hooks/#root)、[中文地址](https://webpack.docschina.org/api/compiler-hooks/)，这里就不一一列举了。\n\n> 注意 ： webpack4 可以用 plugin方法来注册插件，webpack5之后被取消了。\n> compiler.plugin('emit', function (compilation, cb) {})\n\n``` js\nclass BasicPlugin{\n  // 在构造函数中获取用户给该插件传入的配置项\n  constructor(options){\n    this.options = options;\n  }\n\n  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply(compiler) {\n    // 注册第1个事件, 这个事件名叫什么都无所谓，只是个标示而已\n    compiler.hooks.run.tapAsync('BasicPlugin', (compiler, callback) => {\n      console.log('以异步方式触及 run 钩子。')\n      callback()\n    })\n\n    // 注册第2个事件\n    // 在compiler的compilation钩子上注册一个事件BasicPlugin\n    compiler.hooks.compilation.tap('BasicPlugin', (compilation) => {\n      // 测试compilation对象在模块构建之前能得到什么\n      compilation.hooks.buildModule.tap('BasicPlugin', (data) => {\n          console.log(data);\n      })\n    })\n\n    // 注册第3个事件\n    compiler.hooks.emit.tap('BasicPlugin', (compilation) => {\n      // 业务逻辑代码\n    });\n  }\n}\n\nmodule.exports = BasicPlugin;\n```\n\n``` js\n// webpack.config.js\nconst path = require('path');\nconst BasicPlugin = require('./BasicPlugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  plugins: [\n    new BasicPlugin(),\n  ]\n}\n```\n\n\n### 自定义plugin实战\n\n为了更好的实践，给大家提供3个自定义插件来参考。\n\n#### 1. FileListPlugin\n\n需求：在打包完成后，生成一个`fileList.md`文件，文件内容为打包生成的所有文件名。\n\n```\n# 一共有2个文件\n\n- main.bundle.js\n- index.html\n```\n\n代码实现\n\n``` js\nfunction FileListPlugin (options) {\n  this.options = options || {};\n  this.filename = this.options.filename || 'fileList.md'\n}\n\nFileListPlugin.prototype.apply = function (compiler) {\n  // 1.通过compiler.hooks.emit.tapAsync()来触发生成资源到output目录之前的钩子，且回调函数会有两个参数，一个是compilation，一个是cb回调函数\n  compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, cb) => {\n    // 2.要生成的markdown文件的名称\n    const fileListName = this.filename;\n    // 3.通过compilation.assets获取到所有待生成的文件，这里是获取它的长度\n    let len = Object.keys(compilation.assets).length;\n    // 4.定义markdown文件的内容，也就是先定义一个一级标题，\\n表示的是换行符\n    let content = `# 一共有${len}个文件\\n\\n`;\n    // 5.将每一项文件的名称写入markdown文件内\n    for (let filename in compilation.assets) {\n      content += `- ${filename}\\n`\n    }\n    // 6.给我们即将生成的dist文件夹里添加一个新的资源，资源的名称就是fileListName变量\n    compilation.assets[fileListName] = {\n      // 7.写入资源的内容\n      source: function () {\n        return content;\n      },\n      // 8.指定新资源的大小，用于webpack展示\n      size: function () {\n        return content.length;\n      }\n    }\n    // 9.由于我们使用的是tapAsync异步调用，所以必须执行一个回调函数cb，否则打包后就只会创建一个空的dist文件夹。\n    cb();\n  })\n}\nmodule.exports = FileListPlugin;\nmodule.exports = {\n  new FileListPlugin({\n    filename: 'fileList.md'\n  })\n}\n```\n\n#### 2. CompressAssetsPlugin\n\n需求：每次打包完成后，将打包生成的文件生成一个压缩包。\n\n``` js\nconst JSZip = require('jszip');\nconst { RawSource } = require('webpack-sources');\n/*\n  将本次打包的资源都打包成为一个压缩包\n  需求:获取所有打包后的资源\n*/\n\nconst pluginName = 'CompressAssetsPlugin';\n\nclass CompressAssetsPlugin {\n  constructor({ output }) {\n    this.output = output;\n  }\n\n  apply(compiler) {\n    // AsyncSeriesHook 将 assets 输出到 output 目录之前调用该钩子\n    compiler.hooks.emit.tapAsync(pluginName, (compilation, callback) => {\n      // 创建zip对象\n      const zip = new JSZip();\n      // 获取本次打包生成所有的assets资源\n      const assets = compilation.getAssets();\n      // 循环每一个资源\n      assets.forEach(({ name, source }) => {\n        // 调用source()方法获得对应的源代码 这是一个源代码的字符串\n        const sourceCode = source.source();\n        // 往 zip 对象中添加资源名称和源代码内容\n        zip.file(name, sourceCode);\n      });\n      // 调用 zip.generateAsync 生成 zip 压缩包\n      zip.generateAsync({ type: 'nodebuffer' }).then((result) => {\n        // 通过 new RawSource 创建压缩包\n        // 并且同时通过 compilation.emitAsset 方法将生成的 Zip 压缩包输出到 this.output\n        compilation.emitAsset(this.output, new RawSource(result));\n        // 调用 callback 表示本次事件函数结束\n        callback();\n      });\n    });\n  }\n}\n\nmodule.exports = CompressAssetsPlugin;\n```\n\n#### 3. BundleSizeWebpackPlugin\n\n需求：文件超过一定大小时给出警告\n\n``` js\nconst { resolve } = require('path')\nconst fs = require('fs')\n\nclass BundleSizeWebpackPlugin {\n  constructor(options) {\n    this.options = options\n  }\n  apply(compiler) {\n    const { sizeLimit } = this.options\n    console.log('bundle size plugin')\n    // 在编译完成后，执行回调，拿到打包后文件路径，然后读取文件信息获取文件大小，然后定义一些逻辑\n    compiler.hooks.done.tap('BundleSizePlugin', stats => {\n      const { path, filename } = stats.compilation.outputOptions\n      const bundlePath = resolve(path, filename)\n      const { size } = fs.statSync(bundlePath)\n      const bundleSize = size / 1024\n      if (bundleSize < sizeLimit) {\n        console.log(\n          'safe: bundle-size',\n          bundleSize,\n          '\\n size limit: ',\n          sizeLimit\n        )\n      } else {\n        console.warn(\n          'unsafe: bundle-size',\n          bundleSize,\n          '\\n size limit: ',\n          sizeLimit\n        )\n      }\n    })\n  }\n}\n\nmodule.exports = BundleSizeWebpackPlugin\n```\n\n### 常用插件\n\n目前，webpack社区已经有很多成熟的插件了，如果非特殊需求，不用自定义插件。下面介绍几个常用的插件。\n\n#### 1. html-webpack-plugin\n\n`html-webpack-plugin`可以在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中。\n\n``` js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: path.join(__dirname, '/index.html'),\n      minify: {\n        // 压缩HTML文件\n        removeComments: true, // 移除HTML中的注释\n        collapseWhitespace: true, // 删除空白符与换行符\n        minifyCSS: true, // 压缩内联css\n      },\n      inject: true,\n    }),\n  ]\n}\n```\n\n**inject 有四个选项值**\n\n- `true`：默认值，*script* 标签位于 *html* 文件的 *body* 底部\n- `body`：*script* 标签位于 *html* 文件的 *body* 底部（同 *true*）\n- `head`：*script* 标签位于 *head* 标签内\n- `false`：不插入生成的 *js* 文件，只是单纯的生成一个 *html* 文件\n\n#### 2. clean-webpack-plugin\n\n`clean-webpack-plugin` 用于在打包前清理上一次项目生成的 `bundle` 文件，它会根据 `output.path` 自动清理文件夹。\n\n``` js\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.join(__dirname, '/index.html'),\n    }),\n    new CleanWebpackPlugin(), // 所要清理的文件夹名称\n  ]\n}\n```\n\n#### 3. extract-text-webpack-plugin\n\n将css样式从js文件中提取出来最终合成一个css文件，该插件只支持webpack4之前的版本，如果你当前是webpack4及以上版本那么就会报错。\n\n``` js\nconst extractTextPlugin = require('extract-text-webpack-plugin');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: extractTextPlugin.extract({\n          fallback: \"style-loader\",\n          use: \"css-loader\"\n        })\n      }\n    ]\n  },\n  plugins: [\n    new extractTextPlugin({\n      filename: \"[name].css\",\n      allChunks: true\n    })\n  ]\n}\n```\n\n#### 4. mini-css-extract-plugin\n\n该插件与上面的`extract-text-webpack-plugin`的一样，都是将css样式提取出来, 唯一就是用法不同，本插件的webpack4版本之后推荐使用。\n\n``` js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          \"css-loader\"\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: \"css/[name].css\",\n      chunkFilename: \"css/[name].css\"\n    })\n  ]\n}\n```\n\n#### 5. purifycss-webpack\n\n有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。\n\n``` js\nconst path = require('path')\nconst PurifyCssWebpack = require('purifycss-webpack') // 引入PurifyCssWebpack插件\nconst glob = require('glob') // 引入glob模块,用于扫描全部html文件中所引用的css\n\nmodule.exports = merge(common, {\n  plugins: [\n    new PurifyCssWebpack({\n      paths: glob.sync(path.join(__dirname, 'src/*.html')),\n    }),\n  ],\n})\n```\n\n#### 6. optimize-css-assets-webpack-plugin\n\n`optimize-css-assets-webpack-plugin` 用于优化和最小化 css 的插件，它会压缩 css，但是不会像 cssnano 那样移除或合并样式。\n\n``` js\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\") // 压缩css代码\n\nmodule.exports = {\n  optimization: {\n    minimizer: [\n      // 压缩css\n      new OptimizeCSSAssetsPlugin({})\n    ]\n  }\n}\n```\n\n#### 7. DefinePlugin\n\n用于注入全局变量，一般用在环境变量上。无需安装，webpack内置\n\n``` js\nconst Webpack = require(\"webpack\")\nmodule.exports = {\n  plugins: [\n    new Webpack.DefinePlugin({\n      STR: JSON.stringify(\"蛙人\"),\n      \"process.env\": JSON.stringify(\"dev\"),\n      name: \"蛙人\"\n    })\n  ]\n}\n```\n\n#### 8. copy-webpack-plugin\n\n`copy-webpack-plugin` 用于在 webpack 中拷贝文件和文件夹，比如我们需要把一些静态文件拷贝到打包目录，这时候就可以使用这个插件。\n\n``` js\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nmodule.exports = {\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: 'public/js/*.js',\n          to: path.resolve(__dirname, 'dist', 'js'),\n          flatten: true,\n        },\n      ],\n    }),\n  ],\n}\n```\n\n#### 9. imagemin-webpack-plugin\n\n用于压缩图片。\n\n``` js\nconst ImageminPlugin =  require('imagemin-webpack-plugin').default\nmodule.exports = {\n  plugins: [\n    new ImageminPlugin({\n        test: /\\.(jpe?g|png|gif|svg)$/i\n    })\n  ]\n}\n```\n\n\n来源：https://zhuanlan.zhihu.com/p/661670534"]},"__N_SSG":true}