{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/70","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/70/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/70/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/70/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/70","id":1756503706,"node_id":"I_kwDOBiJZIc5osh6a","number":70,"title":"超全面的前端工程化配置指南（eslint+prettier+git提交自动校验和发布）","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2023-06-14T09:56:00Z","updated_at":"2023-06-14T09:57:09Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### 前端工程化配置指南\r\n\r\n> 本文讲解如何构建一个工程化的前端库，并结合 `Github Actions`，自动发布到 `Github` 和 `NPM` 的整个详细流程。\r\n\r\n### 示例\r\n\r\n> 我们经常看到像 `Vue、React` 这些流行的开源项目有很多配置文件，他们是干什么用的？他们的 `Commit、Release` 记录都那么规范，是否基于某种约定？\r\n\r\n废话少说，先上图！\r\n\r\n![工程项目](https://github.com/hankliu62/hankliu62.github.com/assets/8088864/a1ce5b84-6b09-48c8-8de9-5e54e5bb8759)\r\n\r\n上图标红就是相关的工程化配置，有 `Linter、Tests，Github Actions` 等，覆盖开发、测试、发布的整个流程。\r\n\r\n相关配置清单\r\n\r\n* `Eslint`\r\n\r\n* `Prettier`\r\n\r\n* `Commitlint`\r\n\r\n* `Husky`\r\n\r\n* `Jest`\r\n\r\n* `GitHub Actions`\r\n\r\n* `Semantic Release`\r\n\r\n下面我们从创建一个 `TypeScript` 项目开始，一步一步完成所有的工程化配置，并说明每个配置含义以及容易踩的坑。\r\n\r\n### 初始化\r\n\r\n为了避免兼容性问题，建议先将 `node` 升级到最新的长期支持版本。\r\n\r\n首先在 `Github` 上创建一个 `repo`,拉下来之后通过`npm init -y`初始化。然后创建`src`文件夹，写入`index.ts`。\r\n\r\n`package.json` 生成之后，我需要添加如下配置项:\r\n\r\n``` json\r\n  \"main\": \"index.js\",\r\n  \"type\": \"module\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"publishConfig\": {\r\n    \"access\": \"public\"\r\n  }\r\n```\r\n\r\n我们将项目定义为`ESM`规范,前端社区正逐渐向ESM标准迁移，从`Node v12.0.0`开始，只要设置了 `\"type\": \"module\"`, `Node` 会将整个项目视为ESM规范，我们就可以直接写裸写`import/export`。\r\n\r\n`publishConfig.access`表示当前项目发布到NPM的访问级别，它有 `restricted`和`public`两个选项,`restricted`表示我们发布到`NPM`上的是私有包（收费），访问级别默认为`restricted`,因为我们是开源项目所以标记为`public`。\r\n\r\n### 配置\r\n\r\n创建项目之后，我们开始安装工程化相关的依赖，因为我们是 `TypeScript` 项目，所以也需要安装 `TypeScript` 的依赖。\r\n\r\n#### Typescript\r\n\r\n先安装 `TypeScript`，然后使用 `tsc` 命名生成 `tsconfig`.json。\r\n\r\n``` bash\r\nnpm i typescript -D\r\nnpx tsc --init\r\n```\r\n\r\n然后我们需要添加修改 `tsconfig.json` 的配置项，如下：\r\n\r\n``` json\r\n{\r\n  \"compilerOptions\": {\r\n    /* Basic Options */\r\n    \"baseUrl\": \".\", // 模块解析根路径，默认为 tsconfig.json 位于的目录\r\n    \"rootDir\": \"src\", // 编译解析根路径，默认为 tsconfig.json 位于的目录\r\n    \"target\": \"ESNEXT\", // 指定输出 ECMAScript 版本，默认为 es5\r\n    \"module\": \"ESNext\", // 指定输出模块规范，默认为 Commonjs\r\n    \"lib\": [\"ESNext\", \"DOM\"], // 编译需要包含的 API，默认为 target 的默认值\r\n    \"outDir\": \"dist\", // 编译输出文件夹路径，默认为源文件同级目录\r\n    \"sourceMap\": true, // 启用 sourceMap，默认为 false\r\n    \"declaration\": true, // 生成 .d.ts 类型文件，默认为 false\r\n    \"declarationDir\": \"dist/types\", // .d.ts 类型文件的输出目录，默认为 outDir 目录\r\n    /* Strict Type-Checking Options */\r\n    \"strict\": true, // 启用所有严格的类型检查选项，默认为 true\r\n    \"esModuleInterop\": true, // 通过为导入内容创建命名空间，实现 CommonJS 和 ES 模块之间的互操作性，默认为 true\r\n    \"skipLibCheck\": true, // 跳过导入第三方 lib 声明文件的类型检查，默认为 true\r\n    \"forceConsistentCasingInFileNames\": true, // 强制在文件名中使用一致的大小写，默认为 true\r\n    \"moduleResolution\": \"Node\", // 指定使用哪种模块解析策略，默认为 Classic\r\n  },\r\n  \"include\": [\"src\"] // 指定需要编译文件，默认当前目录下除了 exclude 之外的所有.ts, .d.ts,.tsx 文件\r\n}\r\n```\r\n\r\n注意的点，如果你的项目涉及到`WebWorker API`，需要添加到 `lib` 字段中\r\n\r\n```\r\n\"lib\": [\"ESNext\", \"DOM\", \"WebWorker\"],\r\n````\r\n\r\n然后我们将编译后的文件路径添加到 `package.json`，并在 `scripts` 中添加编译命令。\r\n\r\n``` json\r\n-  \"main\": \"index.js\",\r\n+  \"main\": \"dist/index.js\",\r\n+  \"types\": \"dist/types/index.d.ts\"\r\n   \"type\": \"module\",\r\n-   \"scripts\": {\r\n-     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n-   },\r\n+   \"scripts\": {\r\n+     \"dev\": \"tsc --watch\",\r\n+     \"build\": \"npm run clean && tsc\",\r\n+     \"clean\": \"rm -rf dist\"\r\n+  },\r\n   \"publishConfig\": {\r\n     \"access\": \"public\"\r\n   }\r\n```\r\n\r\ntypes 配置项是指定编译生成的类型文件，如果  `compilerOptions.declarationDir` 指定的是`dist`，也就是源码和 `.d.ts` 同级，那么types可以省略。\r\n\r\n验证配置是否生效，在 `index.ts` 写入\r\n\r\n``` ts\r\nconst calc = (a: number, b: number) => {\r\n  return a - b\r\n}\r\nconsole.log(calc(1024, 28))\r\n```\r\n\r\n在控制台中执行\r\n\r\n``` bash\r\nnpm run build && node dist/index.js\r\n```\r\n\r\n会在 `dist` 目录中生成 `types/index.d.ts`、`index.js`、`index.js.map`，并打印 `996`。\r\n\r\n### Eslint & Prettier\r\n\r\n代码规范离不开各种 `Linter`, 之所以把这两个放在一起讲，借用 `Prettier` 官网的一句话：`“使用 Prettier 解决代码格式问题，使用 linters 解决代码质量问题”`。虽然eslint也有格式化功能，但是prettier的格式化功能更强大。\r\n\r\n大部分同学编辑器都装了`prettier-vscode`和`eslint-vscode`这两个插件，如果你项目只有其中一个的配置，因为这两者部分格式化的功能有差异，那么就会造成一个的问题，代码分别被两个插件分别格式化一次，网上解决`prettier+eslint`冲突的方案五花八门，甚至还有把整个rules列表贴出来的。\r\n\r\n那这里我们按照官方推荐，用最少的配置去解决`prettier`和`eslint`的集成问题。\r\n\r\n#### Eslint\r\n\r\n首先安装 `eslint`，然后利用 `eslint` 的命令行工具生成基本配置。\r\n\r\n``` bash\r\nnpm i eslint -D\r\nnpx eslint --init\r\n```\r\n\r\n执行上面命令后会提示一些选项，我们依次选择符合我们项目的配置。\r\n\r\n注意，这里 `eslint` 推荐了三种社区主流的规范，`Airbnb`、`Standard`、`Google`，因个人爱好我选择了不写分号的 `Standard`规范。\r\n\r\n生成的`.eslintrc.cjs`文件应该长这样\r\n\r\n``` js\r\nmodule.exports = {\r\n  env: {\r\n    browser: true,\r\n    es2021: true,\r\n    node: true\r\n  },\r\n  extends: [\r\n    'standard'\r\n  ],\r\n  parser: '@typescript-eslint/parser',\r\n  parserOptions: {\r\n    ecmaVersion: 12,\r\n    sourceType: 'module'\r\n  },\r\n  plugins: [\r\n    '@typescript-eslint'\r\n  ],\r\n  rules: {\r\n  }\r\n}\r\n```\r\n\r\n有些同学可能就要问了，这里为什么生成的配置文件名称是`.eslintrc.cjs`而不是`.eslintrc.js`？\r\n\r\n因为我们将项目定义为`ESM`，`eslint --init`会自动识别`type`，并生成兼容的配置文件名称，如果我们改回.js结尾，再运行`eslint`将会报错。出现这个问题是`eslint`内部使用了`require()`语法读取配置。\r\n\r\n同样，这个问题也适用于其他功能的配置，比如后面会讲到的`Prettier、Commitlint`等，配置文件都不能以`xx.js`结尾，而要改为当前库支持的其他配置文件格式，如：`.xxrc、.xxrc.json、.xxrc.yml`。\r\n\r\n验证配置是否生效，修改`index.ts`\r\n``` js\r\n  const calc = (a: number, b: number) => {\r\n    return a - b\r\n  }\r\n  // console.log(calc(1024, 28))\r\n```\r\n\r\n在`package.json`中添加`lint`命令\r\n\r\n``` json\r\n  \"scripts\": {\r\n    \"dev\": \"tsc --watch\",\r\n    \"build\": \"npm run clean && tsc\",\r\n    \"lint\": \"eslint src --ext .js,.ts --cache --fix\",\r\n    \"clean\": \"rm -rf dist\"\r\n  },\r\n```\r\n\r\n然后在控制台执行 `lint,eslint`将会提示 `1` 条错误信息，说明校验生效。\r\n\r\n``` bash\r\nnpm run lint\r\n# 1:7  error  'calc' is assigned a value but never used  no-unused-vars\r\n```\r\n\r\n因为是 `Typescript` 项目所以我们还要添加Standard规范提供的 `TypeScrip` 扩展配置(其他规范同理)\r\n\r\n安装`eslint-config-standard-with-typescript`\r\n\r\n``` bash\r\nnpm i eslint-config-standard-with-typescript -D\r\n```\r\n\r\n添加修改 `.eslintrc.cjs`\r\n\r\n``` js\r\nmodule.exports = {\r\n  env: {\r\n    browser: true,\r\n    es2021: true,\r\n    node: true\r\n  },\r\n  // - extends: ['standard']\r\n  extends: ['standard', 'eslint-config-standard-with-typescript'],\r\n  parser: '@typescript-eslint/parser',\r\n  parserOptions: {\r\n    ecmaVersion: 12,\r\n    sourceType: 'module',\r\n    project: './tsconfig.json'\r\n  },\r\n  plugins: ['@typescript-eslint'],\r\n  rules: {}\r\n}\r\n```\r\n\r\n验证配置是否生效\r\n\r\n在控制台执行`lint,eslint`将会提示 `2` 条错误信息，说明校验生效。\r\n\r\n``` bash\r\nnpm run lint\r\n# 1:7  error  'calc' is assigned a value but never used  no-unused-vars\r\n# 1:14 error  Missing return type on function\r\n```\r\n\r\n#### Prettier\r\n\r\n现在我们按照官网的推荐方式，把 `prettier` 集成到 `eslint` 的校验中。\r\n\r\n安装 `prettier` 并初始化配置文件\r\n\r\n``` bash\r\nnpm i prettier -D\r\necho {}> .prettierrc.json\r\n```\r\n\r\n然后在`.prettierrc.json`添加配置，这里只需要添加和你所选规范冲突的部分。\r\n\r\n``` json\r\n{\r\n  \"semi\": false, // 是否使用分号\r\n  \"singleQuote\": true, // 使用单引号代替双引号\r\n  \"trailingComma\": \"none\" // 多行时尽可能使用逗号结尾\r\n}\r\n```\r\n\r\n安装解决冲突需要用到的两个依赖\r\n\r\n1. `eslint-config-prettier` 关闭可能与 `prettier` 冲突的规则\r\n\r\n2. `eslint-plugin-prettier` 使用 `prettier` 代替 eslint 格式化\r\n\r\n``` bash\r\nnpm i eslint-config-prettier eslint-plugin-prettier -D\r\n```\r\n\r\n再添加修改 `.eslintrc.cjs`，如下：\r\n\r\n``` js\r\nmodule.exports = {\r\n  env: {\r\n    browser: true,\r\n    es2021: true,\r\n    node: true,\r\n  },\r\n  // - extends: ['standard', 'eslint-config-standard-with-typescript'],\r\n  extends: ['standard', 'eslint-config-standard-with-typescript', 'prettier'],\r\n  parser: '@typescript-eslint/parser',\r\n  parserOptions: {\r\n    ecmaVersion: 12,\r\n    sourceType: 'module',\r\n    project: './tsconfig.json',\r\n  },\r\n  // - plugins: ['@typescript-eslint'],\r\n  plugins: ['@typescript-eslint', 'prettier'],\r\n  // - rules: {},\r\n  rules: {\r\n    'prettier/prettier': 'error'\r\n  },\r\n}\r\n```\r\n\r\n然后验证配置是否生效，修改`index.ts`\r\n\r\n``` ts\r\n// -  const calc = (a: number, b: number) => {\r\nconst calc = (a: number, b: number): number => {\r\n  return a - b\r\n}\r\n// - // console.log(calc(1024, 28))\r\nconsole.log(calc(1024, 28))\r\n```\r\n\r\n然后在控制台执行`lint`,这里`prettier`和`eslint`的行为已保持一致，如果没有报错，那就成功了。\r\n\r\n``` bash\r\nnpm run lint\r\n```\r\n\r\n我们现在已经完成了`eslint`和`prettier`的集成配置。和编辑器无关，也就是说无论你使用什么编辑器，有没有安装相关插件，都不会影响代码校验的效果。\r\n\r\n#### Husky\r\n\r\n因为一个项目通常是团队合作，我们不能保证每个人在提交代码之前执行一遍`lint`校验，所以需要`git hooks` 来自动化校验的过程，否则禁止提交。\r\n\r\n安装Husky并生成`.husky`文件夹\r\n\r\n``` bash\r\nnpm i husky -D\r\nnpx husky install\r\n```\r\n\r\n然后我们需要在每次执行`npm install`时自动启用`husky`\r\n\r\n如果你的`npm`版本大于等于`7.1.0`\r\n\r\n``` bash\r\nnpm set-script prepare \"husky install\"\r\n```\r\n\r\n否则手动在`package.json`中添加\r\n\r\n``` json\r\n\"scripts\": {\r\n    \"dev\": \"tsc --watch\",\r\n    \"build\": \"npm run clean && tsc\",\r\n    \"lint\": \"eslint src --ext .js,.ts --cache --fix\",\r\n    \"clean\": \"rm -rf dist\",\r\n+   \"prepare\": \"husky install\"\r\n},\r\n```\r\n\r\n然后添加一个`lint`钩子\r\n\r\n``` bash\r\nnpx husky add .husky/pre-commit \"npm run lint\"\r\n```\r\n\r\n相当于手动在`.husky/pre-commit`文件写入以下内容：\r\n``` bash\r\n#!/bin/sh\r\n. \"$(dirname \"$0\")/_/husky.sh\"\r\nnpm run lint\r\n```\r\n\r\n测试钩子是否生效，修改`index.ts`\r\n\r\n``` ts\r\nconst calc = (a: number, b: number): number => {\r\n    return a - b\r\n  }\r\n// console.log(calc(1024, 28))\r\n```\r\n\r\n然后提交一条`commit`,如果配置正确将会自动执行`lint`并提示 `1` 条错误信息，`commit`提交将会失败。\r\n\r\n``` bash\r\ngit add .\r\ngit commit -m 'test husky'\r\n# 1:7  error  'calc' is assigned a value but never used\r\n```\r\n\r\n#### Commitlint\r\n\r\n为什么需要 `Commitlint`，除了在后续的生成`changelog`文件和语义发版中需要提取`commit`中的信息，也利于其他同学分析你提交的代码，所以我们要约定`commit`的规范。\r\n\r\n安装 `Commitlint`\r\n\r\n+ `@commitlint/cli Commitlint` 命令行工具\r\n\r\n+ `@commitlint/config-conventional` 基于 `Angular` 的约定规范\r\n\r\n``` bash\r\nnpm i @commitlint/config-conventional @commitlint/cli -D\r\n```\r\n\r\n最后将`Commitlint`添加到钩子\r\n\r\n``` bash\r\nnpx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"'\r\n```\r\n\r\n创建`.commitlintrc`，并写入配置\r\n``` js\r\n{\r\n  \"extends\": [\r\n    \"@commitlint/config-conventional\"\r\n  ]\r\n}\r\n```\r\n\r\n注意，这里配置文件名使用的是`.commitlintrc`而不是默认的`.commitlintrc.js`，详见 `Eslint` 章节\r\n\r\n测试钩子是否生效，修改`index.ts`，让代码正确\r\n\r\n``` ts\r\nconst calc = (a: number, b: number): void => {\r\n  console.log(a - b)\r\n}\r\ncalc(1024, 28)\r\n```\r\n\r\n提交一条不符合规范的`commit`，提交将会失败\r\n\r\n``` bash\r\ngit add .\r\ngit commit -m 'add eslint and commitlint'\r\n```\r\n\r\n修改为正确的`commit`，提交成功！\r\n\r\n``` bash\r\ngit commit -m 'ci: add eslint and commitlint'\r\n```\r\n\r\n`Angular` 规范说明：\r\n\r\n- **feat**：新功能\r\n\r\n- **fix**：修补 BUG\r\n\r\n- **docs**：修改文档，比如 README, CHANGELOG, CONTRIBUTE 等等\r\n\r\n- **style**：不改变代码逻辑 (仅仅修改了空格、格式缩进、逗号等等)\r\n\r\n- **refactor**：重构（既不修复错误也不添加功能）\r\n\r\n- **perf**：优化相关，比如提升性能、体验\r\n\r\n- **test**：增加测试，包括单元测试、集成测试等\r\n\r\n- **build**：构建系统或外部依赖项的更改\r\n\r\n- **ci**：自动化流程配置或脚本修改\r\n\r\n- **chore**：非 src 和 test 的修改，发布版本等\r\n\r\n- **revert**：恢复先前的提交\r\n\r\n#### Jest\r\n\r\n美好生活从测试覆盖率 100% 开始。\r\n\r\n安装`jest`，和类型声明`@types/jest`，它执行需要`ts-node`和`ts-jest`\r\n\r\n这里暂时固定了`ts-node`的版本为 **`v9.1.1`**，新版的**`ts-node@v10.0.0`**会导致jest报错，等待官方修复\r\n\r\n``` bash\r\nnpm i jest @types/jest ts-node@9.1.1 ts-jest -D\r\n```\r\n\r\n初始化配置文件\r\n\r\n``` bash\r\nnpx jest --init\r\n```\r\n\r\n然后修改`jest.config.ts`文件\r\n``` ts\r\n// A preset that is used as a base for Jest's configuration\r\npreset: 'ts-jest'\r\n```\r\n\r\n将测试命令添加到`package.json`中。\r\n\r\n``` json\r\n  \"scripts\": {\r\n    \"dev\": \"tsc --watch\",\r\n    \"build\": \"npm run clean && tsc\",\r\n    \"lint\": \"eslint src --ext .js,.ts --cache --fix\",\r\n    \"clean\": \"rm -rf dist\",\r\n    \"prepare\": \"husky install\",\r\n+   \"test\": \"jest\"\r\n  },\r\n```\r\n\r\n创建测试文件夹`__tests__`和测试文件`__tests__/calc.spec.ts`\r\n\r\n修改index.ts\r\n\r\n``` ts\r\nconst calc = (a: number, b: number): number => {\r\n  return a - b\r\n}\r\n\r\nexport default calc\r\n```\r\n\r\n然后在`calc.spec.ts`中写入测试代码\r\n\r\n``` ts\r\nimport calc from '../src'\r\n\r\ntest('The calculation result should be 996.', () => {\r\n  expect(calc(1024, 28)).toBe(996)\r\n})\r\n```\r\n\r\n验证配置是否生效\r\n\r\n在控制台执行`test`，将会看到测试覆盖率 100% 的结果。\r\n\r\n``` bash\r\nnpm run test\r\n```\r\n\r\n最后我们给`__tests__`目录也加上`lint`校验\r\n\r\n修改`package.json`\r\n\r\n``` json\r\n  \"scripts\": {\r\n    \"dev\": \"tsc --watch\",\r\n    \"build\": \"npm run clean && tsc\",\r\n-   \"lint\": \"eslint src --ext .js,.ts --cache --fix\",\r\n+   \"lint\": \"eslint src __tests__ --ext .js,.ts --cache --fix\",\r\n    \"clean\": \"rm -rf dist\",\r\n    \"prepare\": \"husky install\",\r\n    \"test\": \"jest\"\r\n  },\r\n```\r\n\r\n这里如果我们直接执行`npm run lint`将会报错，提示`__tests__`文件夹没有包含在`tsconfig.json`的`include`中，当我们添加到`include`之后，输出的`dist`中就会包含测试相关的文件，这并不是我们想要的效果。\r\n\r\n我们使用`typescript-eslint`官方给出的解决方案，如下操作：\r\n\r\n新建一个`tsconfig.eslint.json`文件，写入以下内容：\r\n\r\n``` json\r\n{\r\n  \"extends\": \"./tsconfig.json\",\r\n  \"include\": [\"**/*.ts\", \"**/*.js\"]\r\n}\r\n```\r\n\r\n在`.eslintrc.cjs`中修改\r\n\r\n``` cjs\r\n  parserOptions: {\r\n    ecmaVersion: 12,\r\n    sourceType: 'module',\r\n-   project: './tsconfig.json'\r\n+   project: './tsconfig.eslint.json'\r\n  },\r\n```\r\n\r\n然后验证配置是否生效，直接提交我们添加的测试文件,能正确提交说明配置成功。\r\n\r\n``` bash\r\ngit add .\r\ngit commit -m 'test: add unit test'\r\n```\r\n\r\n### Github Actions\r\n\r\n我们通过`Github Actions`实现代码合并或推送到主分支，`dependabot`机器人升级依赖等动作，会自动触发测试和发布版本等一系列流程。\r\n\r\n在项目根目录创建`.github/workflows`文件夹，然后在里面新建`ci.yml`文件和`cd.yml`文件\r\n\r\n在`ci.yml`文件中写入：\r\n\r\n``` yml\r\nname: CI\r\n\r\non:\r\n  push:\r\n    branches:\r\n      - '**'\r\n  pull_request:\r\n    branches:\r\n      - '**'\r\njobs:\r\n  linter:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n      - uses: actions/setup-node@v2\r\n        with:\r\n          node-version: 16\r\n      - run: npm ci\r\n      - run: npm run lint\r\n  tests:\r\n    needs: linter\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n      - uses: actions/setup-node@v2\r\n        with:\r\n          node-version: 16\r\n      - run: npm ci\r\n      - run: npm run test\r\n```\r\n\r\n上面配置大概意思就是，监听所有分支的`push`和`pull_request`动作，自动执行`linter`和`tests`任务。\r\n\r\n然后推送代码，验证配置是否生效\r\n\r\n``` bash\r\ngit add .\r\ngit commit -m 'ci: use github actions'\r\ngit push\r\n```\r\n\r\n此时打开当前项目的 *Github* 页面，然后点击顶部 *Actions* 菜单就会看到正在进行的两个任务，一个将会成功（测试），一个将会失败（发布）。\r\n\r\n上面只是实现了代码自动测试流程，下面实现自动发布的流程。\r\n\r\n在此之前需要到`NPM`网站上注册一个账号（已有可忽略），并创建一个`package`。\r\n\r\n然后创建`GH_TOKEN`和`NPM_TOKEN`（注意，不要在代码中包含任何的 `TOKEN` 信息）：\r\n\r\n- 如何创建 `GITHUB\\_TOKEN`（创建时勾选 *repo* 和 *workflow* 权限）\r\n\r\n- 如何创建 `NPM\\_TOKEN`（创建时选中 *Automation* 权限）\r\n\r\n将创建好的两个`TOKEN`添加到项目的 `Actions secrets` 中：\r\n\r\n*`Github` 项目首页 -> 顶部 `Settings` 菜单 -> 侧边栏 `Secrets`*\r\n\r\n然后修改`package.json`中的“`name`”，“`name`”就是你在`NPM`上创建的`package`的名称。\r\n\r\n在`cd.yml`文件中写入：\r\n\r\n``` yml\r\nname: CD\r\n\r\non:\r\n  push:\r\n    branches:\r\n      - main\r\n  pull_request:\r\n    branches:\r\n      - main\r\njobs:\r\n  release:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v2\r\n      - uses: actions/setup-node@v2\r\n        with:\r\n          node-version: 16\r\n      # https://github.com/semantic-release/git/issues/209\r\n      - run: npm ci --ignore-scripts\r\n      - run: npm run build\r\n      - run: npx semantic-release\r\n        env:\r\n          GH_TOKEN: ${{ secrets.GH_TOKEN }}\r\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\r\n```\r\n\r\n由于“黑命贵”，`Github` 已将新项目的默认分支名称更改为 “`main`”，详见：issues， 为了方便，后面统一称为 `主分支`\r\n\r\n所以如果你的主分支名称是“`main`”，上面的`branches`需要修改为：\r\n\r\n``` yml\r\non:\r\n  push:\r\n    branches:\r\n      - main\r\n  pull_request:\r\n    branches:\r\n      - main\r\n```\r\n\r\n然后安装语义发版依赖，需要用到`semantic-release`和它的插件：\r\n\r\n- **semantic-release**：语义发版核心库\r\n\r\n- **@semantic-release/changelog**：用于自动生成 changelog.md\r\n\r\n- **@semantic-release/git**：用于将发布时产生的更改提交回远程仓库\r\n\r\n``` bash\r\nnpm i semantic-release @semantic-release/changelog @semantic-release/git -D\r\n```\r\n\r\n在项目根目录新建配置文件`.releaserc`并写入：\r\n\r\n``` js\r\n{\r\n  \"branches\": [\"master\"],\r\n  \"plugins\": [\r\n    \"@semantic-release/commit-analyzer\",\r\n    \"@semantic-release/release-notes-generator\",\r\n    \"@semantic-release/changelog\",\r\n    \"@semantic-release/github\",\r\n    \"@semantic-release/npm\",\r\n    \"@semantic-release/git\"\r\n  ]\r\n}\r\n```\r\n\r\n这里同样，如果你的主分支名称是“`main`”，上面的`branches`需要修改为：\r\n\r\n``` js\r\n\"branches\": [\"+([0-9])?(.{+([0-9]),x}).x\", \"main\"],\r\n```\r\n\r\n最后新建分支 *develop* 分支并提交工作内容。\r\n\r\n``` bash\r\ngit checkout -b develop\r\ngit add .\r\ngit commit -m 'feat: complete the CI/CD workflow'\r\ngit push --set-upstream origin develop\r\ngit push\r\n```\r\n\r\n然后将 `develop` 分支合并到 主分支，并提交，注意：这个提交会触发测试并 发布版本 (`自动创建tag和changelog`)\r\n\r\n``` bash\r\ngit checkout master\r\ngit merge develop\r\ngit push\r\n```\r\n\r\n完成上面操作之后，打开 *Github* 项目主页 和 *NPM* 项目主页 可以看到一个 *Release* 的更新记录。\r\n\r\n最后切回到 *develop* 分支，创建一个自动更新依赖的`workflow`。\r\n\r\n在`.github`文件夹中创建`dependabot.yml`文件，并写入内容：\r\n\r\n``` yml\r\nversion: 2\r\nupdates:\r\n  # Enable version updates for npm\r\n  - package-ecosystem: 'npm'\r\n    # Look for `package.json` and `lock` files in the `root` directory\r\n    directory: '/'\r\n    # Check the npm registry for updates every day (weekdays)\r\n    schedule:\r\n      interval: 'weekly'\r\n```\r\n\r\n提交并查看 `workflows` 是否全部通过，再合并到 *主分支* 并提交，这个提交不会触发版本发布。\r\n\r\n``` bash\r\ngit pull origin master\r\ngit add .\r\ngit commit -m 'ci: add dependabot'\r\ngit push\r\n\r\ngit checkout master\r\ngit merge develop\r\ngit push\r\n```\r\n\r\n触发版本发布需要两个条件：\r\n\r\n- 只有当`push和pull_request到` *`主分支`* 上才会触发版本发布\r\n\r\n- 只有`commit`前缀为`feat`、`fix`、`perf`才会发布，否则跳过。\r\n\r\n### 其他\r\n\r\n- [来源](https://blog.csdn.net/wuxiaoying888/article/details/130238060)","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/70/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/70/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### 前端工程化配置指南","### 示例","### 初始化","### 配置","#### Typescript","### Eslint & Prettier","#### Eslint","#### Prettier","#### Husky","#### Commitlint","#### Jest","### Github Actions","### 其他"]},"__N_SSG":true}