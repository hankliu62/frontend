{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/420","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/420/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/420/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/420/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/420","id":2126300505,"node_id":"I_kwDOBiJZIc5-vMVZ","number":420,"title":"Redux应用场景","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6527252877,"node_id":"LA_kwDOBiJZIc8AAAABhQ35jQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview%20questions","name":"interview questions","color":"722ed1","default":false,"description":"面试题"},{"id":6536120916,"node_id":"LA_kwDOBiJZIc8AAAABhZVKVA","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/react","name":"react","color":"0052CC","default":false,"description":"分类-React相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-09T00:54:08Z","updated_at":"2024-02-09T07:02:59Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### 1. Redux应用场景\r\n\r\n在react中，数据在组件中单向流动的，数据只能从父组件向子组件流通（通过props），而两个非父子关系的组件之间通信就比较麻烦，redux的出现就是为了解决这个问题，它将组件之间需要共享的数据存储在一个store里面，其他需要这些数据的组件通过订阅的方式来刷新自己的视图。\r\n\r\n### 2. Redux设计思想\r\n它将整个应用状态存储到store里面，组件可以派发（dispatch）修改数据（state）的行为（action）给store，store内部修改之后，其他组件可以通过订阅（subscribe）中的状态state来刷新（render）自己的视图。\r\n\r\n\r\n### 3. Redux应用的三大原则\r\n\r\n- 单一数据源\r\n我们可以把Redux的状态管理理解成一个全局对象，那么这个全局对象是唯一的，所有的状态都在全局对象store下进行统一”配置”，这样做也是为了做统一管理，便于调试与维护。\r\n\r\n- State是只读的\r\n与React的setState相似，直接改变组件的state是不会触发render进行渲染组件的。同样，在Redux中唯一改变state的方法就是触发action，action是一个用于描述发生了什么的“关键词”，而具体使action在state上更新生效的是reducer，用来描述事件发生的详细过程，reducer充当了发起一个action连接到state的桥梁。这样做的好处是当开发者试图去修改状态时，Redux会记录这个动作是什么类型的、具体完成了什么功能等（更新、传播过程），在调试阶段可以为开发者提供完整的数据流路径。\r\n\r\n- Reducer必须是一个纯函数\r\nReducer用来描述action如何改变state，接收旧的state和action，返回新的state。Reducer内部的执行操作必须是无副作用的，不能对state进行直接修改，当状态发生变化时，需要返回一个全新的对象代表新的state。这样做的好处是，状态的更新是可预测的，另外，这与Redux的比较分发机制相关，阅读Redux判断状态更新的源码部分(combineReducers)，发现Redux是对新旧state直接用==来进行比较，也就是浅比较，如果我们直接在state对象上进行修改，那么state所分配的内存地址其实是没有变化的，“==”是比较对象间的内存地址，因此Redux将不会响应我们的更新。之所以这样处理是避免对象深层次比较所带来的性能损耗（需要递归遍历比较）。\r\n\r\n### 4. 源码实现\r\n\r\n#### 4.1 createStore\r\n\r\n``` js\r\nexport default function createStore(reducer, initialState) {\r\n    let state = initialState //状态\r\n    let listeners = []\r\n    //获取当前状态\r\n    function getState() {\r\n      return state\r\n    }\r\n    //派发修改指令给reducer\r\n    function dispatch(action) {\r\n      //reducer修改之后返回新的state\r\n      state = reducer(state,action)\r\n      //执行所有的监听函数\r\n      listeners.forEach(listener => listener())\r\n    }\r\n\r\n    //订阅 状态state变化之后需要执行的监听函数\r\n    function subscribe(listener) {\r\n      listeners.push(listener) //监听事件\r\n      return function () {\r\n        let index = listeners.indexOf(listener)\r\n        listeners.splice(index,1)\r\n      }\r\n    }\r\n    //在仓库创建完成之后会先派发一次动作，目的是给初始化状态赋值\r\n    dispatch({type:'@@REDUX_INIT'})\r\n    return {\r\n      getState,\r\n      dispatch,\r\n      subscribe\r\n    }\r\n  }\r\n```\r\n\r\naction_type.js\r\n\r\n``` js\r\nexport const ADD = 'ADD'\r\nexport const MINUS = 'MINUS'\r\n```\r\n\r\nreducer.js\r\n\r\n``` js\r\nimport * as TYPES from './actions_type'\r\nlet initialState = {number: 0}\r\nexport default function reducer (state = initialState, action) {\r\n    switch (action.type) {\r\n        case TYPES.ADD:\r\n            return {number: state.number + 1}\r\n         case TYPES.MINUS:\r\n            return {number: state.number - 1}\r\n         default:\r\n             return state\r\n    }\r\n}\r\n```\r\n\r\nstore.js\r\n\r\n``` js\r\nimport {createStore} from 'redux'\r\nimport reducer from './reducer'\r\nconst store = createStore(reducer)\r\nexport default store\r\n```\r\n\r\n组件Counter.js\r\n\r\n``` jsx\r\nimport React, {useState,useEffect} from 'react'\r\nimport store from '../store'\r\nimport * as TYPES from '../store/actions_type'\r\n//类组件写法：\r\nexport default class Counter extends React.Component {\r\n    state = {number: store.getState().number}\r\n    componentDidMount() {\r\n        //当状态发生变化后会让订阅函数执行，会更新当前组件状态，状态更新之后就会刷新组件\r\n        this.unSubscribe = store.subscribe( () => {\r\n            this.setState({number: store.getState().number})\r\n        })\r\n    }\r\n    //组件销毁的时候取消监听函数\r\n    componentWillUnmount() {\r\n        this.unSubscribe()\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <p>{this.state.number}</p>\r\n                <button onClick={()=> store.dispatch({type:TYPES.ADD})}>+</button>\r\n                <button onClick={()=> store.dispatch({type:TYPES.MINUS})}>-</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n//函数组件写法：\r\nexport default function Counter (props) {\r\n    let [number,setNumber] = useState(store.getState().number)\r\n    //订阅\r\n    useEffect(() => {\r\n        return store.subscribe(() => { //这个函数会返回一个销毁函数，此销毁函数会自动在组件销毁的时候调用\r\n            setNumber(store.getState().number)\r\n        })\r\n    },[]) // useEffect的第二个参数是依赖变量的数组，当这个依赖数组发生变化的时候才会执行函数\r\n    // 传入空数组，只会执行一遍\r\n    return (\r\n        <div>\r\n            <p>{store.getState().number}</p>\r\n            <button onClick={()=> store.dispatch({type:TYPES.ADD})}>+</button>\r\n            <button onClick={()=> store.dispatch({type:TYPES.MINUS})}>-</button>\r\n        </div>\r\n    )\r\n }\r\n /**\r\n  * 对于组件来说仓库有两个作用\r\n  * 1.输出：把仓库中的状态在组件中显示\r\n  * 2.输入：在组件里可以派发动作给仓库，从而修改仓库中的状态\r\n  * 3.组件需要订阅状态变化事件，当仓库中的状态发生改变之后需要刷新组件\r\n  */\r\n```\r\n\r\n#### 4.2 bindActionCreators\r\n\r\n简易版\r\n\r\n``` js\r\nexport default function (actionCreators, dispatch) {\r\n    let boundActionsCreators = {}\r\n    //循环遍历重写action\r\n    for(let key in actionCreators) {\r\n        boundActionsCreators[key] = function(...args) {\r\n            //其实dispatch方法会返回派发的action\r\n            return dispatch(actionCreators[key](...args))\r\n        }\r\n    }\r\n    return boundActionsCreators\r\n}\r\n```\r\n\r\n源码版\r\n``` js\r\nfunction bindActionCreator(actionCreator, dispatch) {\r\n  return function () {\r\n    return dispatch(actionCreator.apply(this, arguments))\r\n  }\r\n}\r\n\r\n/**\r\n    参数说明：\r\n        actionCreators: action create函数，可以是一个单函数，也可以是一个对象，这个对象的所有元素都是action create函数\r\n        dispatch: store.dispatch方法\r\n*/\r\nexport default function bindActionCreators(actionCreators, dispatch) {\r\n  // 如果actionCreators是一个函数的话，就调用bindActionCreator方法对action create函数和dispatch进行绑定\r\n  if (typeof actionCreators === 'function') {\r\n    return bindActionCreator(actionCreators, dispatch)\r\n  }\r\n  // actionCreators必须是函数或者对象中的一种，且不能是null\r\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\r\n    throw new Error(\r\n      `bindActionCreators expected an object or a function, instead received ${actionCreators === null ? 'null' : typeof actionCreators}. ` +\r\n      `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`\r\n    )\r\n  }\r\n\r\n  // 获取所有action create函数的名字\r\n  const keys = Object.keys(actionCreators)\r\n  // 保存dispatch和action create函数进行绑定之后的集合\r\n  const boundActionCreators = {}\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i]\r\n    const actionCreator = actionCreators[key]\r\n    // 排除值不是函数的action create\r\n    if (typeof actionCreator === 'function') {\r\n      // 进行绑定\r\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\r\n    }\r\n  }\r\n  // 返回绑定之后的对象\r\n  /**\r\n      boundActionCreators的基本形式就是\r\n      {\r\n      actionCreator: function() {dispatch(actionCreator.apply(this, arguments))}\r\n      }\r\n  */\r\n  return boundActionCreators\r\n}\r\n```\r\n\r\nCounter.js\r\n``` js\r\nimport React, {useState,useEffect} from 'react'\r\nimport store from '../store'\r\nimport actions from '../store/actions_type'\r\nimport { bindActionCreators } from 'redux'\r\n\r\nlet boundActions = bindActionCreators(actions, store.dispatch)\r\n//类组件\r\nexport default class Counter extends React.Component {\r\n    state = {number: store.getState().number}\r\n    componentDidMount() {\r\n        //当状态发生变化后会让订阅函数执行，会更新当前组件状态，状态更新之后就会刷新组件\r\n        this.unSubscribe = store.subscribe( () => {\r\n            this.setState({number: store.getState().number})\r\n        })\r\n    }\r\n    //组件销毁的时候取消监听函数\r\n    componentWillUnmount() {\r\n        this.unSubscribe()\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <p>{this.state.number}</p>\r\n                <button onClick={boundActions.add}>+</button>\r\n                <button onClick={boundActions.minus}>-</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 4.3 combineReducer\r\n\r\n``` js\r\n/**\r\n * 合并reducer\r\n * 1.拿到子reducer，然后合并成一个reducer\r\n * @param {*} state\r\n * @param {*} action\r\n */\r\nexport default  function combineReducers(reducers) {\r\n    //state是合并后得state = {counter1:{number:0},counter2:{number:0}}\r\n    return function (state={}, action) {\r\n        let nextState = {}\r\n        // debugger\r\n        for(let key in reducers) {\r\n            let reducerForKey = reducers[key] //key = counter1,\r\n            //老状态\r\n            let previousStateForKey = state[key] //{number:0}\r\n            let nextStateForKey = reducerForKey(previousStateForKey,action) //执行reducer，返回新得状态\r\n            nextState[key] = nextStateForKey //{number: 1}\r\n        }\r\n        return nextState\r\n    }\r\n}\r\n```\r\n\r\n### react-redux Provider和connect\r\n\r\nProvider.js\r\n\r\n``` js\r\nimport React from 'react'\r\nimport ReactReduxContext from './context'\r\n/**\r\n * Provider 有个store属性，需要向下传递这个属性\r\n * @param {*} props\r\n */\r\nexport default function (props) {\r\n    return (\r\n        <ReactReduxContext.Provider value={{store:props.store}}>\r\n            {props.children}\r\n        </ReactReduxContext.Provider>\r\n    )\r\n}\r\n```\r\n\r\nconnect.js\r\n\r\n``` js\r\nimport React, {useContext, useState, useEffect} from 'react'\r\nimport ReactReduxContext from './context'\r\nimport { bindActionCreators } from 'redux'\r\n\r\nexport default function (mapStateToProps,mapDispatchToProps) {\r\n    return function(OldComponent){\r\n        //返回一个组件\r\n        return function(props) {\r\n            //获取state\r\n            let context = useContext(ReactReduxContext) //context.store\r\n            let [state,setState] = useState(mapStateToProps(context.store.getState()))\r\n            //利用useState只会在初始化的时候绑定一次\r\n            let [boundActions] = useState(() => bindActionCreators(mapDispatchToProps,context.store.dispatch))\r\n            //订阅事件\r\n            useEffect(() => {\r\n                return context.store.subscribe(() => {\r\n                    setState(mapStateToProps(context.store.getState()))\r\n                })\r\n            },[])\r\n            //派发事件 这种方式派发事件的时候每次render都会进行一次事件的绑定，耗费性能\r\n            // let boundActions = bindActionCreators(mapDispatchToProps,context.store.dispatch)\r\n            //返回组件\r\n            return <OldComponent {...props} {...state} {...boundActions} />\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 4.5 redux 中间件middlewares\r\n\r\n正常我们的redux是这样的工作流程，action -> reducer ，这相当于是同步操作，由dispatch触发action之后直接去reducer执行相应的操作。但有时候我们会实现一些异步任务，像点击按钮 -> 获取服务器数据 ->渲染视图，这个时候就需要引入中间件改变redux同步执行流程，形成异步流程来实现我们的任务。有了中间件redux的工作流程就是action -> 中间件 -> reducer ，点击按钮就相当于dispatch 触发action，接着就是服务器获取数据middlewares执行，成功获取数据后触发reducer对应的操作，更新需要渲染的视图数据。\r\n\r\n中间件的机制就是改变数据流，实现异步action，日志输出，异常报告等功能。\r\n\r\n##### 4.5.1 日志中间件\r\n\r\n``` js\r\nimport {createStore} from 'redux'\r\nimport reducer from './reducers/Counter'\r\nconst store = createStore(reducer)\r\n//1.备份原生的dispatch方法\r\n// let dispatch = store.dispatch\r\n// //2.重写dispatch方法 做一些额外操作\r\n// store.dispatch = function (action) {\r\n//     console.log('老状态',store.getState())\r\n//     //触发原生dispatch方法\r\n//     dispatch(action)\r\n//     console.log('新状态', store.getState())\r\n// }\r\n\r\nfunction logger ({dispatch, getState}) { //dispatch是重写后的dispatch\r\n    return function (next) { //next代表原生的dispatch方法，调用下一个中间件或者store.dispatch 级联\r\n        //改写后的dispatch方法\r\n        return function (action) {\r\n            console.log('老状态', getState())\r\n            next(action) //store.dispatch(action)\r\n            console.log('新状态', getState())\r\n            // dispatch(action) //此时的dispatch是重写后的dispatch方法，这样会造成死循环\r\n        }\r\n    }\r\n}\r\n\r\nfunction applyMiddleware(middleware) { //middleware = logger\r\n    return function(createStore) {\r\n        return function (reducer) {\r\n            let store = createStore(reducer) // 返回的是原始的未修改后的store\r\n            let dispatch\r\n            middleware = middleware({ //logger执行 需要传参getState 和 dispatch 此时的 middleware = function(next)\r\n                getState: store.getState,\r\n                dispatch: action => dispatch(action) //指向改写后的新的dispatch 不能是store.dispatch\r\n            })\r\n            dispatch = middleware(store.dispatch) //执行上面返回的middleware ，store.dispatch 代表next\r\n            return {\r\n                ...store,\r\n                dispatch\r\n            }\r\n        }\r\n    }\r\n}\r\nlet store = applyMiddleware(logger)(createStore)(reducer)\r\nexport default store\r\n```\r\n\r\n##### 4.5.2 thunk中间件\r\n\r\n``` js\r\nfunction thunk ({dispatch, getState}) {\r\n    return function (next) {\r\n        return function (action) {\r\n            if(typeof action === 'function') {\r\n                action(dispatch, getState)\r\n            }else {\r\n                next(action)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction applyMiddleware(middleware) { //middleware = logger\r\n    return function(createStore) {\r\n        return function (reducer) {\r\n            let store = createStore(reducer) // 返回的是原始的未修改锅的store\r\n            let dispatch\r\n            middleware = middleware({ //logger执行 需要传参getState 和 dispatch 此时的 middleware = function(next)\r\n                getState: store.getState,\r\n                dispatch: action => dispatch(action) //指向改写后的新的dispatch 不能是store.dispatch\r\n            })\r\n            dispatch = middleware(store.dispatch) //执行上面返回的middleware ，store.dispatch 代表next\r\n            return {\r\n                ...store,\r\n                dispatch\r\n            }\r\n        }\r\n    }\r\n}\r\nlet store = applyMiddleware(thunk)(createStore)(reducer)\r\nexport default store\r\n```\r\n\r\n##### 4.5.3 级联中间件\r\n\r\n上面我们调用的中间件都是单个调用，传进applyMiddleware的参数也是单个的，但是我们要想一次调用多个中间件，那么传到applyMiddleware的参数就是个数组，这个时候就需要级联处理，让他们一次执行。\r\n\r\n``` js\r\nfunction compose(...funcs) {\r\n  if (funcs.length === 0) {\r\n    return (arg) => arg\r\n  }\r\n\r\n  if (funcs.length === 1) {\r\n    return funcs[0]\r\n  }\r\n\r\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\r\n}\r\n\r\n\r\nfunction applyMiddleware(...middlewares) { //middleware = logger\r\n    return function(createStore) {\r\n        return function (reducer) {\r\n            let store = createStore(reducer) // 返回的是原始的未修改锅的store\r\n            let dispatch = () => {\r\n              throw new Error(\r\n                'Dispatching while constructing your middleware is not allowed. ' +\r\n                  'Other middleware would not be applied to this dispatch.'\r\n              )\r\n            }\r\n            let middlewareAPI = {\r\n                getState: store.getState,\r\n                dispatch: action => dispatch(action) //指向改写后的新的dispatch 不能是store.dispatch\r\n            }\r\n            chain= middlewares.map(middleware => middleware(middlewareAPI))\r\n            dispatch = compose(...chain)(store.dispatch)\r\n            // dispatch = middleware(store.dispatch) //执行上面返回的middleware ，store.dispatch 代表next\r\n            return {\r\n                ...store,\r\n                dispatch\r\n            }\r\n        }\r\n    }\r\n}\r\nlet store = applyMiddleware(promise,thunk, logger)(createStore)(reducer)\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/420/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/420/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### 1. Redux应用场景","### 2. Redux设计思想","### 3. Redux应用的三大原则","### 4. 源码实现","#### 4.1 createStore","#### 4.2 bindActionCreators","#### 4.3 combineReducer","### react-redux Provider和connect","#### 4.5 redux 中间件middlewares","##### 4.5.1 日志中间件","##### 4.5.2 thunk中间件","##### 4.5.3 级联中间件"]},"__N_SSG":true}