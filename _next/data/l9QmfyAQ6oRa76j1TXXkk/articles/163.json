{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/163","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/163/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/163/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/163/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/163","id":2124562956,"node_id":"I_kwDOBiJZIc5-okIM","number":163,"title":"介绍防抖节流原理、区别以及应用，并用JavaScript进行实现","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6527252877,"node_id":"LA_kwDOBiJZIc8AAAABhQ35jQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview%20questions","name":"interview questions","color":"722ed1","default":false,"description":"面试题"},{"id":6536264028,"node_id":"LA_kwDOBiJZIc8AAAABhZd5XA","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/handwritten","name":"handwritten","color":"faad14","default":false,"description":"分类-手写题相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-08T07:56:32Z","updated_at":"2024-02-09T08:15:51Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### 1）防抖\r\n\r\n- 原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\r\n\r\n- 适用场景：\r\n  - 按钮提交场景：防止多次提交按钮，只执行最后提交的一次\r\n  - 搜索框联想场景：防止联想发送请求，只发送最后一次输入\r\n\r\n- 简易版实现\r\n\r\n``` js\r\n/**\r\n * 防抖:\r\n *\r\n * 应用场景：当用户进行了某个行为(例如点击)之后。不希望每次行为都会触发方法，而是行为做出后,一段时间内没有再次重复行为，才给用户响应\r\n * 实现原理 : 每次触发事件时设置一个延时调用方法，并且取消之前的延时调用方法。（每次触发事件时都取消之前的延时调用方法）\r\n * @params fun 传入的防抖函数(callback) delay 等待时间\r\n *\r\n */\r\nconst debounce = (fun, delay = 500) => {\r\n    let timer = null //设定一个定时器\r\n    return function (...args) {\r\n        clearTimeout(timer);\r\n        timer = setTimeout(() => {\r\n            fun.apply(this, args)\r\n        }, delay)\r\n    }\r\n}\r\n```\r\n\r\n- 立即执行版实现\r\n\r\n有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。\r\n\r\n``` js\r\n// 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。\r\nfunction debounce(func, wait, immediate) {\r\n  let timeout;\r\n  return function () {\r\n    const context = this;\r\n    const args = arguments;\r\n    if (timeout) clearTimeout(timeout);\r\n    if (immediate) {\r\n      const callNow = !timeout;\r\n      timeout = setTimeout(function () {\r\n        timeout = null;\r\n      }, wait)\r\n      if (callNow) func.apply(context, args)\r\n    } else {\r\n      timeout = setTimeout(function () {\r\n        func.apply(context, args)\r\n      }, wait);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n- 返回值版实现\r\n\r\nfunc函数可能会有返回值，所以需要返回函数结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以只在 immediate 为 true 的时候返回函数的执行结果。\r\n\r\n``` js\r\nfunction debounce(func, wait, immediate) {\r\n  let timeout, result;\r\n  return function () {\r\n    const context = this;\r\n    const args = arguments;\r\n    if (timeout) clearTimeout(timeout);\r\n    if (immediate) {\r\n      const callNow = !timeout;\r\n      timeout = setTimeout(function () {\r\n        timeout = null;\r\n      }, wait)\r\n      if (callNow) result = func.apply(context, args)\r\n    }\r\n    else {\r\n      timeout = setTimeout(function () {\r\n        func.apply(context, args)\r\n      }, wait);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n```\r\n\r\n### 2）节流\r\n\r\n- 原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\r\n\r\n- 适用场景\r\n  - 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动\r\n  - 缩放场景：监控浏览器resize\r\n\r\n- 简易版实现\r\n\r\n``` js\r\n/**\r\n * 节流\r\n *\r\n * 应用场景:用户进行高频事件触发(滚动)，但在限制在n秒内只会执行一次。\r\n * 实现原理: 每次触发时间的时候，判断当前是否存在等待执行的延时函数。\r\n *\r\n * @params fun 传入的防抖函数(callback) delay 等待时间\r\n *\r\n */\r\nconst throttle = (fun, delay = 1000) => {\r\n  let flag = true;\r\n  return function (...args) {\r\n    if (!flag) return;\r\n    flag = false;\r\n    setTimeout(() => {\r\n      fun.apply(this, args);\r\n      flag = true;\r\n    }, delay);\r\n  }\r\n}\r\n```\r\n\r\n\r\n- 使用时间戳实现\r\n\r\n使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。\r\n\r\n``` js\r\nfunction throttle(func, wait) {\r\n  let context, args;\r\n  let previous = 0;\r\n\r\n  return function () {\r\n    let now = +new Date();\r\n    context = this;\r\n    args = arguments;\r\n    if (now - previous > wait) {\r\n      func.apply(context, args);\r\n      previous = now;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n- 使用定时器实现\r\n\r\n当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\r\n\r\n``` js\r\nfunction throttle(func, wait) {\r\n  let timeout;\r\n  return function () {\r\n    const context = this;\r\n    const args = arguments;\r\n    if (!timeout) {\r\n      timeout = setTimeout(function () {\r\n        timeout = null;\r\n        func.apply(context, args)\r\n      }, wait);\r\n    }\r\n  }\r\n}\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/163/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/163/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### 1）防抖","### 2）节流"]},"__N_SSG":true}