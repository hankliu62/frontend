{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/73","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/73/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/73/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/73/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/73","id":1788712285,"node_id":"I_kwDOBiJZIc5qnZVd","number":73,"title":"如何使用 Next.js 检测 React s-s-r App 上的设备？","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2023-07-05T03:50:17Z","updated_at":"2023-07-05T03:50:17Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"技术标签:\r\n\r\n【中文标题】如何使用 Next.js 检测 React s-s-r App 上的设备？\r\n【英文标题】：How to detect the device on React s-s-r App with Next.js?\r\n【发布时间】：2020-04-17 00:39:57\r\n【问题描述】：\r\n在一个网络应用程序上，我想显示两个不同的菜单，一个用于移动设备，一个用于桌面浏览器。 我使用带有服务器端渲染的 Next.js 应用程序和库 react-device-detect。\r\n\r\n这里是CodeSandox link。\r\n``` tsx\r\nimport Link from \"next/link\";\r\nimport  BrowserView, MobileView  from \"react-device-detect\";\r\n\r\nexport default () => (\r\n  <div>\r\n    Hello World.\" \"\r\n    <Link href=\"/about\">\r\n      <a>About</a>\r\n    </Link>\r\n    <BrowserView>\r\n      <h1> This is rendered only in browser </h1>\r\n    </BrowserView>\r\n    <MobileView>\r\n      <h1> This is rendered only on mobile </h1>\r\n    </MobileView>\r\n  </div>\r\n);\r\n```\r\n如果您在浏览器中打开它并\r\n切换到移动\r\n视图并查看控制台，您会收到以下错误：\r\n\r\n警告：文本内容不匹配。服务器：“这只是渲染 在浏览器“客户端：”这仅在移动设备上呈现“\r\n\r\n发生这种情况是因为服务器的渲染检测到了浏览器，而在客户端，他是移动设备。我发现的唯一解决方法是生成两者并像这样使用 CSS：\r\n```\r\n.activeOnMobile \r\n  @media screen and (min-width: 800px) \r\n    display: none;\r\n  \r\n\r\n\r\n.activeOnDesktop \r\n  @media screen and (max-width: 800px) \r\n    display: none;\r\n  \r\n```\r\n而不是图书馆，但我不太喜欢这种方法。有人知道直接在反应代码中处理 s-s-r 应用程序上的设备类型的良好做法吗？\r\n\r\n【问题讨论】：\r\n\r\n我认为该 atm 没有解决方案，因为在服务器端渲染然后浏览器信息是不可知的，它还与您的\r\n[html](https://it.cha138.com/html/)\r\n响应的缓存时间有关\r\n### 【参考方案1】：\r\n我认为您应该通过在您的页面中使用 getInitialProps 来做到这一点，因为它同时在服务器和客户端上运行，并通过首先检测您是否只是收到对网页的请求来获取设备类型（所以您是仍然在服务器上），或者如果您正在重新渲染（所以您在客户端上）。\r\n\r\n```\r\n// index.js\r\n\r\nIndexPage.getInitialProps = ( req ) => \r\n  let userAgent;\r\n  if (req)  // if you are on the server and you get a 'req' property from your context\r\n    userAgent = req.headers['user-agent'] // get the user-agent from the headers\r\n   else \r\n    userAgent = navigator.userAgent // if you are on the client you can access the navigator from the window object\r\n  \r\n```\r\n现在您可以使用正则表达式来查看设备是移动设备还是桌面设备。\r\n```\r\n// still in getInitialProps\r\n\r\nlet isMobile = Boolean(userAgent.match(\r\n  /\r\n[android](https://it.cha138.com/android/)\r\n|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i\r\n))\r\n\r\nreturn  isMobile \r\n```\r\n现在您可以访问将返回 true 或 false 的 isMobile 道具\r\n```\r\nconst IndexPage = ( isMobile ) => \r\n  return ( \r\n    <div>\r\n     isMobile ? (<h1>I am on mobile!</h1>) : (<h1>I am on desktop! </h1>) \r\n    </div>\r\n  )\r\n```\r\n我从this article here 得到了这个答案 希望对你有帮助\r\n\r\n更新\r\n\r\n自 Next 9.5.0 起，getInitialProps 将被 getStaticProps 和 getServerSideProps 取代。 getStaticProps 用于获取静态数据，将用于在构建时创建一个 html 页面，getServerSideProps 在每个请求上动态生成页面，并接收带有 req 属性的 context 对象，就像 @ 987654332@。不同之处在于getServerSideProps 不会知道navigator，因为它只是服务器端。用法也有点不同，因为您必须导出异步函数，而不是在组件上声明方法。它会这样工作：\r\n```\r\nconst HomePage = ( deviceType ) => \r\nlet componentToRender\r\n  if (deviceType === 'mobile') \r\n    componentToRender = <MobileComponent />\r\n   else \r\n    componentToRender = <DesktopComponent />\r\n  \r\n\r\n  return componentToRender\r\n\r\n\r\nexport async function getServerSideProps(context) \r\n  const UA = context.req.headers['user-agent'];\r\n  const isMobile = Boolean(UA.match(\r\n    /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i\r\n  ))\r\n  \r\n  return \r\n    props: \r\n      deviceType: isMobile ? 'mobile' : 'desktop'\r\n    \r\n  \r\n\r\n\r\n\r\nexport default HomePage\r\n\r\n```\r\n\r\n请注意，由于getServerSideProps和getStaticProps是互斥的，你需要放弃getStaticProps提供的SSG优势才能知道用户的设备类型。如果您只需要处理几个样式细节，我建议不要为此目的使用 getServerSideProps。如果页面的结构因设备类型而有很大不同，那可能是值得的\r\n\r\n【讨论】：\r\n\r\n谢谢，我去测试一下 嗨 Dylanbob211，从任何组件获取 isMobile 道具的方法是什么？ 好吧，你的页面组件中有这个道具（index.js 或 getInitialProp 函数所在的任何页面组件），所以你需要传递这个道具。您可以使用 prop-drilling 技术（从父级传递到子级的分类道具）、使用状态管理器（redux、mobx 等）或使用 Context API 来完成。问题是你只能在页面组件中获得这个道具，因为你需要使用 getInitialProps 请记住navigator 永远不会在getInitialProps 中定义，getInitialProps 仅在服务器端运行，因此您将始终收到req.headers['user-agent'] 您仍然可以使用 _app.js 应用 getInitialProps 方法，然后将其作为道具传递给您的页面。\r\n###【参考方案2】：\r\n最新更新：\r\n\r\n因此，如果您不介意在客户端执行此操作，则可以使用下面一些人建议的动态导入。这适用于使用静态页面生成的用例。\r\n\r\n我创建了一个组件，它将所有 react-device-detect 导出作为道具传递（明智的做法是只过滤掉所需的导出，因为这样就不会摇晃）\r\n```\r\n// Device/Device.tsx\r\n\r\nimport  ReactNode  from 'react'\r\nimport * as rdd from 'react-device-detect'\r\n\r\ninterface DeviceProps \r\n  children: (props: typeof rdd) => ReactNode\r\n\r\nexport default function Device(props: DeviceProps) \r\n  return <div className=\"device-layout-component\">props.children(rdd)</div>\r\n\r\n\r\n// Device/index.ts\r\n\r\nimport dynamic from 'next/dynamic'\r\n\r\nconst Device = dynamic(() => import('./Device'),  s-s-r: false )\r\n\r\nexport default Device\r\n```\r\n然后当你想使用该组件时，你可以这样做\r\n```\r\nconst Example = () => \r\n  return (\r\n    <Device>\r\n      ( isMobile ) => \r\n        if (isMobile) return <div>My Mobile View</div>\r\n        return <div>My Desktop View</div>\r\n      \r\n    </Device>\r\n  )\r\n```\r\n我个人只是用一个钩子来做这个，虽然初始的 props 方法更好。\r\n```\r\nimport  useEffect  from 'react'\r\n\r\nconst getMobileDetect = (userAgent: NavigatorID['userAgent']) => \r\n  const isAndroid = () => Boolean(userAgent.match(/Android/i))\r\n  const is\r\n[ios](https://it.cha138.com/ios/)\r\n = () => Boolean(userAgent.match(/iPhone|iPad|iPod/i))\r\n  const isOpera = () => Boolean(userAgent.match(/Opera Mini/i))\r\n  const isWindows = () => Boolean(userAgent.match(/IEMobile/i))\r\n  const iss-s-r = () => Boolean(userAgent.match(/s-s-r/i))\r\n  const isMobile = () => Boolean(isAndroid() || isIos() || isOpera() || isWindows())\r\n  const isDesktop = () => Boolean(!isMobile() && !iss-s-r())\r\n  return \r\n    isMobile,\r\n    isDesktop,\r\n    isAndroid,\r\n    isIos,\r\n    iss-s-r,\r\n  \r\n\r\nconst useMobileDetect = () => \r\n  useEffect(() => , [])\r\n  const userAgent = typeof navigator === 'undefined' ? 's-s-r' : navigator.userAgent\r\n  return getMobileDetect(userAgent)\r\n\r\n\r\nexport default useMobileDetect\r\n```\r\n我遇到了滚动动画在移动设备上很烦人的问题，所以我制作了一个基于设备的启用滚动动画组件；\r\n```\r\nimport React,  ReactNode  from 'react'\r\nimport ScrollAnimation,  ScrollAnimationProps  from 'react-animate-on-scroll'\r\nimport useMobileDetect from 'src/utils/useMobileDetect'\r\n\r\ninterface DeviceScrollAnimation extends ScrollAnimationProps \r\n  device: 'mobile' | 'desktop'\r\n  children: ReactNode\r\n\r\n\r\nexport default function DeviceScrollAnimation( device, animateIn, animateOut, initiallyVisible, ...props : DeviceScrollAnimation) \r\n  const currentDevice = useMobileDetect()\r\n\r\n  const flag = device === 'mobile' ? currentDevice.isMobile() : device === 'desktop' ? currentDevice.isDesktop() : true\r\n\r\n  return (\r\n    <ScrollAnimation\r\n      animateIn=flag ? animateIn : 'none'\r\n      animateOut=flag ? animateOut : 'none'\r\n      initiallyVisible=flag ? initiallyVisible : true\r\n      ...props\r\n    />\r\n  )\r\n```\r\n更新：\r\n所以在进一步深入兔子洞之后，我想出的最佳解决方案是在 useEffect 中使用 react-device-detect，如果您进一步检查设备检测，您会注意到它导出通过设置的 const ua-parser-js库\r\n```\r\nexport const UA = new UAParser();\r\n\r\nexport const browser = UA.getBrowser();\r\nexport const cpu = UA.getCPU();\r\nexport const device = UA.getDevice();\r\nexport const engine = UA.getEngine();\r\nexport const os = UA.getOS();\r\nexport const ua = UA.getUA();\r\nexport const setUA = (uaStr) => UA.setUA(uaStr);\r\n```\r\n这导致初始设备是导致错误检测的服务器。\r\n\r\n我分叉了 repo 并创建并添加了一个s-s-r-selector，它要求你传入一个用户代理。这可以使用初始道具来完成\r\n\r\n更新：\r\n由于 Ipad 没有提供正确或定义得足够好的用户代理，请参阅issue，我决定创建一个挂钩来更好地检测设备\r\n```\r\nimport  useEffect, useState  from 'react'\r\n\r\nfunction isTouchDevice() \r\n  if (typeof window === 'undefined') return false\r\n  const prefixes = ' -webkit- -moz- -o- -ms- '.split(' ')\r\n  function mq(query) \r\n    return typeof window !== 'undefined' && window.matchMedia(query).matches\r\n  \r\n  // @ts-ignore\r\n  if ('ontouchstart' in window || (window?.DocumentTouch && document instanceof DocumentTouch)) return true\r\n  const query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('') // include the 'heartz' - https://git.io/vznFH\r\n  return mq(query)\r\n\r\n\r\nexport default function useIsTouchDevice() \r\n  const [isTouch, setIsTouch] = useState(false)\r\n  useEffect(() => \r\n    const  isAndroid, isIPad13, isIPhone13, isWinPhone, isMobileSafari, isTablet  = require('react-device-detect')\r\n    setIsTouch(isTouch || isAndroid || isIPad13 || isIPhone13 || isWinPhone || isMobileSafari || isTablet || isTouchDevice())\r\n  , [])\r\n\r\n  return isTouch\r\n```\r\n因为我每次调用该钩子时都需要该包，所以更新了 UA 信息，它还修复了 s-s-r 不同步警告。\r\n\r\n【讨论】：\r\n\r\n我觉得应该改成if ('ontouchstart' in window || (window?.Document &amp;&amp; document instanceof Document)) return true;。不是100%肯定，但是TS抱怨，还有this 啊，我明白了，这打破了包装。我暂时将interface Window DocumentTouch: any; 添加到我的global.d.ts。这暂时有效：if ('ontouchstart' in window || (window?.DocumentTouch &amp;&amp; document instanceof Document)) return true;\r\n###【参考方案3】：\r\n对于当前的 Next.js (v 9.5+)，我使用 next/dynamic 和 react-detect-device 实现了这一点。\r\n\r\n例如，在我的header 组件上：\r\n```\r\n...\r\nimport dynamic from 'next/dynamic';\r\n...\r\n\r\nconst MobileMenuHandler = dynamic(() => import('./mobileMenuHandler'), \r\n s-s-r: false,\r\n);\r\n\r\nreturn (\r\n...\r\n    <MobileMenuHandler\r\n        isMobileMenuOpen=isMobileMenuOpen\r\n        setIsMobileMenuOpen=setIsMobileMenuOpen\r\n    />\r\n)\r\n...\r\n```\r\n然后在MobileMenuHandler，只在客户端调用：\r\n```\r\nimport  isMobile  from 'react-device-detect';\r\n...\r\nreturn(\r\n   isMobile && !isMobileMenuOpen ? (\r\n       <Menu\r\n          onClick=() => setIsMobileMenuOpen(true)\r\n          className=classes.menuIcon\r\n       />\r\n   ) : null\r\n)\r\n```\r\n这样，react-detect-device 仅在客户端处于活动状态，并且可以给出正确的读数。\r\n\r\n见Next.js docs。\r\n\r\n【讨论】：\r\n\r\n###【参考方案4】：\r\n只动态加载需要的JS文件\r\n你可以用next/dynamic动态加载组件，只会加载合适的组件。\r\n\r\n在我的情况下，您可以使用 react-detect-device 或 is-mobile。在这种情况下，我为移动和桌面创建了单独的布局，并根据设备加载了相应的组件。\r\n```\r\nimport dynamic from 'next/dynamic';\r\nconst mobile = require('is-mobile');\r\n\r\nconst ShowMobile = dynamic(() => mobile() ? import('./ShowMobile.mobile') : import('./ShowMobile'),  s-s-r: false )\r\n\r\n\r\nconst TestPage = () => \r\n\r\n   return <ShowMobile />\r\n\r\n\r\nexport default TestPage\r\n```\r\n您可以查看codesandbox 。只会加载所需的 component.JS。\r\n\r\n编辑：\r\n\r\n以上内容与条件加载组件有何不同？例如\r\n```\r\nisMobile ? <MobileComponent /> : <NonMobileComponent />\r\n```\r\n第一个解决方案不会加载JS文件，而在第二个解决方案中，两个JS文件都会被加载。这样您就可以节省一次往返行程。\r\n\r\n【讨论】：\r\n\r\n###【参考方案5】：\r\n如果您不介意总是渲染桌面版本并在前端计算逻辑，那么挂钩逻辑可以非常简单。\r\n```\r\nexport const useDevice = () => \r\n  const [firstLoad, setFirstLoad] = React.useState(true);\r\n  React.useEffect(() =>  setFirstLoad(false); , []);\r\n\r\n  const s-s-r = firstLoad || typeof navigator === \"undefined\";\r\n\r\n  const isAndroid = !s-s-r && /android/i.test(navigator.userAgent);\r\n  const isIos = !s-s-r && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\r\n\r\n  return \r\n    isAndroid,\r\n    isIos,\r\n    isDesktop: !isAndroid && !isIos\r\n  ;\r\n;\r\n```\r\n【讨论】：\r\n\r\n###【参考方案6】：\r\n```\r\nimport React,  useState, useEffect \r\nimport  isMobile  from 'react-device-detect'\r\n\r\n...\r\n\r\n\r\nconst [_isMobile, setMobile] = useState();\r\n\r\n    useEffect(() => \r\n        setMobile(isMobile);\r\n    , [setMobile]);\r\n\r\n<div hidden=_isMobile> Desktop View</div>\r\n\r\n<div hidden=!_isMobile> MobileView </div>\r\n```\r\n【讨论】：\r\n\r\n###【参考方案7】：\r\n这总是有效的。 （我在尝试了上述技术后使用了这个包，但它对我不起作用。）\r\n\r\n优点：组件呈现服务器端，因此客户端在尝试检测用户代理时不会闪烁。\r\n```\r\nimport  isMobile  from \"mobile-device-detect\";\r\n```\r\n只需导入包并创建您的布局。\r\n```\r\nimport  isMobile  from \"mobile-device-detect\";\r\n\r\nconst Desktop = () => \r\n  return (\r\n    <>\r\n      desktop\r\n    </>\r\n  );\r\n;\r\n\r\nDesktop.layout = Layout;\r\n\r\nconst Mobile = () => \r\n  return (\r\n    <>\r\n      mobile\r\n    </>\r\n  );\r\n;\r\n\r\nMobile.layout = LayoutMobile;\r\n\r\nconst Page = isMobile ? Desktop : Mobile;\r\n\r\nexport default Page;\r\n```\r\n【讨论】：\r\n\r\n以上是关于如何使用 Next.js 检测 React s-s-r App 上的设备？的主要内容，如果未能解决你的问题，请参考以下文章\r\n\r\n[如何在 Next.js/React 中使用带有 @prismicio/client 库的时间线参考](https://it.cha138.com/zhidao/show-3353086.html)\r\n\r\n[如何在 Next.js 中使用带有顺风 css 的 React Suite？](https://it.cha138.com/wen1/show-11570731.html)\r\n\r\n[在 Next.js 中，如何使用来自 getServerSideProps 的数据更新 React Context 状态？](https://it.cha138.com/zhidao/show-18345872.html)\r\n\r\n[Next.js 11正式发布，React 应用的后端渲染](https://it.cha138.com/jingpin/show-165577.html)\r\n\r\n[如何使用 formdata 将图像文件发送到 React/Next js api？](https://it.cha138.com/wen4/show-3652501.html)\r\n\r\n[使用 React 和 Next.js 构建博客](https://it.cha138.com/android/show-32296.html)","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/73/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/73/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### 【参考方案1】：","###【参考方案2】：","###【参考方案3】：","###【参考方案4】：","###【参考方案5】：","###【参考方案6】：","###【参考方案7】："]},"__N_SSG":true}