{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/341","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/341/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/341/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/341/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/341","id":2125616115,"node_id":"I_kwDOBiJZIc5-slPz","number":341,"title":"什么是泛型？","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6527252877,"node_id":"LA_kwDOBiJZIc8AAAABhQ35jQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview%20questions","name":"interview questions","color":"722ed1","default":false,"description":"面试题"},{"id":6536131138,"node_id":"LA_kwDOBiJZIc8AAAABhZVyQg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/typescript","name":"typescript","color":"487E6B","default":false,"description":"分类-Typescript相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-08T16:37:58Z","updated_at":"2024-02-09T07:32:06Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"泛型是程序设计语言中的一种风格或范式，相当于类型模板，允许在声明类、接口或函数等成员时忽略类型，而在未来使用时再指定类型，其主要目的是为它们提供有意义的约束，提升代码的可重用性。\r\n\r\n### 一、泛型参数\r\n\r\n当一个函数需要能处理多种类型的参数和返回值，并且还得约束它们之间的关系（例如类型要相同）时，就可以采用泛型的语法，如下所示。\r\n\r\n``` ts\r\nfunction send<T>(data: T): T {\r\n  return data;\r\n}\r\n```\r\n\r\n函数名称后面跟了，其中把T称为泛型参数或泛型变量，表示某种数据类型。注意，T只是个占位符，可以命名的更含语义，例如TKey、TValue等。在使用时，既可以指定类型，也可以利用类型推论自动确定类型，如下所示。\r\n\r\n``` ts\r\nsend<number>(10);        //指定类型\r\nsend(10);            　　//类型推论\r\n```\r\n\r\n当需要处理T类型的数组时，可以像下面这么写。\r\n\r\n``` ts\r\nfunction send<T>(data: T[]): T[] {\r\n  return data;\r\n}\r\n\r\nsend<number>([1, 2, 3]);\r\n```\r\n\r\n当指定一个泛型函数的类型时，需要包含泛型参数，如下所示，其中泛型参数和函数参数的名称都可与定义时的不同。\r\n\r\n``` ts\r\nlet func: (<U>(data: U) => U) = send;\r\n```\r\n\r\n泛型参数还支持传递多个，只需在声明时增加类型占位符即可。在下面的示例中，将T和U合并成了一个元组类型，还有许多其它用法，将在后面讲解。\r\n\r\n``` ts\r\nfunction send<T, U>(data: [T, U]): [T, U] {\r\n  return data;\r\n}\r\nsend<number, string>([1, \"a\"]);\r\n```\r\n\r\n### 二、泛型接口\r\n\r\n在接口中，可利用泛型来约束函数的结构，如下所示，接口中声明的调用签名包含泛型参数。\r\n\r\n``` ts\r\ninterface Func {\r\n  <T>(str: T): T;\r\n}\r\nfunction send<T>(str: T): T {\r\n  return str;\r\n}\r\nlet fn: Func = send;\r\n```\r\n\r\n泛型参数还可以作为接口的一个参数存在，即把用尖括号包裹的泛型参数移到接口名称之后，如下所示。\r\n\r\n``` ts\r\ninterface Func<T> {\r\n  (str: T): T;\r\n}\r\nfunction send<T>(str: T): T {\r\n  return str;\r\n}\r\nlet fn: Func<string> = send;\r\n```\r\n\r\n当把Func接口作为类型使用时，需要向其传入一个类型，例如上面赋值语句中的string。\r\n\r\n### 三、泛型类\r\n\r\n泛型类与泛型接口类似，也是在名称后添加泛型参数，如下所示，其中send属性中的“=>”符号不表示箭头函数，而是用来定义方法的返回值类型。\r\n\r\n``` ts\r\nclass Person<T> {\r\n  name: T;\r\n  send: (data: T) => T;\r\n}\r\n```\r\n\r\n在实例化泛型类时，需要为其指定一种类型，如下所示。\r\n\r\n``` ts\r\nlet person = new Person<string>();\r\nperson.send = function(data) {\r\n  return data;\r\n}\r\n```\r\n\r\n注意，类的静态部分不能使用泛型参数。\r\n\r\n### 四、泛型约束\r\n\r\n在使用泛型时，由于事先不清楚参数的数据类型，因此不能随意调用它的属性或方法，甚至无法对其使用运算符。在下面的示例中，访问了data的length属性，但由于编译器无法确定它的类型，因此就会报错。\r\n\r\n``` ts\r\nfunction send<T>(data: T): T {\r\n  console.log(data.length);\r\n  return data;\r\n}\r\n```\r\n\r\nTypeScript允许为泛型参数添加约束条件，从而就能调用相应的属性或方法了，如下所示，通过extends关键字约束T必须是string的子类型。\r\n\r\n``` ts\r\nfunction send<T extends string>(data: T): T {\r\n  console.log(data.length);\r\n  return data;\r\n}\r\n```\r\n\r\n在添加了这个约束之后，send()函数就无法接收数字类型的参数了，如下所示。\r\n\r\n``` ts\r\nsend(\"10\");        //正确\r\nsend(10);          //错误\r\n```\r\n\r\n#### 1）创建类的实例\r\n\r\n在使用泛型创建类的工厂函数时，需要声明T类型拥有构造函数，如下所示。\r\n\r\n``` ts\r\nclass Programmer {}\r\nfunction create<T>(ctor: {new(): T}): T {\r\n  return new ctor();\r\n}\r\ncreate(Programmer);\r\n```\r\n\r\n用“{new(): T}”替代原先的类型占位符，表示可以被new运算符实例化，并且得到的是T类型，另一种相同作用的写法如下所示。\r\n\r\n``` ts\r\nfunction create<T>(ctor: new()=>T): T {\r\n  return new ctor();\r\n}\r\n```\r\n\r\n#### 2）多个泛型参数\r\n\r\n在TypeScript中，多个泛型参数之间也可以相互约束，如下所示，创建了基类Person和派生类Programmer，并将create()函数中的T约束为U的子类型。\r\n\r\n``` ts\r\nclass Person { }\r\nclass Programmer extends Person { }\r\nfunction create<T extends U, U>(target: T, source: U): T {\r\n  return target;\r\n}\r\n```\r\n\r\n当传递给create()函数的参数不符合约束条件时，就会在编译阶段报错，如下所示。\r\n\r\n``` ts\r\ncreate(Programmer, Person);        //正确\r\ncreate(Programmer, 10);            //错误\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/341/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/341/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### 一、泛型参数","### 二、泛型接口","### 三、泛型类","### 四、泛型约束","#### 1）创建类的实例","#### 2）多个泛型参数"]},"__N_SSG":true}