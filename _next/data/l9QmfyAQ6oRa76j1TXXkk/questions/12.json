{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/12","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/12/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/12/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/12/events","html_url":"https://github.com/hankliu62/interview/issues/12","id":2129433071,"node_id":"I_kwDOLNphd85-7JHv","number":12,"title":"EventSource和轮询的优缺点","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468110,"node_id":"LA_kwDOLNphd88AAAABhkJvTg","url":"https://api.github.com/repos/hankliu62/interview/labels/javascript","name":"javascript","color":"383040","default":false,"description":"Javascript相关"},{"id":6547468186,"node_id":"LA_kwDOLNphd88AAAABhkJvmg","url":"https://api.github.com/repos/hankliu62/interview/labels/network","name":"network","color":"D613F5","default":false,"description":"网络相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-12T05:12:01Z","updated_at":"2024-02-12T05:12:01Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### EventSource\r\n\r\n#### 简介\r\n\r\nEventSource 是服务器推送的一个网络事件接口。一个EventSource实例会对HTTP服务开启一个持久化的连接，以text/event-stream 格式发送事件, 会一直保持开启直到被要求关闭。\r\n\r\n一旦连接开启，来自服务端传入的消息会以事件的形式分发至你代码中。如果接收消息中有一个事件字段，触发的事件与事件字段的值相同。如果没有事件字段存在，则将触发通用事件。\r\n\r\n与 WebSockets,不同的是，服务端推送是单向的。数据信息被单向从服务端到客户端分发. 当不需要以消息形式将数据从客户端发送到服务器时，这使它们成为绝佳的选择。例如，对于处理社交媒体状态更新，新闻提要或将数据传递到客户端存储机制（如IndexedDB或Web存储）之类的，EventSource无疑是一个有效方案。\r\n\r\n- `EventSource`（Server-sent events）简称SSE用于向服务端发送事件，它是基于http协议的单向通讯技术，以`text/event-stream`格式接受事件，如果不关闭会一直处于连接状态，直到调用`EventSource.close()`方法才能关闭连接；\r\n\r\n- `EvenSource`本质上也就是`XHR-streaming`只不过浏览器给它提供了标准的API封装和协议。\r\n\r\n- 由于`EventSource`是单向通讯，所以只能用来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。\r\n\r\n- `EventSource`虽然不支持双向通讯，但是在功能设计上他也有一些优点比如可以自动重连接,event IDs,以及发送随机事件的等功能\r\n\r\n`EventSource`案例浏览器端代码如下所示:\r\n\r\n``` js\r\n// 实例化 EventSource 参数是服务端监听的路由\r\nvar source = new EventSource('http://localhost:3000');\r\n\r\nsource.onopen = function (event) { // 与服务器连接成功回调\r\n  console.log('成功与服务器连接');\r\n}\r\n\r\n// 监听从服务器发送来的所有没有指定事件类型的消息(没有event字段的消息)\r\nsource.onmessage = function (event) { // 监听未命名事件\r\n  console.log('未命名事件', event.data);\r\n}\r\n\r\nsource.onerror = function (error) { // 监听错误\r\n  console.log('错误');\r\n}\r\n\r\n// 监听指定类型的事件（可以监听多个）\r\nsource.addEventListener(\"ping\", function (event) {\r\n  console.log(\"ping\", event.data)\r\n})\r\n```\r\n\r\n服务器端\r\n\r\n``` js\r\nconst http = require('http');\r\n\r\nhttp.createServer((req, res) => {\r\n  res.writeHead(200, {\r\n    'Content-Type' :'text/event-stream',\r\n    'Access-Control-Allow-Origin':'*'\r\n  });\r\n\r\n  let i = 0;\r\n  const timer = setInterval(()=>{\r\n    const date = {date:new Date()}\r\n    var content ='event: ping\\n'+\"data:\"+JSON.stringify(date)+\"\" +\"\\n\\n\";\r\n    res.write(content);\r\n  },1000)\r\n\r\n  res.connection.on(\"close\", function(){\r\n    res.end();\r\n    clearInterval(timer);\r\n    console.log(\"Client closed connection. Aborting.\");\r\n  });\r\n\r\n}).listen(3000);\r\nconsole.log('server is run http://localhost:3000');\r\n```\r\n\r\n#### EventSource规范字段\r\n\r\n- **event**: 事件类型，如果指定了该字段，则在客户端接收到该条消息时，会在当前的EventSource对象上触发一个事件，事件类型就是该字段的字段值，你可以使用addEventListener()方法在当前EventSource对象上监听任意类型的命名事件，如果该条消息没有event字段，则会触发onmessage属性上的事件处理函数。\r\n- **data**: 消息的数据字段，如果该消息包含多个data字段，则客户端会用换行符把他们连接成一个字符串来处理\r\n- **id**: 事件ID，会成为当前EventSource对象的内部属性“最后一个事件ID”的属性值；\r\n- **retry**: 一个整数值，指定了重新连接的时间（单位为毫秒），如果该字段不是整数，则会被忽略。\r\n\r\n#### EventSource属性\r\n\r\n- **EventSource.onerror**: 是一个 EventHandler，当发生错误时被调用，并且在此对象上派发 error 事件。\r\n- **EventSource.onmessage**: 是一个 EventHandler，当收到一个 message事件，即消息来自源头时被调用。\r\n- **EventSource.onopen**: 是一个 EventHandler，当收到一个 open 事件，即连接刚打开时被调用。\r\n- **EventSource.readyState**(只读): 一个 unsigned short 值，代表连接状态。可能值是CONNECTING (0), OPEN (1), 或者 CLOSED (2)。\r\n- **EventSource.url**(只读): 一个DOMString，代表源头的URL。\r\n\r\n#### EventSource 通讯过程\r\n\r\n![EventSource通讯过程](https://user-images.githubusercontent.com/8088864/125590756-ffd10207-83de-4166-a8b5-9fc848c191cc.png)\r\n\r\n#### 缺点\r\n\r\n1. 因为是服务器->客户端的，所以它不能处理客户端请求流\r\n2. 因为是明确指定用于传输UTF-8数据的，所以对于传输二进制流是低效率的，即使你转为base64的话，反而增加带宽的负载，得不偿失。\r\n\r\n### 轮询\r\n\r\n#### 短轮询(Polling)\r\n\r\n是一种简单粗暴，同样也是一种效率低下的实现“实时”通讯方案，这种方案的原理就是定期向服务器发送请求，主动拉取最新的消息队列。\r\n\r\n客户端代码：\r\n\r\n``` js\r\nfunction Polling() {\r\n  fetch(url).then(data => {\r\n    // somthing\r\n  }).catch(err => {\r\n    console.error(err);\r\n  });\r\n}\r\n\r\n//每5s执行一次\r\nsetInterval(polling, 5000);\r\n```\r\n\r\n![短轮询流程](https://user-images.githubusercontent.com/8088864/125591641-814c4239-47e3-41da-ad9e-a0c7e64dfe72.png)\r\n\r\n这种轮询方式比较适合服务器信息定期更新的场景，如天气预报股票行情等，每隔一段时间会进行更新，且轮询间隔的服务器更新频率保持一致是比较理想的方式，但很多多时候会因网络或者服务器出现阻塞早场事件间隔不一致。\r\n\r\n优点：\r\n\r\n- 可以看到实现非常简单，它的兼容性也比较好的只要支持http协议就可以用这种方式实现\r\n\r\n缺点：\r\n\r\n- 资源浪费: 比如轮询的间隔小于服务器信息跟新频率，会浪费很多HTTP请求，消耗宝贵的CPU时间和带宽。\r\n\r\n- 容易导致请求轰炸: 例如当服务器负载比较高时，第一个请求还没有处理完，这时第三、第四个请求接踵而来，无用的额外请求对服务器端进行了轰炸。\r\n\r\n#### 长轮询(Long Polling)\r\n\r\n这是一种优化的轮询方式，称为长轮询，sockjs就是使用的这种轮询方式，长轮询值的是浏览器发送一个请求到服务器，服务器只有在有可用的新数据时才会响应。\r\n\r\n客户端代码:\r\n\r\n``` js\r\nfunction LongPolling() {\r\n    fetch(url).then(data => {\r\n        LongPolling();\r\n    }).catch(err => {\r\n        LongPolling();\r\n        console.log(err);\r\n    });\r\n}\r\nLongPolling();\r\n```\r\n\r\n![长轮询流程](https://user-images.githubusercontent.com/8088864/125592542-e5c7fb6b-18b8-434f-a4ee-f986684dcbbf.png)\r\n\r\n客户端向服务器发送一个消息获取请求时，服务器会将当前的消息队列返回给客户端，然后关闭连接。当消息队列为空的时，服务器不会立即关闭连接，而是等待指定的时间间隔，如果在这个时间间隔内没有新的消息，则由客户端主动超时关闭连接。\r\n\r\n相比Polling，客户端的轮询请求只有在上一个请求连接关闭后才会重新发起。这就解决了Polling的请求轰炸问题。服务器可以控制的请求时序，因为在服务器未响应之前，客户端不会发送额为的请求。\r\n\r\n优点:\r\n\r\n- 长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。\r\n\r\n缺点:\r\n\r\n- 连接挂起也会导致资源的浪费。\r\n\r\n### EventSource VS 轮询\r\n\r\n|  | 轮询(Polling) | 长轮询(Long-Polling) | EventSource |\r\n| ---- | ---- | ---- | ---- |\r\n| 通信协议 | http | http | http |\r\n| 触发方式 | client(客户端) | client(客户端) | client、server(客户端、服务端) |\r\n| 优点 | 兼容性好容错性强，实现简单 | 比短轮询节约服务器资源 | 实现简便，开发成本低 |\r\n| 缺点 | 安全性差，占较多的内存资源与请求数量，容易对服务器造成压力，请求时间间隔容易导致不一致 | 安全性差，占较多的内存资源与请求数，请求时间间隔容易导致不一致 | 只适用高级浏览器，老版本的浏览器不兼容 |\r\n| 延迟 | 非实时，延迟取决于请求间隔 | 非实时，延迟取决于请求间隔 | 非实时，默认3秒延迟，延迟可自定义 |\r\n\r\n### 总结\r\n\r\n通过对上面两种对通讯技术比较，可以从不同的角度考虑；\r\n\r\n- 兼容性: 短轮询 > 长轮询 > EventSource\r\n- 性能: EvenSource > 长轮询 > 短轮询\r\n- 服务端推送: EventSource > 长连接 （短轮询基本不考虑）","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/12/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/12/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### EventSource","#### 简介","#### EventSource规范字段","#### EventSource属性","#### EventSource 通讯过程","#### 缺点","### 轮询","#### 短轮询(Polling)","#### 长轮询(Long Polling)","### EventSource VS 轮询","### 总结"]},"__N_SSG":true}