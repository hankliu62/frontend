{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/184","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/184/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/184/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/184/events","html_url":"https://github.com/hankliu62/interview/issues/184","id":2129494241,"node_id":"I_kwDOLNphd85-7YDh","number":184,"title":"MVVM","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468371,"node_id":"LA_kwDOLNphd88AAAABhkJwUw","url":"https://api.github.com/repos/hankliu62/interview/labels/react","name":"react","color":"0052CC","default":false,"description":"React相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-12T06:22:02Z","updated_at":"2024-02-12T06:22:03Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### **MVVM 由以下三个内容组成**\r\n\r\n- `View`：界面\r\n- `Model`：数据模型\r\n- `ViewModel`：作为桥梁负责沟通 `View` 和 `Model`\r\n\r\n> - 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合\r\n> - 在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel\r\n\r\n- 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持\r\n\r\n### **脏数据检测**\r\n\r\n- 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次\r\n- 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数\r\n\r\n### **数据劫持**\r\n\r\n- `Vue` 内部使用了 `Obeject.defineProperty()` 来实现双向绑定，通过这个函数可以监听到 `set` 和 `get `的事件\r\n\r\n```javascript\r\nvar data = { name: 'yck' }\r\nobserve(data)\r\nlet name = data.name // -> get value\r\ndata.name = 'yyy' // -> change value\r\n\r\nfunction observe(obj) {\r\n  // 判断类型\r\n  if (!obj || typeof obj !== 'object') {\r\n    return\r\n  }\r\n  Object.keys(data).forEach(key => {\r\n    defineReactive(data, key, data[key])\r\n  })\r\n}\r\n\r\nfunction defineReactive(obj, key, val) {\r\n  // 递归子属性\r\n  observe(val)\r\n  Object.defineProperty(obj, key, {\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: function reactiveGetter() {\r\n      console.log('get value')\r\n      return val\r\n    },\r\n    set: function reactiveSetter(newVal) {\r\n      console.log('change value')\r\n      val = newVal\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n> 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅\r\n\r\n```html\r\n<div>\r\n    {{name}}\r\n</div>\r\n```\r\n\r\n> 在解析如上模板代码时，遇到 `{{name}}` 就会给属性 `name` 添加发布订阅\r\n\r\n\r\n```javascript\r\n// 通过 Dep 解耦\r\nclass Dep {\r\n  constructor() {\r\n    this.subs = []\r\n  }\r\n  addSub(sub) {\r\n    // sub 是 Watcher 实例\r\n    this.subs.push(sub)\r\n  }\r\n  notify() {\r\n    this.subs.forEach(sub => {\r\n      sub.update()\r\n    })\r\n  }\r\n}\r\n// 全局属性，通过该属性配置 Watcher\r\nDep.target = null\r\n\r\nfunction update(value) {\r\n  document.querySelector('div').innerText = value\r\n}\r\n\r\nclass Watcher {\r\n  constructor(obj, key, cb) {\r\n    // 将 Dep.target 指向自己\r\n    // 然后触发属性的 getter 添加监听\r\n    // 最后将 Dep.target 置空\r\n    Dep.target = this\r\n    this.cb = cb\r\n    this.obj = obj\r\n    this.key = key\r\n    this.value = obj[key]\r\n    Dep.target = null\r\n  }\r\n  update() {\r\n    // 获得新值\r\n    this.value = this.obj[this.key]\r\n    // 调用 update 方法更新 Dom\r\n    this.cb(this.value)\r\n  }\r\n}\r\nvar data = { name: 'yck' }\r\nobserve(data)\r\n// 模拟解析到 `{{name}}` 触发的操作\r\nnew Watcher(data, 'name', update)\r\n// update Dom innerText\r\ndata.name = 'yyy'\r\n```\r\n\r\n> 接下来,对 defineReactive 函数进行改造\r\n\r\n```javascript\r\nfunction observe(obj) {\r\n  // 判断类型\r\n  if (!obj || typeof obj !== 'object') {\r\n    return\r\n  }\r\n  Object.keys(data).forEach(key => {\r\n    defineReactive(data, key, data[key])\r\n  })\r\n}\r\n\r\nfunction defineReactive(obj, key, val) {\r\n  // 递归子属性\r\n  observe(val)\r\n  let dp = new Dep()\r\n  Object.defineProperty(obj, key, {\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: function reactiveGetter() {\r\n      console.log('get value')\r\n      // 将 Watcher 添加到订阅\r\n      if (Dep.target) {\r\n        dp.addSub(Dep.target)\r\n      }\r\n      return val\r\n    },\r\n    set: function reactiveSetter(newVal) {\r\n      console.log('change value')\r\n      val = newVal\r\n      // 执行 watcher 的 update 方法\r\n      dp.notify()\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n> 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加\r\n\r\n### **Proxy 与 Obeject.defineProperty 对比**\r\n\r\n- `Obeject.defineProperty` 虽然已经能够实现双向绑定了，但是他还是有缺陷的。\r\n  - 只能对属性进行数据劫持，所以需要深度遍历整个对象\r\n  - 对于数组不能监听到数据的变化\r\n\r\n> 虽然 `Vue` 中确实能检测到数组数据的变化，但是其实是使用了 `hack` 的办法，并且也是有缺陷的","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/184/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/184/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### **MVVM 由以下三个内容组成**","### **脏数据检测**","### **数据劫持**","### **Proxy 与 Obeject.defineProperty 对比**"]},"__N_SSG":true}