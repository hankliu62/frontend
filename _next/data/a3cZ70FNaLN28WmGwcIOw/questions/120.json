{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/120","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/120/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/120/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/120/events","html_url":"https://github.com/hankliu62/interview/issues/120","id":2129451809,"node_id":"I_kwDOLNphd85-7Nsh","number":120,"title":"React Fiber架构中，迭代器和requestIdleCallback结合的优势","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468371,"node_id":"LA_kwDOLNphd88AAAABhkJwUw","url":"https://api.github.com/repos/hankliu62/interview/labels/react","name":"react","color":"0052CC","default":false,"description":"React相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-12T05:35:31Z","updated_at":"2024-03-04T14:15:55Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### requestIdleCallback API\r\n\r\nrequestIdleCallback 是浏览器提供的 Web API，它是 React Fiber 中用到的核心 API。\r\n\r\n#### API 介绍\r\n\r\n[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 利用浏览器的空余时间执行任务，如果浏览器没有空余时间，可以随时终止这些任务。\r\n\r\n这样可以实现如果有更高优先级的任务要执行时，当前执行的任务可以被终止，优先执行高级别的任务。\r\n\r\n原理是该方法将 在浏览器的空闲时段内调用的函数 排队。\r\n\r\n这样使得开发者能够在主事件循环上 执行后台和低优先级的任务，而不会影响 像动画和用户交互 这些关键的延迟触发的事件。\r\n\r\n这里的“延迟”指的是大量计算导致运行时间较长。\r\n\r\n#### 浏览器空余时间\r\n\r\n页面是一帧一帧绘制出来的，当每秒绘制的帧数达到 60 时，页面时流畅的，小于这个值时，用户会感觉到卡顿。\r\n\r\n1秒60帧意思是1秒中60张画面在切换。\r\n\r\n当帧数低于人眼的捕捉频率（有说24帧或30帧，考虑到视觉残留现象，这个数值可能会更低）时，人脑会识别这是几张图片在切换，也就是静态的。\r\n\r\n当帧数高于人眼的捕捉频率，人脑会认为画面是连续的，也就是动态的动画。\r\n\r\n帧数越高画面就看起来更流畅。\r\n\r\n1秒60帧（大约 1000/60 ≈ 16ms 切换一个画面）差不多是人眼能识别卡顿的分界线。\r\n\r\n如果每一帧执行的时间小于 16 ms，就说明浏览器有空余时间。\r\n\r\n一帧时间内浏览器要做的事情包括：脚本执行、样式计算、布局、重绘、合成等。\r\n\r\n如果某一项内容执行时间过长，浏览器会推迟渲染，造成丢帧卡顿，就没有剩余时间。\r\n\r\n#### 应用场景\r\n\r\n比如现在有一项计算任务，这项任务需要花费比较长的时间(例如超过16ms）去执行。\r\n\r\n在执行任务的过程当中，浏览器的主线程会被一直占用。\r\n\r\n在主线程被占用的过程中，浏览器是被阻塞的，并不能执行其他的任务。\r\n\r\n如果此时用户想要操作页面，比如向下滑动页面查看其它内容，浏览器是不能响应用户的操作的，给用户的感觉就是页面卡死了，体验非常差。\r\n\r\n**如何解决呢？**\r\n\r\n可以将这项任务注册到 `requestIdleCallback` 中，利用浏览器的空余时间执行它。\r\n\r\n当用户操作页面时，就是**优先级比较高的任务**被执行时，此时计算任务会被终止，优先响应用户的操作，这样用户就不会感觉页面发生卡顿了。\r\n\r\n当高优先级的任务执行完成后，再继续执行计算任务。\r\n\r\n`requestIdleCallback` 的作用就是利用浏览器的空余时间执行这些需要大量计算的任务，当空余时间结束，会中断计算任务，执行高优先级的任务，以达到不阻塞主线程任务（例如浏览器 UI 渲染）的目的。\r\n\r\n#### 使用方式\r\n\r\n``` js\r\nvar handle = window.requestIdleCallback(callback[, options])\r\n```\r\n\r\n- callback：一个在空闲时间即将被调用的回调函数\r\n    - 该函数接收一个形参：IdleDeadline，它提供一个方法和一个属性：\r\n      - 方法：timeRemaining()\r\n        - 用于获取浏览器空闲期的剩余时间，也就是空余时间\r\n          - 返回值是毫秒数\r\n          - 如果闲置期结束，则返回 0\r\n        - 根据时间的多少可以来决定是否要执行任务\r\n      - 属性：didTimeout(Boolean，只读)\r\n        - 表示是否是上一次空闲期因为超时而没有执行的回调函数\r\n        - 超时时间由 requestIdleCallback 的参数options.timeout 定义\r\n- options：可选配置，目前只有一个配置项\r\n    - timeout：超时时间，如果设置了超时时间并超时，回调函数还没有被调用，则会在下一次空闲期强制被调用\r\n\r\n#### 功能体验\r\n\r\n页面中有两个按钮和一个 DIV，点击第一个按钮执行一项昂贵的计算，使其长期占用主线程，当计算任务执行的时候去点击第二个按钮更改页面中 DIV 的背景颜色。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>requestIdleCallback</title>\r\n    <style>\r\n      #box {\r\n        background: palegoldenrod;\r\n        padding: 20px;\r\n        margin-bottom: 10px;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"box\">playground</div>\r\n    <button id=\"btn1\">执行计算任务</button>\r\n    <button id=\"btn2\">更改背景颜色</button>\r\n\r\n    <script>\r\n      var box = document.querySelector('#box');\r\n      var btn1 = document.querySelector('#btn1');\r\n      var btn2 = document.querySelector('#btn2');\r\n      var number = 100000000;\r\n      var value = 0;\r\n\r\n      function calc() {\r\n        while (number > 0) {\r\n          value = Math.random() < 0.5 ? Math.random() : Math.random();\r\n          number--;\r\n        }\r\n      }\r\n\r\n      btn1.onclick = function () {\r\n        calc();\r\n      }\r\n\r\n      btn2.onclick = function () {\r\n        console.log(number); // 0：计算任务执行完\r\n        box.style.background = 'palegreen';\r\n      }\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n![requestIdleCallback功能体验1](https://user-images.githubusercontent.com/8088864/125783134-1435e780-a620-4cbf-b8c3-c04fccd4b145.png)\r\n\r\n使用 requestIdleCallback可以完美解决这个卡顿问题：\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>requestIdleCallback</title>\r\n    <style>\r\n      #box {\r\n        background: palegoldenrod;\r\n        padding: 20px;\r\n        margin-bottom: 10px;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"box\">playground</div>\r\n    <button id=\"btn1\">执行计算任务</button>\r\n    <button id=\"btn2\">更改背景颜色</button>\r\n\r\n    <script>\r\n      var box = document.querySelector('#box');\r\n      var btn1 = document.querySelector('#btn1');\r\n      var btn2 = document.querySelector('#btn2');\r\n      var number = 100000000;\r\n      var value = 0;\r\n\r\n      function calc(IdleDeadline) {\r\n        while (number > 0 && IdleDeadline.timeRemaining() > 1) {\r\n          value = Math.random() < 0.5 ? Math.random() : Math.random();\r\n          number--;\r\n        }\r\n\r\n        if (number > 0) {\r\n          requestIdleCallback(calc);\r\n        } else {\r\n          console.log('计算结束');\r\n        }\r\n      }\r\n\r\n      btn1.onclick = function () {\r\n        requestIdleCallback(calc);\r\n      }\r\n\r\n      btn2.onclick = function () {\r\n        console.log(number); // 0：计算任务执行完\r\n        box.style.background = 'palegreen';\r\n      }\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n![requestIdleCallback功能体验2](https://user-images.githubusercontent.com/8088864/125783529-12c4da73-fe20-4757-b858-169f381efce4.png)\r\n\r\n- 浏览器在空余时间执行 calc 函数\r\n- 当空余时间小于 1ms 时，跳出while循环\r\n- calc 根据 number 判断计算任务是否执行完成，如果没有完成，则继续注册新的空闲期的任务\r\n- 当 btn2 点击事件触发，会等到当前空闲期任务执行完后执行“更改背景颜色”的任务\r\n- “更改背景颜色”任务执行完成后，继续进入空闲期，执行后面的任务\r\n\r\n由此可见，所谓执行优先级更高的任务，是手动将计算任务拆分到浏览器的空闲期，以实现每次进入空闲期之前优先执行主线程的任务。\r\n\r\n### Fiber 出现的目的\r\n\r\nFiber 其实是 React 16 新的 DOM 比对算法的名字，旧的 DOM 比对算法的名字是 Stack。\r\n\r\n#### React 16之前的版本存在的问题\r\n\r\nReact 16之前的版本对比更新 VirtualDOM 的过程是采用**循环加递归**实现的。\r\n\r\n这种对比方式有一个问题，就是一旦任务开始进行就无法中断（由于递归需要一层一层的进入，一层一层的退出，所以过程不能中断）。\r\n\r\n如果应用中组件数量庞大，主线程被长期占用，直到整棵 VirtualDOM 树对比更新完成之后主线程才能被释放，主线程才能执行其它任务。\r\n\r\n这就会导致一些用户交互、动画等任务无法立即得到执行，页面就会产生卡顿，非常影响用户的体验。\r\n\r\n因为递归利用的 **JavaScript 自身的执行栈**，所以旧版 DOM 比对的算法称为 **Stack(堆栈)**。\r\n\r\n**核心问题：递归无法中断，执行重任务耗时长，JavaScript 又是单线程的，无法同时执行其它任务，导致在绘制页面的过程当中不能执行其它任务，比如元素动画、用户交互等任务必须延后，给用户的感觉就是页面变得卡顿，用户体验差。**\r\n\r\n### Stack 算法模拟\r\n\r\n模拟 React 16 之前将虚拟 DOM 转化成真实 DOM 的递归算法：\r\n\r\n``` jsx\r\n// 要渲染的 jsx\r\nconst jsx = (\r\n  <div id=\"a1\">\r\n    <div id=\"b1\">\r\n      <div id=\"c1\"></div>\r\n      <div id=\"c2\"></div>\r\n    </div>\r\n    <div id=\"b2\"></div>\r\n  </div>\r\n)\r\n```\r\n\r\njsx 会被 Babel 转化成 `React.createElement()` 的调用，最终返回一个虚拟 DOM 对象：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nconst jsx = /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"a1\"\r\n}, /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"b1\"\r\n}, /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"c1\"\r\n}), /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"c2\"\r\n})), /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"b2\"\r\n}));\r\n```\r\n\r\n去掉一些属性，打印结果：\r\n\r\n``` js\r\nconst jsx = {\r\n  type: 'div',\r\n  props: {\r\n    id: 'a1',\r\n    children: [\r\n      {\r\n        type: 'div',\r\n        props: {\r\n          id: 'b1',\r\n          children: [\r\n            {\r\n              type: 'div',\r\n              props: {\r\n                id: 'c1'\r\n              }\r\n            },\r\n            {\r\n              type: 'div',\r\n              props: {\r\n                id: 'c2'\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      {\r\n        type: 'div',\r\n        props: {\r\n          id: 'b2'\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n递归转化真实 DOM：\r\n\r\n``` js\r\nconst jsx = {...}\r\nfunction render(vdom, container) {\r\n  // 创建元素\r\n  const element = document.createElement(vdom.type);\r\n  // 为元素添加属性\r\n  Object.keys(vdom.props)\r\n    .filter(prop => prop !== 'children')\r\n    .forEach(prop => (element[prop] = vdom.props[prop]));\r\n  // 递归创建子元素\r\n  if (Array.isArray(vdom.props.children)) {\r\n    vdom.props.children.forEach(child => render(child, element));\r\n  }\r\n  // 将元素添加到页面中\r\n  container.appendChild(element);\r\n}\r\n\r\nrender(jsx, document.getElementById('root'));\r\n```\r\n\r\nDOM 更新就是在上面递归的过程中加入了 Virtual DOM 对比的过程。\r\n\r\n可以看到递归是无法中断的。\r\n\r\n### React 16 解决方案 - Fiber\r\n\r\n1. 利用浏览器空余时间执行任务，拒绝长时间占用主线程\r\n    - 在新版本的 React 版本中，使用了 requestIdleCallback API\r\n    - 利用浏览器空余时间执行 VirtualDOM 比对任务，也就表示 VirtualDOM 比对不会长期占用主线程\r\n    - 如果有高优先级的任务要执行，就会暂时终止 VirtualDOM 的比对过程，先去执行高优先级的任务\r\n    - 高优先级任务执行完成，再回来继续执行 VirtualDOM 比对任务\r\n    - 这样页面就不会出现卡顿现象\r\n2. 放弃递归，只采用循环，因为循环可以被中断\r\n    - 由于递归必须一层一层进入，一层一层退出，所以过程无法中断\r\n    - 所以要实现任务的终止再继续，就必须放弃递归，只采用循环的方式执行比对的过程\r\n    - 因为循环是可以终止的，只需要将循环的条件保存下来，下一次任务就可以从中断的地方执行了\r\n3. 任务拆分，将任务拆分成一个个的小任务\r\n    - 如果任务要实现终止再继续，任务的单元就必须要小\r\n    - 这样任务即使没有执行完就被终止，重新执行任务的代价就会小很多\r\n    - 所以要进行任务的拆分，将一个大的任务拆分成一个个小的任务\r\n    - VirtualDOM 比对任务如何拆分？\r\n        - 以前将整棵 VirtualDOM 树的比对看作一个任务\r\n        - 现在将树中每一个节点的比对看作一个任务\r\n\r\n新版 React 的解决方案核心就是第 1 点，第 2、3 点都是为了实现第 1 点而存在的，\r\n\r\nFiber 翻译过来是“纤维”，意思就是执行任务的颗粒度变得细腻，像纤维一样。\r\n\r\n可以通过这个 [Demo](https://claudiopro.github.io/react-fiber-vs-stack-demo/) 查看 Stack 算法 和 Fiber 算法的效果区别。\r\n\r\n### 实现思路\r\n\r\n在 Fiber 方案中，为了实现任务的终止再继续，DOM 对比算法被拆分成了两阶段：\r\n\r\n1. render 阶段（可中断）\r\n    - VirtualDOM 的比对，构建 Fiber 对象，构建链表\r\n\r\n2. commit 阶段（不可中断）\r\n    - 根据构建的链表进行 DOM 操作\r\n\r\n过程就是：\r\n\r\n1. 在使用 React 编写用户界面的时候仍然使用 JSX 语法\r\n2. Babel 会将 JSX 语法转换成 `React.createElement()` 方法的调用\r\n3. `React.createElement()` 方法调用后会返回 VirtualDOM 对象\r\n4. 接下来就可以执行第一个阶段了：**构建 Fiber 对象**\r\n    - 采用循环的方式从 VirtualDOM 对象中，找到每一个内部的 VirtualDOM 对象\r\n    - 为每一个 VirtualDOM 对象构建 Fiber 对象\r\n    - Fiber 对象也是 JavaScript 对象，它是从 VirtualDOM 对象衍化来的，它除了 type、props、children以外还存储了更多节点的信息，其中包含的一个核心信息是：当前节点要进行的操作，例如删除、更新、新增\r\n    - 在构建 Fiber 的过程中还要构建链表\r\n5. 接着进行第二阶段的操作：**执行 DOM 操作**\r\n\r\n总结：\r\n\r\n- DOM 初始渲染：`根据 VirtualDOM` --> `创建 Fiber 对象 及 构建链表` --> `将 Fiber 对象存储的操作应用到真实 DOM 中`\r\n- DOM 更新操作：`newFiber(重新获取所有 Fiber 对象)` --> `newFiber vs oldFiber(获取旧的 Fiber 对象，进行比对) 将差异操作追加到链表` --> `将 Fiber 对象应用到真实 DOM 中`\r\n\r\n### 什么是 Fiber\r\n\r\nFiber 有两层含义：\r\n\r\n- Fiber 是一个执行单元\r\n- Fiber 是一种数据结构\r\n\r\n#### 执行单元\r\n\r\n在 React 16 之前，将 Virtual DOM 树整体看成一个任务进行递归处理，任务整体庞大执行耗时且不能中断。\r\n\r\n在 React 16，将整个任务拆分成一个个小的任务进行处理，每个小的任务指的就是一个 Fiber 节点的构建。\r\n\r\n任务会在浏览器的空闲时间被执行，每个单元执行完成后，React 都会检查是否还有空余时间，如果有继续执行下一个人物单元，直到没有空余时间或者所有任务执行完毕，如果没有空余时间就交还主线程的控制权。\r\n\r\n![React Fiber 执行单元流程图](https://user-images.githubusercontent.com/8088864/125878368-317a2c5c-8b16-4877-981c-3883075423bc.png)\r\n\r\n#### 数据结构\r\n\r\nFiber 是一种数据结构，支撑 React 构建任务的运转。\r\n\r\nFiber 其实就是 JavaScript 对象，对象中存储了当前节点的父节点、第一个子节点、下一个兄弟节点，以便在构建链表和执行 DOM 操作的时候知道它们的关系。\r\n\r\n在 render 阶段的时候，React 会从上（root）向下，再从下向上构建所有节点对应的 Fiber 对象，在从下向上的同时还会构建链表，最后将链头存储到 Root Fiber。\r\n\r\n- 从上向下\r\n    - 从 Root 节点开始构建，优先构建子节点\r\n\r\n- 从下向上\r\n    - 如果当前节点没有子节点，就会构建下一个兄弟节点\r\n    - 如果当前节点没有子节点，也没有下一个兄弟节点，就会返回父节点，构建父节点的兄弟节点\r\n    - 如果父节点的下一个兄弟节点有子节点，就继续向下构建\r\n    - 如果父节点没有下一个兄弟节点，就继续向上查找\r\n\r\n在第二阶段的时候，通过链表结构的属性（child、sibling、parent）准确构建出完整的 DOM 节点树，从而才能将 DOM 对象追加到页面当中。\r\n\r\n``` js\r\n// Fiber 对象\r\n{\r\n  type // 节点类型（元素、文本、组件）（具体的类型）\r\n  props // 节点属性（props中包含children属性，标识当前节点的子级 VirtualDOM）\r\n  stateNode // 节点的真实 DOM 对象 | 类组件实例对象 | 函数组件的定义方法\r\n  tag // 节点标记（对具体类型的分类 host_root[顶级节点root] || host_component[普通DOM节点] || class_component[类组件] || function_component[函数组件]）\r\n  effectTag // 当前 Fiber 在 commit 阶段需要被执行的副作用类型/操作（新增、删除、修改）\r\n  nextEffect // 单链表用来快速查找下一个 sideEffect\r\n  lastEffect // 存储最新副作用，用于构建链表的 nextEffect\r\n  firstEffect // 存储第一个要执行的副作用，用于向 root 传递第一个要操作的 DOM\r\n  parent // 当前 Fiber 的父级 Fiber（React 中是 `return`）\r\n  child // 当前 Fiber 的第一个子级 Fiber\r\n  sibling // 当前 Fiber 的下一个兄弟 Fiber\r\n  alternate // 当前节点对应的旧 Fiber 的备份，用于新旧 Fiber 比对\r\n}\r\n```\r\n\r\n以上面的示例为例：\r\n\r\n``` jsx\r\n<div id=\"a1\">\r\n  <div id=\"b1\">\r\n    <div id=\"c1\"></div>\r\n    <div id=\"c2\"></div>\r\n  </div>\r\n  <div id=\"b2\"></div>\r\n</div>\r\n```\r\n\r\n![React Fiber 数据结构](https://user-images.githubusercontent.com/8088864/125878754-89f402ab-cb4b-466a-bef3-c6f20b9e10f8.png)\r\n\r\n``` js\r\n// B1 的 Fiber 对象包含这几个属性：\r\n{\r\n  child: C1_Fiber,\r\n  sibling: B2_Fiber,\r\n  parent: A1_Fiber\r\n}\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/120/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/120/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### requestIdleCallback API","#### API 介绍","#### 浏览器空余时间","#### 应用场景","#### 使用方式","#### 功能体验","### Fiber 出现的目的","#### React 16之前的版本存在的问题","### Stack 算法模拟","### React 16 解决方案 - Fiber","### 实现思路","### 什么是 Fiber","#### 执行单元","#### 数据结构"]},"__N_SSG":true}