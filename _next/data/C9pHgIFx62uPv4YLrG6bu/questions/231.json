{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/231","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/231/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/231/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/231/events","html_url":"https://github.com/hankliu62/interview/issues/231","id":2129511349,"node_id":"I_kwDOLNphd85-7cO1","number":231,"title":"前端错误监控","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468011,"node_id":"LA_kwDOLNphd88AAAABhkJu6w","url":"https://api.github.com/repos/hankliu62/interview/labels/engine","name":"engine","color":"1d76db","default":false,"description":"工程化相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-12T06:40:12Z","updated_at":"2024-02-12T06:40:13Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### 1 前言\r\n\r\n> 错误监控包含的内容是：\r\n\r\n- 前端错误的分类\r\n- 每种错误的捕获方式\r\n- 上报错误的基本原理\r\n\r\n> 面试时，可能有两种问法：\r\n\r\n- 如何监测 `js` 错误？（开门见山的方式）\r\n- 如何保证**产品质量**？（其实问的也是错误监控）\r\n\r\n\r\n### 2 前端错误的分类\r\n\r\n包括两种：\r\n\r\n- 即时运行错误（代码错误）\r\n- 资源加载错误\r\n\r\n\r\n### 3 每种错误的捕获方式\r\n\r\n\r\n#### 3.1 即时运行错误的捕获方式\r\n\r\n**方式1**：`try ... catch`。\r\n\r\n> 这种方式要部署在代码中。\r\n\r\n**方式2：**`window.onerror`函数。这个函数是全局的。\r\n\r\n```js\r\n\twindow.onerror = function(msg, url, row, col, error) { ... }\r\n```\r\n\r\n> 参数解释：\r\n\r\n- `msg`为异常基本信息\r\n- `source`为发生异常`Javascript`文件的`url`\r\n- `row`为发生错误的行号\r\n\r\n> 方式二中的`window.onerror`是属于DOM0的写法，我们也可以用DOM2的写法：`window.addEventListener(\"error\", fn);`也可以。\r\n\r\n**问题延伸1：**\r\n\r\n`window.onerror`默认无法捕获**跨域**的`js`运行错误。捕获出来的信息如下：（基本属于无效信息）\r\n\r\n> 比如说，我们的代码想引入`B`网站的`b.js`文件，怎么捕获它的异常呢？\r\n\r\n**解决办法**：在方法二的基础之上，做如下操作：\r\n\r\n1. 在`b.js`文件里，加入如下 `response` `header`，表示允许跨域：（或者世界给静态资源`b.js`加这个 response header）\r\n\r\n```js\r\n\tAccess-Control-Allow-Origin: *\r\n```\r\n\r\n2. 引入第三方的文件`b.js`时，在`<script>`标签中增加`crossorigin`属性；\r\n\r\n\r\n\r\n**问题延伸2：**\r\n\r\n> 只靠方式二中的`window.onerror`是不够的，因为我们无法获取文件名是什么，不知道哪里出了错误。解决办法：把**堆栈**信息作为msg打印出来，堆栈里很详细。\r\n\r\n\r\n\r\n#### 3.2 资源加载错误的捕获方式\r\n\r\n> 上面的`window.onerror`只能捕获即时运行错误，无法捕获资源加载错误。原理是：资源加载错误，并不会向上冒泡，`object.onerror`捕获后就会终止（不会冒泡给`window`），所以`window.onerror`并不能捕获资源加载错误。\r\n\r\n- **方式1**：`object.onerror`。`img`标签、`script`标签等节点都可以添加`onerror`事件，用来捕获资源加载的错误。\r\n- **方式2**：performance.getEntries。可以获取所有已加载资源的加载时长，通过这种方式，可以间接的拿到没有加载的资源错误。\r\n\r\n举例：\r\n\r\n> 浏览器打开一个网站，在`Console`控制台下，输入：\r\n\r\n```js\r\n\tperformance.getEntries().forEach(function(item){console.log(item.name)})\r\n```\r\n\r\n或者输入：\r\n\r\n```js\r\n\tperformance.getEntries().forEach(item=>{console.log(item.name)})\r\n```\r\n\r\n\r\n> 上面这个`api`，返回的是数组，既然是数组，就可以用`forEach`遍历。打印出来的资源就是**已经成功加载**的资源。；\r\n\r\n![](http://img.smyhvae.com/20180311_2030.png)\r\n\r\n> 再入`document.getElementsByTagName('img')`，就会显示出所有**需要加载**的的img集合。\r\n\r\n> 于是，`document.getElementsByTagName('img')`获取的资源数组减去通过`performance.getEntries()`获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接捕获到资源加载错误。\r\n\r\n这种方式非常有用，一定要记住。\r\n\r\n\r\n**方式3；**Error事件捕获。\r\n\r\n> 源加载错误，虽然会阻止冒泡，但是不会阻止捕获。我们可以在捕获阶段绑定error事件。例如：\r\n\r\n![](http://img.smyhvae.com/20180311_2040.png)\r\n\r\n\r\n\r\n> **总结：**如果我们能回答出后面的两种方式，面试官对我们的印象会大大增加。既可以体现出我们对错误监控的了解，还可以体现出我们对事件模型的掌握。\r\n\r\n\r\n### 4 错误上报的两种方式\r\n\r\n- **方式一**：采用Ajax通信的方式上报（此方式虽然可以上报错误，但是我们并不采用这种方式）\r\n- **方式二：**利用Image对象上报（推荐。网站的监控体系都是采用的这种方式）\r\n\r\n> 方式二的实现方式如下：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n\r\n<script>\r\n\t//通过Image对象进行错误上报\r\n    (new Image()).src = 'http://smyhvae.com/myPath?badjs=msg';   // myPath表示上报的路径（我要上报到哪里去）。后面的内容是自己加的参数。\r\n</script>\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\n\r\n> 打开浏览器，效果如下：\r\n\r\n![](http://img.smyhvae.com/20180311_2055.png)\r\n\r\n上图中，红色那一栏表明，我的请求已经发出去了。点进去看看：\r\n\r\n![](http://img.smyhvae.com/20180311_2057.png)\r\n\r\n> 这种方式，不需要借助第三方的库，一行代码即可搞定。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/231/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/231/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### 1 前言","### 2 前端错误的分类","### 3 每种错误的捕获方式","#### 3.1 即时运行错误的捕获方式","#### 3.2 资源加载错误的捕获方式","### 4 错误上报的两种方式"]},"__N_SSG":true}