{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/604","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/604/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/604/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/604/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/604","id":2131538332,"node_id":"I_kwDOBiJZIc5_DLGc","number":604,"title":"手写题相关的面试题","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536264028,"node_id":"LA_kwDOBiJZIc8AAAABhZd5XA","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/handwritten","name":"handwritten","color":"faad14","default":false,"description":"分类-手写题相关"},{"id":6552343574,"node_id":"LA_kwDOBiJZIc8AAAABhozUFg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview","name":"interview","color":"79D677","default":false,"description":"分类-面试题相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-13T06:14:59Z","updated_at":"2024-02-13T08:50:52Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"---\r\n\r\ntitle: 手写题相关的面试题\r\n\r\ndate: 2024-02-13 16:50:51\r\n\r\ntag: [blog, interview, handwritten]\r\n\r\n---\r\n\r\n## 介绍防抖节流原理、区别以及应用，并用JavaScript进行实现\r\n\r\n### 1）防抖\r\n\r\n- 原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\r\n\r\n- 适用场景：\r\n  - 按钮提交场景：防止多次提交按钮，只执行最后提交的一次\r\n  - 搜索框联想场景：防止联想发送请求，只发送最后一次输入\r\n\r\n- 简易版实现\r\n\r\n``` js\r\n/**\r\n * 防抖:\r\n *\r\n * 应用场景：当用户进行了某个行为(例如点击)之后。不希望每次行为都会触发方法，而是行为做出后,一段时间内没有再次重复行为，才给用户响应\r\n * 实现原理 : 每次触发事件时设置一个延时调用方法，并且取消之前的延时调用方法。（每次触发事件时都取消之前的延时调用方法）\r\n * @params fun 传入的防抖函数(callback) delay 等待时间\r\n *\r\n */\r\nconst debounce = (fun, delay = 500) => {\r\n    let timer = null //设定一个定时器\r\n    return function (...args) {\r\n        clearTimeout(timer);\r\n        timer = setTimeout(() => {\r\n            fun.apply(this, args)\r\n        }, delay)\r\n    }\r\n}\r\n```\r\n\r\n- 立即执行版实现\r\n\r\n有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。\r\n\r\n``` js\r\n// 有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。\r\nfunction debounce(func, wait, immediate) {\r\n  let timeout;\r\n  return function () {\r\n    const context = this;\r\n    const args = arguments;\r\n    if (timeout) clearTimeout(timeout);\r\n    if (immediate) {\r\n      const callNow = !timeout;\r\n      timeout = setTimeout(function () {\r\n        timeout = null;\r\n      }, wait)\r\n      if (callNow) func.apply(context, args)\r\n    } else {\r\n      timeout = setTimeout(function () {\r\n        func.apply(context, args)\r\n      }, wait);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n- 返回值版实现\r\n\r\nfunc函数可能会有返回值，所以需要返回函数结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以只在 immediate 为 true 的时候返回函数的执行结果。\r\n\r\n``` js\r\nfunction debounce(func, wait, immediate) {\r\n  let timeout, result;\r\n  return function () {\r\n    const context = this;\r\n    const args = arguments;\r\n    if (timeout) clearTimeout(timeout);\r\n    if (immediate) {\r\n      const callNow = !timeout;\r\n      timeout = setTimeout(function () {\r\n        timeout = null;\r\n      }, wait)\r\n      if (callNow) result = func.apply(context, args)\r\n    }\r\n    else {\r\n      timeout = setTimeout(function () {\r\n        func.apply(context, args)\r\n      }, wait);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n```\r\n\r\n### 2）节流\r\n\r\n- 原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\r\n\r\n- 适用场景\r\n  - 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动\r\n  - 缩放场景：监控浏览器resize\r\n\r\n- 简易版实现\r\n\r\n``` js\r\n/**\r\n * 节流\r\n *\r\n * 应用场景:用户进行高频事件触发(滚动)，但在限制在n秒内只会执行一次。\r\n * 实现原理: 每次触发时间的时候，判断当前是否存在等待执行的延时函数。\r\n *\r\n * @params fun 传入的防抖函数(callback) delay 等待时间\r\n *\r\n */\r\nconst throttle = (fun, delay = 1000) => {\r\n  let flag = true;\r\n  return function (...args) {\r\n    if (!flag) return;\r\n    flag = false;\r\n    setTimeout(() => {\r\n      fun.apply(this, args);\r\n      flag = true;\r\n    }, delay);\r\n  }\r\n}\r\n```\r\n\r\n\r\n- 使用时间戳实现\r\n\r\n使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。\r\n\r\n``` js\r\nfunction throttle(func, wait) {\r\n  let context, args;\r\n  let previous = 0;\r\n\r\n  return function () {\r\n    let now = +new Date();\r\n    context = this;\r\n    args = arguments;\r\n    if (now - previous > wait) {\r\n      func.apply(context, args);\r\n      previous = now;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n- 使用定时器实现\r\n\r\n当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\r\n\r\n``` js\r\nfunction throttle(func, wait) {\r\n  let timeout;\r\n  return function () {\r\n    const context = this;\r\n    const args = arguments;\r\n    if (!timeout) {\r\n      timeout = setTimeout(function () {\r\n        timeout = null;\r\n        func.apply(context, args)\r\n      }, wait);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6, 4, 5, 6, 11, 23, 42, 56, 78, 90）\r\n\r\n``` js\r\nfunction f1(arr, count) {\r\n  // 数组从大到小排序\r\n  arr.sort((a, b) => b - a);\r\n  // 计算平均值\r\n  let avg = arr.reduce((a,b) => a + b) / count;\r\n  let resArr = [];\r\n  let current = 0;\r\n\r\n  // 从大到小求和，取最接近平均值的一组，放入二维数组\r\n  for (let i = 0; i < count - 1; i++) {\r\n    if (current + arr[arr.length-1] / 2 < avg && i) {\r\n      arr.pop();\r\n      resArr[i-1].push(arr[arr.length-1]);\r\n    }\r\n    current = 0;\r\n    resArr[i] = [];\r\n    arr.forEach((item, index) => {\r\n      current += item;\r\n      arr.splice(index,1);\r\n      resArr[i].push(item);\r\n      if (current > avg) {\r\n        current -= item;\r\n        arr.splice(index,0,item);\r\n        resArr[i].pop();\r\n      }\r\n    });\r\n  }\r\n\r\n  resArr[count-1] = arr;\r\n\r\n  return resArr;\r\n}\r\n//测试，第一个参数为数组，第二个为份数\r\nconsole.log(f1([11,42,23,4,5,6,4,5,6,11,23,42,56,78,90], 3))\r\n```\r\n\r\n## 实现 lodash 的_.get\r\n\r\n在 js 中经常会出现嵌套调用这种情况，如 a.b.c.d.e，但是这么写很容易抛出异常。你需要这么写 a && a.b && a.b.c && a.b.c.d && a.b.c.d.e，但是显得有些啰嗦与冗长了。特别是在 graphql 中，这种嵌套调用更是难以避免。\r\n\r\n这时就需要一个 get 函数，使用 get(a, 'b.c.d.e') 简单清晰，并且容错性提高了很多。\r\n\r\n### 1）代码实现\r\n\r\n``` js\r\nfunction get(source, path, defaultValue = undefined) {\r\n  // a[3].b -> a.3.b -> [a,3,b]\r\n // path 中也可能是数组的路径，全部转化成 . 运算符并组成数组\r\n  const paths = path.replace(/\\[(\\d+)\\]/g, \".$1\").split(\".\");\r\n  let result = source;\r\n  for (const p of paths) {\r\n    // 注意 null 与 undefined 取属性会报错，所以使用 Object 包装一下。\r\n    result = Object(result)[p];\r\n    if (result == undefined) {\r\n      return defaultValue;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n// 测试用例\r\nconsole.log(get({ a: null }, \"a.b.c\", 3)); // output: 3\r\nconsole.log(get({ a: undefined }, \"a\", 3)); // output: 3\r\nconsole.log(get({ a: null }, \"a\", 3)); // output: 3\r\nconsole.log(get({ a: [{ b: 1 }] }, \"a[0].b\", 3)); // output: 1\r\n```\r\n\r\n## 实现 add(1)(2)(3)\r\n\r\n考点：函数柯里化\r\n\r\n函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。\r\n\r\n### 1）粗暴版\r\n\r\n``` js\r\nfunction add (a) {\r\n  return function (b) {\r\n    return function (c) {\r\n      return a + b + c;\r\n    }\r\n  }\r\n}\r\nconsole.log(add(1)(2)(3)); // 6\r\n```\r\n\r\n### 2）柯里化解决方案\r\n\r\n#### 参数长度固定\r\n\r\n``` js\r\nconst curry = (fn) =>(judge = (...args) => args.length === fn.length ? fn(...args) : (...arg) => judge(...args, ...arg));\r\nconst add = (a, b, c) => a + b + c;\r\nconst curryAdd = curry(add);\r\nconsole.log(curryAdd(1)(2)(3)); // 6\r\nconsole.log(curryAdd(1, 2)(3)); // 6\r\nconsole.log(curryAdd(1)(2, 3)); // 6\r\n```\r\n\r\n#### 参数长度不固定\r\n\r\n``` js\r\nfunction add (...args) {\r\n  //求和\r\n  return args.reduce((a, b) => a + b);\r\n}\r\n\r\nfunction currying (fn) {\r\n  let args = [];\r\n\r\n  return function temp (...newArgs) {\r\n    if (newArgs.length) {\r\n      args = [\r\n        ...args,\r\n        ...newArgs\r\n      ];\r\n      return temp;\r\n    } else {\r\n      let val = fn.apply(this, args);\r\n      args = []; //保证再次调用时清空\r\n      return val;\r\n    }\r\n  }\r\n}\r\n\r\nlet addCurry = currying(add);\r\nconsole.log(addCurry(1)(2)(3)(4, 5)());  //15\r\nconsole.log(addCurry(1)(2)(3, 4, 5)());  //15\r\nconsole.log(addCurry(1)(2, 3, 4, 5)());  //15\r\n```\r\n\r\n## 实现 Promise.all\r\n\r\n### 1）核心思路\r\n\r\n1. 接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数\r\n2. 这个方法返回一个新的 promise 对象，\r\n3. 遍历传入的参数，用Promise.resolve()将参数\"包一层\"，使其变成一个promise对象\r\n4. 参数所有回调成功才是成功，返回值数组与参数顺序一致\r\n5. 参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。\r\n\r\n### 2）实现代码\r\n\r\n一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了～\r\n\r\n``` js\r\nfunction promiseAll(promises) {\r\n  return new Promise(function(resolve, reject) {\r\n    if (!Array.isArray(promises)) {\r\n        throw new TypeError(`argument must be a array`);\r\n    }\r\n    var resolvedCounter = 0;\r\n    var promiseNum = promises.length;\r\n    var resolvedResult = [];\r\n    for (let i = 0; i < promiseNum; i++) {\r\n      Promise.resolve(promises[i]).then(value=>{\r\n        resolvedCounter++;\r\n        resolvedResult[i] = value;\r\n        if (resolvedCounter === promiseNum) {\r\n          return resolve(resolvedResult);\r\n        }\r\n      }, error=>{\r\n        return reject(error);\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n// test\r\nlet p1 = new Promise(function (resolve, reject) {\r\n  setTimeout(function () {\r\n    resolve(1);\r\n  }, 1000);\r\n})\r\nlet p2 = new Promise(function (resolve, reject) {\r\n  setTimeout(function () {\r\n    resolve(2);\r\n  }, 2000);\r\n})\r\nlet p3 = new Promise(function (resolve, reject) {\r\n  setTimeout(function () {\r\n    resolve(3);\r\n  }, 3000);\r\n})\r\npromiseAll([p3, p1, p2]).then(res => {\r\n  console.log(res); // [3, 1, 2]\r\n});\r\n```\r\n\r\n## 手写代码\r\n\r\n**手写事件侦听器，并要求兼容浏览器**\r\n\r\n``` js\r\nvar eventUtil = {\r\n  getEvent: function(event) {\r\n      return event || window.event;\r\n  },\r\n\r\n  getTarget: function(event) {\r\n      return event.target || event.srcElement;\r\n  },\r\n\r\n  addListener: function(element, type, hander) {\r\n      if (element.addEventListener) {\r\n          element.addEventListener(type, hander, false);\r\n      } else if (element.attachEvent) {\r\n          element.attachEvent('on' + type, hander);\r\n      } else {\r\n          element['on' + type] = hander;\r\n      }\r\n  },\r\n\r\n  removeListener: function(element, type, hander) {\r\n      if (element.removeEventListener) {\r\n          element.removeEventListener(type, hander, false);\r\n      } else if (element.deattachEvent) {\r\n          element.detachEvent(type, hander);\r\n      } else {\r\n          element['on' + type] = null;\r\n      }\r\n  },\r\n\r\n  preventDefault: function(event) {\r\n      if (event.preventDefault) {\r\n          event.preventDefault();\r\n      } else {\r\n          event.returnValue = false;\r\n      }\r\n  },\r\n\r\n  stopPropagation: function(event) {\r\n      if (event.stopPropagation) {\r\n          event.stopPropagation();\r\n      } else {\r\n          event.cancelBubble = true;\r\n      }\r\n  }\r\n};\r\n\r\n// 调用\r\n(function() {\r\n  var btn = document.getElementById(\"btn\");\r\n  var link = document.getElementsByTagName(\"a\")[0];\r\n\r\n  eventUtil.addListener(btn, \"click\", function(event) {\r\n      var event = eventUtil.getEvent(event);\r\n      var target = eventUtil.getTarget(event);\r\n      alert(event.type);\r\n      alert(target);\r\n      eventUtil.stopPropagation(event);\r\n  });\r\n\r\n  eventUtil.addListener(link, \"click\", function(event) {\r\n      alert(\"prevent default event\");\r\n      var event = eventUtil.getEvent(event);\r\n      eventUtil.preventDefault(event);\r\n  });\r\n\r\n  eventUtil.addListener(document.body, \"click\", function() {\r\n      alert(\"click body\");\r\n  });\r\n})();\r\n```\r\n\r\n**手写事件模型**\r\n\r\n``` js\r\nvar Event = (function () {\r\n    var list = {}, bind, trigger, remove;\r\n    bind = function (key, fn) {\r\n        if (!list[key]) {\r\n            list[key] = [];\r\n        }\r\n        list[key].push(fn);\r\n    };\r\n    trigger = function () {\r\n        var key = Array.prototype.shift.call(arguments);\r\n        var fns = list[key];\r\n        if (!fns || fns.length === 0) {\r\n            return false;\r\n        }\r\n        for (var i = 0, fn; fn = fns[i++];) {\r\n            fn.apply(this, arguments);\r\n        }\r\n    };\r\n    remove = function (key, fn) {\r\n        var fns = list[key];\r\n        if (!fns) {\r\n            return false;\r\n        }\r\n        if (!fn) {\r\n            fns & (fns.length = 0);\r\n        } else {\r\n            for (var i = fns.length - 1; i >= 0; i--) {\r\n                var _fn = fns[i];\r\n                if (_fn === fn) {\r\n                    fns.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return {\r\n        bind: bind,\r\n        trigger: trigger,\r\n        remove: remove\r\n    }\r\n})();\r\n\r\n// 调用\r\nEvent.bind('Hit', function(){ console.log('bind event'); }); // 绑定事件\r\nEvent.trigger(\"Hit\", function(){ console.log('trigger event'); }); // 触发事件\r\n```\r\n\r\n**手写事件代理，并要求兼容浏览器**\r\n\r\n``` js\r\nfunction delegateEvent(parentEl, selector, type, fn) {\r\n    var handler = function(e){\r\n          var e = e || window.event;\r\n          var target = e.target || e.srcElement;\r\n          if (matchSelector(target, selector)) {\r\n              if(fn) {\r\n                  fn.call(target, e);\r\n              }\r\n          }\r\n    };\r\n    if(parentEl.addEventListener){\r\n        parentEl.addEventListener(type, handler);\r\n    }else{\r\n        parentEl.attachEvent(\"on\" + type, handler);\r\n    }\r\n}\r\n/**\r\n * support #id, tagName, .className\r\n */\r\nfunction matchSelector(ele, selector) {\r\n    // if use id\r\n    if (selector.charAt(0) === \"#\") {\r\n        return ele.id === selector.slice(1);\r\n    }\r\n    // if use class\r\n    if (selector.charAt(0) === \".\") {\r\n        return (\" \" + ele.className + \" \").indexOf(\" \" + selector.slice(1) + \" \") != -1;\r\n    }\r\n    // if use tagName\r\n    return ele.tagName.toLowerCase() === selector.toLowerCase();\r\n}\r\n\r\n// 调用\r\nvar box = document.getElementById(\"box\");\r\ndelegateEvent(box, \"a\", \"click\", function(){\r\n    console.log(this.href);\r\n})\r\n```\r\n\r\n**手写事件触发器，并要求兼容浏览器**\r\n\r\n``` js\r\nvar fireEvent = function(element, event){\r\n    if (document.createEventObject){\r\n        var mockEvent = document.createEventObject();\r\n        return element.fireEvent('on' + event, mockEvent)\r\n    }else{\r\n        var mockEvent = document.createEvent('HTMLEvents');\r\n        mockEvent.initEvent(event, true, true);\r\n        return element.dispatchEvent(mockEvent);\r\n    }\r\n}\r\n```\r\n\r\n**手写 Function.bind 函数**\r\n\r\n``` js\r\nif (!Function.prototype.bind) {\r\n  Function.prototype.bind = function (oThis) {\r\n    if (typeof this !== \"function\") {\r\n      throw new TypeError(\"'this' is not function\");\r\n    }\r\n\r\n    // bind's default arguments, array without first element\r\n    // first part arguments for the function\r\n    var aBindArgs = Array.prototype.slice.call(arguments, 1);\r\n    var fToBind = this; // the function will be binding\r\n    var fNOP = function () {};\r\n    var fBound = function () {\r\n          // target this will be binding\r\n          var oThis = this instanceof fNOP ? this : oThis || this;\r\n          // last part arguments for the function\r\n          var aCallArgs = Array.prototype.slice.call(arguments);\r\n          // complete arguments for the function\r\n          var aFuncArgs = aBindArgs.concat(aCallArgs);\r\n          return fToBind.apply(oThis, aFuncArgs);\r\n        };\r\n\r\n    // fBound extends fToBind\r\n    fNOP.prototype = this.prototype;\r\n    fBound.prototype = new fNOP();\r\n\r\n    return fBound;\r\n  };\r\n}\r\n\r\n// 调用\r\nvar add = function(a, b, c){ return a + b + c;};\r\nvar newAdd = add.bind(null, 1, 2);\r\nvar result = newAdd(3);\r\n```\r\n\r\n**手写数组快速排序**\r\n\r\n``` js\r\nvar quickSort = function(arr) {\r\n    if (arr.length <= 1) { return arr; }\r\n    var pivotIndex = Math.floor(arr.length / 2);\r\n    var pivot = arr.splice(pivotIndex, 1)[0];\r\n    var left = [];\r\n    var right = [];\r\n    for (var i = 0, len = arr.length; i < len; i++){\r\n        if (arr[i] < pivot) {\r\n          left.push(arr[i]);\r\n        } else {\r\n          right.push(arr[i]);\r\n        }\r\n    }\r\n    return quickSort(left).concat([pivot], quickSort(right));\r\n};\r\n\r\n// 调用\r\nquickSort([9, 4, 2, 8, 1, 5, 3, 7]);\r\n```\r\n\r\n**手写数组冒泡排序**\r\n\r\n``` js\r\nvar bubble = function(arr){\r\n    var maxIndex = arr.length - 1, temp, flag;\r\n    for (var i = maxIndex; i > 0; i--) {\r\n        flag = true\r\n        for (var j = 0; j < i; j++) {\r\n            if (arr[j] > arr[j + 1]) {\r\n                temp = arr[j];\r\n                arr[j] = arr[j + 1];\r\n                arr[j + 1] = temp;\r\n                flag = false;\r\n            }\r\n        }\r\n        if(! flag){\r\n            break;\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n// 调用\r\nvar arr = bubble([13, 69, 28, 93, 55, 75, 34]);\r\n```\r\n\r\n**手写数组去重**\r\n\r\n\r\n``` js\r\nArray.prototype.unique = function() { return [...new Set(this)];};\r\n// 调用\r\n[1, 2, 3, 3, 2, 1].unique();\r\n\r\nfunction unique1(arr){\r\n    var hash = {}, result = [];\r\n    for(var i=0, len=arr.length; i<len; i++){\r\n        if(! hash[arr[i]]){\r\n          result.push(arr[i]);\r\n          hash[arr[i]] = true;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n// 调用\r\nunique1([1, 2, 3, 3, 2, 1]);\r\n\r\nArray.prototype.unique2 = function(){\r\n    this.sort();\r\n    var result = [this[0]];\r\n    var len = this.length;\r\n    for(var i = 0; i < len; i++){\r\n        if(this[i] !== result[result.length - 1]){\r\n          result.push(this[i]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n// 调用\r\n[1, 2, 3, 3, 2, 1].unique2();\r\n\r\nfunction unique3(arr){\r\n    var result = [];\r\n    for(var i=0; i<arr.length; i++){\r\n        if(result.indexOf(arr[i]) == -1){\r\n          result.push(arr[i]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n// 调用\r\nunique3([1, 2, 3, 3, 2, 1]);\r\n```\r\n\r\n**将url的查询参数解析成字典对象**\r\n\r\n\r\n``` js\r\nfunction parseQuery(url) {\r\n  url = url == null ? window.location.href : url;\r\n  var search = url.substring(url.lastIndexOf(\"?\") + 1);\r\n  var hash = {};\r\n  var reg = /([^?&=]+)=([^?&=]*)/g;\r\n  search.replace(reg, function (match, $1, $2) {\r\n      var name = decodeURIComponent($1);\r\n      var val = decodeURIComponent($2);\r\n      hash[name] = String(val);\r\n      return match;\r\n  });\r\n  return hash;\r\n}\r\n```\r\n\r\n**封装函数节流函数**\r\n\r\n``` js\r\nvar throttle = function(fn, delay, mustRunDelay){\r\n  var timer = null;\r\n  var t_start;\r\n  return function(){\r\n    var context = this, args = arguments, t_curr = +new Date();\r\n    clearTimeout(timer);\r\n    if(!t_start){\r\n      t_start = t_curr;\r\n    }\r\n    if(t_curr - t_start >= mustRunDelay){\r\n      fn.apply(context, args);\r\n      t_start = t_curr;\r\n    } else {\r\n      timer = setTimeout(function(){\r\n        fn.apply(context, args);\r\n      }, delay);\r\n    }\r\n  };\r\n};\r\n\r\n// 调用（两次间隔50ms内连续触发不执行，但每累计100ms至少执行一次\r\nwindow.onresize = throttle(myFunc, 50, 100);\r\n```\r\n\r\n**用JS实现千位分隔符**\r\n\r\n``` js\r\nfunction test1(num){\r\n  var str = (+ num) + '';\r\n  var len = str.length;\r\n  if(len <= 3) return str;\r\n  num = '';\r\n  while(len > 3){\r\n      len -= 3;\r\n      num = ',' + str.substr(len, 3) + num;\r\n  }\r\n  return str.substr(0, len) + num;\r\n}\r\n\r\nfunction test2(num){\r\n  // ?= 正向匹配:匹配位置\r\n  // ?! 正向不匹配:排除位置\r\n  var str = (+num).toString();\r\n  var reg = /(?=(?!\\b)(\\d{3})+$)/g;\r\n  return str.replace(reg, ',');\r\n}\r\n```\r\n\r\n## 尾递归优化递归\r\n\r\n``` js\r\nfunction factorial(n)\r\n{\r\n    if (n === 1) {\r\n      return 1;\r\n    }\r\n\r\n    return n * factorial(n - 1);\r\n}\r\n```\r\n\r\n``` js\r\nfunction factorialTailRecursion(n, acc)\r\n{\r\n    if (n === 1) {\r\n      return acc;\r\n    }\r\n\r\n    return factorialTailRecursion(n - 1, acc * n);\r\n}\r\n```\r\n\r\n## 笔试题\r\n\r\n### 怎么看待笔试题\r\n从我个人对面试的看法来说，我是很不喜欢面试的时候手写代码的，尤其是像Promise这样的代码。因为它并不能完全反应出应聘者的真实前端技术水平，并且这种记忆复杂代码的工作，在项目开发中也并不会发挥多大作用。\r\n\r\n所以如果是我招聘前端小伙伴的话，我多半是不会出笔试题的。\r\n\r\n当然我也能理解为什么很多公司的基础面试会考手写Promise，原因可能有以下几点：\r\n\r\n- 节省时间，手写代码能淘汰掉一大批没有基础的应聘者。\r\n- 虽然不能保证上限，但却可以确保下限。\r\n- 对于应届生来说，没有项目经验，只能出这类题了。\r\n- 智力筛选，能手写出Promise的同学，智力和记忆力应该不会太差。\r\n- 招认真准备的应聘者，能手写出Promise的一定是经过了一定时间的面试准备。\r\n\r\n### 笔试题该怎么准备\r\n- 使用ChatGPT：虽然ChatGPT取代程序员的工作短期来看可能性不大，但是用它来刷手写题真的很节省时间。\r\n- 持续更新各种面试手写题以及参考答案，隔一段时间来看看即可。\r\n- 尽量把每一个手写题在实际中的应用给讲一讲，比如像深拷贝、LRU、EventEmitter这些，当你知道它的应用之后，可能就更容易理解和记忆了。\r\n\r\n## 手写防抖函数\r\n\r\n``` javascript\r\nfunction debounce(func, delay) {\r\n  let timerId;\r\n  return function(...args) {\r\n    if (timerId) {\r\n      clearTimeout(timerId);\r\n    }\r\n    timerId = setTimeout(() => {\r\n      func.apply(this, args);\r\n    }, delay);\r\n  }\r\n}\r\n```\r\n\r\n## 手写节流函数\r\n\r\n``` javascript\r\nfunction throttle(func, delay) {\r\n  let lastTime = 0;\r\n  return function(...args) {\r\n    const currentTime = Date.now();\r\n    if (currentTime - lastTime >= delay) {\r\n      func.apply(this, args);\r\n      lastTime = currentTime;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## EventEmitter发布订阅模式\r\n\r\nEventEmitter是一个常考题，用途很广泛，可以用于前端组件通信，用于Nodejs异步编程，另外它就是个发布订阅模式。\r\n\r\n``` javascript\r\nclass EventEmitter {\r\n  constructor() {\r\n    this.events = {}; // 用一个对象来保存事件和订阅者\r\n  }\r\n\r\n  // 添加事件\r\n  on(event, listener) {\r\n    if (!this.events[event]) {\r\n      this.events[event] = [];\r\n    }\r\n    this.events[event].push(listener);\r\n  }\r\n\r\n  // 触发事件\r\n  emit(event, ...args) {\r\n    const listeners = this.events[event] || [];\r\n    listeners.forEach((listener) => listener(...args));\r\n  }\r\n\r\n  // 移除事件\r\n  off(event, listener) {\r\n    const listeners = this.events[event] || [];\r\n    const index = listeners.indexOf(listener);\r\n    if (index >= 0) {\r\n      listeners.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nEventEmitter包含三个核心方法：\r\n\r\n1. on(event, listener)：用于添加事件和订阅者。接收两个参数，event表示事件名称，listener表示订阅者的回调函数。\r\n\r\n2. emit(event, ...args)：用于触发事件。接收一个事件名称和任意数量的参数。当事件被触发时，所有订阅该事件的回调函数将被调用，并将参数传递给它们。\r\n\r\n3. off(event, listener)：用于移除事件和订阅者。接收两个参数，event表示事件名称，listener表示要移除的订阅者的回调函数。\r\n\r\n调用示例：\r\n\r\n``` javascript\r\nconst emitter = new EventEmitter();\r\n\r\n// 添加订阅者\r\nemitter.on('hello', (name) => {\r\n  console.log(`Hello, ${name}!`);\r\n});\r\n\r\n// 触发事件\r\nemitter.emit('hello', 'Tom'); // 输出：Hello, Tom!\r\n```\r\n\r\n## 手写Promise\r\n\r\n要实现一个符合 Promise/A+ 规范的 Promise，需要注意以下几个要点：\r\n\r\n1. 状态转移：Promise 可以处于三种状态之一，分别是“pending”（等待状态）、“fulfilled”（已完成状态）和“rejected”（已拒绝状态）。当 Promise 转移到已完成或已拒绝状态时，需要保证状态不可逆转。\r\n\r\n2. 异步处理：Promise 可以处理异步操作，例如使用定时器或者在事件回调中执行异步代码。需要确保在异步操作完成之后，Promise 状态可以正确地转移。\r\n\r\n3. 链式调用：Promise 支持链式调用，也就是说每次调用 then() 方法后，都会返回一个新的 Promise。在 Promise 链中，每个 Promise 的状态都会受到前一个 Promise 的影响，因此需要保证每个 Promise 都能正确处理自己的状态。\r\n\r\n4. 错误处理：当 Promise 被拒绝时，可以通过 catch() 方法或在 then() 方法中传入第二个参数来处理错误。需要保证错误能够正确地冒泡，并且能够捕获到所有可能出现的错误。\r\n\r\n5. 静态方法：Promise 还有一些静态方法，例如 Promise.all()、Promise.race()、Promise.resolve() 和 Promise.reject() 等。这些方法与实例方法有所不同，需要额外注意实现。\r\n\r\n6. 链式调用的值传递：在链式调用中，每个 then() 方法可以返回一个值或一个新的 Promise。如果返回一个值，后续的 then() 方法应该接收到这个值。如果返回一个新的 Promise，后续的 then() 方法应该等待这个 Promise 完成，并接收到它的结果。\r\n\r\n``` javascript\r\nclass MyPromise {\r\n  constructor(executor) {\r\n    this.state = 'pending';\r\n    this.value = null;\r\n    this.reason = null;\r\n    this.onResolvedCallbacks = [];\r\n    this.onRejectedCallbacks = [];\r\n\r\n    const resolve = (value) => {\r\n      if (this.state === 'pending') {\r\n        this.state = 'fulfilled';\r\n        this.value = value;\r\n        this.onResolvedCallbacks.forEach(callback => callback(value));\r\n      }\r\n    }\r\n\r\n    const reject = (reason) => {\r\n      if (this.state === 'pending') {\r\n        this.state = 'rejected';\r\n        this.reason = reason;\r\n        this.onRejectedCallbacks.forEach(callback => callback(reason));\r\n      }\r\n    }\r\n\r\n    try {\r\n      executor(resolve, reject);\r\n    } catch (error) {\r\n      reject(error);\r\n    }\r\n  }\r\n\r\n  then(onResolved, onRejected) {\r\n    onResolved = typeof onResolved === 'function' ? onResolved : value => value;\r\n    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\r\n\r\n    const promise = new MyPromise((resolve, reject) => {\r\n      const handle = (callback, state) => {\r\n        try {\r\n          const result = callback(this.value);\r\n          if (result instanceof MyPromise) {\r\n            result.then(resolve, reject);\r\n          } else {\r\n            state(result);\r\n          }\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      }\r\n\r\n      if (this.state === 'fulfilled') {\r\n        setTimeout(() => handle(onResolved, resolve), 0);\r\n      } else if (this.state === 'rejected') {\r\n        setTimeout(() => handle(onRejected, reject), 0);\r\n      } else {\r\n        this.onResolvedCallbacks.push(() => handle(onResolved, resolve));\r\n        this.onRejectedCallbacks.push(() => handle(onRejected, reject));\r\n      }\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  catch(onRejected) {\r\n    return this.then(null, onRejected);\r\n  }\r\n\r\n  static resolve(value) {\r\n    return new MyPromise(resolve => resolve(value));\r\n  }\r\n\r\n  static reject(reason) {\r\n    return new MyPromise((_, reject) => reject(reason));\r\n  }\r\n\r\n  static all(promises) {\r\n    return new MyPromise((resolve, reject) => {\r\n      const results = [];\r\n      let count = 0;\r\n\r\n      const handleResult = (index, value) => {\r\n        results[index] = value;\r\n        count++;\r\n        if (count === promises.length) {\r\n          resolve(results);\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < promises.length; i++) {\r\n        promises[i].then(value => handleResult(i, value), reject);\r\n      }\r\n    });\r\n  }\r\n\r\n  static race(promises) {\r\n    return new MyPromise((resolve, reject) => {\r\n      for (let i = 0; i < promises.length; i++) {\r\n        promises[i].then(resolve, reject);\r\n      }\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n## 手写LRU缓存算法\r\n\r\n``` javascript\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity;\r\n    this.cache = new Map();\r\n  }\r\n\r\n  get(key) {\r\n    if (!this.cache.has(key)) {\r\n      return -1;\r\n    }\r\n    const value = this.cache.get(key);\r\n    this.cache.delete(key);\r\n    this.cache.set(key, value);\r\n    return value;\r\n  }\r\n\r\n  put(key, value) {\r\n    if (this.cache.has(key)) {\r\n      this.cache.delete(key);\r\n    } else if (this.cache.size >= this.capacity) {\r\n      const firstKey = this.cache.keys().next().value;\r\n      this.cache.delete(firstKey);\r\n    }\r\n    this.cache.set(key, value);\r\n  }\r\n}\r\n```\r\n\r\n## 手写apply\r\n\r\n``` javascript\r\nFunction.prototype.myApply = function(context, argsArray) {\r\n  context = context || window;\r\n  context.fn = this;\r\n  let result;\r\n  if (argsArray) {\r\n    result = context.fn(...argsArray);\r\n  } else {\r\n    result = context.fn();\r\n  }\r\n  delete context.fn;\r\n  return result;\r\n}\r\n```\r\n\r\n## 手写bind\r\n\r\n``` javascript\r\nFunction.prototype.myBind = function (context, ...args) {\r\n  const fn = this;\r\n  return function (...args2) {\r\n    return fn.apply(context, [...args, ...args2]);\r\n  };\r\n};\r\n```\r\n\r\n## 手写call\r\n\r\n``` javascript\r\nFunction.prototype.myCall = function (context, ...args) {\r\n  const fn = Symbol(\"fn\");\r\n  context = context || window;\r\n  context[fn] = this;\r\n  const result = context[fn](...args);\r\n  delete context[fn];\r\n  return result;\r\n};\r\n```\r\n\r\n## 手写Object.create\r\n\r\n``` javascript\r\nfunction createObject(proto) {\r\n  function F() {}\r\n  F.prototype = proto;\r\n  return new F();\r\n}\r\n```\r\n\r\n创建一个空的函数F，然后将proto设置为F的原型，最后返回一个新的F实例。这个新实例的原型链就指向了proto。\r\n\r\n## 手写instanceof方法\r\n\r\n``` javascript\r\nfunction myInstanceOf(obj, constructor) {\r\n  // 首先判断参数是否合法\r\n  if (obj === null || typeof obj !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  // 获取对象的原型\r\n  let proto = Object.getPrototypeOf(obj);\r\n\r\n  // 遍历原型链\r\n  while (proto !== null) {\r\n    if (proto === constructor.prototype) {\r\n      return true;\r\n    }\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return false;\r\n}\r\n```\r\n\r\n首先判断传入的 obj 是否是一个对象，如果不是则返回 false。接着获取对象的原型，然后遍历整个原型链。如果在原型链中找到了 `constructor.prototype`，则返回 true，否则返回 false。\r\n\r\n## 手写new操作符\r\n\r\n``` javascript\r\nfunction myNew(constructor, ...args) {\r\n  // 创建一个新对象，它的原型指向构造函数的原型对象\r\n  const obj = Object.create(constructor.prototype);\r\n\r\n  // 执行构造函数，并将 this 指向新对象\r\n  const result = constructor.apply(obj, args);\r\n\r\n  // 如果构造函数返回一个对象，则返回这个对象，否则返回新对象\r\n  return result instanceof Object ? result : obj;\r\n}\r\n```\r\n我们首先使用 `Object.create` 方法创建一个新对象，它的原型指向构造函数的原型对象。接着执行构造函数，并将 this 指向新对象。如果构造函数返回一个对象，则返回这个对象，否则返回新对象。\r\n\r\n## 函数柯里化\r\n\r\n``` javascript\r\nfunction curry(fn) {\r\n  return function curried(...args) {\r\n    if (args.length >= fn.length) {\r\n      return fn.apply(this, args);\r\n    } else {\r\n      return function(...moreArgs) {\r\n        return curried.apply(this, args.concat(moreArgs));\r\n      };\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n我们定义了一个 curry 函数，它接受一个函数 fn 作为参数，并返回一个新函数。这个新函数接受任意个数的参数，并通过递归的方式将这些参数拆分成一系列嵌套的函数，最终返回一个新函数，执行原函数 fn。\r\n\r\n## 手写Ajax\r\n\r\n``` javascript\r\nfunction ajax(method, url, data, successCallback, errorCallback) {\r\n  // 创建 XMLHttpRequest 对象\r\n  const xhr = new XMLHttpRequest();\r\n\r\n  // 监听 readyState 变化事件\r\n  xhr.onreadystatechange = function() {\r\n    if (xhr.readyState === 4) {\r\n      if (xhr.status === 200) {\r\n        // 请求成功，执行成功回调函数\r\n        successCallback(xhr.responseText);\r\n      } else {\r\n        // 请求失败，执行错误回调函数\r\n        errorCallback(xhr.status);\r\n      }\r\n    }\r\n  };\r\n\r\n  // 初始化请求\r\n  xhr.open(method, url, true);\r\n\r\n  // 设置请求头\r\n  xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\r\n\r\n  // 发送请求\r\n  xhr.send(data);\r\n}\r\n```\r\n\r\n1. 定义一个 ajax 函数，它接受五个参数：请求方法（method）、请求地址（url）、请求数据（data）、成功回调函数（successCallback）和错误回调函数（errorCallback）。\r\n\r\n2. 创建一个 XMLHttpRequest 对象，并设置它的 readyState 变化事件的回调函数。在回调函数中，判断 readyState 是否为 4，以及状态码是否为 200。如果是，则执行成功回调函数，并将响应文本作为参数传入；否则，执行错误回调函数，并将状态码作为参数传入。\r\n\r\n3. 接着，调用 open 方法初始化请求，并调用 setRequestHeader 方法设置请求头。最后，我们调用 send 方法发送请求，并将请求数据作为参数传入。\r\n\r\n## 数组去重\r\n\r\n1. 使用Set去重\r\n\r\n``` javascript\r\nfunction uniqueBySet(arr) {\r\n  return [...new Set(arr)];\r\n}\r\n```\r\n\r\n2. 使用Array.reduce()方法去重\r\n``` javascript\r\nfunction uniqueByReduce(arr) {\r\n  return arr.reduce((acc, cur) => {\r\n    if (!acc.includes(cur)) {\r\n      acc.push(cur);\r\n    }\r\n    return acc;\r\n  }, []);\r\n}\r\n```\r\n\r\n3. filter去重\r\n``` javascript\r\nfunction unique(arr) {\r\n  return arr.filter((item, index, array) => {\r\n    return array.indexOf(item) === index;\r\n  });\r\n}\r\n```\r\n\r\n## 数组扁平化\r\n\r\nJS 数组扁平化是将一个多维数组变成一维数组的操作，可以使用多种方法来实现，以下是其中一种手写实现：\r\n\r\n``` javascript\r\nfunction flatten(arr) {\r\n  return arr.reduce((prev, curr) => {\r\n    return prev.concat(Array.isArray(curr) ? flatten(curr) : curr);\r\n  }, []);\r\n}\r\n```\r\n\r\n使用数组的 reduce 方法来递归地将多维数组扁平化。对于每个元素，如果它是一个数组，则递归调用 flatten 函数将其扁平化；否则，将其直接加入结果数组中。最终，我们将所有结果数组拼接起来，得到一个一维数组。\r\n\r\n## 循环打印红黄绿\r\n\r\n``` javascript\r\nfunction printTrafficLight() {\r\n  const colors = ['红灯', '黄灯', '绿灯'];\r\n  let index = 0;\r\n  setInterval(() => {\r\n    console.log(colors[index]);\r\n    index = (index + 1) % colors.length;\r\n  }, 1000);\r\n}\r\n\r\nprintTrafficLight();\r\n```\r\n\r\n我们首先定义了一个包含三种颜色的数组 colors，以及一个变量 index，用于表示当前应该输出哪种颜色。然后，我们使用 setInterval 方法每隔 1 秒输出一种颜色，并将 index 增加 1，以便下次输出下一个颜色。由于我们需要循环输出颜色，当 index 增加到 3 时，我们使用模运算将其重置为 0，从而重新开始循环输出。\r\n\r\n## 手写继承\r\n\r\n一般只需要实现组合寄生继承的形式就可以了,它通过借用构造函数来继承父类的属性，通过原型链来继承父类的方法，并使用寄生方式来修复原型链：\r\n\r\n``` javascript\r\nfunction inheritPrototype(subType, superType) {\r\n  const prototype = Object.create(superType.prototype);\r\n  prototype.constructor = subType;\r\n  subType.prototype = prototype;\r\n}\r\n\r\nfunction Animal(name) {\r\n  this.name = name;\r\n  this.colors = ['white', 'black'];\r\n}\r\n\r\nAnimal.prototype.eat = function() {\r\n  console.log(this.name + ' is eating.');\r\n};\r\n\r\nfunction Dog(name) {\r\n  Animal.call(this, name);\r\n  this.type = 'dog';\r\n}\r\n\r\ninheritPrototype(Dog, Animal);\r\n\r\nDog.prototype.bark = function() {\r\n  console.log(this.name + ' is barking.');\r\n};\r\n\r\nconst dog = new Dog('Snoopy');\r\ndog.eat(); // 输出 \"Snoopy is eating.\"\r\ndog.bark(); // 输出 \"Snoopy is barking.\"\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/604/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/604/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 介绍防抖节流原理、区别以及应用，并用JavaScript进行实现","### 1）防抖","### 2）节流","## 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6, 4, 5, 6, 11, 23, 42, 56, 78, 90）","## 实现 lodash 的_.get","### 1）代码实现","## 实现 add(1)(2)(3)","### 1）粗暴版","### 2）柯里化解决方案","#### 参数长度固定","#### 参数长度不固定","## 实现 Promise.all","### 1）核心思路","### 2）实现代码","## 手写代码","## 尾递归优化递归","## 笔试题","### 怎么看待笔试题","### 笔试题该怎么准备","## 手写防抖函数","## 手写节流函数","## EventEmitter发布订阅模式","## 手写Promise","## 手写LRU缓存算法","## 手写apply","## 手写bind","## 手写call","## 手写Object.create","## 手写instanceof方法","## 手写new操作符","## 函数柯里化","## 手写Ajax","## 数组去重","## 数组扁平化","## 循环打印红黄绿","## 手写继承"]},"__N_SSG":true}