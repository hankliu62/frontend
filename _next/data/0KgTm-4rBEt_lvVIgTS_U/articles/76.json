{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/76","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/76/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/76/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/76/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/76","id":1802080014,"node_id":"I_kwDOBiJZIc5raY8O","number":76,"title":"前端code review流程规范","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536681139,"node_id":"LA_kwDOBiJZIc8AAAABhZ3Wsw","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/engine","name":"engine","color":"1d76db","default":false,"description":"分类-工程化相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2023-07-13T03:19:23Z","updated_at":"2024-04-08T05:14:41Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 前端code review流程规范\r\n\r\n### 引言\r\n任何软件都是协同开发的，CodeReview 非常重要，对团队来说，它可以帮助你减少代码质量问题，提高开发效率，提升稳定性，同时还能保证软件架构的稳定性，防止代码结构被恶意破坏导致难以维护。对个人来说，它可以帮助你快速成长，通过学习不同的代码风格和实现，让你能快速的掌握更多技巧，同时在review别人代码同时，也是你自己思路的重构过程，帮助你更好的理解系统的业务。\r\n\r\n### 概述\r\n\r\n#### CodeReview 的覆盖范围\r\n**Good CodeReview** 会检查代码的正确性、测试覆盖率、功能变化、是否遵循代码规范与最佳实践、可以指出一些较为明显的改进点，比如难以阅读的写法、未使用到变量、一些边界问题、commit 数量过大需要拆分等等。\r\n**Better CodeReview** 会检查引入代码的必要性，与已有系统是否适配，是否具有可维护性，从抽象角度思考代码是否与已有系统逻辑能够自洽。\r\n\r\n#### CodeReview 的语气\r\n**Good CodeReview** 会给出建设性意见，而不是发表强硬措辞要求对方改正，或认为自己的意见是唯一正确的答案，因为这样的评论其实具有一定攻击性，激发对方的防御心理，产生敌对心态，这样会从内部瓦解一个团队。最好能给出建议，或者多个选择，给对方留有余地。\r\n**Better CodeReview** 永远是考虑全面且正向积极的，**会对写的好的地方进行鼓励**，对写的不好的地方也体现出善解人意的关怀，考虑到对方可能花费了很多心血，以一种换位思考的鼓励心态进行评论。\r\n\r\n#### 如何完成 CodeReview 的审阅\r\n**Good CodeReview** 不会轻易通过那些开放式 PR，至少在其被得到充分讨论前，但每个 Review 者对自己关注的部分完成 Review 后需要进行反馈，无论是 “**看起来不错**” 或者用缩写单词 “**LGTM**”，之后需要有明确的跟进，比如通过协作软件通知作者进行进一步反馈。\r\n**Better CodeReview** 实际执行中会更加灵活一些，对于一些比较紧急的改动会留下改进建议，但快速通过，让作者通过后续代码提交解决遗留的问题。\r\n\r\n#### 从 CodeReview 到直接交流\r\n**Good CodeReview** 会给出完整的评论和修改建议，如果后续提交的代码不符合预期，Review 者可以直接与代码提交者面对面交流，这样可以避免后续花费更多沟通时间。\r\n**Better CodeReview** 会在第一次给出完整的评论和修改建议，如果后续提交代码不符合预期，会立即与代码提交者当面沟通，避免异步沟通带来更多的理解偏差。\r\n\r\n#### 区分重点\r\n**Good CodeReview** 可以区分提示的重要程度，并在不太重要的改动前面加上 “**nit:**” 标记，这样可以使提交者的注意力集中在重要的问题上。\r\n**Better CodeReview** 会采取工具手段解决这些问题，比如一些代码 lint 工具，因为这些问题往往是可以被工具自动化解决的。\r\n\r\n#### 针对新人的 CodeReview\r\n**Good CodeReview** 对任何人都是用相同评判标准，可以遵循上面几点注意事项。\r\n**Better CodeReview** 会对新人区分对待，对新人给予更多的耐心、解释和评论，甚至给出解决方法，并更积极的给出鼓励。\r\n\r\n### 建议\r\n\r\n#### 小批量【每次 Review 的代码量要少】\r\n需求比较少时，同时针对Link和Transfer业务来说，前端开发人员只有一个，针对Top后台的业务相关来说不是特别的熟悉，我们发起CR时指定审阅人员一般会选择对业务需求这块比较熟悉的人，所以Link和Transfer业务的开发人员Review的次数比较少，由于需要CodeReview的次数和拒绝率进行考核，所以最好是能进行小批量的CodeReview，我们可以将需求进行拆分，每个功能点都进行一次CodeReview，可以指定不同的人进行审阅，而不是等一个需求开发进行一半再进行整体的CodeReview，这样的话能也节省审阅人员的Review的时间。\r\n\r\n代码量少的好处显而易见，修改了哪里非常清晰，问题也会一目了然。一次推给别人 1000+ 行代码，还想得到有价值的 Review，可能性微乎其微。\r\n\r\n#### 多批次【Review 要频繁发生】\r\n小批量的CodeReview必要进行多批次的CodeReview，增加项目组其他人熟悉系统业务的机会，同时也能让自己养成及时提交代码和所有代码进行CodeReview的好习惯\r\n\r\n#### 快速响应\r\n以前我们C1前端的CodeReview一般选择一次需求只会在showcase的前一天进行一次CodeReview，这样的话CodeReview代码量比较大，所以很多时候要得比较急时，往往是匆匆潦草的打上一个“**LGTM**”，即使或者是不急的情况下，看到一个代码量如此庞大的CodeReview，当审阅人有其他事情的时候，往往会造成拖延，不能及时的进行响应。\r\n\r\n当每次 Review 的粒度不大，Review 又比较频繁时，快速响应才能成为可能，也是必然的要求，在这个数据上，Google 的中位数是 4 小时。我们不要求4小时的及时响应，最好是**上午的Review在下班之前当天能完成，下午的Review再第二天下班之前能完成**，拖到久了可能会造成遗忘。\r\n\r\n#### 综合在线 Review 和面对面讨论\r\n我们一般都会选择在线Review的方式，这也是常态化的一种方式，遇到有待优化或者优秀的代码时，我们一般会加相应的注释，有时候注释无法很好的表达你的意思的时候，我们可以进行面对面的讨论，而且我们一个团队的座位也离的很近，面对面讨论很方便而且能更清楚的表达双方的看法，加强团队的沟通。\r\n\r\n#### 及时表达肯定，委婉表达意见\r\n只针对代码，不针对人。这听起来很简单，都知道对事不对人的重要性，但是要非常小心不能违背。审查并不是只提反面意见的，**在遇到好的实现，不错的想法的时候，可以表示肯定**，当然这个数量不宜多，要不然适得其反。至于表达意见方面，我来举几个例子：\r\n\r\n- 对于一些**次要问题**，我都会标注这个问题是一个 **picky 或者 nit 的问题**（“挑剔的问题”）。这样的好处在于，明确告知对方，我虽然提出了这个问题，但是它没有什么大不了的，如果你坚持不改，我也不打算说服你。或者说，**我对这个问题持有不同的看法，但是我也并不坚信我的提议更好**。 \r\n\r\n- 使用**也许、或许、可能、似乎**这样表示不确定的语气词。这样的好处是，缓和自己表达观点的语气。比如说：“**这个地方重构一下，去掉这个循环，也许会更好。**” \r\n- **间接地表达否定**。比如说，你看到对方配置了周期为 60 秒，但是你觉得不对，但又不很确定，你可以这样说：“**我有一个疑问，为什么这里要使用 60 秒而不是其他值呢？**” 对方可能会反应过来这个值选取得不够恰当。你看，这个方式就是使用疑问，而非直接的否定，这就委婉得多。 \r\n- **放上例子、讨论的链接**，以及其它一些辅助材料证明自己的观点，但是不要直接表述观点，让对方来确认这个观点。比如说：“下面的讨论是关于这个逻辑的另一种实现方式，不知你觉得如何？” \r\n- **先肯定，再否定**。这个我想很多人一直都在用，先摆事实诚恳地说一些同意和正面的话，然后用“不过”、“但是”和“然而”之类的将话锋一转，说出相反的情况，这样也就在言论中比较了优劣，意味着这是经过权衡得出的结论。\r\n\r\n### 时机\r\n不一定要完成需求的80%才进行CodeReview，那样的话代码量可能也会堆积的比较多，我们可以按照下面两种维度来拆分CodeReview的代码量，具体如何拆分可以根据自己的习惯来，唯一的原则是要遵循小批次的建议，每次CodeReview的代码量最好控制在**20min**之内。\r\n\r\n#### 1. 按功能维度拆分\r\n我们可以**每完成一个功能点就进行CodeReview**，比如开发业务需求时，一般的业务需求都会分成ABCD等多个功能点，我们完成第一个功能点可以进行一次CodeReview，根据dev分支进行`arc diff`，再次完成一下个功能点时，根据上一个功能点的`commit id`进行`arc diff`,上一个CodeReview中的代码将不在下一个CodeReview中，保持每个CodeReview的代码量不是很繁多，值得注意的是，**根据业务功能点进行拆分CodeReview时，最好在Summary中贴入业务需求的PROD文档地址，同时说明当前CodeReview实现的是哪一点**，便于审阅人员更好的理解代码。或者更小力度，**完成某个通用的组件进行CodeReview**\r\n\r\n#### 2. 按时间维度拆分\r\n\r\n如果有业务功能需求开发时，每天下班前提交一次代码，每天提交代码的时候发起一次CodeReview\r\n```\r\n# 开发完一个功能点时，切到dev分支，拉最新的dev代码\r\narc diff --create dev\r\n\r\n# Summary: [TOP_1.8.2规格搜索](xxxx) 【A】案例搜索\r\n# Reviewers: 可以有多个，谁有空就可以进行review\r\n\r\n# 下一个功能点开发完成时，上一次CodeReview的CommitID: 5baebdb2f92ce684b0666d80b12c5f61631e608f\r\narc diff 5baebdb2f92ce684b0666d80b12c5f61631e608f\r\n\r\n# 同上\r\n```\r\n\r\n### 流程\r\n1. 审核人列表中的第一位，默认为该审核的 owner，负责该条的通过/拒绝，其他审核人可以添加评论。\r\n2. Review 最晚要在 24h 内完成。可以根据个人习惯每天开始或者结束的时候统一 review。\r\n3. 发起Review完以后，推荐发起者也先阅读下自己代码，当前全局来审阅的自己的代码的时候，有时也可能发现一些代码上的问题。\r\n\r\n### 规则\r\n#### 整体性检查\r\n1. 代码切分到模块是否合理\r\n2. class、method等命名要规范\r\n3. 常量、枚举值是否提取到公共文件\r\n\r\n#### 安全检查\r\n1. 使用dangerouslySetInnerHTML展示返回内容时，和后端预防xss攻击\r\n2. 提交表单时，必填项校验\r\n3. 常见的数字、URL、电话号码、邮箱地址等等做校验判断\r\n5. 不确定数据的属性访问时，先判空\r\n6. 避免重要的用户信息存在浏览器缓存\r\n7. 优先使用空标签(<></>)代替不必要加的div元素\r\n\r\n#### 性能\r\n1. 循环中不要调用后台接口\r\n2. 列表必须使用分页或者滚动加载\r\n3. 避免创建不需要的对象(变量是否被引用)\r\n4. 元素数组避免使用Index作为Key属性\r\n\r\n#### 业务检查\r\n1. 实现方式是否过于复杂\r\n2. 实现方式是否好维护\r\n3. 实现方式是否好测试\r\n4. 复杂的场景做个design review\r\n6. 列表中图片展示是否使用缩略图\r\n7. 列表中图片展示是否懒加载\r\n9. 模态框表单提交时，使用防抖防止重复提交\r\n10. 不再使用七牛相关能力\r\n11. 了解antd组件能力，尽量复用antd组件\r\n12. for循环最多3层\r\n13. OSS上传文件时，注意文件大小限制\r\n\r\n#### 注释\r\n1. class用途有注释\r\n2. method用途有注释\r\n3. 复杂的代码块有逻辑说明\r\n\r\n#### 冗余代码\r\n1. 不再运行的代码要清理干净，不要做简单的注释\r\n2. 重复代码提取成公共组件或者工具类\r\n3. 已经下线的业务，代码清理干净\r\n\r\n更多规则可以在下述规则文件进行添加，如果有认为不可理的地方也可以进行讨论更新至下述规则文件：","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/76/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/76/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 前端code review流程规范","### 引言","### 概述","#### CodeReview 的覆盖范围","#### CodeReview 的语气","#### 如何完成 CodeReview 的审阅","#### 从 CodeReview 到直接交流","#### 区分重点","#### 针对新人的 CodeReview","### 建议","#### 小批量【每次 Review 的代码量要少】","#### 多批次【Review 要频繁发生】","#### 快速响应","#### 综合在线 Review 和面对面讨论","#### 及时表达肯定，委婉表达意见","### 时机","#### 1. 按功能维度拆分","#### 2. 按时间维度拆分","### 流程","### 规则","#### 整体性检查","#### 安全检查","#### 性能","#### 业务检查","#### 注释","#### 冗余代码"]},"__N_SSG":true}