{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/555","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/555/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/555/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/555/events","html_url":"https://github.com/hankliu62/interview/issues/555","id":2141250124,"node_id":"I_kwDOLNphd85_oOJM","number":555,"title":"最大子序和(53)","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6578481463,"node_id":"LA_kwDOLNphd88AAAABiBupNw","url":"https://api.github.com/repos/hankliu62/interview/labels/leetcode","name":"leetcode","color":"7F3AE3","default":false,"description":"Leetcode相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-19T00:04:42Z","updated_at":"2024-02-19T00:04:42Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"题目如下：\r\n\r\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\r\n\r\n```\r\n示例 1：\r\n\r\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\r\n输出：6\r\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\r\n\r\n示例 2：\r\n\r\n输入：nums = [1]\r\n输出：1\r\n\r\n示例 3：\r\n\r\n输入：nums = [0]\r\n输出：0\r\n```\r\n\r\n**思路**：\r\n\r\n- 这道题可以用动态规划来解决，关键是找动态转移方程\r\n- 我们动态转移方程中，`dp`表示每一个`nums`下标的最大自序和，所以`dp[i]`的意思为：包括下标i之前的最大连续子序列和为`dp[i]`。\r\n\r\n确定转义方程的公示：\r\n\r\n`dp[i]`只有两个方向可以推出来：\r\n\r\n1. 如果`dp[i - 1] < 0`，也就是当前遍历到`nums`的`i`，之前的最大子序和是负数，那么我们就没必要继续加它了，因为`dp[i] = dp[i - 1] + nums[i]` 会比`nums[i]`更小，所以此时还不如`dp[i] = nums[i]`，就是目前遍历到`i`的最大子序和呢\r\n2. 同理`dp[i - 1] > 0`，说明`nums[i]`值得去加`dp[i - 1]`，此时回避`nums[i]`更大\r\n\r\n这样代码就出来了，其实更多的就是求`dp`，遍历`nums`每一个下标都会产生最大子序和，我们记录下来即可\r\n\r\n``` js\r\nvar maxSubArray = function(nums) {\r\n  let res = nums[0];\r\n  const dp = [nums[0]];\r\n  for(let i=1;i < nums.length;i++){\r\n      if(dp[i-1]>0){\r\n        dp[i]=nums[i]+dp[i-1]\r\n      }else{\r\n       dp[i]=nums[i]\r\n      }\r\n\r\n    res=Math.max(dp[i],res)\r\n  }\r\n  return res\r\n};\r\n```","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/555/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/555/timeline","performed_via_github_app":null,"state_reason":null},"menus":[]},"__N_SSG":true}