{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/21","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/21/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/21/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/21/events","html_url":"https://github.com/hankliu62/interview/issues/21","id":2129434156,"node_id":"I_kwDOLNphd85-7JYs","number":21,"title":"五、渲染机制","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468066,"node_id":"LA_kwDOLNphd88AAAABhkJvIg","url":"https://api.github.com/repos/hankliu62/interview/labels/html","name":"html","color":"13c2c2","default":false,"description":"HTML相关"},{"id":6547468110,"node_id":"LA_kwDOLNphd88AAAABhkJvTg","url":"https://api.github.com/repos/hankliu62/interview/labels/javascript","name":"javascript","color":"383040","default":false,"description":"Javascript相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-12T05:13:28Z","updated_at":"2024-03-08T05:29:22Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"**浏览器的渲染机制一般分为以下几个步骤**\r\n\r\n- 处理 `HTML` 并构建 `DOM` 树。\r\n- 处理 `CSS` 构建 `CSSOM` 树。\r\n- 将 `DOM` 与 `CSSOM` 合并成一个渲染树。\r\n- 根据渲染树来布局，计算每个节点的位置。\r\n- 调用 `GPU` 绘制，合成图层，显示在屏幕上\r\n\r\n- 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢\r\n- 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM\r\n\r\n### 5.1 图层\r\n\r\n> 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用\r\n\r\n**通过以下几个常用属性可以生成新图层**\r\n\r\n- 3D 变换：`translate3d`、`translateZ`\r\n- `will-change`\r\n- `video`、`iframe` 标签\r\n- 通过动画实现的 `opacity` 动画转换\r\n- `position: fixed`\r\n\r\n### 5.2 重绘（Repaint）和回流（Reflow）\r\n\r\n- 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘\r\n- 回流是布局或者几何属性需要改变就称为回流\r\n\r\n> 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流\r\n\r\n**所以以下几个动作可能会导致性能问题**：\r\n\r\n- 改变 window 大小\r\n- 改变字体\r\n- 添加或删除样式\r\n- 文字改变\r\n- 定位或者浮动\r\n- 盒模型\r\n\r\n**很多人不知道的是，重绘和回流其实和 Event loop 有关**\r\n\r\n- 当 Event loop 执行完 `Microtasks` 后，会判断 `document` 是否需要更新。因为浏览器是 `60Hz `的刷新率，每 `16ms `才会更新一次。\r\n- 然后判断是否有 `resize` 或者 `scroll` ，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 `16ms` 才会触发一次，并且自带节流功能。\r\n- 判断是否触发了` media query`\r\n- 更新动画并且发送事件\r\n- 判断是否有全屏操作事件\r\n- 执行 `requestAnimationFrame` 回调\r\n- 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好\r\n- 更新界面\r\n- 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调\r\n\r\n**减少重绘和回流**\r\n\r\n- 使用 `translate` 替代 `top`\r\n- 使用 `visibility` 替换` display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）\r\n- 不要使用 `table` 布局，可能很小的一个小改动会造成整个 table 的重新布局\r\n- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`\r\n- `CSS` 选择符从右往左匹配查找，避免 `DOM` 深度过深\r\n- 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video `标签，浏览器会自动将该节点变为图层","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/21/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/21/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### 5.1 图层","### 5.2 重绘（Repaint）和回流（Reflow）"]},"__N_SSG":true}