{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/612","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/612/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/612/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/612/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/612","id":2131539029,"node_id":"I_kwDOBiJZIc5_DLRV","number":612,"title":"Typescript相关的面试题","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536131138,"node_id":"LA_kwDOBiJZIc8AAAABhZVyQg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/typescript","name":"typescript","color":"487E6B","default":false,"description":"分类-Typescript相关"},{"id":6552343574,"node_id":"LA_kwDOBiJZIc8AAAABhozUFg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview","name":"interview","color":"79D677","default":false,"description":"分类-面试题相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-13T06:15:37Z","updated_at":"2024-02-13T08:51:27Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"---\r\n\r\ntitle: Typescript相关的面试题\r\n\r\ndate: 2024-02-13 16:51:26\r\n\r\ntag: [blog, interview, typescript]\r\n\r\n---\r\n\r\n## 说说TS和ES的区别，以及TS带来的好处？\r\n\r\n目标：生命周期较长（常常持续几年）的复杂SPA应用，保障开发效率的同时提升代码的可维护性和线上运行时质量。\r\n\r\n- 从开发效率上看，虽然需要多写一些类型定义代码，但TS在VSCode、WebStorm等IDE下可以做到智能提示，智能感知bug，同时我们项目常用的一些第三方类库框架都有TS类型声明，我们也可以给那些没有TS类型声明的稳定模块写声明文件，如我们的前端KOP框架(目前还是蚂蚁内部框架，类比dva)，这在团队协作项目中可以提升整体的开发效率。\r\n- 从可维护性上看，长期迭代维护的项目开发和维护的成员会有很多，团队成员水平会有差异，而软件具有熵的特质，长期迭代维护的项目总会遇到可维护性逐渐降低的问题，有了强类型约束和静态检查，以及智能IDE的帮助下，可以降低软件腐化的速度，提升可维护性，且在重构时，强类型和静态类型检查会帮上大忙，甚至有了类型定义，会不经意间增加重构的频率（更安全、放心）。\r\n- 从线上运行时质量上看，我们现在的SPA项目的很多bug都是由于一些调用方和被调用方（如组件模块间的协作、接口或函数的调用）的数据格式不匹配引起的，由于TS有编译期的静态检查，让我们的bug尽可能消灭在编译器，加上IDE有智能纠错，编码时就能提前感知bug的存在，我们的线上运行时质量会更为稳定可控。\r\n\r\nTS适合大规模JavaScript应用，正如他的官方宣传语JavaScript that scales。从以下几点可以看到TS在团队协作、可维护性、易读性、稳定性（编译期提前暴露bug）等方面上有着明显的好处：\r\n\r\n- 加上了类型系统，对于阅读代码的人和编译器都是友好的。对阅读者来说，类型定义加上IDE的智能提示，增强了代码的易读型；对于编译器来说，类型定义可以让编译器揪出隐藏的bug。\r\n- 类型系统+静态分析检查+智能感知/提示，使大规模的应用代码质量更高，运行时bug更少，更方便维护。\r\n- 有类似VSCode这样配套的IDE支持，方便的查看类型推断和引用关系，可以更方便和安全的进行重构，再也不用全局搜索，一个个修改了。\r\n- 给应用配置、应用状态、前后端接口及各种模块定义类型，整个应用都是一个个的类型定义，使协作更为方便、高效和安全。\r\n\r\n## TypeScript 简介及优缺点\r\n\r\nTypeScript 是 JavaScript 的一个超集，提供了类型系统和对ES6的支持，可编译成纯 JavaScript，可以运行在任何浏览器上，TS编译工具也可运行在任何服务器和系统上\r\n\r\n### 优点\r\n- （1）增强代码的可读性和可维护性，强类型的系统相当于最好的文档，在编译时即可发现大部分的错误，增强编辑器的功能。\r\n- （2）包容性，js文件可以直接改成 ts 文件，不定义类型可自动推论类型，可以定义几乎一切类型，ts 编译报错时也可以生成 js 文件，兼容第三方库，即使不是用ts编写的\r\n- （3）有活跃的社区，大多数的第三方库都可提供给 ts 的类型定义文件，完全支持 es6 规范\r\n\r\n### 缺点\r\n- （1）增加学习成本，需要理解接口（Interfaces）和泛型（Generics），类（class），枚举类型（Enums）\r\n- （2）短期增加开发成本，增加类型定义，但减少维护成本\r\n- （3）ts 集成到构建流程需要一定的工作量\r\n- （4）和有些库结合时不是很完美\r\n\r\n## TypeScript中的void和null与undefined两种类型的区别是什么？\r\n\r\nts中的null和undefined是其他类型的子类型，可以赋值给其他类型：\r\n\r\n``` ts\r\n// 方式1\r\nlet a: number = null;\r\n// 方式2\r\nlet a: number = undefind;\r\n// 方式3\r\nlet a: null;\r\nlet b: number = a;\r\n//方式4\r\nlet a: undefined;\r\nlet b: number = a;\r\n```\r\n\r\n但是void和其他类型是平等关系，不能直接赋值:\r\n\r\n``` ts\r\nlet a: void;\r\n// 错误\r\nlet b: number = a;\r\n```\r\n\r\n严格模式中\r\n\r\n严格模式通过tsconfig.json配置，配置如下：\r\n\r\n``` json\r\n{\r\n    \"compilerOptions\": { // 编译选项,可以被忽略，这时编译器会使用默认值\r\n        \"strictNullChecks\": true, // 在严格的null检查模式下，null和undefined值不包含在任何类型里，只允许赋值给void和本身对应的类型。\r\n    }\r\n}\r\n```\r\n\r\n严格模式下，undefined和null不能给其他类型赋值，只能给他们自己的类型赋值。\r\n``` ts\r\nlet a: null = null;\r\nlet b: undefined = undefined;\r\n```\r\n\r\n\r\n但是undefined可以给void赋值：\r\n\r\n``` ts\r\nlet c: void = undefined;\r\n```\r\n\r\n## TypeScript的类型推论\r\n\r\n### 类型推论\r\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\r\n\r\n### 什么是类型推论\r\n\r\n以下代码虽然没有指定类型，但是会在编译的时候报错：\r\n\r\n``` ts\r\nlet myFavoriteNumber = 'seven';\r\nmyFavoriteNumber = 7;\r\n\r\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\r\n```\r\n\r\n事实上，它等价于：\r\n\r\n``` ts\r\nlet myFavoriteNumber: string = 'seven';\r\nmyFavoriteNumber = 7;\r\n\r\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\r\n```\r\n\r\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\r\n\r\n**如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 `any` 类型而完全不被类型检查：**\r\n\r\n``` ts\r\nlet myFavoriteNumber;\r\nmyFavoriteNumber = 'seven';\r\nmyFavoriteNumber = 7;\r\n```\r\n\r\n## 在TypeScript中，readonly和const两个关键字有什么区别？\r\n\r\n### 相同点\r\n\r\nreadonly和const这二者都是常量，一旦初始化就不能在改变\r\n\r\n### 不同点\r\n\r\n1. const只能在声明时初始化，而readonly既可以在声明中初始化，又可以在构造函数中初始化；\r\n2. const隐含static，不可以再写static const；readonly则不默认static，如需要可以写static readonly；\r\n3. const是编译期静态解析的常量（因此其表达式必须在编译时就可以求值）；readonly则是运行期动态解析的常量；\r\n4. const既可用来修饰类中的成员，也可修饰函数体内的局部变量；readonly只可以用于修饰类中的成员。\r\n\r\n## 什么是泛型？\r\n\r\n泛型是程序设计语言中的一种风格或范式，相当于类型模板，允许在声明类、接口或函数等成员时忽略类型，而在未来使用时再指定类型，其主要目的是为它们提供有意义的约束，提升代码的可重用性。\r\n\r\n### 一、泛型参数\r\n\r\n当一个函数需要能处理多种类型的参数和返回值，并且还得约束它们之间的关系（例如类型要相同）时，就可以采用泛型的语法，如下所示。\r\n\r\n``` ts\r\nfunction send<T>(data: T): T {\r\n  return data;\r\n}\r\n```\r\n\r\n函数名称后面跟了，其中把T称为泛型参数或泛型变量，表示某种数据类型。注意，T只是个占位符，可以命名的更含语义，例如TKey、TValue等。在使用时，既可以指定类型，也可以利用类型推论自动确定类型，如下所示。\r\n\r\n``` ts\r\nsend<number>(10);        //指定类型\r\nsend(10);            　　//类型推论\r\n```\r\n\r\n当需要处理T类型的数组时，可以像下面这么写。\r\n\r\n``` ts\r\nfunction send<T>(data: T[]): T[] {\r\n  return data;\r\n}\r\n\r\nsend<number>([1, 2, 3]);\r\n```\r\n\r\n当指定一个泛型函数的类型时，需要包含泛型参数，如下所示，其中泛型参数和函数参数的名称都可与定义时的不同。\r\n\r\n``` ts\r\nlet func: (<U>(data: U) => U) = send;\r\n```\r\n\r\n泛型参数还支持传递多个，只需在声明时增加类型占位符即可。在下面的示例中，将T和U合并成了一个元组类型，还有许多其它用法，将在后面讲解。\r\n\r\n``` ts\r\nfunction send<T, U>(data: [T, U]): [T, U] {\r\n  return data;\r\n}\r\nsend<number, string>([1, \"a\"]);\r\n```\r\n\r\n### 二、泛型接口\r\n\r\n在接口中，可利用泛型来约束函数的结构，如下所示，接口中声明的调用签名包含泛型参数。\r\n\r\n``` ts\r\ninterface Func {\r\n  <T>(str: T): T;\r\n}\r\nfunction send<T>(str: T): T {\r\n  return str;\r\n}\r\nlet fn: Func = send;\r\n```\r\n\r\n泛型参数还可以作为接口的一个参数存在，即把用尖括号包裹的泛型参数移到接口名称之后，如下所示。\r\n\r\n``` ts\r\ninterface Func<T> {\r\n  (str: T): T;\r\n}\r\nfunction send<T>(str: T): T {\r\n  return str;\r\n}\r\nlet fn: Func<string> = send;\r\n```\r\n\r\n当把Func接口作为类型使用时，需要向其传入一个类型，例如上面赋值语句中的string。\r\n\r\n### 三、泛型类\r\n\r\n泛型类与泛型接口类似，也是在名称后添加泛型参数，如下所示，其中send属性中的“=>”符号不表示箭头函数，而是用来定义方法的返回值类型。\r\n\r\n``` ts\r\nclass Person<T> {\r\n  name: T;\r\n  send: (data: T) => T;\r\n}\r\n```\r\n\r\n在实例化泛型类时，需要为其指定一种类型，如下所示。\r\n\r\n``` ts\r\nlet person = new Person<string>();\r\nperson.send = function(data) {\r\n  return data;\r\n}\r\n```\r\n\r\n注意，类的静态部分不能使用泛型参数。\r\n\r\n### 四、泛型约束\r\n\r\n在使用泛型时，由于事先不清楚参数的数据类型，因此不能随意调用它的属性或方法，甚至无法对其使用运算符。在下面的示例中，访问了data的length属性，但由于编译器无法确定它的类型，因此就会报错。\r\n\r\n``` ts\r\nfunction send<T>(data: T): T {\r\n  console.log(data.length);\r\n  return data;\r\n}\r\n```\r\n\r\nTypeScript允许为泛型参数添加约束条件，从而就能调用相应的属性或方法了，如下所示，通过extends关键字约束T必须是string的子类型。\r\n\r\n``` ts\r\nfunction send<T extends string>(data: T): T {\r\n  console.log(data.length);\r\n  return data;\r\n}\r\n```\r\n\r\n在添加了这个约束之后，send()函数就无法接收数字类型的参数了，如下所示。\r\n\r\n``` ts\r\nsend(\"10\");        //正确\r\nsend(10);          //错误\r\n```\r\n\r\n#### 1）创建类的实例\r\n\r\n在使用泛型创建类的工厂函数时，需要声明T类型拥有构造函数，如下所示。\r\n\r\n``` ts\r\nclass Programmer {}\r\nfunction create<T>(ctor: {new(): T}): T {\r\n  return new ctor();\r\n}\r\ncreate(Programmer);\r\n```\r\n\r\n用“{new(): T}”替代原先的类型占位符，表示可以被new运算符实例化，并且得到的是T类型，另一种相同作用的写法如下所示。\r\n\r\n``` ts\r\nfunction create<T>(ctor: new()=>T): T {\r\n  return new ctor();\r\n}\r\n```\r\n\r\n#### 2）多个泛型参数\r\n\r\n在TypeScript中，多个泛型参数之间也可以相互约束，如下所示，创建了基类Person和派生类Programmer，并将create()函数中的T约束为U的子类型。\r\n\r\n``` ts\r\nclass Person { }\r\nclass Programmer extends Person { }\r\nfunction create<T extends U, U>(target: T, source: U): T {\r\n  return target;\r\n}\r\n```\r\n\r\n当传递给create()函数的参数不符合约束条件时，就会在编译阶段报错，如下所示。\r\n\r\n``` ts\r\ncreate(Programmer, Person);        //正确\r\ncreate(Programmer, 10);            //错误\r\n```\r\n\r\n## TypeScript 类型兼容性整理\r\n\r\n### 一、介绍\r\n\r\nTypeScript里的类型兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。\r\n\r\n它正好与名义(nominal)类型形成对比。\r\n\r\nTypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。因为JavaScript里广泛的使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述类型比名义类型系统更好。\r\n\r\n#### 1.基本规则，具有相同的属性\r\n\r\n``` ts\r\n// 基本规则是具有相同的属性\r\n// 类似继承，子类型中的属性在父类中都存在，反之则编译失败\r\n// 特别说明，TypeScript中类的属性默认值都为undefined\r\n// 属性为undefined的不会编译到js文件中去\r\ninterface Named {\r\n    name: string;\r\n}\r\nclass Person {\r\n    name: string;\r\n    age:number;\r\n}\r\nlet p: Named;\r\n//Person没有继承Named\r\n//同样编译通过，运行通过\r\np = new Person();\r\np.name = '张三丰';\r\nconsole.info(p);\r\n```\r\n\r\n### 二、函数兼容性\r\n\r\n#### 1. 形参\r\n\r\n``` ts\r\n// 函数兼容性比较\r\n// 形参需要包含关系\r\n// 形参1是形参2的子类型，参数名字可以不相同\r\nlet x = (a: number) => 0;\r\nlet y = (b: number, s: string) => 0;\r\nx = y; // 编译报错，x参数中没有s参数\r\ny = x;\r\n```\r\n\r\n#### 2. 返回类型\r\n\r\n``` ts\r\n// 返回类型，需要被包含关系\r\n// 返回类型1,是返回类型2的子类型\r\nlet x = () => ({name:'Alice'});\r\nlet y = () => ({name:'Alice',location:'Seattle'});\r\ny = x; // 编译报错，x中没有返回参数location\r\nx = y;\r\n```\r\n\r\n#### 3. 可选参数及剩余参数\r\n\r\n比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。\r\n\r\n当一个函数有剩余参数时，它被当做无限个可选参数。\r\n\r\n这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded。\r\n\r\n### 三、枚举\r\n\r\n枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。\r\n\r\n``` ts\r\n// 枚举\r\n// 枚举类型与数字类型兼容，并且数字黑星与枚举类型兼容。不同枚举类型之间是不兼容的.\r\nenum Status {\r\n  Ready,\r\n  Warting\r\n}\r\nenum Color {\r\n  Red,\r\n  Blue,\r\n  Green\r\n}\r\nconsole.log(Status.Ready == 0); // 输出true\r\nlet status = Status.Ready; // 输出0\r\nconsole.log(status);\r\nstatus = 2;\r\nconsole.log(status); // 输出2\r\n//status = Color.Blue; / /编译报错，不同枚举类型之间不兼容\r\n```\r\n\r\n### 四、类\r\n\r\n类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。\r\n\r\n``` ts\r\nclass Animal {\r\n  feet: number;\r\n  constructor(name: string, numFeet: number) { }\r\n}\r\n\r\nclass Size {\r\n  feet: number;\r\n  constructor(numFeet: number) { }\r\n}\r\n\r\nlet a: Animal;\r\nlet s: Size;\r\n\r\na = s;  // OK\r\ns = a;  // OK\r\n```\r\n\r\n私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。\r\n\r\n### 五、泛型\r\n\r\n因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。\r\n\r\n``` ts\r\ninterface Empty<T> {\r\n}\r\nlet x: Empty<number>;\r\nlet y: Empty<string>;\r\n\r\nx = y;  // okay, y matches structure of x\r\n```\r\n\r\n### 六、高级注册\r\n\r\n目前为止，我们使用了`兼容性`，它在语言规范里没有定义。 在TypeScript里，有两种类型的兼容性：子类型与赋值。 它们的不同点在于，赋值扩展了子类型兼容，允许给 **any** 赋值或从**any**取值和允许数字赋值给枚举类型或枚举类型赋值给数字。\r\n\r\n语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的甚至在 **implements** 和 **extends** 语句里。\r\n\r\n## 接口interface和类型别名type的用法区别\r\n\r\n### 定义对象类型\r\n\r\n接口interface和类型别名type用来定义对象类型时，都可以支持，而且泛型也可以使用。\r\n\r\n``` ts\r\ninterface IPerson<T> {\r\n  age: T;\r\n  name: string\r\n};\r\n\r\nconst hank1: IPerson<number> = {\r\n  age: 18,\r\n  name: 'hank',\r\n};\r\n\r\ntype TPerson<T> = {\r\n  age: T;\r\n  name: string\r\n};\r\n\r\nconst hank2: TPerson<number> = {\r\n  age: 18,\r\n  name: 'hank',\r\n};\r\n```\r\n\r\n### 定义简单(基本数据)类型\r\n\r\n类型别名type可以用来定义简单类型时，接口interface不支持定义简单类型\r\n\r\n``` ts\r\ntype Name = string | number;\r\n\r\nconst name = 'hank';\r\n```\r\n\r\n### 定义函数类型\r\n\r\n接口interface和类型别名type都支持用来定义函数类型，具体写法会存在区别，\r\n\r\n``` ts\r\ninterface ISetPerson {\r\n  (age: number, name: string) => void;\r\n}\r\n\r\nconst setPerson1: ISetPerson = (age: number, name: string): void => {};\r\n\r\ntype TSetPerson = (age: number, name: string) => void;\r\n\r\nconst setPerson2: TSetPerson = (age: number, name: string): void => {};\r\n```\r\n\r\n### 被类实现\r\n\r\n接口interface可以被类实现(implements)，类型别名无法被类实现\r\n\r\n``` ts\r\ninterface ISetPerson {\r\n  setPerson(age: number, name: string) => void;\r\n}\r\n\r\nclass Person implements ISetPerson {\r\n  setPerson(age: number, name: string): void => {\r\n\r\n  }\r\n}\r\n```\r\n\r\n### 自己能否继承(extends)\r\n\r\n接口interface能继承(extends)其他的的接口，但是类型别名无法继承(extends)其他的类型别名，但可以使用交叉类型代替extends来达到同样的效果\r\n\r\n``` ts\r\ninterface ICommon {\r\n  sex: string\r\n};\r\n\r\ninterface IPerson<T> extends ICommon {\r\n  age: T;\r\n  name: string\r\n};\r\n\r\nconst hank1: IPerson<number> = {\r\n  sex: 'Man',\r\n  age: 18,\r\n  name: 'hank',\r\n};\r\n\r\ntype TCommon = {\r\n  sex: string,\r\n};\r\n\r\ntype TPerson<T> = {\r\n  age: T;\r\n  name: string\r\n} & TCommon; // 交叉类型\r\n\r\nconst hank2: TPerson<number> = {\r\n  sex: 'Man',\r\n  age: 18,\r\n  name: 'hank',\r\n};\r\n```\r\n\r\n类型别名type可以使用联合类型、交叉类型还有元组等类型\r\n\r\n``` ts\r\n\r\ninterface ICommon {\r\n  sex: string\r\n};\r\n\r\ninterface IPerson<T> extends ICommon {\r\n  age: T;\r\n  name: string\r\n};\r\n\r\ntype TCommon = {\r\n  sex: string,\r\n};\r\n\r\ntype TPerson<T> = {\r\n  age: T;\r\n  name: string\r\n} & TCommon; // 交叉类型\r\n\r\n// 联合类型\r\ntype P1 = IPerson<number> | TPerson<number>;\r\n// 元组\r\ntype P2 = [IPerson<number>, TPerson<number>];\r\n```\r\n\r\n### 结合typeof使用\r\n\r\n类型别名type最大的特点是可以结合typeof使用\r\n\r\n``` ts\r\nclass Person {\r\n  setPerson(age: number, name: string) {\r\n\r\n  }\r\n}\r\n\r\ntype TPerson = typeof Person;\r\n\r\nconst CPerson: TPerson = class {\r\n  setPerson(age: number, name: string) {\r\n\r\n  }\r\n}\r\n```\r\n\r\n## TypeScript 中的 d.ts 文件有什么作用\r\n\r\nTypeScript 相比 JavaScript 增加了类型声明。这些类型声明帮助编译器识别类型，从而帮助开发者在编译阶段就能发现错误。\r\n\r\nd.ts类型定义文件，我感觉现在对我的用处就是编辑器的智能提示\r\n\r\n## TypeScript 命名空间和模块\r\n\r\n### 命名空间和模块\r\n\r\n关于术语的说明：值得注意的是，在TypeScript 1.5中，命名法已经改变。\r\n\r\n\"内部模块\"现在是\"命名空间\"。\r\n\r\n\"外部模块\"现在只是\"模块\"，以便与ECMAScript 2015的术语保持一致（即module X {相当于现在首选的namespace X {）。\r\n\r\n### 使用命名空间\r\n\r\n命名空间只是全局命名空间中的JavaScript对象。\r\n这使命名空间成为一个非常简单的构造。\r\n它们可以跨多个文件，并且可以使用--outFile连接。\r\n命名空间可以是在Web应用程序中构建代码的好方法，所有依赖项都包含在HTML页面中的\\<script>标记中。\r\n\r\n就像所有全局命名空间污染一样，很难识别组件依赖性，尤其是在大型应用程序中。\r\n\r\n### 使用模块\r\n\r\n就像命名空间一样，模块可以包含代码和声明。\r\n主要区别在于模块声明了它们的依赖关系。\r\n\r\n模块还依赖于模块加载器（例如CommonJs/Require.js）。\r\n对于小型JS应用程序而言，这可能不是最佳选择，但对于大型应用程序，成本具有长期模块化和可维护性优势。\r\n模块为捆绑提供了更好的代码重用，更强的隔离和更好的工具支持。\r\n\r\n值得注意的是，对于Node.js应用程序，模块是构造代码的默认方法和推荐方法。\r\n\r\n从ECMAScript 2015开始，模块是该语言的本机部分，并且应该受到所有兼容引擎实现的支持。\r\n因此，对于新项目，模块将是推荐的代码组织机制。\r\n\r\n### 命名空间和模块的缺陷\r\n\r\n下面我们将描述使用命名空间和模块时的各种常见缺陷，以及如何避免它们。\r\n\r\n``` ts\r\n/// <reference>-ing a module\r\n```\r\n\r\n一个常见的错误是尝试使用/// \\<reference ... />语法来引用模块文件，而不是使用import语句。\r\n为了理解这种区别，我们首先需要了解编译器如何根据导入的路径找到模块的类型信息（例如...在,import x from \"...\";const x = require(\"...\");等等。路径。\r\n\r\n编译器将尝试使用适当的路径查找.ts，.tsx和.d.ts。\r\n如果找不到特定文件，则编译器将查找环境模块声明。\r\n回想一下，这些需要在.d.ts文件中声明。\r\n\r\nmyModules.d.ts\r\n\r\n``` ts\r\n// In a .d.ts file or .ts file that is not a module:\r\ndeclare module \"SomeModule\" {\r\n  export function fn(): string;\r\n}\r\n```\r\n\r\nmyOtherModule.ts\r\n``` ts\r\n/// <reference path=\"myModules.d.ts\" />\r\nimport * as m from \"SomeModule\";\r\n```\r\n\r\n这里的引用标记允许我们找到包含环境模块声明的声明文件。\r\n这就是使用几个TypeScript示例使用的node.d.ts文件的方式。\r\n\r\n### 无需命名空间\r\n\r\n如果您要将程序从命名空间转换为模块，则可以很容易地得到如下所示的文件：\r\n\r\nshapes.ts\r\n\r\n``` ts\r\nexport namespace Shapes {\r\n  export class Triangle { /* ... */ }\r\n  export class Square { /* ... */ }\r\n}\r\n```\r\n\r\n这里的顶级模块Shapes无缘无故地包装了Triangle和Square。\r\n这对您的模块的消费者来说是令人困惑和恼人的：\r\n\r\nshapeConsumer.ts\r\n\r\n``` ts\r\nimport * as shapes from \"./shapes\";\r\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\r\n```\r\n\r\nTypeScript中模块的一个关键特性是两个不同的模块永远不会为同一范围提供名称。\r\n因为模块的使用者决定分配它的名称，所以不需要主动地将命名空间中的导出符号包装起来。\r\n\r\n为了重申您不应该尝试命名模块内容的原因，命名空间的一般概念是提供构造的逻辑分组并防止名称冲突。\r\n由于模块文件本身已经是逻辑分组，并且其顶级名称由导入它的代码定义，因此不必为导出的对象使用其他模块层。\r\n\r\n这是一个修改过的例子：\r\nshapes.ts\r\n\r\n``` ts\r\nexport class Triangle { /* ... */ }\r\nexport class Square { /* ... */ }\r\n```\r\n\r\nshapeConsumer.ts\r\n\r\n``` ts\r\nimport * as shapes from \"./shapes\";\r\nlet t = new shapes.Triangle();\r\n```\r\n\r\n### 模块的权衡\r\n\r\n正如JS文件和模块之间存在一对一的对应关系一样，TypeScript在模块源文件与其发出的JS文件之间具有一对一的对应关系。\r\n这样做的一个结果是，根据您定位的模块系统，无法连接多个模块源文件。\r\n例如，在定位commonjs或umd时不能使用outFile选项，但使用TypeScript 1.8及更高版本时，可以在定位amd或system时使用outFile。\r\n\r\n## TypeScript 装饰器\r\n\r\n1. 装饰器是一种特殊类型的声明，本质上就是一个方法，可以注入到类、方法、属性、参数上，扩展其功能；\r\n2. 常见的装饰器：类装饰器、属性装饰器、方法装饰器、参数装饰器...\r\n3. 装饰器在写法上有：普通装饰器(无法传参)、装饰器工厂(可传参)\r\n4. 装饰器已是ES7的标准特性之一，是过去几年JS最大的成就之一！\r\n5. 启用装饰器：\r\n\r\n  ``` json\r\n  \"compilerOptions\": {\r\n      \"experimentalDecorators\": true\r\n  }\r\n  ```\r\n\r\n### 类装饰器\r\n\r\n#### 类装饰器在类声明之前被声明，应用于类构造函数，可以监视、修改、替换类的定义，传入一个参数；\r\n\r\n``` ts\r\nfunction logClz(params: Function) {\r\n  console.log(params)  // class HttpClient\r\n}\r\n\r\n@logClz\r\nclass HttpClient {\r\n  constructor() {\r\n  }\r\n}\r\n\r\n// logClz() 接收的参数params就是被装饰的类HttpClient\r\n// 为HttpClient动态扩展属性属性和方法\r\n\r\nfunction logClz(params: Function) {\r\n  params.prototype.url = 'xxxx';\r\n  params.prototype.run = function() {\r\n    console.log('run...');\r\n  };\r\n}\r\nvar http: HttpClient = new HttpClient();\r\nhttp.run(); // run...\r\n```\r\n\r\n#### 装饰器工厂：闭包，返回的函数才是真正的装饰器。\r\n``` ts\r\nfunction logClz(params: string) {\r\n  console.log('params:', params);  //params: hello\r\n  return function(target: Function) {\r\n    console.log('target:', target);  //target: class HttpClient\r\n    target.prototype.url = params;  //扩展一个url属性\r\n  }\r\n}\r\n\r\n@logClz('hello')\r\nclass HttpClient {\r\n  constructor() {}\r\n}\r\nvar http: HttpClient = new HttpClient();\r\nconsole.log(http.url);  //hello\r\n```\r\n\r\n#### 重载构造函数\r\n\r\n1. 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数；\r\n2. 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明；\r\n\r\n``` ts\r\nfunction logClz(target:any) {\r\n  return class extends target {\r\n    url = 'change url'\r\n    getData() {\r\n      console.log('getData:', this.url);\r\n    }\r\n  }\r\n}\r\n@logClz\r\nclass HttpClient {\r\n  public url:string|undefined;\r\n  constructor() {\r\n    this.url = 'init url'\r\n  }\r\n  getData() {\r\n    console.log(this.url);\r\n  }\r\n}\r\nvar http: HttpClient = new HttpClient();  //装饰器返回的就是HttpClient的子类，因此TS可以自动推导 http 的类型\r\nhttp.getData(); //getData: change url\r\n```\r\n\r\n#### 修改类的定义\r\n\r\n``` ts\r\nfunction fn(v: number) {\r\n  return function<T extends {new(...args: any[]): {}}>(cst: T): T {\r\n    class Ps extends cst {\r\n      age: number = v;\r\n    }\r\n  }\r\n}\r\n@fn(10)\r\nclass Person {}  //age:number = 10\r\n@fn(20)\r\nclass Cat {}  //age:number = 20\r\nlet p: Person = new Person(); //装饰之后的Person已经变成了Ps\r\nconsole.log(p.age)  //10\r\n\r\nlet c: Cat = new Cat();\r\nconsole.log(c.age)  //20\r\n```\r\n\r\n`T extends {new(...args: any[]): {}}：{new(...args: any[]): {}}` 是对象字面量，等效于 `new(...args: any[]) => {}`，意思是一个能 new 的函数，返回值类型是 `{}`\r\n\r\n``` ts\r\nfunction identity<T>(arg: T): T {\r\n  return arg;\r\n}\r\nlet myIdentity: <U>(arg: U) => U = identity;\r\n// 等效:\r\nlet myIdentity: {<T>(arg: T): T} = identity;\r\n\r\n// 转换成接口:\r\ninterface GenericIdentityFn {\r\n  <T>(arg: T): T;\r\n}\r\nlet myIdentity: GenericIdentityFn = identity;\r\n```\r\n\r\n### 属性装饰器\r\n\r\n#### 属性装饰器表达式会在运行时当作函数被调用，传入两个参数：\r\n\r\n1. 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象；\r\n2. 成员的名字；\r\n\r\n``` ts\r\nfunction logProp(params: string) {\r\n  return function(target: any, key: string) {\r\n    console.log(target)  // { constructor:f, getData:f }\r\n    console.log(key)  // url\r\n    target[key] = params;  // 通过原型对象修改属性值 = 装饰器传入的参数\r\n    target.api = 'xxxxx';  // 扩展属性\r\n    target.run = function() {  // 扩展方法\r\n      console.log('run...');\r\n    }\r\n  }\r\n}\r\nclass HttpClient {\r\n  @logProp('http://baidu.com')\r\n  public url: any|undefined;\r\n  constructor() { }\r\n  getData() {\r\n    console.log(this.url);\r\n  }\r\n}\r\nvar http: HttpClient = new HttpClient();\r\nhttp.getData();  // http://baidu.com\r\nconsole.log(http.api);  // xxxxx\r\nhttp.run();  // run...\r\n```\r\n\r\n### 方法装饰器\r\n\r\n- 1. 方法装饰器被应用到方法的属性描述符上，可以用来监视、修改、替换方法的定义；\r\n- 2. 方法装饰器会在运行时传入3个参数：\r\n  - 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象；\r\n  - 成员的名字；\r\n  - 成员的属性描述符；\r\n\r\n``` ts\r\nfunction get(params: string) {\r\n  console.log(params) // 装饰器传入的参数：http://baidu.com\r\n  return function(target: any, key: string, descriptor: PropertyDescriptor) {\r\n    console.log(target)  // { constructor:f, getData:f }\r\n    console.log(key)  // getData\r\n    console.log(descriptor)  // {value: ƒ, writable: true, enumerable: false, configurable: true} value就是方法体\r\n    /* 修改被装饰的方法 */\r\n    //1. 保存原方法体\r\n    var oldMethod = descriptor.value;\r\n    //2. 重新定义方法体\r\n    descriptor.value = function(...args: any[]) {\r\n      //3. 把传入的数组元素都转为字符串\r\n      let newArgs = args.map((item)=>{\r\n        return String(item);\r\n      });\r\n      //4. 执行原来的方法体\r\n      oldMethod.apply(this, newArgs);\r\n      // 等效于 oldMethod.call(this, ...newArgs);\r\n    }\r\n  }\r\n}\r\nclass HttpClient {\r\n  constructor() { }\r\n  @get('http://baidu.com')\r\n  getData(...args: any[]) {\r\n    console.log('getData: ', args);\r\n  }\r\n}\r\nvar http = new HttpClient();\r\nhttp.getData(1, 2, true);  // getData: [\"1\", \"2\", \"true\"]\r\n```\r\n\r\n### 方法参数装饰器\r\n\r\n- 1. 参数装饰器表达式会在运行时被调用，可以为类的原型增加一些元素数据，传入3个参数：\r\n  - 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象；\r\n  - 方法名称，如果装饰的是构造函数的参数，则值为undefined\r\n  - 参数在函数参数列表中的索引；\r\n\r\n``` ts\r\nfunction logParams(params:any) {\r\n  console.log(params)  // 装饰器传入的参数：uuid\r\n  return function(target:any, methodName:any, paramIndex:any) {\r\n    console.log(target)  // { constructor:f, getData:f }\r\n    console.log(methodName)  // getData\r\n    console.log(paramIndex)  // 0\r\n  }\r\n}\r\nclass HttpClient {\r\n  constructor() { }\r\n  getData(@logParams('uuid') uuid:any) {\r\n    console.log(uuid);\r\n  }\r\n}\r\n```\r\n\r\n- 2. 注意：参数装饰器只能用来监视一个方法的参数是否被传入；\r\n- 3. 参数装饰器在Angular中被广泛使用,特别是结合reflect-metadata库来支持实验性的Metadata API；\r\n- 4. 参数装饰器的返回值会被忽略。\r\n\r\n### 装饰器的执行顺序\r\n\r\n- 装饰器组合：TS支持多个装饰器同时装饰到一个声明上，语法支持从左到右，或从上到下书写；\r\n``` ts\r\n@f @g x\r\n\r\n@f\r\n@g\r\nx\r\n```\r\n\r\n- 在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：\r\n  - 由上至下依次对装饰器表达式求值;\r\n  - 求值的结果会被当作函数，由下至上依次调用.\r\n\r\n- 不同装饰器的执行顺序：属性装饰器 > 方法装饰器 > 参数装饰器 > 类装饰器\r\n\r\n``` ts\r\nfunction logClz11(params:string) {\r\n  return function(target: any) {\r\n    console.log('logClz11')\r\n  }\r\n}\r\nfunction logClz22(params?:string) {\r\n  return function(target:any) {\r\n    console.log('logClz22')\r\n  }\r\n}\r\nfunction logAttr(params?:string) {\r\n  return function(target:any, attrName:any) {\r\n    console.log('logAttr')\r\n  }\r\n}\r\nfunction logMethod(params?:string) {\r\n  return function(target:any, methodName:any, desc:any) {\r\n    console.log('logMethod')\r\n  }\r\n}\r\nfunction logParam11(params?:any) {\r\n  return function(target:any, methodName:any, paramIndex:any) {\r\n    console.log('logParam11')\r\n  }\r\n}\r\nfunction logParam22(params?:any) {\r\n  return function(target:any, methodName:any, paramIndex:any) {\r\n    console.log('logParam22')\r\n  }\r\n}\r\n\r\n@logClz11('http://baidu.com')\r\n@logClz22()\r\nclass HttpClient {\r\n  @logAttr()\r\n  public url:string|undefined;\r\n\r\n  constructor() { }\r\n\r\n  @logMethod()\r\n  getData() {\r\n    console.log('get data');\r\n  }\r\n\r\n  setData(@logParam11() param1:any, @logParam22() param2:any) {\r\n    console.log('set data');\r\n  }\r\n}\r\n// logAttr --> logMethod --> logParam22 --> logParam11 --> logClz22 --> logClz11\r\n```\r\n\r\n## TS有什么优缺点？为什么要用TS？\r\n\r\n### TS 的优点：\r\n\r\n- 可以减少低级的语法错误。\r\n- 规范团队代码，对大型项目来说规范很重要。\r\n- 智能提示，定义类型能让编辑器更好的自动提示，提升编码效率。\r\n\r\n### TS 的缺点：\r\n\r\n- 学习成本高。\r\n- 开发成本高，又要做业务又要编写类型文件，有时候还得解决奇奇怪怪的报错。\r\n\r\n### 适用场景：\r\n\r\n- 大型项目和团队开发。\r\n- 库和框架开发。\r\n- 对于一些重要的逻辑或者代码，可以使用TS来增强其可靠性。\r\n\r\n## 什么是泛型,有什么作用？\r\n\r\nTS泛型简单来说就是类型参数，在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。\r\n\r\n举个简单的例子，我们定义一个数据响应体的接口：\r\n\r\n``` typescript\r\ninterface IResponseData<T>{\r\n    code: number;\r\n    message?: string;\r\n    data: T;\r\n}\r\n```\r\n\r\n其中data的类型并没有写死，而是可以在我们使用的时候传入：\r\n\r\n``` typescript\r\ninterface User {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\n// 使用时传入User类型\r\nconst response: IResponseData<User> = {\r\n  code: 200,\r\n  message: \"Success\",\r\n  data: {\r\n    id: 1,\r\n    name: \"xiaoming\",\r\n    email: \"xxx@qq.com\"\r\n  }\r\n};\r\n```\r\n\r\n## 类型别名type和接口interface有什么区别？\r\n\r\n1. 类型别名不能被继承或者实现，接口可以被继承或者实现。\r\n2. 类型别名可以定义任何类型，包括联合类型、交叉类型、字面量类型、原始类型等。接口只能定义对象类型，包括属性、方法、索引等。\r\n3. 类型别名通常用于为复杂类型创建别名，以方便在代码中使用。接口通常用于定义某个实体的结构，以及实现该结构的对象或类。\r\n\r\n总结一下，如果你需要定义一个对象类型，或者需要使用继承和实现的特性，那么应该使用接口；如果你需要定义任意类型的别名，或者需要定义联合类型和交叉类型等复杂类型，那么应该使用类型别名。\r\n\r\n## 什么是装饰器？\r\n\r\n装饰器的作用，简单来说就是代码复用，和Java里的注解以及Rust里的属性宏类似。\r\n\r\n把通用的代码封装成装饰器，然后在使用的时候就可以将`@xxx`添加在方法或者类上，方法和类就得到了加强，特别简洁优雅。\r\n\r\n例如mobx里的`@observable`以及NestJS里的`@Controller`。\r\n\r\n举个简单的自定义装饰器例子，我们来实现一个自动打印函数参数以及返回值的装饰器。\r\n\r\n首先来定义装饰器：\r\n\r\n``` Typescript\r\n// target表示装饰的目标对象\r\n// propertyKey表示装饰的属性或方法名\r\n// descriptor表示属性或方法的描述符\r\nfunction log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\r\n  const originalMethod = descriptor.value;\r\n\r\n  descriptor.value = function (...args: any[]) {\r\n    console.log(`调用 ${propertyKey}，参数为: ${JSON.stringify(args)}`);\r\n    const result = originalMethod.apply(this, args);\r\n    console.log(`方法 ${propertyKey} 返回值为: ${JSON.stringify(result)}`);\r\n    return result;\r\n  };\r\n\r\n  return descriptor;\r\n}\r\n```\r\n\r\n然后使用一下这个装饰器：\r\n\r\n``` typescript\r\nclass Test {\r\n  @log\r\n  add(a: number, b: number) {\r\n    return a + b;\r\n  }\r\n}\r\n\r\nconst test = new Test();\r\nconsole.log(test.add(2, 3)); // 会打印出参数2,3和返回值5\r\n```\r\n\r\n## 什么是类型体操，有哪些应用？\r\n\r\nTS类型体操指的是用各种技巧和骚操作来创建复杂类型。\r\n\r\n类型体操一般在业务项目里出现的少，在三方库里出现的多，比如Vue3源码里面就有很多复杂的类型体操运算。\r\n\r\n关于类型体操，褒贬不一，有人认为是秀操作，实际作用不大，也有人认为很高级。\r\n\r\n我个人是不太倾向在前端项目里执着于玩类型体操的，但是一些常见的TS技巧是需要学习的，比如类型别名、交叉类型和联合类型、条件类型、工具类型、泛型，在处理复杂类型运算的时候，就很有用。\r\n\r\n## any用的多吗，有什么弊端？\r\n\r\n使用any类型的主要目的是在不清楚变量类型的情况下避免编译错误，但是，频繁地使用any类型那就等于白白浪费了TS的类型检查能力。\r\n\r\n正确的做法是尽可能避免使用any类型，尽可能地使用明确的类型，这样可以提高代码的可读性和可维护性，并且可以减少潜在的运行时错误。\r\n\r\n但是有时候时间紧任务重又不得不用，所以一句话总结就是，尽量不用，不到万不得已不轻易用any。\r\n\r\n## 你知道哪些工具类型，怎么用？\r\n\r\n工具类型主要用于处理和转换已有类型，它们不是实际的类型，而是用来处理类型的工具。简单来说，工具类型可以认为是TS类型的工具函数，把原有类型当参数来处理。\r\n\r\n举一个简单的Partial工具类型应用的例子：\r\n\r\n``` typescript\r\n// 已有类型User\r\ninterface User {\r\n  name: string;\r\n  age: number;\r\n}\r\n\r\n// 新类型PartialUser，使用Partial将属性都变成可选\r\ntype PartialUser = Partial<User>; // { name?: string; age?: number; }\r\n```\r\n\r\n常用工具类型有：\r\n\r\n- **Partial<T>**：将类型 T 的所有属性变为可选属性。\r\n- **Required<T>**：将类型 T 的所有属性变为必选属性。\r\n- **Readonly<T>**：将类型 T 的所有属性变为只读属性。\r\n- **Record<K, T>**：创建一个类型，其中属性名为类型 K 中的值，属性值为类型 T 中的值。\r\n- **Pick<T, K>**：从类型 T 中选择属性名为类型 K 中的属性，创建一个新类型。\r\n- **Omit<T, K>**：从类型 T 中排除属性名为类型 K 中的属性，创建一个新类型。\r\n- **Exclude<T, U>**：从类型 T 中排除类型 U 中的所有属性。\r\n- **Extract<T, U>**：从类型 T 中提取类型 U 中存在的所有属性。\r\n- **NonNullable<T>**：从类型 T 中移除 null 和 undefined。\r\n- **ReturnType<T>**：获取函数类型 T 的返回值类型。\r\n\r\n## TS里怎么处理第三方库类型，怎么给第三方库编写类型文件？\r\n\r\nTS社区维护了一个名为DefinitelyTyped的项目，提供了大量的第三方库的类型定义文件，大多数三方库类型文件都可以直接在这里面下载。\r\n\r\n但是如果第三方库没有提供类型定义文件时，我们可以通过手动编写类型文件的方式，为第三方库添加类型支持。\r\n\r\n给三方库编写类型的文件步骤如下：\r\n\r\n1. 创建d.ts文件：在项目中创建一个新的d.ts文件，文件名可以与库名相同，例如`lodash.d.ts`。\r\n\r\n2. 定义模块：使用`declare module`语句定义模块名，模块名应与库的导出模块名一致。例如，对于lodash库，可以这样定义模块：\r\n\r\n``` Typescript\r\ndeclare module 'lodash' {\r\n  // 在此处添加类型定义\r\n}\r\n```\r\n\r\n3. 添加类型定义：在模块内部添加对应的类型定义，例如函数、变量、类等。根据需要，可以使用 interface、type、class 等关键字定义不同类型的接口。\r\n\r\n4. 导出类型：使用 export 关键字导出需要公开的类型。例如，对于以下的 utils 函数，可以这样定义：\r\n\r\n``` typescript\r\ndeclare module 'lodash' {\r\n  function utils(...args: any[]): any;\r\n  export { utils };\r\n}\r\n```\r\n\r\n5. 使用类型文件：在需要使用第三方库的地方，通过import语句引入类型定义即可：\r\n\r\n``` typescript\r\nimport { utils } from 'lodash';\r\n```\r\n\r\n## React项目怎么使用TS？Vue项目怎么使用TS？\r\n\r\n### React：\r\nReact脚手架自带TS模板，新建项目的时候，带上参数即可。\r\n\r\nReact项目里需要考虑类型的地方主要有：\r\n\r\n- 定义props和state的类型。\r\n- 事件处理函数中事件对象的类型，尽量不要用any。\r\n- 对三方库的封装要考虑类型。\r\n- 对于Hooks的参数和返回值的约束类型。\r\n- 数据接口需要定义类型。\r\n\r\n### Vue：\r\n\r\n- Vue2项目可以通过添加 class-component 和 vue-property-decorator 库来使用TS。\r\n\r\n- Vue3对TS支持更好，可以通过vue-cli或者vite来直接启动TS模板的脚手架。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/612/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/612/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 说说TS和ES的区别，以及TS带来的好处？","## TypeScript 简介及优缺点","### 优点","### 缺点","## TypeScript中的void和null与undefined两种类型的区别是什么？","## TypeScript的类型推论","### 类型推论","### 什么是类型推论","## 在TypeScript中，readonly和const两个关键字有什么区别？","### 相同点","### 不同点","## 什么是泛型？","### 一、泛型参数","### 二、泛型接口","### 三、泛型类","### 四、泛型约束","#### 1）创建类的实例","#### 2）多个泛型参数","## TypeScript 类型兼容性整理","### 一、介绍","#### 1.基本规则，具有相同的属性","### 二、函数兼容性","#### 1. 形参","#### 2. 返回类型","#### 3. 可选参数及剩余参数","### 三、枚举","### 四、类","### 五、泛型","### 六、高级注册","## 接口interface和类型别名type的用法区别","### 定义对象类型","### 定义简单(基本数据)类型","### 定义函数类型","### 被类实现","### 自己能否继承(extends)","### 结合typeof使用","## TypeScript 中的 d.ts 文件有什么作用","## TypeScript 命名空间和模块","### 命名空间和模块","### 使用命名空间","### 使用模块","### 命名空间和模块的缺陷","### 无需命名空间","### 模块的权衡","## TypeScript 装饰器","### 类装饰器","#### 类装饰器在类声明之前被声明，应用于类构造函数，可以监视、修改、替换类的定义，传入一个参数；","#### 装饰器工厂：闭包，返回的函数才是真正的装饰器。","#### 重载构造函数","#### 修改类的定义","### 属性装饰器","#### 属性装饰器表达式会在运行时当作函数被调用，传入两个参数：","### 方法装饰器","### 方法参数装饰器","### 装饰器的执行顺序","## TS有什么优缺点？为什么要用TS？","### TS 的优点：","### TS 的缺点：","### 适用场景：","## 什么是泛型,有什么作用？","## 类型别名type和接口interface有什么区别？","## 什么是装饰器？","## 什么是类型体操，有哪些应用？","## any用的多吗，有什么弊端？","## 你知道哪些工具类型，怎么用？","## TS里怎么处理第三方库类型，怎么给第三方库编写类型文件？","## React项目怎么使用TS？Vue项目怎么使用TS？","### React：","### Vue："]},"__N_SSG":true}