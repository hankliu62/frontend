{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/658","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/658/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/658/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/658/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/658","id":2241437443,"node_id":"I_kwDOBiJZIc6FmZ8D","number":658,"title":"使用 AbortController 实现异步操作控制","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536875857,"node_id":"LA_kwDOBiJZIc8AAAABhaDPUQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/html","name":"html","color":"13c2c2","default":false,"description":"分类-HTML相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-04-13T08:45:08Z","updated_at":"2024-04-14T06:10:57Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 使用 AbortController 实现异步操作控制\n\n### 背景\n\n在 `JavaScript` 中，我们经常需要执行一些异步操作，例如发起网络请求、执行定时任务等。然而，有时候我们希望能够在某些条件下中止这些异步操作，以节省资源或提高用户体验。这时候，`AbortController` 就派上了用场。\n\n`AbortController` 是一个可以用来控制异步操作的对象，它可以与 `Promise`、`Fetch API` 等配合使用，实现在异步操作进行中中止操作的功能。本文将介绍 `AbortController` 的基本用法，并提供详细的示例来说明其在实际场景中的应用。\n\n### 基本用法\n`AbortController` 提供了两个主要的方法：`abort()` 和 `signal` 属性。\n\n- **abort()**: 调用该方法可以中止与 `AbortController` 相关联的异步操作。\n- **signal**: 这是一个只读属性，它返回一个 `AbortSignal` 对象，用于监听异步操作的中止状态。\n下面是一个基本的示例：\n\n``` javascript\n\nconst controller = new AbortController();\nconst signal = controller.signal;\n\n// 监听中止信号\nsignal.addEventListener('abort', () => {\n  console.log('Operation aborted');\n});\n\n// 5秒后中止操作\nsetTimeout(() => {\n  controller.abort();\n}, 5000);\n```\n\n在这个示例中，我们创建了一个 `AbortController` 对象 `controller`，并从中获取了 `signal` 属性。然后，我们通过 `setTimeout()` 函数设定了一个 `5` 秒后的定时任务，当定时任务执行时，调用了 `controller.abort()` 方法来中止操作。同时，我们通过 `signal.addEventListener()` 方法监听了中止信号，并在中止时输出了一条日志。\n\n### 结合 Fetch API\n\n`AbortController` 最常见的用法之一是与 `Fetch API` 结合使用，实现中止网络请求的功能。下面是一个示例：\n\n``` javascript\n\nconst controller = new AbortController();\nconst signal = controller.signal;\n\nfetch('https://api.example.com/data', { signal })\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => {\n    if (error.name === 'AbortError') {\n      console.log('Request aborted');\n    } else {\n      console.error('Error:', error);\n    }\n  });\n\n// 10秒后中止请求\nsetTimeout(() => {\n  controller.abort();\n}, 10000);\n```\n\n在这个示例中，我们创建了一个 `AbortController` 对象 `controller`，并将其与 `Fetch API` 中的 `signal` 属性关联起来。然后，我们发起了一个网络请求，当请求完成时输出了返回的数据，如果请求被中止，则捕获到 `AbortError` 并输出一条相应的日志。最后，我们设置了一个 10 秒后的定时任务，当定时任务执行时，调用了 `controller.abort()` 方法来中止网络请求。\n\n### 结合 Promise\n\n除了与 `Fetch API` 结合使用外，`AbortController` 还可以与 `Promise` 结合使用，实现中止 `Promise` 执行的功能。下面是一个示例：\n\n``` javascript\n\nfunction fetchData(signal) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (signal.aborted) {\n        reject(new DOMException('AbortError', 'AbortError'));\n      } else {\n        resolve('Data fetched successfully');\n      }\n    }, 3000);\n  });\n}\n\nconst controller = new AbortController();\nconst signal = controller.signal;\n\nfetchData(signal)\n  .then(data => console.log(data))\n  .catch(error => {\n    if (error.name === 'AbortError') {\n      console.log('Operation aborted');\n    } else {\n      console.error('Error:', error);\n    }\n  });\n\n// 5秒后中止操作\nsetTimeout(() => {\n  controller.abort();\n}, 5000);\n```\n\n在这个示例中，我们定义了一个 `fetchData()` 函数，该函数返回一个 `Promise` 对象，在一定时间后返回数据或者中止操作。然后，我们创建了一个 `AbortController` 对象 `controller`，并将其与 `Promise` 关联起来。最后，我们设置了一个 `5` 秒后的定时任务，当定时任务执行时，调用了 `controller.abort()` 方法来中止 `Promise` 执行。\n\n### Axios 请求通过 CancelToken 来取消请求\n\n`Axios` 自带有取消请求的借口，在 `Axios` 中通过 `CancelToken` 取消请求发送。下面是一个示例：\n\n``` javascript\n/ 引入 Axios 库\nconst axios = require('axios');\n\n// 创建一个 CancelToken.source 对象\nconst { CancelToken, axiosInstance } = axios;\nconst source = CancelToken.source();\n\n// 创建一个 Axios 请求\nconst request = axiosInstance.get('https://api.example.com/data', {\n  cancelToken: source.token // 传递 CancelToken 对象到请求配置中\n});\n\n// 设置一个定时器，在 3 秒后取消请求\nsetTimeout(() => {\n  source.cancel('Request canceled due to timeout');\n}, 3000);\n\n// 发起请求并处理响应\nrequest.then(response => {\n  console.log('Response:', response.data);\n}).catch(error => {\n  if (axios.isCancel(error)) {\n    console.log('Request canceled:', error.message);\n  } else {\n    console.error('Error:', error);\n  }\n});\n```\n\n在这个示例中，我们首先引入 `Axios` 库，并创建了一个 `CancelToken.source` 对象 `source`。然后，我们发起一个 `GET` 请求，并在请求配置中传递了 `cancelToken: source.token`，以便 `Axios` 知道我们要使用哪个 `CancelToken` 来取消请求。\n\n接着，我们设置了一个定时器，在 `3` 秒后调用 `source.cancel()` 方法取消请求，并传递了一个取消原因。最后，我们发起请求，并在 `.then()` 和 `.catch()` 方法中分别处理响应和错误。如果请求被取消，我们通过 `axios.isCancel(error)` 来检查错误类型，并输出相应的日志。\n\n### XMLHttpRequest 通过 abort 来取消请求\n\n在现代浏览器环境中，我们可以使用 `XMLHttpRequest（XHR）` 对象来发起网络请求，`XHR` 里面存在 `abort` 能用来取消这些请求。以下是一个使用XHR取消请求的示例：\n\n``` javascript\n// 创建一个XHR对象\nconst xhr = new XMLHttpRequest();\n\n// 监听请求状态变化\nxhr.onreadystatechange = function() {\n  // 请求完成并且响应状态为200时，处理响应\n  if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n    console.log('Response:', xhr.responseText);\n  }\n};\n\n// 准备发送请求，但不发送\nxhr.open('GET', 'https://api.example.com/data');\n\n// 发送请求\nxhr.send();\n\n// 设置一个定时器，在3秒后取消请求\nsetTimeout(() => {\n  xhr.abort();\n  console.log('Request canceled');\n}, 3000);\n```\n\n在这个示例中，我们首先创建了一个 `XMLHttpRequest` 对象 `xhr`，并设置了它的 `onreadystatechange` 事件处理程序来监听请求状态变化。然后，我们调用 `xhr.open()` 方法来准备发送一个 `GET` 请求到指定的 `URL`，但并不发送请求。接着，我们调用 `xhr.send()` 方法来实际发送请求。\n\n同时，我们设置了一个定时器，在3秒后调用 `xhr.abort()` 方法来取消请求。当调用 `xhr.abort()` 方法时，`XHR` 对象将会立即终止当前的网络请求。\n\n最后，当请求完成并且响应状态为 `200` 时，我们通过 `xhr.responseText` 属性获取响应数据，并输出到控制台。\n\n### 结论\n\n`AbortController` 是一个非常有用的工具，它为我们提供了在异步操作进行中中止操作的能力。通过结合 `Fetch API`、`Promise` 等，我们可以在网络请求、定时任务等场景中灵活地使用 `AbortController`，从而提高代码的可控性和可靠性。希望本文的介绍能够帮助你更好地理解和应用 `AbortController`。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/658/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/658/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 使用 AbortController 实现异步操作控制\n\n### 背景\n\n在 `JavaScript` 中，我们经常需要执行一些异步操作，例如发起网络请求、执行定时任务等。然而，有时候我们希望能够在某些条件下中止这些异步操作，以节省资源或提高用户体验。这时候，`AbortController` 就派上了用场。\n\n`AbortController` 是一个可以用来控制异步操作的对象，它可以与 `Promise`、`Fetch API` 等配合使用，实现在异步操作进行中中止操作的功能。本文将介绍 `AbortController` 的基本用法，并提供详细的示例来说明其在实际场景中的应用。\n\n### 基本用法\n`AbortController` 提供了两个主要的方法：`abort()` 和 `signal` 属性。\n\n- **abort()**: 调用该方法可以中止与 `AbortController` 相关联的异步操作。\n- **signal**: 这是一个只读属性，它返回一个 `AbortSignal` 对象，用于监听异步操作的中止状态。\n下面是一个基本的示例：\n\n``` javascript\n\nconst controller = new AbortController();\nconst signal = controller.signal;\n\n// 监听中止信号\nsignal.addEventListener('abort', () => {\n  console.log('Operation aborted');\n});\n\n// 5秒后中止操作\nsetTimeout(() => {\n  controller.abort();\n}, 5000);\n```\n\n在这个示例中，我们创建了一个 `AbortController` 对象 `controller`，并从中获取了 `signal` 属性。然后，我们通过 `setTimeout()` 函数设定了一个 `5` 秒后的定时任务，当定时任务执行时，调用了 `controller.abort()` 方法来中止操作。同时，我们通过 `signal.addEventListener()` 方法监听了中止信号，并在中止时输出了一条日志。\n\n### 结合 Fetch API\n\n`AbortController` 最常见的用法之一是与 `Fetch API` 结合使用，实现中止网络请求的功能。下面是一个示例：\n\n``` javascript\n\nconst controller = new AbortController();\nconst signal = controller.signal;\n\nfetch('https://api.example.com/data', { signal })\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => {\n    if (error.name === 'AbortError') {\n      console.log('Request aborted');\n    } else {\n      console.error('Error:', error);\n    }\n  });\n\n// 10秒后中止请求\nsetTimeout(() => {\n  controller.abort();\n}, 10000);\n```\n\n在这个示例中，我们创建了一个 `AbortController` 对象 `controller`，并将其与 `Fetch API` 中的 `signal` 属性关联起来。然后，我们发起了一个网络请求，当请求完成时输出了返回的数据，如果请求被中止，则捕获到 `AbortError` 并输出一条相应的日志。最后，我们设置了一个 10 秒后的定时任务，当定时任务执行时，调用了 `controller.abort()` 方法来中止网络请求。\n\n### 结合 Promise\n\n除了与 `Fetch API` 结合使用外，`AbortController` 还可以与 `Promise` 结合使用，实现中止 `Promise` 执行的功能。下面是一个示例：\n\n``` javascript\n\nfunction fetchData(signal) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (signal.aborted) {\n        reject(new DOMException('AbortError', 'AbortError'));\n      } else {\n        resolve('Data fetched successfully');\n      }\n    }, 3000);\n  });\n}\n\nconst controller = new AbortController();\nconst signal = controller.signal;\n\nfetchData(signal)\n  .then(data => console.log(data))\n  .catch(error => {\n    if (error.name === 'AbortError') {\n      console.log('Operation aborted');\n    } else {\n      console.error('Error:', error);\n    }\n  });\n\n// 5秒后中止操作\nsetTimeout(() => {\n  controller.abort();\n}, 5000);\n```\n\n在这个示例中，我们定义了一个 `fetchData()` 函数，该函数返回一个 `Promise` 对象，在一定时间后返回数据或者中止操作。然后，我们创建了一个 `AbortController` 对象 `controller`，并将其与 `Promise` 关联起来。最后，我们设置了一个 `5` 秒后的定时任务，当定时任务执行时，调用了 `controller.abort()` 方法来中止 `Promise` 执行。\n\n### Axios 请求通过 CancelToken 来取消请求\n\n`Axios` 自带有取消请求的借口，在 `Axios` 中通过 `CancelToken` 取消请求发送。下面是一个示例：\n\n``` javascript\n/ 引入 Axios 库\nconst axios = require('axios');\n\n// 创建一个 CancelToken.source 对象\nconst { CancelToken, axiosInstance } = axios;\nconst source = CancelToken.source();\n\n// 创建一个 Axios 请求\nconst request = axiosInstance.get('https://api.example.com/data', {\n  cancelToken: source.token // 传递 CancelToken 对象到请求配置中\n});\n\n// 设置一个定时器，在 3 秒后取消请求\nsetTimeout(() => {\n  source.cancel('Request canceled due to timeout');\n}, 3000);\n\n// 发起请求并处理响应\nrequest.then(response => {\n  console.log('Response:', response.data);\n}).catch(error => {\n  if (axios.isCancel(error)) {\n    console.log('Request canceled:', error.message);\n  } else {\n    console.error('Error:', error);\n  }\n});\n```\n\n在这个示例中，我们首先引入 `Axios` 库，并创建了一个 `CancelToken.source` 对象 `source`。然后，我们发起一个 `GET` 请求，并在请求配置中传递了 `cancelToken: source.token`，以便 `Axios` 知道我们要使用哪个 `CancelToken` 来取消请求。\n\n接着，我们设置了一个定时器，在 `3` 秒后调用 `source.cancel()` 方法取消请求，并传递了一个取消原因。最后，我们发起请求，并在 `.then()` 和 `.catch()` 方法中分别处理响应和错误。如果请求被取消，我们通过 `axios.isCancel(error)` 来检查错误类型，并输出相应的日志。\n\n### XMLHttpRequest 通过 abort 来取消请求\n\n在现代浏览器环境中，我们可以使用 `XMLHttpRequest（XHR）` 对象来发起网络请求，`XHR` 里面存在 `abort` 能用来取消这些请求。以下是一个使用XHR取消请求的示例：\n\n``` javascript\n// 创建一个XHR对象\nconst xhr = new XMLHttpRequest();\n\n// 监听请求状态变化\nxhr.onreadystatechange = function() {\n  // 请求完成并且响应状态为200时，处理响应\n  if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n    console.log('Response:', xhr.responseText);\n  }\n};\n\n// 准备发送请求，但不发送\nxhr.open('GET', 'https://api.example.com/data');\n\n// 发送请求\nxhr.send();\n\n// 设置一个定时器，在3秒后取消请求\nsetTimeout(() => {\n  xhr.abort();\n  console.log('Request canceled');\n}, 3000);\n```\n\n在这个示例中，我们首先创建了一个 `XMLHttpRequest` 对象 `xhr`，并设置了它的 `onreadystatechange` 事件处理程序来监听请求状态变化。然后，我们调用 `xhr.open()` 方法来准备发送一个 `GET` 请求到指定的 `URL`，但并不发送请求。接着，我们调用 `xhr.send()` 方法来实际发送请求。\n\n同时，我们设置了一个定时器，在3秒后调用 `xhr.abort()` 方法来取消请求。当调用 `xhr.abort()` 方法时，`XHR` 对象将会立即终止当前的网络请求。\n\n最后，当请求完成并且响应状态为 `200` 时，我们通过 `xhr.responseText` 属性获取响应数据，并输出到控制台。\n\n### 结论\n\n`AbortController` 是一个非常有用的工具，它为我们提供了在异步操作进行中中止操作的能力。通过结合 `Fetch API`、`Promise` 等，我们可以在网络请求、定时任务等场景中灵活地使用 `AbortController`，从而提高代码的可控性和可靠性。希望本文的介绍能够帮助你更好地理解和应用 `AbortController`。"]},"__N_SSG":true}