{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/608","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/608/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/608/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/608/events","html_url":"https://github.com/hankliu62/interview/issues/608","id":2251993851,"node_id":"I_kwDOLNphd86GOrL7","number":608,"title":"虚拟列表实现思路","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468110,"node_id":"LA_kwDOLNphd88AAAABhkJvTg","url":"https://api.github.com/repos/hankliu62/interview/labels/javascript","name":"javascript","color":"383040","default":false,"description":"Javascript相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":{"url":"https://api.github.com/repos/hankliu62/interview/milestones/5","html_url":"https://github.com/hankliu62/interview/milestone/5","labels_url":"https://api.github.com/repos/hankliu62/interview/milestones/5/labels","id":10707688,"node_id":"MI_kwDOLNphd84Ao2Lo","number":5,"title":"5","description":"描述问题难度，难度5🌟","creator":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"open_issues":5,"closed_issues":0,"state":"open","created_at":"2024-03-20T03:36:41Z","updated_at":"2024-04-26T03:44:40Z","due_on":null,"closed_at":null},"comments":0,"created_at":"2024-04-19T03:16:27Z","updated_at":"2024-04-19T03:27:05Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"实现虚拟列表（Virtual List）的关键在于只渲染当前视窗内可见的部分，而不是渲染整个列表。\r\n\r\n### 固定高度虚拟列表实现思路：\r\n\r\n#### 确定列表项高度\r\n\r\n在组件中确定每个列表项的固定高度。假设我们的列表项高度是 50px。\r\n\r\n``` jsx\r\n// ListItem.js\r\nimport React from 'react';\r\n\r\nconst ListItem = ({ text }) => {\r\n  return (\r\n    <div className=\"list-item\">\r\n      {text}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ListItem;\r\n```\r\n\r\n#### 计算可见区域\r\n\r\n根据列表容器的高度和列表项的固定高度，我们可以计算出当前视窗内能容纳多少个列表项。\r\n\r\n``` jsx\r\n// VirtualList.js\r\nimport React, { useRef, useState, useEffect } from 'react';\r\nimport ListItem from './ListItem';\r\n\r\nconst VirtualList = ({ data }) => {\r\n  const listContainerRef = useRef(null);\r\n  const [visibleItems, setVisibleItems] = useState([]);\r\n  const listItemHeight = 50; // 列表项固定高度\r\n\r\n  useEffect(() => {\r\n    const listContainer = listContainerRef.current;\r\n    const updateVisibleItems = () => {\r\n      const scrollTop = listContainer.scrollTop;\r\n      const startIdx = Math.floor(scrollTop / listItemHeight);\r\n      const endIdx = Math.min(startIdx + Math.ceil(listContainer.clientHeight / listItemHeight), data.length);\r\n      setVisibleItems(data.slice(startIdx, endIdx));\r\n    };\r\n\r\n    listContainer.addEventListener('scroll', updateVisibleItems);\r\n    updateVisibleItems(); // 初始渲染可见列表项\r\n\r\n    return () => {\r\n      listContainer.removeEventListener('scroll', updateVisibleItems);\r\n    };\r\n  }, [data, listItemHeight]);\r\n\r\n  return (\r\n    <div className=\"list-container\" ref={listContainerRef}>\r\n      {visibleItems.map(item => (\r\n        <ListItem key={item.id} text={item.text} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default VirtualList;\r\n```\r\n\r\n#### 只渲染可见列表项\r\n根据计算得到的可见区域列表项范围，我们只渲染这部分列表项。\r\n\r\n#### 优化滚动性能\r\n为了提高性能，我们使用 useEffect 钩子监听滚动事件，并使用节流或者防抖来优化滚动事件的处理。\r\n\r\n``` jsx\r\n// 在 VirtualList 组件中的 useEffect 钩子中使用 lodash 的 throttle 进行优化\r\nimport _ from 'lodash';\r\n\r\nuseEffect(() => {\r\n  const listContainer = listContainerRef.current;\r\n  const updateVisibleItems = _.throttle(() => {\r\n    const scrollTop = listContainer.scrollTop;\r\n    const startIdx = Math.floor(scrollTop / listItemHeight);\r\n    const endIdx = Math.min(startIdx + Math.ceil(listContainer.clientHeight / listItemHeight), data.length);\r\n    setVisibleItems(data.slice(startIdx, endIdx));\r\n  }, 100); // 在滚动结束后 100ms 内只触发一次渲染函数\r\n\r\n  listContainer.addEventListener('scroll', updateVisibleItems);\r\n  updateVisibleItems(); // 初始渲染可见列表项\r\n\r\n  return () => {\r\n    listContainer.removeEventListener('scroll', updateVisibleItems);\r\n  };\r\n}, [data, listItemHeight]);\r\n```\r\n\r\n#### 处理异步数据加载\r\n如果列表数据是异步加载的，需要在数据加载完成后重新渲染可见的列表项。\r\n\r\n``` jsx\r\n// 模拟异步加载数据的情况\r\nimport { useState, useEffect } from 'react';\r\n\r\nconst VirtualList = () => {\r\n  const [data, setData] = useState([]);\r\n\r\n  useEffect(() => {\r\n    // 模拟异步加载数据\r\n    fetch('https://example.com/api/data')\r\n      .then(response => response.json())\r\n      .then(data => {\r\n        setData(data); // 更新列表数据\r\n      })\r\n      .catch(error => console.error('Error fetching data:', error));\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"container\">\r\n      {data.length > 0 && <VirtualList data={data} />}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n### 非固定高度虚拟列表实现思路：\r\n\r\n在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的就能获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本、图片之类的可变内容，会导致列表项的高度并不相同。\r\n\r\n我们在列表渲染之前，确实没有办法知道每一项的高度，但是又必须要渲染出来，那怎么办呢？\r\n\r\n这里有一个解决方法，就是先给没有渲染出来的列表项设置一个预估高度，等到这些数据渲染成真实dom元素了之后，再获取到他们的真实高度去更新原来设置的预估高度，下面我们来看看跟定高列表有什么不同，具体要怎么实现吧！\r\n\r\n#### 初始化数据，设置预估高度\r\n\r\n首先，基于估计的高度，计算整个列表每一个元素的`height`，`top`，`bottom`等信息，并且计算整个列表的高度。\r\n\r\n预估高度的设置其实是有技巧的，列表项预估高度设置的越大，展现出来的数据就会越少，所以当预估高度比实际高度大很多的时候，很容易出现可视区域数据量太少而引起的可视区域出现部分空白。为了避免这种情况，我们的预估高度应该设置为列表项产生的最小值，这样尽管可能会多渲染出几条数据，但能保证首次呈现给用户的画面中没有空白。\r\n\r\n``` jsx\r\n// 请求更多的数据\r\nuseEffect(() => {\r\n  (async () => {\r\n    // 只有当前不在请求状态的时候才可以发送新的请求\r\n    if (!isRequestRef.current) {\r\n      console.log('发送请求了');\r\n      try {\r\n        isRequestRef.current = true\r\n        const { offset } = options\r\n        let limit = 20\r\n        if (offset === 1) limit = 40\r\n        const { data: { comments, more } } = await axios({\r\n          url: `http://localhost:3000/comment/music?id=${186015 - offset}&limit=${limit}&offset=1`\r\n        })\r\n        isNeedLoad.current = more\r\n        // 获取缓存中最后一个数据的索引值，如果没有，则返回-1\r\n        const lastIndex = dataListRef.current.length ? dataListRef.current[dataListRef.current.length - 1].index : -1\r\n        // 先将请求到的数据添加到缓存数组中去\r\n        dataListRef.current = [...dataListRef.current, ...comments]\r\n        const dataList = dataListRef.current\r\n        // 将刚刚请求到的新数据做一下处理，为他们添加上对应的索引值、预估高度、以及元素首尾距离容器顶部的距离\r\n        for (let i = lastIndex + 1, len = dataListRef.current.length; i < len; i++) {\r\n          dataList[i].index = i\r\n          // 预估高度是列表项对应的最小高度\r\n          dataList[i].height = 63\r\n          // 每一个列表项头部距离容器顶部的距离等于上一个元素尾部距离容器顶部的距离\r\n          dataList[i].top = dataList[i - 1]?.bottom || 0\r\n          // 每一个列表项尾部距离容器顶部的距离等于上一个元素头部距离容器顶部的距离加上自身列表项的高度\r\n          dataList[i].bottom = dataList[i].top + dataList[i].height\r\n        }\r\n        isRequestRef.current = false\r\n        boxScroll()\r\n      } catch (err) {\r\n        console.log(err);\r\n      } finally {\r\n        isRequestRef.current = false\r\n      }\r\n    }\r\n  })()\r\n}, [options])\r\n// 根据初始数据，算出默认的高度，以及默认的间隔\r\n```\r\n\r\n#### 根据列表数据项渲染完后更新后面的数据\r\n\r\n只要我们重新渲染一次列表组件，就会重新计算一下当前列表每一项中的真实高度并更新到缓存中去，当下次我们再用到缓存中的这些数据时，使用的就是真实高度，同时的话需要更新当前列表中之后的列表数据预估的`top`，`bottom`等信息。\r\n\r\n``` js\r\n// 每次组件重新渲染即用户滚动更改了数据之后需要将列表中我们还不知道的列表项高度更新到我们的缓存数据中去，以便下一次更新的时候能够正常渲染。\r\n\r\n\r\nuseEffect(() => { \r\n  const doms = containerRef.current.children[0].children\r\n  const len = doms.length\r\n  // 因为一开始我们没有请求数据，所以即使组件渲染完了，但是没有列表项，此时不需要执行后续操作\r\n  if (len) {\r\n    // 遍历所有的列表结点，根据结点的真实高度去更改缓存中的高度\r\n    for (let i = 0; i < len; i++) {\r\n      const realHeight = doms[i].offsetHeight\r\n      const originHeight = showList[i].height\r\n      const dValue = realHeight - originHeight\r\n      // 如果列表项的真实高度就是缓存中的高度，则不需要进行更新\r\n      if (dValue) {\r\n        const index = showList[i].index\r\n        const allData = dataListRef.current\r\n        /**\r\n           * 如果列表项的真实高度不是缓存中的高度，那么不仅要更新缓存中这一项的bottom和height属性\r\n           * 在该列表项后续的所有列表项的top、bottom都会受到它的影响，所以我们又需要一层for循环进行更改缓存中后续的值\r\n           */\r\n        allData[index].bottom += dValue\r\n        allData[index].height = realHeight\r\n        /**\r\n           * 注意：这里更改的一定要是缓存数组中对应位置后续的所有值，如果只改变的是showList值的话\r\n           * 会造成dataList间断性的bottom和下一个top不连续，因为startIndex、endIndex以及空白填充区域都是依据top和bottom值来进行计算的\r\n           * 所以会导致最后计算的结果出错，滑动得来的startIndex变化幅度大且滚动条不稳定，出现明显抖动问题\r\n           */\r\n        for (let j = index + 1, len = allData.length; j < len; j++) {\r\n          allData[j].top = allData[j - 1].bottom\r\n          allData[j].bottom += dValue\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // eslint-disable-next-line\r\n})\r\n\r\n// 这里有两个感觉不太好的地方，其一就是每次都需要把当前的都算一遍，之前算过的也要在算一遍，如果算过的话，就不用再算了，其二就是当发现有变化，不仅这个数据的数据需要更新，后面的所有数据也需要一并更新，这样如果总的数据很大的话，不知道计算时间是多少，会不会造成页面的卡顿\r\n```\r\n\r\n**进阶**：缓存已经计算过的数据索引，如果再次滚动到当前元素的时候，后面的数据不需要重新计算位置相关的值了，只有滚动到未更新的元素的时候才需要重新计算后面的置相关的值。\r\n\r\n#### 获取可视区域的起始和结束元素索引\r\n\r\n获取可视区域的起始和结束元素索引的时候，最好设置上下滚动缓冲区域消除快速滚动白屏。\r\n\r\n我们发现下面规律：\r\n\r\n1. 列表项的 `bottom` 属性代表的就是该元素尾部到容器顶部的距离；\r\n2. 可视区的第一个元素的 `bottom` 是第一个大于 `滚动高度`的；\r\n3. 可视区最后一个元素的 `bottom` 是第一个大于 `滚动高度 + 可视高度`的。\r\n\r\n我们可以利用这条规则遍历缓存数组找到对应的可视区的第一个元素的索引 `startIndex` 和可视区最后一个元素的索引 `endIndex`\r\n\r\n由于初始化列表元素的数据有顺序的，所以获取 `startIndex` 的方法可以考虑通过二分查找的方式来降低检索次数，减少时间复杂度。\r\n\r\n``` jsx\r\n// 得到要渲染数据的起始索引和结束索引\r\nconst getIndex = () => {\r\n  // 设置缓冲区域的数据量\r\n  const aboveCount = 5\r\n  const belowCount = 5\r\n  // 结果数组，里面包含了起始索引和结束索引\r\n  const resObj = {\r\n    startIndex: 0,\r\n    endIndex: 0,\r\n  }\r\n  const scrollTop = containerRef.current.scrollTop\r\n  const dataList = dataListRef.current\r\n  const len = dataList.length\r\n  // 设置上层缓冲区，如果索引值大于缓冲区域，那么就需要减小startIndex的值用于设置顶层缓冲区\r\n  const startIndex = binarySearch(scrollTop)\r\n  if (startIndex <= aboveCount) {\r\n    resObj.startIndex = 0\r\n  } else {\r\n    resObj.startIndex = startIndex - aboveCount\r\n  }\r\n  /**\r\n     * 缓冲数据中第一个bottom大于滚动高度加上可视区域高度的元素就是可视区域最后一个元素\r\n     * 如果没有找到的话就说明当前滚动的幅度过大，缓存中没有数据的bottom大于我们的目标值，所以搜索不到对应的索引，我们只能拿缓存数据中的最后一个元素补充上\r\n     */\r\n  const endIndex = binarySearch(scrollTop + curContainerHeight.current) || len - 1\r\n  // 增大endIndex的索引值用于为滚动区域下方设置一段缓冲区，避免快速滚动所导致的白屏问题\r\n  resObj.endIndex = endIndex + belowCount\r\n  return resObj\r\n}\r\n\r\n// 由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过二分查找的方式来降低检索次数：\r\nconst binarySearch = (value) => {\r\n  const list = dataListRef.current\r\n  let start = 0;\r\n  let end = list.length - 1;\r\n  let tempIndex = null;\r\n  while (start <= end) {\r\n    let midIndex = parseInt((start + end) / 2);\r\n    let midValue = list[midIndex].bottom;\r\n    if (midValue === value) {\r\n      // 说明当前滚动区域加上可视区域刚好是一个结点的边界，那么我们可以以其下一个结点作为末尾元素\r\n      return midIndex + 1;\r\n    } else if (midValue < value) {\r\n      // 由于当前值与目标值还有一定的差距，所以我们需要增加start值以让下次中点的落点更靠后\r\n      start = midIndex + 1;\r\n    } else if (midValue > value) {\r\n      // 因为我们的目的并不是找到第一个满足条件的值，而是要找到满足条件的最小索引值\r\n      if (tempIndex === null || tempIndex > midIndex) {\r\n        tempIndex = midIndex;\r\n      }\r\n      // 由于我们要继续找更小的索引，所以需要让end-1以缩小范围，让下次中点的落点更靠前\r\n      end--\r\n    }\r\n  }\r\n  return tempIndex;\r\n}\r\n```\r\n\r\n#### 监听滚动事件动态截取数据，动态设置上下空白占位空间\r\n\r\n动态截取数据的操作和定高的虚拟列表几乎一样，区别比较大的地方就在 `padding` 值的计算方式上。在定高的列表中，我们可以根据起始索引值和结尾索引值直接计算出空白填充区域的高度。\r\n\r\n其实在不定高的列表中，计算方式更加简单，因为 `startIndex` 对应元素的 `top` 值就是我们需要填充的上空白区域，下空白区域也可以根据整个列表的高度（最后一个元素的bottom值）和 `endIndex` 对应元素的 `bottom` 值之差得出。\r\n\r\n``` jsx\r\nconst scrollHandle = () => {\r\n  // 获取当前要渲染元素的起始索引和结束索引值\r\n  let { startIndex, endIndex } = getIndex()\r\n  /**\r\n     * 如果是用户滚动触发的，而且两次startIndex的值都一样，那么就没有必要执行下面的逻辑，\r\n     * 除非是用户重新请求了之后需要默认执行一次该函数，这是一种特殊情况，就是startIndex没变，但需要执行后续的操作\r\n     */\r\n  if (!isNeedLoad && lastStartIndex.current === startIndex) return\r\n  // 渲染完一次之后就需要初始化isNeedLoad\r\n  isNeedLoad.current = false\r\n  // 用于实时监控lastStartIndex的值\r\n  lastStartIndex.current = startIndex\r\n  // 下层缓冲区域最后的元素接触到屏幕底部的时候，就可以请求发送数据了\r\n  const currLen = dataListRef.current.length\r\n  if (endIndex >= currLen - 1) {\r\n    // 当前不在请求状态下时才可以改变请求参数发送获取更多数据的请求\r\n    !isRequestRef.current && setOptions(state => ({ offset: state.offset + 1 }))\r\n    // 注意endIndex不可以大于缓存中最后一个元素的索引值\r\n    endIndex = currLen - 1\r\n  }\r\n  // 空白填充区域的样式\r\n  topBlankFill.current = {\r\n    // 改变空白填充区域的样式，起始元素的top值就代表起始元素距顶部的距离，可以用来充当paddingTop值\r\n    paddingTop: `${dataListRef.current[startIndex].top}px`,\r\n    // 缓存中最后一个元素的bottom值与endIndex对应元素的bottom值的差值可以用来充当paddingBottom的值\r\n    paddingBottom: `${dataListRef.current[dataListRef.current.length - 1].bottom - dataListRef.current[endIndex].bottom}px`\r\n  }\r\n  setShowList(dataListRef.current.slice(startIndex, endIndex + 1))\r\n}\r\n```\r\n\r\n#### 问题思考\r\n\r\n我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开。在这种场景下，由于图片会发送网络请求，列表项可能已经渲染到页面中了，但是图片还没有加载出来，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，获取到的高度有无包含图片高度，从而造成计算不准确的情况。\r\n\r\n但是这种任意由图片来撑开盒子大小的场景很少见，因为这样会显得整个列表很不规则。大多数展示图片的列表场景，其实都是提前确定要展示图片的尺寸的，比如微博，1张图片的尺寸是多少，2x2，3x3的尺寸是多少都是提前设计好的，只要我们给img标签加了固定高度，这样就算图片还没有加载出来，但是我们也能够准确的知道列表项的高度是多少。\r\n\r\n如果你真的遇到了这种列表项会由图片任意撑开的场景，可以给图片绑定 `onload` 事件，等到它加载完之后再重新计算一下列表的高度，然后把它更新到缓存数据中，这是一种方法。其次，还可以使用 `ResizeObserver` 来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度，只不过MDN有说道这只是在实验中的一个功能，所以暂时可能没有办法兼容所有的浏览器！\r\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/608/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/608/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### 固定高度虚拟列表实现思路：","#### 确定列表项高度","#### 计算可见区域","#### 只渲染可见列表项","#### 优化滚动性能","#### 处理异步数据加载","### 非固定高度虚拟列表实现思路：","#### 初始化数据，设置预估高度","#### 根据列表数据项渲染完后更新后面的数据","#### 获取可视区域的起始和结束元素索引","#### 监听滚动事件动态截取数据，动态设置上下空白占位空间","#### 问题思考"]},"__N_SSG":true}