{"pageProps":{"issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/570","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/570/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/570/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/570/events","html_url":"https://github.com/hankliu62/interview/issues/570","id":2168212872,"node_id":"I_kwDOLNphd86BPE2I","number":570,"title":"TypeScript 中的 any、unknown、never 和 void 作用和区别","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":6547468429,"node_id":"LA_kwDOLNphd88AAAABhkJwjQ","url":"https://api.github.com/repos/hankliu62/interview/labels/typescript","name":"typescript","color":"487E6B","default":false,"description":"Typescript相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-03-05T03:17:06Z","updated_at":"2024-03-09T03:00:06Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"### any\r\n\r\nany 表示 任意类型。\r\n\r\n它是任意类型的父类，任意类型的值都可以赋予给 any 类型：\r\n\r\n``` ts\r\n// 编译不会报错\r\nlet anything: any = '前端西瓜哥';\r\n\r\nlet flag: boolean = true;\r\nanything = flag;\r\n\r\nanything = { num: 2 };\r\n```\r\n\r\n它可以表示任何类型，并使用它们的语法，就像写没有类型的原生 JS 一样。\r\n\r\n``` ts\r\n// 编译不会报错\r\nconst a: any = 6;\r\n\r\na();\r\na.key1 = true;\r\n```\r\n\r\nany 相当于抛弃了类型系统，会让代码变得不可预测和难以维护，需要程序员小心维护，一有不慎会造成运行时的错误，所以尽量少用。\r\n\r\n但在引入一些没有提供类型的第三方纯 JS 库时，还是得将它们标为 any，这个确实没啥办法。\r\n\r\n除非你自己给第三方库写类型声明，但太不现实，因为你不熟悉第三方库的 API，且可能有很复杂的类型推导要实现。\r\n\r\nany 的存在是为了兼容无类型的 JS。TS 作为 JS 的超集，用 any 开后门是不得不做的事情。\r\n\r\n### unknown\r\n\r\nunknown 可以认为是 类型更安全的 any。\r\n\r\n和 any 一样，unknown 也是任何类型的子类型，所有类型都可以传给 unknown，包括 any。\r\n\r\n``` ts\r\n// 编译不会报错\r\nlet a: unknown = '前端西瓜哥';\r\n\r\nlet b: any;\r\na = b;\r\n\r\na = { num: 2 };\r\n```\r\n\r\n说 unknown 更安全，是因为 unknown 是不能进行任何操作的。如果要使用，需要用 as 来进行显式的类型断言。\r\n\r\n``` ts\r\ndeclare const user: known;\r\n\r\n// 报错，unknown 不能被使用\r\nuser.toLowerCase();\r\n\r\n// 开发者认为 user 是个字符串\r\n// 使用 as 进行类型推断才能使用\r\n(user as string).toLowerCase();\r\n```\r\n\r\n或者我们可以用类型收窄（Type Narrowing）；\r\n\r\n```\r\ndeclare const user: unknown;\r\n\r\nif (typeof user === 'string') {\r\n  user.toLowerCase();\r\n}\r\n```\r\n\r\n对于一些可疑的没有类型的变量，如果你不希望它被不小心使用，此时就可以用 unknown。\r\n\r\n总结就是：unknown 能看不能用，想用先类型断言。\r\n\r\n### never\r\nnever 表示一个 无法被观测的类型，被赋予了该类型的变量什么都不能做。\r\n\r\n使用 never 的一些场景。\r\n\r\n#### （1）一个无法走到 return 返回值的函数，比如一定会抛出错误或死循环：\r\n\r\n``` ts\r\n// 这里的 never 表示无法执行到函数返回它的返回值\r\nfunction foo(): never {\r\n  throw new Error('something wrong!')\r\n}\r\n```\r\n\r\n#### （2）TS 在判断条件下会做类型的收窄，当类型收缩到无类型可用，类型就变成了 never：\r\n\r\n``` ts\r\nfunction getData(id: number | string) {\r\n  if (typeof id === 'string') {\r\n    // id 类型变成了 string\r\n  } else if (typeof id === 'number') {\r\n    // id 类型变成了 number\r\n  } else {\r\n    // id 类型变成了 never\r\n  }\r\n}\r\n```\r\n\r\n或者做了一种不可能为 true 的类型收窄：\r\n\r\n``` ts\r\nif (typeof id === 'number' && typeof id === 'string') {\r\n  // id 不可能同时是 number 和 string\r\n  // 所以会变成 never\r\n}\r\n```\r\n\r\n或无法求出交集的交叉类型：\r\n\r\n``` ts\r\n// ImpossibleType 会得到 never\r\ntype ImpossibleType = string & number;\r\n```\r\n\r\n#### （3）类型编程中，在做模式匹配时，如果匹配失败，还是要返回一个类型的。为了表示失败，返回一个 never 表示返回的类型是无法被使用的。\r\n\r\n比如 TS 内置的 Parameters 高级类型，会通过模式匹配提取函数的参数数组类型。如果无法匹配到参数，会返回 never：\r\n\r\n``` ts\r\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never\r\n```\r\n\r\n#### （4）类型编程中，将一些类型丢弃。never 在联合类型以及重映射的 key 中会被丢弃。\r\n\r\n比如 TS 内置的 Exclude 高级类型，会将联合类型 T 中的不属于 U 的 key 丢弃掉。\r\n\r\n``` ts\r\ntype Exclude<T, U> = T extends U ? never : T\r\n\r\ntype T = Exclude<\"a\" | \"b\" | \"c\", \"a\">;\r\n// T 的类型为 \"b\" | \"c\"\r\n// 其实应该是 never | \"b\" | \"c\"，但 never 无意义，被丢掉了\r\n```\r\n\r\n### void\r\n\r\nvoid 用于表示一个 函数没有返回值。\r\n\r\n``` ts\r\nfunction sayHi(): void {\r\n  console.log('Hi!');\r\n}\r\n```\r\n\r\n当然在实际 JS 运行时，还是会返回一个默认的 undefined 的。但 TS 给返回值设置为 void，语义更好些。\r\n\r\n### 总结\r\n- any 是任意类型，具有所有类型的行为，可被执行，可访问属性，超脱于类型系统之外。\r\n- unknown 则是类型更安全的 any，同样可以将任何类型赋给它，但不能执行任何操作，必须用类型断言来显示说明类型才能去执行操作。\r\n- never 是无法观测的类型，比如不会执行完的函数的返回值，合并结果不存在的交叉类型。在类型编程中非常活跃，常用于丢弃一些子类型。\r\n- void 就比较简单，只是代表函数没有返回值，没有其他的场景了。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/570/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/570/timeline","performed_via_github_app":null,"state_reason":null},"menus":["### any","### unknown","### never","#### （1）一个无法走到 return 返回值的函数，比如一定会抛出错误或死循环：","#### （2）TS 在判断条件下会做类型的收窄，当类型收缩到无类型可用，类型就变成了 never：","#### （3）类型编程中，在做模式匹配时，如果匹配失败，还是要返回一个类型的。为了表示失败，返回一个 never 表示返回的类型是无法被使用的。","#### （4）类型编程中，将一些类型丢弃。never 在联合类型以及重映射的 key 中会被丢弃。","### void","### 总结"]},"__N_SSG":true}