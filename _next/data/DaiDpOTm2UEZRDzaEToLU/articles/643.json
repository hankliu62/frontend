{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/643","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/643/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/643/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/643/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/643","id":2218780068,"node_id":"I_kwDOBiJZIc6EP-Wk","number":643,"title":"cache-loader","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536123165,"node_id":"LA_kwDOBiJZIc8AAAABhZVTHQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/webpack","name":"webpack","color":"923874","default":false,"description":"分类-Webpack相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-04-01T18:05:33Z","updated_at":"2024-04-01T18:05:34Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## cache-loader\n\n`cache-loader` 允许在磁盘（默认）或数据库中缓存后续加载器的结果。\n\n### 开始使用\n\n要开始使用，您需要安装 `cache-loader`：\n\n``` console\nnpm install --save-dev cache-loader\n```\n\n将此加载器添加到其他（耗时的）加载器前面，以便在磁盘上缓存结果。\n\nwebpack.config.js\n\n``` js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.ext$/,\n        use: ['cache-loader', ...loaders],\n        include: path.resolve('src'),\n      },\n    ],\n  },\n};\n```\n\n> ⚠️ 请注意，保存和读取缓存文件会有一定的开销，因此只将此加载器用于缓存耗时的加载器。\n\n\n### 选项\n\n|         名称          |                       类型                       |                        n 默认值                        | 描述                                                                                                                                                            |\n| :-------------------: | :----------------------------------------------: | :-----------------------------------------------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|  **`cacheContext`**   |                    `{String}`                    |                       `undefined`                       | 允许您覆盖默认的缓存上下文，以便相对于某个路径生成缓存。默认情况下，它将使用绝对路径。                            |\n|    **`cacheKey`**     |    `{Function(options, request) -> {String}}`    |                       `undefined`                       | 允许您覆盖默认的缓存键生成器。                                                                                                                     |\n| **`cacheDirectory`**  |                    `{String}`                    | `findCacheDir({ name: 'cache-loader' }) or os.tmpdir()` | 提供一个缓存目录，其中应存储缓存项（用于默认的读写实现）。                                                              |\n| **`cacheIdentifier`** |                    `{String}`                    |     `cache-loader:{version} {process.env.NODE_ENV}`     | 提供一个无效标识符，用于生成哈希值。您可以将其用于加载器的额外依赖项（用于默认的读写实现） |\n|     **`compare`**     |      `{Function(stats, dep) -> {Boolean}}`       |                       `undefined`                       | 允许您覆盖缓存的依赖项与正在读取的依赖项之间的默认比较函数。返回 `true` 以使用缓存的资源。                   |\n|    **`precision`**    |                    `{Number}`                    |                           `0`                           | 在将这些参数传递给比较函数之前，使用此毫秒数对`stats`和`dep`的`mtime`进行四舍五入。                                          |\n|      **`read`**       |    `{Function(cacheKey, callback) -> {void}}`    |                       `undefined`                       | 允许您覆盖从文件中读取默认缓存数据的函数。                                                                                                               |\n|    **`readOnly`**     |                   `{Boolean}`                    |                         `false`                         | 允许您覆盖默认值，并使缓存只读（在某些环境中很有用，您不希望更新缓存，而只是从中读取）。       |\n|      **`write`**      | `{Function(cacheKey, data, callback) -> {void}}` |                       `undefined`                       | 允许您覆盖将默认缓存数据写入文件（例如Redis，memcached）的函数。                                                                                        |\n\n### 示例\n\n#### 基础\n\n**webpack.config.js**\n\n``` js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ['cache-loader', 'babel-loader'],\n        include: path.resolve('src'),\n      },\n    ],\n  },\n};\n```\n\n在基础示例中，`cache-loader` 被用于缓存对 `.js` 文件的处理结果。当文件内容发生变化时，缓存将被无效化，并且会重新处理文件。这种缓存机制可以显著提高构建速度，特别是当处理大量未更改的文件时。\n\n#### 数据库集成\n\n**webpack.config.js**\n\n``` js\n// 或者使用其他数据库客户端 - memcached, mongodb, ...\nconst redis = require('redis');\nconst crypto = require('crypto');\n\n// ...\n// 连接到客户端\n// ...\n\nconst BUILD_CACHE_TIMEOUT = 24 * 3600; // 1天\n\nfunction digest(str) {\n  return crypto\n    .createHash('md5')\n    .update(str)\n    .digest('hex');\n}\n\n// 生成自定义缓存键\nfunction cacheKey(options, request) {\n  return `build:cache:${digest(request)}`;\n}\n\n// 从数据库读取数据并解析\nfunction read(key, callback) {\n  client.get(key, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!result) {\n      return callback(new Error(`Key ${key} not found`));\n    }\n\n    try {\n      let data = JSON.parse(result);\n      callback(null, data);\n    } catch (e) {\n      callback(e);\n    }\n  });\n}\n\n// 在cacheKey下将数据写入数据库\nfunction write(key, data, callback) {\n  client.set(key, JSON.stringify(data), 'EX', BUILD_CACHE_TIMEOUT, callback);\n}\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'cache-loader',\n            options: {\n              cacheKey,\n              read,\n              write,\n            },\n          },\n          'babel-loader',\n        ],\n        include: path.resolve('src'),\n      },\n    ],\n  },\n};\n```\n\n`ache-loader` 被配置为使用自定义的读取和写入函数，这些函数将数据存储在 `Redis` 数据库中。通过 `cacheKey` 函数，可以为每个请求生成一个唯一的缓存键。`read` 函数从数据库中读取缓存数据，并将其解析为 `JavaScript` 对象。`write` 函数将处理后的数据写入数据库，并设置了一个过期时间（在这种情况下为 `1` 天）。\n\n通过这种方式，缓存数据可以在构建过程中跨多个运行实例共享，并且可以持久化存储，即使 `webpack` 构建进程重启也不会丢失。这可以进一步提高构建速度，特别是在大型项目中，并且可以在多个构建任务之间共享缓存数据。\n\n翻译: [cache-loader](https://www.npmjs.com/package/cache-loader)","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/643/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/643/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## cache-loader\n\n`cache-loader` 允许在磁盘（默认）或数据库中缓存后续加载器的结果。\n\n### 开始使用\n\n要开始使用，您需要安装 `cache-loader`：\n\n``` console\nnpm install --save-dev cache-loader\n```\n\n将此加载器添加到其他（耗时的）加载器前面，以便在磁盘上缓存结果。\n\nwebpack.config.js\n\n``` js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.ext$/,\n        use: ['cache-loader', ...loaders],\n        include: path.resolve('src'),\n      },\n    ],\n  },\n};\n```\n\n> ⚠️ 请注意，保存和读取缓存文件会有一定的开销，因此只将此加载器用于缓存耗时的加载器。\n\n\n### 选项\n\n|         名称          |                       类型                       |                        n 默认值                        | 描述                                                                                                                                                            |\n| :-------------------: | :----------------------------------------------: | :-----------------------------------------------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|  **`cacheContext`**   |                    `{String}`                    |                       `undefined`                       | 允许您覆盖默认的缓存上下文，以便相对于某个路径生成缓存。默认情况下，它将使用绝对路径。                            |\n|    **`cacheKey`**     |    `{Function(options, request) -> {String}}`    |                       `undefined`                       | 允许您覆盖默认的缓存键生成器。                                                                                                                     |\n| **`cacheDirectory`**  |                    `{String}`                    | `findCacheDir({ name: 'cache-loader' }) or os.tmpdir()` | 提供一个缓存目录，其中应存储缓存项（用于默认的读写实现）。                                                              |\n| **`cacheIdentifier`** |                    `{String}`                    |     `cache-loader:{version} {process.env.NODE_ENV}`     | 提供一个无效标识符，用于生成哈希值。您可以将其用于加载器的额外依赖项（用于默认的读写实现） |\n|     **`compare`**     |      `{Function(stats, dep) -> {Boolean}}`       |                       `undefined`                       | 允许您覆盖缓存的依赖项与正在读取的依赖项之间的默认比较函数。返回 `true` 以使用缓存的资源。                   |\n|    **`precision`**    |                    `{Number}`                    |                           `0`                           | 在将这些参数传递给比较函数之前，使用此毫秒数对`stats`和`dep`的`mtime`进行四舍五入。                                          |\n|      **`read`**       |    `{Function(cacheKey, callback) -> {void}}`    |                       `undefined`                       | 允许您覆盖从文件中读取默认缓存数据的函数。                                                                                                               |\n|    **`readOnly`**     |                   `{Boolean}`                    |                         `false`                         | 允许您覆盖默认值，并使缓存只读（在某些环境中很有用，您不希望更新缓存，而只是从中读取）。       |\n|      **`write`**      | `{Function(cacheKey, data, callback) -> {void}}` |                       `undefined`                       | 允许您覆盖将默认缓存数据写入文件（例如Redis，memcached）的函数。                                                                                        |\n\n### 示例\n\n#### 基础\n\n**webpack.config.js**\n\n``` js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ['cache-loader', 'babel-loader'],\n        include: path.resolve('src'),\n      },\n    ],\n  },\n};\n```\n\n在基础示例中，`cache-loader` 被用于缓存对 `.js` 文件的处理结果。当文件内容发生变化时，缓存将被无效化，并且会重新处理文件。这种缓存机制可以显著提高构建速度，特别是当处理大量未更改的文件时。\n\n#### 数据库集成\n\n**webpack.config.js**\n\n``` js\n// 或者使用其他数据库客户端 - memcached, mongodb, ...\nconst redis = require('redis');\nconst crypto = require('crypto');\n\n// ...\n// 连接到客户端\n// ...\n\nconst BUILD_CACHE_TIMEOUT = 24 * 3600; // 1天\n\nfunction digest(str) {\n  return crypto\n    .createHash('md5')\n    .update(str)\n    .digest('hex');\n}\n\n// 生成自定义缓存键\nfunction cacheKey(options, request) {\n  return `build:cache:${digest(request)}`;\n}\n\n// 从数据库读取数据并解析\nfunction read(key, callback) {\n  client.get(key, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!result) {\n      return callback(new Error(`Key ${key} not found`));\n    }\n\n    try {\n      let data = JSON.parse(result);\n      callback(null, data);\n    } catch (e) {\n      callback(e);\n    }\n  });\n}\n\n// 在cacheKey下将数据写入数据库\nfunction write(key, data, callback) {\n  client.set(key, JSON.stringify(data), 'EX', BUILD_CACHE_TIMEOUT, callback);\n}\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'cache-loader',\n            options: {\n              cacheKey,\n              read,\n              write,\n            },\n          },\n          'babel-loader',\n        ],\n        include: path.resolve('src'),\n      },\n    ],\n  },\n};\n```\n\n`ache-loader` 被配置为使用自定义的读取和写入函数，这些函数将数据存储在 `Redis` 数据库中。通过 `cacheKey` 函数，可以为每个请求生成一个唯一的缓存键。`read` 函数从数据库中读取缓存数据，并将其解析为 `JavaScript` 对象。`write` 函数将处理后的数据写入数据库，并设置了一个过期时间（在这种情况下为 `1` 天）。\n\n通过这种方式，缓存数据可以在构建过程中跨多个运行实例共享，并且可以持久化存储，即使 `webpack` 构建进程重启也不会丢失。这可以进一步提高构建速度，特别是在大型项目中，并且可以在多个构建任务之间共享缓存数据。\n\n翻译: [cache-loader](https://www.npmjs.com/package/cache-loader)"]},"__N_SSG":true}