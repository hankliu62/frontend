{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/661","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/661/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/661/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/661/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/661","id":2266679126,"node_id":"I_kwDOBiJZIc6HGsdW","number":661,"title":"跨浏览器标签页进行通讯的方式简介","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536875857,"node_id":"LA_kwDOBiJZIc8AAAABhaDPUQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/html","name":"html","color":"13c2c2","default":false,"description":"分类-HTML相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-04-27T01:09:33Z","updated_at":"2024-04-27T01:09:33Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## 跨浏览器标签页进行通讯的方式简介\n\n在现代 `Web` 应用程序中，跨浏览器标签页之间进行通讯是一项重要的功能。无论是在多标签页应用程序中同步状态，还是在不同浏览器窗口之间共享数据，实现跨标签页通讯都是必不可少的。在本文中，我们将探讨跨浏览器标签页进行通讯的各种方式，并详细介绍每种方式的 `API` 和使用场景。\n\n### 所有方法\n\n1. 使用 `Web Storage API`\n2. 使用 `Broadcast Channel API`\n3. 使用 `SharedWorker`\n4. 使用 `Service Worker`\n5. 使用 `WebSocket`\n6. 使用 `PostMessage API`\n7. 使用 `IndexedDB`\n\n### Web Storage API\n\n#### 简介\n\n- **简介**：`Web Storage API` 提供了一种在客户端存储数据的方法，包括 `localStorage` 和 `sessionStorage` 两种方式。它们可以在不同的浏览器标签页之间共享数据，而不受页面刷新或关闭的影响。\n- **优点**：简单易用，支持持久化存储。\n- **缺点**：只能存储字符串类型的数据，且容量有限。\n- **适用场景**：适合存储小型数据，如用户偏好设置或临时状态。\n\n#### API\n\n- **localStorage**: 保存的数据没有过期时间，可以一直存在于浏览器中。\n- **sessionStorage**: 保存的数据在浏览器会话结束时被清除，适合临时存储数据。\n\n#### 使用场景\n\n- 在同一浏览器的不同标签页中共享数据。\n- 存储用户首选项或状态信息。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Web Storage Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"saveData()\">Save Data</button>\n    <button onclick=\"getData()\">Get Data</button>\n\n    <script>\n        function saveData() {\n            const input = document.getElementById('input').value;\n            localStorage.setItem('data', input);\n        }\n\n        function getData() {\n            const data = localStorage.getItem('data');\n            alert(data);\n        }\n\n        window.addEventListener('storage', event => {\n            alert('Data changed in another tab: ' + event.newValue);\n        });\n    </script>\n</body>\n</html>\n\n<!-- another-page.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Another Page</title>\n</head>\n<body>\n    <button onclick=\"getData()\">Get Data from Main Page</button>\n\n    <script>\n        function getData() {\n            const data = localStorage.getItem('data');\n            alert(data);\n        }\n\n        window.addEventListener('storage', event => {\n            alert('Data changed in another tab: ' + event.newValue);\n        });\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入数据并保存，然后在另一个页面中点击按钮获取数据。同时，当一个标签页修改了 localStorage 的值，另一个标签页也会收到通知。\n\n### Broadcast Channel API\n\n#### 简介\n\n- **简介**：`Broadcast Channel API` 允许在不同的浏览器标签页之间进行实时通信，通过创建一个共享的消息通道来传递数据。\n- **优点**：支持实时通信，消息发送和接收都非常简单。\n- **缺点**：不支持 `IE` 浏览器。\n- **适用场景**：适合需要实时通讯的场景，如多标签页间的数据同步。\n\n#### API\n- **BroadcastChannel**: 创建一个用于跨文档通信的通道。\n\n#### 使用场景\n- 在不同的浏览器标签页之间传递消息。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Broadcast Channel Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        const channel = new BroadcastChannel('channel');\n\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            channel.postMessage(input);\n        }\n    </script>\n</body>\n</html>\n\n<!-- another-page.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Another Page</title>\n</head>\n<body>\n    <p id=\"message\"></p>\n\n    <script>\n        const channel = new BroadcastChannel('channel');\n\n        channel.onmessage = event => {\n            document.getElementById('message').textContent = event.data;\n        };\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入消息并发送，在另一个页面中接收并显示消息。\n\n### SharedWorker\n\n#### 简介\n\n- **简介**：`SharedWorker` 允许在多个浏览器上下文之间共享同一个 `Worker` 实例，提供了一种全局范围的通讯机制。\n- **优点**：支持多标签页之间的实时通信，可以与所有标签页共享相同的数据。\n- **缺点**：不支持 `IE` 浏览器。\n- **适用场景**：适合需要共享状态或实现实时通讯的场景。\n\n#### API\n- **SharedWorker**: 创建一个共享的 `Web Worker` 实例，可以被多个浏览上下文共享。\n\n#### 使用场景\n\n- 在不同浏览器标签页之间共享数据或进行通讯。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>SharedWorker Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        const worker = new SharedWorker('worker.js');\n\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            worker.port.postMessage(input);\n        }\n\n        worker.port.onmessage = event => {\n            alert(event.data);\n        };\n    </script>\n</body>\n</html>\n```\n\n``` javascript\n// worker.js\nconst ports = [];\n\nonconnect = event => {\n    const port = event.ports[0];\n    ports.push(port);\n    port.onmessage = event => {\n        const message = event.data;\n        ports.forEach(port => port.postMessage(message));\n    };\n};\n```\n\n在一个页面中输入消息并发送，在另一个页面中接收并显示消息。\n\n### Service Worker\n\n#### 简介\n- **简介**：`Service Worker` 是一种在浏览器后台运行的脚本，可以拦截和处理网络请求，并实现离线缓存和推送通知等功能。\n- **优点**：支持后台运行，可以拦截网络请求，实现离线缓存和推送通知。\n- **缺点**：只能用于现代浏览器，且需要 `HTTPS` 支持。\n- **适用场景**：适合需要离线访问或推送通知的场景，如聊天应用或离线应用。\n\n#### API\n\n- **Service Worker**: 在后台运行的脚本，可以拦截和处理网络请求，并进行推送通知等功能。\n\n#### 使用场景\n\n- 在不同标签页之间共享数据或进行通讯。\n- 实现离线缓存和推送通知。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Service Worker Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        // 注册 Service Worker\n        navigator.serviceWorker.register('sw.js');\n\n        // 发送消息\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            navigator.serviceWorker.controller.postMessage(input);\n        }\n\n        // 监听消息\n        navigator.serviceWorker.addEventListener('message', event => {\n            alert(event.data);\n        });\n    </script>\n</body>\n</html>\n```\n\n``` javascript\n// sw.js\nself.addEventListener('message', event => {\n    const message = event.data;\n    clients.matchAll().then(clients => {\n        clients.forEach(client => client.postMessage(message));\n    });\n});\n```\n\n在一个页面中输入消息并发送，在另一个页面中接收并显示消息。\n\n### WebSocket\n\n#### 简介\n\n- **简介**：`WebSocket` 提供了一种在客户端和服务器之间建立持久连接的方式，实现了双向通信。\n- **优点**：支持双向通信，可以实现实时通讯。\n- **缺点**：需要在服务器端实现 `WebSocket` 服务，且不支持跨域请求。\n- **适用场景**：适合实时通讯场景，如聊天应用或在线游戏。\n\n#### API\n- **WebSocket**: 在客户端和服务器之间建立持久连接，实现双向通信。\n\n#### 使用场景\n\n在不同浏览器标签页之间进行实时通讯。\n\n```javascript\n// server.js\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', ws => {\n    ws.on('message', message => {\n        wss.clients.forEach(client => {\n            if (client !== ws && client.readyState === WebSocket.OPEN) {\n                client.send(message);\n            }\n        });\n    });\n});\n```\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>WebSocket Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        const socket = new WebSocket('ws://localhost:8080');\n\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            socket.send(input);\n        }\n\n        socket.onmessage = event => {\n            alert(event.data);\n        };\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入消息并发送，在另一个页面中接收并显示消息。\n\n### PostMessage API\n\n#### 简介\n\n- **简介**：`PostMessage API` 允许跨文档之间安全地传递消息，可以实现跨域通信。\n- **优点**：支持跨域通信，使用简单。\n- **缺点**：需要对接收消息的文档进行信任验证，存在安全风险。\n- **适用场景**：适合不同域名之间的数据交换或通信。\n\n#### API\n- **window.postMessage()**: 向其他窗口发送消息。\n\n#### 使用场景\n\n- 在不同窗口之间进行跨域通信。\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>PostMessage Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        const popup = window.open('another-page.html');\n\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            popup.postMessage(input, '*');\n        }\n    </script>\n</body>\n</html>\n\n<!-- another-page.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Another Page</title>\n</head>\n<body>\n    <p id=\"message\"></p>\n\n    <script>\n        window.addEventListener('message', event => {\n            document.getElementById('message').textContent = event.data;\n        });\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入数据并保存，然后在另一个页面中点击按钮获取数据。\n\n### IndexedDB\n\n#### 简介\n\n- **简介**：`IndexedDB` 提供了一个异步的、事务型的数据库，适用于存储大量结构化数据。\n- **优点**：支持存储大量结构化数据，数据存储在客户端本地。\n- **缺点**：使用复杂，需要学习 `IndexedDB` 的 `API`。\n- **适用场景**：适合需要存储大量结构化数据的场景，如离线应用或数据分析应用。\n\n#### API\n\n- **IndexedDB**: 提供了一个异步的、事务型的数据库。\n\n#### 使用场景\n\n- 存储大量结构化数据，如离线应用程序的数据。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>IndexedDB Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"saveData()\">Save Data</button>\n    <button onclick=\"getData()\">Get Data</button>\n\n    <script>\n        const request = indexedDB.open('myDatabase');\n\n        request.onupgradeneeded = event => {\n            const db = event.target.result;\n            const objectStore = db.createObjectStore('data', { keyPath: 'id' });\n        };\n\n        function saveData() {\n            const input = document.getElementById('input').value;\n            const db = request.result;\n            const transaction = db.transaction('data', 'readwrite');\n            const objectStore = transaction.objectStore('data');\n            objectStore.add({ id: 1, data: input });\n        }\n\n        function getData() {\n            const db = request.result;\n            const transaction = db.transaction('data', 'readonly');\n            const objectStore = transaction.objectStore('data');\n            const request = objectStore.get(1);\n            request.onsuccess = event => {\n                const data = event.target.result;\n                alert(data.data);\n            };\n        }\n    </script>\n</body>\n</html>\n\n<!-- another-page.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Another Page</title>\n</head>\n<body>\n    <button onclick=\"getData()\">Get Data from Main Page</button>\n\n    <script>\n        function getData() {\n            const request = indexedDB.open('myDatabase');\n            request.onsuccess = event => {\n                const db = event.target.result;\n                const transaction = db.transaction('data', 'readonly');\n                const objectStore = transaction.objectStore('data');\n                const request = objectStore.get(1);\n                request.onsuccess = event => {\n                    const data = event.target.result;\n                    alert(data.data);\n                };\n            };\n        }\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入数据并保存，然后在另一个页面中点击按钮获取数据。\n\n### 总结\n\n在本文中，我们介绍了跨浏览器标签页进行通讯的多种方式，并提供了详细的 `API` 和使用场景。根据您的具体需求和项目要求","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/661/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/661/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## 跨浏览器标签页进行通讯的方式简介\n\n在现代 `Web` 应用程序中，跨浏览器标签页之间进行通讯是一项重要的功能。无论是在多标签页应用程序中同步状态，还是在不同浏览器窗口之间共享数据，实现跨标签页通讯都是必不可少的。在本文中，我们将探讨跨浏览器标签页进行通讯的各种方式，并详细介绍每种方式的 `API` 和使用场景。\n\n### 所有方法\n\n1. 使用 `Web Storage API`\n2. 使用 `Broadcast Channel API`\n3. 使用 `SharedWorker`\n4. 使用 `Service Worker`\n5. 使用 `WebSocket`\n6. 使用 `PostMessage API`\n7. 使用 `IndexedDB`\n\n### Web Storage API\n\n#### 简介\n\n- **简介**：`Web Storage API` 提供了一种在客户端存储数据的方法，包括 `localStorage` 和 `sessionStorage` 两种方式。它们可以在不同的浏览器标签页之间共享数据，而不受页面刷新或关闭的影响。\n- **优点**：简单易用，支持持久化存储。\n- **缺点**：只能存储字符串类型的数据，且容量有限。\n- **适用场景**：适合存储小型数据，如用户偏好设置或临时状态。\n\n#### API\n\n- **localStorage**: 保存的数据没有过期时间，可以一直存在于浏览器中。\n- **sessionStorage**: 保存的数据在浏览器会话结束时被清除，适合临时存储数据。\n\n#### 使用场景\n\n- 在同一浏览器的不同标签页中共享数据。\n- 存储用户首选项或状态信息。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Web Storage Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"saveData()\">Save Data</button>\n    <button onclick=\"getData()\">Get Data</button>\n\n    <script>\n        function saveData() {\n            const input = document.getElementById('input').value;\n            localStorage.setItem('data', input);\n        }\n\n        function getData() {\n            const data = localStorage.getItem('data');\n            alert(data);\n        }\n\n        window.addEventListener('storage', event => {\n            alert('Data changed in another tab: ' + event.newValue);\n        });\n    </script>\n</body>\n</html>\n\n<!-- another-page.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Another Page</title>\n</head>\n<body>\n    <button onclick=\"getData()\">Get Data from Main Page</button>\n\n    <script>\n        function getData() {\n            const data = localStorage.getItem('data');\n            alert(data);\n        }\n\n        window.addEventListener('storage', event => {\n            alert('Data changed in another tab: ' + event.newValue);\n        });\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入数据并保存，然后在另一个页面中点击按钮获取数据。同时，当一个标签页修改了 localStorage 的值，另一个标签页也会收到通知。\n\n### Broadcast Channel API\n\n#### 简介\n\n- **简介**：`Broadcast Channel API` 允许在不同的浏览器标签页之间进行实时通信，通过创建一个共享的消息通道来传递数据。\n- **优点**：支持实时通信，消息发送和接收都非常简单。\n- **缺点**：不支持 `IE` 浏览器。\n- **适用场景**：适合需要实时通讯的场景，如多标签页间的数据同步。\n\n#### API\n- **BroadcastChannel**: 创建一个用于跨文档通信的通道。\n\n#### 使用场景\n- 在不同的浏览器标签页之间传递消息。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Broadcast Channel Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        const channel = new BroadcastChannel('channel');\n\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            channel.postMessage(input);\n        }\n    </script>\n</body>\n</html>\n\n<!-- another-page.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Another Page</title>\n</head>\n<body>\n    <p id=\"message\"></p>\n\n    <script>\n        const channel = new BroadcastChannel('channel');\n\n        channel.onmessage = event => {\n            document.getElementById('message').textContent = event.data;\n        };\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入消息并发送，在另一个页面中接收并显示消息。\n\n### SharedWorker\n\n#### 简介\n\n- **简介**：`SharedWorker` 允许在多个浏览器上下文之间共享同一个 `Worker` 实例，提供了一种全局范围的通讯机制。\n- **优点**：支持多标签页之间的实时通信，可以与所有标签页共享相同的数据。\n- **缺点**：不支持 `IE` 浏览器。\n- **适用场景**：适合需要共享状态或实现实时通讯的场景。\n\n#### API\n- **SharedWorker**: 创建一个共享的 `Web Worker` 实例，可以被多个浏览上下文共享。\n\n#### 使用场景\n\n- 在不同浏览器标签页之间共享数据或进行通讯。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>SharedWorker Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        const worker = new SharedWorker('worker.js');\n\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            worker.port.postMessage(input);\n        }\n\n        worker.port.onmessage = event => {\n            alert(event.data);\n        };\n    </script>\n</body>\n</html>\n```\n\n``` javascript\n// worker.js\nconst ports = [];\n\nonconnect = event => {\n    const port = event.ports[0];\n    ports.push(port);\n    port.onmessage = event => {\n        const message = event.data;\n        ports.forEach(port => port.postMessage(message));\n    };\n};\n```\n\n在一个页面中输入消息并发送，在另一个页面中接收并显示消息。\n\n### Service Worker\n\n#### 简介\n- **简介**：`Service Worker` 是一种在浏览器后台运行的脚本，可以拦截和处理网络请求，并实现离线缓存和推送通知等功能。\n- **优点**：支持后台运行，可以拦截网络请求，实现离线缓存和推送通知。\n- **缺点**：只能用于现代浏览器，且需要 `HTTPS` 支持。\n- **适用场景**：适合需要离线访问或推送通知的场景，如聊天应用或离线应用。\n\n#### API\n\n- **Service Worker**: 在后台运行的脚本，可以拦截和处理网络请求，并进行推送通知等功能。\n\n#### 使用场景\n\n- 在不同标签页之间共享数据或进行通讯。\n- 实现离线缓存和推送通知。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Service Worker Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        // 注册 Service Worker\n        navigator.serviceWorker.register('sw.js');\n\n        // 发送消息\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            navigator.serviceWorker.controller.postMessage(input);\n        }\n\n        // 监听消息\n        navigator.serviceWorker.addEventListener('message', event => {\n            alert(event.data);\n        });\n    </script>\n</body>\n</html>\n```\n\n``` javascript\n// sw.js\nself.addEventListener('message', event => {\n    const message = event.data;\n    clients.matchAll().then(clients => {\n        clients.forEach(client => client.postMessage(message));\n    });\n});\n```\n\n在一个页面中输入消息并发送，在另一个页面中接收并显示消息。\n\n### WebSocket\n\n#### 简介\n\n- **简介**：`WebSocket` 提供了一种在客户端和服务器之间建立持久连接的方式，实现了双向通信。\n- **优点**：支持双向通信，可以实现实时通讯。\n- **缺点**：需要在服务器端实现 `WebSocket` 服务，且不支持跨域请求。\n- **适用场景**：适合实时通讯场景，如聊天应用或在线游戏。\n\n#### API\n- **WebSocket**: 在客户端和服务器之间建立持久连接，实现双向通信。\n\n#### 使用场景\n\n在不同浏览器标签页之间进行实时通讯。\n\n```javascript\n// server.js\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', ws => {\n    ws.on('message', message => {\n        wss.clients.forEach(client => {\n            if (client !== ws && client.readyState === WebSocket.OPEN) {\n                client.send(message);\n            }\n        });\n    });\n});\n```\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>WebSocket Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        const socket = new WebSocket('ws://localhost:8080');\n\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            socket.send(input);\n        }\n\n        socket.onmessage = event => {\n            alert(event.data);\n        };\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入消息并发送，在另一个页面中接收并显示消息。\n\n### PostMessage API\n\n#### 简介\n\n- **简介**：`PostMessage API` 允许跨文档之间安全地传递消息，可以实现跨域通信。\n- **优点**：支持跨域通信，使用简单。\n- **缺点**：需要对接收消息的文档进行信任验证，存在安全风险。\n- **适用场景**：适合不同域名之间的数据交换或通信。\n\n#### API\n- **window.postMessage()**: 向其他窗口发送消息。\n\n#### 使用场景\n\n- 在不同窗口之间进行跨域通信。\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>PostMessage Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"sendMessage()\">Send Message</button>\n\n    <script>\n        const popup = window.open('another-page.html');\n\n        function sendMessage() {\n            const input = document.getElementById('input').value;\n            popup.postMessage(input, '*');\n        }\n    </script>\n</body>\n</html>\n\n<!-- another-page.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Another Page</title>\n</head>\n<body>\n    <p id=\"message\"></p>\n\n    <script>\n        window.addEventListener('message', event => {\n            document.getElementById('message').textContent = event.data;\n        });\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入数据并保存，然后在另一个页面中点击按钮获取数据。\n\n### IndexedDB\n\n#### 简介\n\n- **简介**：`IndexedDB` 提供了一个异步的、事务型的数据库，适用于存储大量结构化数据。\n- **优点**：支持存储大量结构化数据，数据存储在客户端本地。\n- **缺点**：使用复杂，需要学习 `IndexedDB` 的 `API`。\n- **适用场景**：适合需要存储大量结构化数据的场景，如离线应用或数据分析应用。\n\n#### API\n\n- **IndexedDB**: 提供了一个异步的、事务型的数据库。\n\n#### 使用场景\n\n- 存储大量结构化数据，如离线应用程序的数据。\n\n``` html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>IndexedDB Example</title>\n</head>\n<body>\n    <input type=\"text\" id=\"input\">\n    <button onclick=\"saveData()\">Save Data</button>\n    <button onclick=\"getData()\">Get Data</button>\n\n    <script>\n        const request = indexedDB.open('myDatabase');\n\n        request.onupgradeneeded = event => {\n            const db = event.target.result;\n            const objectStore = db.createObjectStore('data', { keyPath: 'id' });\n        };\n\n        function saveData() {\n            const input = document.getElementById('input').value;\n            const db = request.result;\n            const transaction = db.transaction('data', 'readwrite');\n            const objectStore = transaction.objectStore('data');\n            objectStore.add({ id: 1, data: input });\n        }\n\n        function getData() {\n            const db = request.result;\n            const transaction = db.transaction('data', 'readonly');\n            const objectStore = transaction.objectStore('data');\n            const request = objectStore.get(1);\n            request.onsuccess = event => {\n                const data = event.target.result;\n                alert(data.data);\n            };\n        }\n    </script>\n</body>\n</html>\n\n<!-- another-page.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Another Page</title>\n</head>\n<body>\n    <button onclick=\"getData()\">Get Data from Main Page</button>\n\n    <script>\n        function getData() {\n            const request = indexedDB.open('myDatabase');\n            request.onsuccess = event => {\n                const db = event.target.result;\n                const transaction = db.transaction('data', 'readonly');\n                const objectStore = transaction.objectStore('data');\n                const request = objectStore.get(1);\n                request.onsuccess = event => {\n                    const data = event.target.result;\n                    alert(data.data);\n                };\n            };\n        }\n    </script>\n</body>\n</html>\n```\n\n在一个页面中输入数据并保存，然后在另一个页面中点击按钮获取数据。\n\n### 总结\n\n在本文中，我们介绍了跨浏览器标签页进行通讯的多种方式，并提供了详细的 `API` 和使用场景。根据您的具体需求和项目要求"]},"__N_SSG":true}