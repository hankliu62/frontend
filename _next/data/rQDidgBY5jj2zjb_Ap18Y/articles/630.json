{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/630","id":2218770981,"node_id":"I_kwDOBiJZIc6EP8Il","number":630,"title":"Web安全之 XSS 攻击","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536825198,"node_id":"LA_kwDOBiJZIc8AAAABhaAJbg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/network","name":"network","color":"D613F5","default":false,"description":"分类-网络相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-04-01T18:01:11Z","updated_at":"2024-04-01T18:01:12Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## Web安全之 XSS 攻击\n\n### 简介\n**XSS，全称跨站脚本攻击（Cross-Site Scripting）**，是一种网络安全漏洞攻击，指攻击者在网页中嵌入恶意脚本，当其他用户浏览该网页时，恶意脚本就会在其浏览器上执行，从而达到攻击者窃取用户信息、破坏数据、篡改网页内容、在用户浏览器上执行非法任务等目的。\n\n### 分类\n\n`XSS`攻击分为三种类型：\n\n- **反射型XSS（Reflected XSS）**：攻击者将恶意脚本嵌入到URL地址中，当其他用户访问这个URL时，恶意脚本就会在其浏览器中执行。这种攻击方式需要用户主动点击含有恶意脚本的链接才会触发。\n\n- **存储型XSS（Stored XSS）**：攻击者将恶意脚本存储到被攻击的网站数据库中，当其他用户访问网站时，恶意脚本会从数据库中取出并在用户浏览器中执行。这种攻击方式不需要用户主动点击链接，只要用户浏览被攻击的网站就可能被攻击。\n\n- **DOM型XSS（DOM-based XSS）**：攻击者通过修改页面的DOM结构，注入恶意脚本，当其他用户浏览该页面时，恶意脚本会在用户浏览器中执行。这种攻击方式也不需要用户主动点击链接，只需要用户浏览被修改的页面就可能被攻击。\n\n### 案例\n\n#### 反射型XSS\n\n在`Node.js`中，一个反射型`XSS`攻击的案例可能涉及一个web应用，该应用没有正确地处理或转义用户输入的数据，并将其直接插入到HTML响应中。攻击者可以构造一个包含恶意脚本的URL，当其他用户访问这个URL时，恶意脚本会在用户的浏览器中执行。\n\n以下是一个简单的`Node.js`反射型`XSS`攻击的案例：\n\n``` javascript\nconst express = require('express');\nconst app = express();\napp.use(express.static('public'));\n\napp.get('/profile', (req, res) => {\n  // 假设用户可以通过URL参数传递他们的名字\n  const username = req.query.username;\n\n  // 没有对用户输入进行任何处理或转义\n  const html = `<html>\n                <body>\n                  <h1>Welcome, ${username}!</h1>\n                </body>\n              </html>`;\n\n  res.send(html);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在这个例子中，我们创建了一个简单的`Express`应用，其中有一个`/profile`路由，该路由从URL的查询参数中获取用户名（`username`）。然后，我们将这个用户名嵌入到一个`HTML`字符串中，并将其作为响应发送回客户端。\n\n攻击者可以构造一个包含恶意脚本的URL，如：\n\n```\nhttp://example.com/profile?username=<script>alert('XSS');</script>\n```\n\n当用户访问这个`URL`时，浏览器会接收到包含恶意脚本的`HTML`响应，并执行该脚本，从而触发`XSS`攻击。\n\n为了防止反射型`XSS`攻击，开发者应该对用户输入进行适当的过滤和转义。在这个案例中，可以使用如`escape-html`这样的库来转义`HTML`特殊字符：\n\n``` javascript\nconst escapeHtml = require('escape-html');\n\napp.get('/profile', (req, res) => {\n  const username = req.query.username;\n\n  // 转义用户输入中的HTML特殊字符\n  const escapedUsername = escapeHtml(username);\n\n  const html = `<html>\n                <body>\n                  <h1>Welcome, ${escapedUsername}!</h1>\n                </body>\n              </html>`;\n\n  res.send(html);\n});\n```\n\n通过转义用户输入，恶意脚本将不会被浏览器执行，从而防止了`XSS`攻击。此外，开发者还应该使用内容安全策略（`CSP`）等额外安全措施来增强应用的安全性。\n\n<!-- more -->\n\n#### 存储型XSS\n在`存储型XSS（Persistent XSS）`攻击中，恶意脚本被用户提交并存储到服务器端的数据库中。当其他用户访问包含这些恶意脚本的页面时，脚本会在用户的浏览器上执行。下面是一个简单的`Node.js`存储型XSS案例，我们将使用`Express`框架和`MongoDB`数据库。\n\n首先，确保你已经安装了以下依赖：\n\n``` bash\nnpm install express body-parser mongoose\n```\n\n然后，你可以创建一个简单的`Express`应用，并设置一个`MongoDB`数据库来存储评论。\n\n```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst mongoose = require('mongoose');\n\nconst app = express();\n\n// 连接到MongoDB数据库\nmongoose.connect('mongodb://localhost/xss-example', { useNewUrlParser: true, useUnifiedTopology: true });\n\n// 定义评论模型\nconst Comment = mongoose.model('Comment', new mongoose.Schema({\n  content: String\n}));\n\n// 使用body-parser中间件来解析请求体\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 路由：添加评论\napp.post('/comment', async (req, res) => {\n  try {\n    // 创建新的评论并保存到数据库\n    const newComment = new Comment({ content: req.body.content });\n    await newComment.save();\n    res.send('Comment added successfully!');\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('An error occurred while saving the comment.');\n  }\n});\n\n// 路由：显示所有评论\napp.get('/comments', async (req, res) => {\n  try {\n    // 从数据库中获取所有评论\n    const comments = await Comment.find({});\n\n    // 渲染评论列表的HTML\n    const html = renderComments(comments);\n    res.send(html);\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('An error occurred while fetching the comments.');\n  }\n});\n\n// 渲染评论列表的HTML\nfunction renderComments(comments) {\n  let html = '<html><body>';\n  comments.forEach(comment => {\n    // 这里没有对评论内容进行转义，这会导致存储型XSS漏洞\n    html += `<div>${comment.content}</div>`;\n  });\n  html += '</body></html>';\n  return html;\n}\n\n// 启动服务器\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n在这个案例中，我们定义了一个`Comment`模型，用于在`MongoDB`数据库中存储评论。`/comment`路由接受`POST`请求，将用户提交的评论保存到数据库中。`/comments`路由则负责从数据库中检索所有评论，并将它们渲染为HTML页面。\n\n重要提示：在这个案例的`renderComments`函数中，我们没有对评论内容进行任何形式的转义或过滤。这意味着如果用户在评论中输入了恶意脚本，它将被直接插入到`HTML`页面中，并在其他用户查看该页面时执行。这就是`存储型XSS`攻击的核心。\n\n为了防止`存储型XSS`攻击，你应该对所有的用户输入进行适当的转义或过滤。在`Express`应用中，你可以使用如`express-sanitized`和`helmet`这样的中间件来设置一些基本的`HTTP`头，以增加安全性。另外，使用模板引擎（如`ejs`、`pug`等）也可以帮助你更安全地渲染用户输入的数据，因为这些模板引擎通常会自动转义特殊字符。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。\n\n#### DOM型XSS\n在`React`应用程序中，`DOM型XSS`（跨站脚本）攻击通常发生在直接将用户输入嵌入到`JSX`中而没有进行适当的转义或过滤时。`React`本身不会自动转义用户输入，因此开发者需要确保在渲染用户输入之前进行适当的处理。下面是一个简单的`React`应用案例，展示了如果不正确地处理用户输入，可能会导致的`DOM型XSS`攻击：\n\n首先，创建一个简单的`React`组件，它将接收一个名为`username`的属性，并将其直接渲染到页面上：\n\n```jsx\nimport React from 'react';\n\nfunction UserProfile({ username }) {\n  return (\n    <div>\n      <h1>Welcome, {username}!</h1>\n    </div>\n  );\n}\n\nexport default UserProfile;\n```\n\n然后，在父组件中使用这个`UserProfile`组件，并假设从某个地方（例如URL参数、数据库或用户输入）获取`username`：\n\n``` jsx\nimport React from 'react';\nimport UserProfile from './UserProfile';\n\nfunction App() {\n  // 假设这是从某个不安全的来源获取的用户名\n  const username = \"Alice <img src='https://example.com/x.png' onerror='alert(\\\"XSS\\\")' />\";\n\n  return (\n    <div className=\"App\">\n      <UserProfile username={username} />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n在这个案例中，如果`username`包含了恶意的`HTML`和`JavaScript`代码，那么这段代码将会被执行，导致`XSS`攻击。\n\n为了防止这种攻击，你应该在渲染用户输入之前使用某种方法对其进行转义，以确保它不会被浏览器解析为`HTML`或`JavaScript`代码。在`React`中，你可以使用内置的`dangerouslySetInnerHTML`属性配合适当的转义函数来安全地渲染`HTML`内容。然而，这通常不是推荐的做法，因为它可能会引入其他安全风险。\n\n更好的做法是使用库如`react-dom-purify`来清理用户输入中的潜在恶意代码。下面是如何使用`react-dom-purify`来防止`XSS`攻击的例子：\n\n首先，安装`react-dom-purify`：\n\n``` bash\nnpm install react-dom-purify\n```\n\n然后，在你的`React`组件中使用它：\n\n``` jsx\nimport React from 'react';\nimport DOMPurify from 'react-dom-purify';\n\nfunction UserProfile({ username }) {\n  // 使用DOMPurify来清理用户输入中的潜在恶意代码\n  const safeUsername = DOMPurify.sanitize(username);\n\n  return (\n    <div>\n      <h1>Welcome, {safeUsername}!</h1>\n    </div>\n  );\n}\n\nexport default UserProfile;\n```\n\n在这个修改后的例子中，即使`username`包含了恶意的`HTML`和`JavaScript`代码，`DOMPurify.sanitize`函数也会将其清理掉，确保它们不会被浏览器执行。\n\n总之，为了防止`DOM型XSS`攻击，你应该始终确保在将用户输入渲染到React组件之前对其进行适当的转义或清理。\n\n#### ejs 模板引擎\n\n例如，如果你使用`ejs`作为模板引擎，你可以这样渲染评论：\n\n```ejs\n<body>\n  <% comments.forEach(function(comment) { %>\n    <div><%= comment.content %></div>\n  <% }); %>\n</body>\n```\n\n在这个例子中，`<%= comment.content %>`会自动转义`comment.content`中的特殊字符，从而防止`XSS`攻击。\n\n为了防止反射型和`存储型XSS`攻击，开发者应该对用户输入的数据进行适当的验证、过滤和转义。在`Node.js`中，可以使用诸如`express-sanitized`和`helmet`等中间件来增强应用的安全性。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。\n\n#### express-sanitized 中间件\n`express-sanitized` 是一个 `Express.js` 的中间件，用于帮助防止跨站脚本（`XSS`）攻击。它通过提供一组函数来清理和转义用户输入的数据，从而减少潜在的安全风险。然而，需要注意的是，`express-sanitized` 本身并不提供全面的 `XSS` 保护。它应当与其他安全措施（如内容安全策略（`CSP`）、`HTTP` 头设置等）一起使用。\n\n下面是一个简单的 `Node.js` 案例，演示了如何使用 `express-sanitized` 中间件来防止反射型 `XSS` 攻击：\n\n首先，你需要安装 `express` 和 `express-sanitized`：\n\n```bash\nnpm install express express-sanitized\n```\n然后，你可以创建一个简单的 Express 应用，并使用 express-sanitized 来清理用户输入的数据：\n\n``` javascript\nconst express = require('express');\nconst sanitized = require('express-sanitized');\nconst app = express();\n\n// 使用 express-sanitized 中间件\napp.use(sanitized());\n\n// 一个简单的 GET 路由，接收用户输入并反射回去\napp.get('/reflect', (req, res) => {\n  // 假设我们从 URL 参数中获取用户输入\n  const userInput = req.query.message;\n\n  // 使用 express-sanitized 的 sanitize 函数来清理用户输入\n  const cleanedInput = sanitized.sanitize(userInput);\n\n  // 将清理后的用户输入嵌入到 HTML 中\n  const html = `\n    <html>\n      <body>\n        <h1>Welcome, ${cleanedInput}!</h1>\n      </body>\n    </html>\n  `;\n\n  res.send(html);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在这个例子中，我们定义了一个 `/reflect` 路由，该路由从 `URL` 参数 `message` 中获取用户输入。然后，我们使用 `express-sanitized` 的 sanit`ize 函数来清理用户输入，该函数会移除或转义潜在的恶意脚本标签。最后，我们将清理后的用户输入嵌入到 `HTML` 响应中。\n\n然而，需要注意的是，仅仅依赖 `express-sanitized` 是不够的。你应该始终遵循最佳实践，如使用模板引擎（如 `Pug`、`EJS` 等）来自动处理 `HTML` 转义，设置适当的 `HTTP` 头（如 `X-XSS-Protection` 和 `Content-Security-Policy`），并且对用户输入进行严格的验证和过滤。\n\n另外，`express-sanitized` 可能不是最新的或最广泛使用的 `XSS` 防护中间件。对于更全面的 `XSS` 防护，你可以考虑使用 `helmet` 中间件，它提供了多种增强 `Express` 应用安全性的功能，包括 `XSS` 防护。\n\n#### helmet 中间件\n\n`helmet` 是一个 `Express.js` 的中间件，用于设置各种 `HTTP` 头来帮助预防一些已知的 `web` 漏洞，包括跨站脚本攻击（XSS）和数据泄露等。尽管 `helmet` 本身并不能完全防止 `XSS` 攻击，但它可以通过设置某些 `HTTP` 头来减少攻击面。\n\n下面是一个使用 `helmet` 中间件来增强 `Express.js` 应用安全性的简单案例：\n\n首先，你需要安装 `express` 和 `helmet`：\n\n``` bash\nnpm install express helmet\n```\n\n然后，创建一个 `Express` 应用并引入 `helmet` 中间件：\n\n``` javascript\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// 使用 helmet 中间件\napp.use(helmet());\n\n// 一个简单的 GET 路由\napp.get('/', (req, res) => {\n  res.send('Hello, World!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在上面的代码中，`helmet()` 函数是一个方便的快捷方式，用于启用多个安全头。这些头包括：\n\n- `content-security-policy`：帮助检测和缓解某些类型的攻击，包括跨站脚本和数据注入攻击。\n- `x-dns-prefetch-control`：控制浏览器是否应该执行 `DNS` 预取。\n- `x-frame-options`：指示浏览器是否应该允许页面被嵌入到 `<iframe>`、`<frame>`、`<embed>` 或 `<object>` 元素中。\n- `x-content-type-options`：防止浏览器猜测响应的 `MIME` 类型。\n- `x-xss-protection`：启用浏览器的反射型 `XSS` 保护。\n- `x-permitted-cross-domain-policies`：限制 `Adobe Flash Player` 的跨域策略文件的使用。\n- `referrer-policy`：控制浏览器在发送 `HTTP` 引用头时如何生成和发送引用信息。\n\n请注意，尽管 `helmet` 提供了这些保护措施，但它们并不是万无一失的。特别是 `content-security-policy` 头，它允许你明确指定哪些内容是安全的，是防止 `XSS` 攻击的重要工具。你需要根据你的应用程序的具体需求来配置它。\n\n此外，你还需要确保应用程序的其他部分（如模板引擎、用户输入验证等）也采取了适当的安全措施。`helmet` 只能作为安全策略的一部分，而不能单独依赖它来完全防止 `XSS` 攻击。\n\n### 预防措施\n\n为了防范`XSS`攻击，可以采取以下措施：\n\n1. 对用户输入的数据进行过滤和转义，防止恶意脚本的注入。\n2. 使用`HTTPOnly`属性设置Cookie，防止攻击者通过`XSS`攻击窃取用户信息。\n3. 使用 `CSP` 内容安全策略（`Content-Security-Policy`）限制网站中能够执行的脚本，防止恶意脚本的执行。\n4. 使用最新的Web安全技术和框架，如`React`、`Vue`等，它们提供了内置的`XSS`防护措施。\n5. 定期对网站进行安全漏洞扫描和测试，及时发现和修复`XSS`漏洞。","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/630/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## Web安全之 XSS 攻击\n\n### 简介\n**XSS，全称跨站脚本攻击（Cross-Site Scripting）**，是一种网络安全漏洞攻击，指攻击者在网页中嵌入恶意脚本，当其他用户浏览该网页时，恶意脚本就会在其浏览器上执行，从而达到攻击者窃取用户信息、破坏数据、篡改网页内容、在用户浏览器上执行非法任务等目的。\n\n### 分类\n\n`XSS`攻击分为三种类型：\n\n- **反射型XSS（Reflected XSS）**：攻击者将恶意脚本嵌入到URL地址中，当其他用户访问这个URL时，恶意脚本就会在其浏览器中执行。这种攻击方式需要用户主动点击含有恶意脚本的链接才会触发。\n\n- **存储型XSS（Stored XSS）**：攻击者将恶意脚本存储到被攻击的网站数据库中，当其他用户访问网站时，恶意脚本会从数据库中取出并在用户浏览器中执行。这种攻击方式不需要用户主动点击链接，只要用户浏览被攻击的网站就可能被攻击。\n\n- **DOM型XSS（DOM-based XSS）**：攻击者通过修改页面的DOM结构，注入恶意脚本，当其他用户浏览该页面时，恶意脚本会在用户浏览器中执行。这种攻击方式也不需要用户主动点击链接，只需要用户浏览被修改的页面就可能被攻击。\n\n### 案例\n\n#### 反射型XSS\n\n在`Node.js`中，一个反射型`XSS`攻击的案例可能涉及一个web应用，该应用没有正确地处理或转义用户输入的数据，并将其直接插入到HTML响应中。攻击者可以构造一个包含恶意脚本的URL，当其他用户访问这个URL时，恶意脚本会在用户的浏览器中执行。\n\n以下是一个简单的`Node.js`反射型`XSS`攻击的案例：\n\n``` javascript\nconst express = require('express');\nconst app = express();\napp.use(express.static('public'));\n\napp.get('/profile', (req, res) => {\n  // 假设用户可以通过URL参数传递他们的名字\n  const username = req.query.username;\n\n  // 没有对用户输入进行任何处理或转义\n  const html = `<html>\n                <body>\n                  <h1>Welcome, ${username}!</h1>\n                </body>\n              </html>`;\n\n  res.send(html);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在这个例子中，我们创建了一个简单的`Express`应用，其中有一个`/profile`路由，该路由从URL的查询参数中获取用户名（`username`）。然后，我们将这个用户名嵌入到一个`HTML`字符串中，并将其作为响应发送回客户端。\n\n攻击者可以构造一个包含恶意脚本的URL，如：\n\n```\nhttp://example.com/profile?username=<script>alert('XSS');</script>\n```\n\n当用户访问这个`URL`时，浏览器会接收到包含恶意脚本的`HTML`响应，并执行该脚本，从而触发`XSS`攻击。\n\n为了防止反射型`XSS`攻击，开发者应该对用户输入进行适当的过滤和转义。在这个案例中，可以使用如`escape-html`这样的库来转义`HTML`特殊字符：\n\n``` javascript\nconst escapeHtml = require('escape-html');\n\napp.get('/profile', (req, res) => {\n  const username = req.query.username;\n\n  // 转义用户输入中的HTML特殊字符\n  const escapedUsername = escapeHtml(username);\n\n  const html = `<html>\n                <body>\n                  <h1>Welcome, ${escapedUsername}!</h1>\n                </body>\n              </html>`;\n\n  res.send(html);\n});\n```\n\n通过转义用户输入，恶意脚本将不会被浏览器执行，从而防止了`XSS`攻击。此外，开发者还应该使用内容安全策略（`CSP`）等额外安全措施来增强应用的安全性。\n\n<!-- more -->\n\n#### 存储型XSS\n在`存储型XSS（Persistent XSS）`攻击中，恶意脚本被用户提交并存储到服务器端的数据库中。当其他用户访问包含这些恶意脚本的页面时，脚本会在用户的浏览器上执行。下面是一个简单的`Node.js`存储型XSS案例，我们将使用`Express`框架和`MongoDB`数据库。\n\n首先，确保你已经安装了以下依赖：\n\n``` bash\nnpm install express body-parser mongoose\n```\n\n然后，你可以创建一个简单的`Express`应用，并设置一个`MongoDB`数据库来存储评论。\n\n```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst mongoose = require('mongoose');\n\nconst app = express();\n\n// 连接到MongoDB数据库\nmongoose.connect('mongodb://localhost/xss-example', { useNewUrlParser: true, useUnifiedTopology: true });\n\n// 定义评论模型\nconst Comment = mongoose.model('Comment', new mongoose.Schema({\n  content: String\n}));\n\n// 使用body-parser中间件来解析请求体\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 路由：添加评论\napp.post('/comment', async (req, res) => {\n  try {\n    // 创建新的评论并保存到数据库\n    const newComment = new Comment({ content: req.body.content });\n    await newComment.save();\n    res.send('Comment added successfully!');\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('An error occurred while saving the comment.');\n  }\n});\n\n// 路由：显示所有评论\napp.get('/comments', async (req, res) => {\n  try {\n    // 从数据库中获取所有评论\n    const comments = await Comment.find({});\n\n    // 渲染评论列表的HTML\n    const html = renderComments(comments);\n    res.send(html);\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('An error occurred while fetching the comments.');\n  }\n});\n\n// 渲染评论列表的HTML\nfunction renderComments(comments) {\n  let html = '<html><body>';\n  comments.forEach(comment => {\n    // 这里没有对评论内容进行转义，这会导致存储型XSS漏洞\n    html += `<div>${comment.content}</div>`;\n  });\n  html += '</body></html>';\n  return html;\n}\n\n// 启动服务器\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n在这个案例中，我们定义了一个`Comment`模型，用于在`MongoDB`数据库中存储评论。`/comment`路由接受`POST`请求，将用户提交的评论保存到数据库中。`/comments`路由则负责从数据库中检索所有评论，并将它们渲染为HTML页面。\n\n重要提示：在这个案例的`renderComments`函数中，我们没有对评论内容进行任何形式的转义或过滤。这意味着如果用户在评论中输入了恶意脚本，它将被直接插入到`HTML`页面中，并在其他用户查看该页面时执行。这就是`存储型XSS`攻击的核心。\n\n为了防止`存储型XSS`攻击，你应该对所有的用户输入进行适当的转义或过滤。在`Express`应用中，你可以使用如`express-sanitized`和`helmet`这样的中间件来设置一些基本的`HTTP`头，以增加安全性。另外，使用模板引擎（如`ejs`、`pug`等）也可以帮助你更安全地渲染用户输入的数据，因为这些模板引擎通常会自动转义特殊字符。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。\n\n#### DOM型XSS\n在`React`应用程序中，`DOM型XSS`（跨站脚本）攻击通常发生在直接将用户输入嵌入到`JSX`中而没有进行适当的转义或过滤时。`React`本身不会自动转义用户输入，因此开发者需要确保在渲染用户输入之前进行适当的处理。下面是一个简单的`React`应用案例，展示了如果不正确地处理用户输入，可能会导致的`DOM型XSS`攻击：\n\n首先，创建一个简单的`React`组件，它将接收一个名为`username`的属性，并将其直接渲染到页面上：\n\n```jsx\nimport React from 'react';\n\nfunction UserProfile({ username }) {\n  return (\n    <div>\n      <h1>Welcome, {username}!</h1>\n    </div>\n  );\n}\n\nexport default UserProfile;\n```\n\n然后，在父组件中使用这个`UserProfile`组件，并假设从某个地方（例如URL参数、数据库或用户输入）获取`username`：\n\n``` jsx\nimport React from 'react';\nimport UserProfile from './UserProfile';\n\nfunction App() {\n  // 假设这是从某个不安全的来源获取的用户名\n  const username = \"Alice <img src='https://example.com/x.png' onerror='alert(\\\"XSS\\\")' />\";\n\n  return (\n    <div className=\"App\">\n      <UserProfile username={username} />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n在这个案例中，如果`username`包含了恶意的`HTML`和`JavaScript`代码，那么这段代码将会被执行，导致`XSS`攻击。\n\n为了防止这种攻击，你应该在渲染用户输入之前使用某种方法对其进行转义，以确保它不会被浏览器解析为`HTML`或`JavaScript`代码。在`React`中，你可以使用内置的`dangerouslySetInnerHTML`属性配合适当的转义函数来安全地渲染`HTML`内容。然而，这通常不是推荐的做法，因为它可能会引入其他安全风险。\n\n更好的做法是使用库如`react-dom-purify`来清理用户输入中的潜在恶意代码。下面是如何使用`react-dom-purify`来防止`XSS`攻击的例子：\n\n首先，安装`react-dom-purify`：\n\n``` bash\nnpm install react-dom-purify\n```\n\n然后，在你的`React`组件中使用它：\n\n``` jsx\nimport React from 'react';\nimport DOMPurify from 'react-dom-purify';\n\nfunction UserProfile({ username }) {\n  // 使用DOMPurify来清理用户输入中的潜在恶意代码\n  const safeUsername = DOMPurify.sanitize(username);\n\n  return (\n    <div>\n      <h1>Welcome, {safeUsername}!</h1>\n    </div>\n  );\n}\n\nexport default UserProfile;\n```\n\n在这个修改后的例子中，即使`username`包含了恶意的`HTML`和`JavaScript`代码，`DOMPurify.sanitize`函数也会将其清理掉，确保它们不会被浏览器执行。\n\n总之，为了防止`DOM型XSS`攻击，你应该始终确保在将用户输入渲染到React组件之前对其进行适当的转义或清理。\n\n#### ejs 模板引擎\n\n例如，如果你使用`ejs`作为模板引擎，你可以这样渲染评论：\n\n```ejs\n<body>\n  <% comments.forEach(function(comment) { %>\n    <div><%= comment.content %></div>\n  <% }); %>\n</body>\n```\n\n在这个例子中，`<%= comment.content %>`会自动转义`comment.content`中的特殊字符，从而防止`XSS`攻击。\n\n为了防止反射型和`存储型XSS`攻击，开发者应该对用户输入的数据进行适当的验证、过滤和转义。在`Node.js`中，可以使用诸如`express-sanitized`和`helmet`等中间件来增强应用的安全性。此外，对于`存储型XSS`，还需要确保在将用户数据插入到`HTML`之前进行适当的转义处理。\n\n#### express-sanitized 中间件\n`express-sanitized` 是一个 `Express.js` 的中间件，用于帮助防止跨站脚本（`XSS`）攻击。它通过提供一组函数来清理和转义用户输入的数据，从而减少潜在的安全风险。然而，需要注意的是，`express-sanitized` 本身并不提供全面的 `XSS` 保护。它应当与其他安全措施（如内容安全策略（`CSP`）、`HTTP` 头设置等）一起使用。\n\n下面是一个简单的 `Node.js` 案例，演示了如何使用 `express-sanitized` 中间件来防止反射型 `XSS` 攻击：\n\n首先，你需要安装 `express` 和 `express-sanitized`：\n\n```bash\nnpm install express express-sanitized\n```\n然后，你可以创建一个简单的 Express 应用，并使用 express-sanitized 来清理用户输入的数据：\n\n``` javascript\nconst express = require('express');\nconst sanitized = require('express-sanitized');\nconst app = express();\n\n// 使用 express-sanitized 中间件\napp.use(sanitized());\n\n// 一个简单的 GET 路由，接收用户输入并反射回去\napp.get('/reflect', (req, res) => {\n  // 假设我们从 URL 参数中获取用户输入\n  const userInput = req.query.message;\n\n  // 使用 express-sanitized 的 sanitize 函数来清理用户输入\n  const cleanedInput = sanitized.sanitize(userInput);\n\n  // 将清理后的用户输入嵌入到 HTML 中\n  const html = `\n    <html>\n      <body>\n        <h1>Welcome, ${cleanedInput}!</h1>\n      </body>\n    </html>\n  `;\n\n  res.send(html);\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在这个例子中，我们定义了一个 `/reflect` 路由，该路由从 `URL` 参数 `message` 中获取用户输入。然后，我们使用 `express-sanitized` 的 sanit`ize 函数来清理用户输入，该函数会移除或转义潜在的恶意脚本标签。最后，我们将清理后的用户输入嵌入到 `HTML` 响应中。\n\n然而，需要注意的是，仅仅依赖 `express-sanitized` 是不够的。你应该始终遵循最佳实践，如使用模板引擎（如 `Pug`、`EJS` 等）来自动处理 `HTML` 转义，设置适当的 `HTTP` 头（如 `X-XSS-Protection` 和 `Content-Security-Policy`），并且对用户输入进行严格的验证和过滤。\n\n另外，`express-sanitized` 可能不是最新的或最广泛使用的 `XSS` 防护中间件。对于更全面的 `XSS` 防护，你可以考虑使用 `helmet` 中间件，它提供了多种增强 `Express` 应用安全性的功能，包括 `XSS` 防护。\n\n#### helmet 中间件\n\n`helmet` 是一个 `Express.js` 的中间件，用于设置各种 `HTTP` 头来帮助预防一些已知的 `web` 漏洞，包括跨站脚本攻击（XSS）和数据泄露等。尽管 `helmet` 本身并不能完全防止 `XSS` 攻击，但它可以通过设置某些 `HTTP` 头来减少攻击面。\n\n下面是一个使用 `helmet` 中间件来增强 `Express.js` 应用安全性的简单案例：\n\n首先，你需要安装 `express` 和 `helmet`：\n\n``` bash\nnpm install express helmet\n```\n\n然后，创建一个 `Express` 应用并引入 `helmet` 中间件：\n\n``` javascript\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// 使用 helmet 中间件\napp.use(helmet());\n\n// 一个简单的 GET 路由\napp.get('/', (req, res) => {\n  res.send('Hello, World!');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n```\n\n在上面的代码中，`helmet()` 函数是一个方便的快捷方式，用于启用多个安全头。这些头包括：\n\n- `content-security-policy`：帮助检测和缓解某些类型的攻击，包括跨站脚本和数据注入攻击。\n- `x-dns-prefetch-control`：控制浏览器是否应该执行 `DNS` 预取。\n- `x-frame-options`：指示浏览器是否应该允许页面被嵌入到 `<iframe>`、`<frame>`、`<embed>` 或 `<object>` 元素中。\n- `x-content-type-options`：防止浏览器猜测响应的 `MIME` 类型。\n- `x-xss-protection`：启用浏览器的反射型 `XSS` 保护。\n- `x-permitted-cross-domain-policies`：限制 `Adobe Flash Player` 的跨域策略文件的使用。\n- `referrer-policy`：控制浏览器在发送 `HTTP` 引用头时如何生成和发送引用信息。\n\n请注意，尽管 `helmet` 提供了这些保护措施，但它们并不是万无一失的。特别是 `content-security-policy` 头，它允许你明确指定哪些内容是安全的，是防止 `XSS` 攻击的重要工具。你需要根据你的应用程序的具体需求来配置它。\n\n此外，你还需要确保应用程序的其他部分（如模板引擎、用户输入验证等）也采取了适当的安全措施。`helmet` 只能作为安全策略的一部分，而不能单独依赖它来完全防止 `XSS` 攻击。\n\n### 预防措施\n\n为了防范`XSS`攻击，可以采取以下措施：\n\n1. 对用户输入的数据进行过滤和转义，防止恶意脚本的注入。\n2. 使用`HTTPOnly`属性设置Cookie，防止攻击者通过`XSS`攻击窃取用户信息。\n3. 使用 `CSP` 内容安全策略（`Content-Security-Policy`）限制网站中能够执行的脚本，防止恶意脚本的执行。\n4. 使用最新的Web安全技术和框架，如`React`、`Vue`等，它们提供了内置的`XSS`防护措施。\n5. 定期对网站进行安全漏洞扫描和测试，及时发现和修复`XSS`漏洞。"]},"__N_SSG":true}