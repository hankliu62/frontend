{"pageProps":{"article":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/640","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/640/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/640/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/640/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/640","id":2218772392,"node_id":"I_kwDOBiJZIc6EP8eo","number":640,"title":"WebWorker 和 postMessage 使用指南","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6536875857,"node_id":"LA_kwDOBiJZIc8AAAABhaDPUQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/html","name":"html","color":"13c2c2","default":false,"description":"分类-HTML相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-04-01T18:01:41Z","updated_at":"2024-04-01T18:01:42Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"body":"## WebWorker 和 postMessage 使用指南\n\n### 概述\n\n在网页开发中，我们通常使用 `JavaScript` 来处理和响应用户的各种操作。然而，随着网页变得越来越复杂，我们需要执行的任务也变得越来越繁重。这些任务可能包括大量的计算、数据处理、文件读取等。如果我们直接在主线程中执行这些任务，可能会导致页面卡顿、响应变慢，甚至阻塞用户的其他操作。为了解决这个问题，`Web Worker` 应运而生。\n\n`JavaScript` 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 `CPU` 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。\n\n`Web Worker` 的作用，就是为 `JavaScript` 创造多线程环境，允许主线程创建 `Worker` 线程，将一些任务分配给后者运行。在主线程运行的同时，`Worker` 线程在后台运行，两者互不干扰。等到 `Worker` 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 `Worker` 线程负担了，主线程（通常负责 `UI` 交互）就会很流畅，不会被阻塞或拖慢。\n\n`Web Worker` 是一种在浏览器后台运行的 `JavaScript` 线程,`Worker` 线程一旦新建成功，就会始终运行，它独立于主线程运行，不会阻塞页面的渲染和用户交互，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 `Worker` 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。\n\n`Web Worker` 有以下几个使用注意点。\n\n#### （1）同源限制\n\n分配给 `Worker` 线程运行的脚本文件，必须与主线程的脚本文件同源。\n\n#### （2）DOM 限制\n\n`Worker` 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 `DOM` 对象，也无法使用`document`、`window`、`parent`这些对象。但是，`Worker` 线程可以`navigator`对象和`location`对象。\n\n#### （3）通信联系\n\n`Worker` 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。`(postMessage)`\n\n#### （4）脚本限制\n\n`Worker` 线程不能执行`alert()`方法和`confirm()`方法，但可以使用 `XMLHttpRequest` 对象发出 AJAX 请求。\n\n#### （5）文件限制\n\n`Worker` 线程无法读取本地文件，即不能打开本机的文件系统`（file://）`，它所加载的脚本，必须来自网络。\n\n### 基本用法\n\n#### 主线程\n\n主线程采用`new`命令，调用`Worker()`构造函数，新建一个 `Worker` 线程。\n\n``` js\nvar worker = new Worker('work.js');\n```\n\n`Worker()`构造函数的参数是一个脚本文件，该文件就是 `Worker` 线程所要执行的任务。由于 `Worker` 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），`Worker` 就会默默地失败。\n\n然后，主线程调用`worker.postMessage()`方法，向 `Worker` 发消息。\n\n``` js\nworker.postMessage('Hello World');\nworker.postMessage({method: 'echo', args: ['Work']});\n// worker.postMessage() 方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。\n```\n\n接着，主线程通过`worker.onmessage`指定监听函数，接收子线程发回来的消息。\n\n``` js\nworker.onmessage = function (event) {\n  console.log('Received message ' + event.data);\n  doSomething();\n}\n\nfunction doSomething() {\n  // 执行任务\n  worker.postMessage('Work done!');\n}\n```\n\n上面代码中，事件对象的data属性可以获取 `Worker` 发来的数据。\n\n`Worker` 完成任务以后，主线程就可以把它关掉。\n\n``` js\nworker.terminate();\n```\n\n#### Worker 线程\n\n`Worker` 线程内部需要有一个监听函数，监听`message`事件。\n\n``` js\nself.addEventListener('message', function (e) {\n  self.postMessage('You said: ' + e.data);\n}, false);\n```\n\n上面代码中，`self`代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。\n\n```js\n// 写法一\nthis.addEventListener('message', function (e) {\n  this.postMessage('You said: ' + e.data);\n}, false);\n\n// 写法二\naddEventListener('message', function (e) {\n  postMessage('You said: ' + e.data);\n}, false);\n```\n\n除了使用`self.addEventListener()`指定监听函数，也可以使用`self.onmessage`指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。`self.postMessage()`方法用来向主线程发送消息。\n\n根据主线程发来的数据，`Worker` 线程可以调用不同的方法，下面是一个例子。\n\n``` js\nself.addEventListener('message', function (e) {\n  var data = e.data;\n  switch (data.cmd) {\n    case 'start':\n      self.postMessage('WORKER STARTED: ' + data.msg);\n      break;\n    case 'stop':\n      self.postMessage('WORKER STOPPED: ' + data.msg);\n      self.close(); // Terminates the worker.\n      break;\n    default:\n      self.postMessage('Unknown command: ' + data.msg);\n  };\n}, false);\n```\n\n上面代码中，`self.close()`用于在 `Worker` 内部关闭自身。\n\n#### Worker 加载脚本\n\n`Worker` 内部如果要加载其他脚本，有一个专门的方法`importScripts()`。\n\n``` js\nimportScripts('script1.js');\n```\n\n该方法可以同时加载多个脚本。\n\n``` js\nimportScripts('script1.js', 'script2.js');\n```\n\n#### Worker 错误处理\n\n主线程可以监听 `Worker` 是否发生错误。如果发生错误，`Worker` 会触发主线程的error事件。\n\n``` js\nworker.onerror(function (event) {\n  console.log([\n    'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message\n  ].join(''));\n});\n\n// 或者\nworker.addEventListener('error', function (event) {\n  // ...\n});\n```\n\n`Worker` 内部也可以监听error事件。\n\n#### 关闭 Worker\n\n使用完毕，为了节省系统资源，必须关闭 `Worker` 。\n\n``` js\n// 主线程\nworker.terminate();\n\n// Worker 线程\nself.close();\n```\n\n### 数据通信\n\n前面说过，主线程与 `Worker` 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，`Worker` 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 `Worker`，后者再将它还原。\n\n主线程与 `Worker` 之间也可以交换二进制数据，比如 `File`、`Blob`、`ArrayBuffer` 等类型，也可以在线程之间发送。下面是一个例子。\n\n``` js\n// 主线程\nvar uInt8Array = new Uint8Array(new ArrayBuffer(10));\nfor (var i = 0; i < uInt8Array.length; ++i) {\n  uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]\n}\nworker.postMessage(uInt8Array);\n\n// Worker 线程\nself.onmessage = function (e) {\n  var uInt8Array = e.data;\n  postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString());\n  postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);\n};\n```\n\n但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 `Worker` 发送一个 `500MB` 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，`JavaScript` 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做`Transferable Objects`。这使得主线程可以快速把数据交给 `Worker`，对于影像处理、声音处理、`3D` 运算等就非常方便了，不会产生性能负担。\n\n如果要直接转移数据的控制权，就要使用下面的写法。\n\n``` js\n// Transferable Objects 格式\nworker.postMessage(arrayBuffer, [arrayBuffer]);\n\n// 例子\nvar ab = new ArrayBuffer(1);\nworker.postMessage(ab, [ab]);\n```\n\n### 同页面的 Web Worker\n\n通常情况下，`Worker` 载入的是一个单独的 `JavaScript` 脚本文件，但是也可以载入与主线程在同一个网页的代码。\n\n``` html\n<!DOCTYPE html>\n  <body>\n    <script id=\"worker\" type=\"app/worker\">\n      addEventListener('message', function () {\n        postMessage('some message');\n      }, false);\n    </script>\n  </body>\n</html>\n```\n\n上面是一段嵌入网页的脚本，注意必须指定`<script>`标签的type属性是一个浏览器不认识的值，上例是`app/worker`。\n\n然后，读取这一段嵌入页面的脚本，用 `Worker` 来处理。\n\n``` js\nvar blob = new Blob([document.querySelector('#worker').textContent]);\nvar url = window.URL.createObjectURL(blob);\nvar worker = new Worker(url);\n\nworker.onmessage = function (e) {\n  // e.data === 'some message'\n};\n```\n\n上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 `URL`，再让 `Worker` 加载这个 `URL`。这样就做到了，主线程和 `Worker` 的代码都在同一个网页上面。\n\n### Worker 线程完成轮询\n\n有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 `Worker` 里面。\n\n``` js\nfunction createWorker(f) {\n  var blob = new Blob(['(' + f.toString() +')()']);\n  var url = window.URL.createObjectURL(blob);\n  var worker = new Worker(url);\n  return worker;\n}\n\nvar pollingWorker = createWorker(function (e) {\n  var cache;\n\n  function compare(new, old) { ... };\n\n  setInterval(function () {\n    fetch('/my-api-endpoint').then(function (res) {\n      var data = res.json();\n\n      if (!compare(data, cache)) {\n        cache = data;\n        self.postMessage(data);\n      }\n    })\n  }, 1000)\n});\n\npollingWorker.onmessage = function () {\n  // render data\n}\n\npollingWorker.postMessage('init');\n```\n\n上面代码中，`Worker` 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。\n\n### Worker 新建 Worker\n\n`Worker` 线程内部还能再新建 `Worker` 线程（目前只有 `Firefox` 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 `Worker`。\n\n主线程代码如下。\n\n``` js\nvar worker = new Worker('worker.js');\nworker.onmessage = function (event) {\n  document.getElementById('result').textContent = event.data;\n};\n```\n\n`Worker` 线程代码如下:\n\n``` js\n// worker.js\n\n// settings\nvar num_workers = 10;\nvar items_per_worker = 1000000;\n\n// start the workers\nvar result = 0;\nvar pending_workers = num_workers;\nfor (var i = 0; i < num_workers; i += 1) {\n  var worker = new Worker('core.js');\n  worker.postMessage(i * items_per_worker);\n  worker.postMessage((i + 1) * items_per_worker);\n  worker.onmessage = storeResult;\n}\n\n// handle the results\nfunction storeResult(event) {\n  result += event.data;\n  pending_workers -= 1;\n  if (pending_workers <= 0)\n    postMessage(result); // finished!\n}\n```\n\n上面代码中，`Worker` 线程内部新建了10个 `Worker` 线程，并且依次向这10个 `Worker` 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。\n\n``` js\n// core.js\nvar start;\nonmessage = getStart;\nfunction getStart(event) {\n  start = event.data;\n  onmessage = getEnd;\n}\n\nvar end;\nfunction getEnd(event) {\n  end = event.data;\n  onmessage = null;\n  work();\n}\n\nfunction work() {\n  var result = 0;\n  for (var i = start; i < end; i += 1) {\n    // perform some complex calculation here\n    result += 1;\n  }\n  postMessage(result);\n  close();\n}\n```\n\n### API\n\n#### 主线程\n\n浏览器原生提供`Worker()`构造函数，用来供主线程生成 `Worker` 线程。\n\n``` js\nvar myWorker = new Worker(jsUrl, options);\n```\n\n`Worker()`构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 `JS` 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 `Worker` 的名称，用来区分多个 `Worker` 线程。\n\n``` js\n// 主线程\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\n\n// Worker 线程\nself.name // myWorker\n```\n\n`Worker()`构造函数返回一个 `Worker` 线程对象，用来供主线程操作 `Worker`。`Worker` 线程对象的属性和方法如下。\n\n- **Worker.onerror：**指定 `error` 事件的监听函数。\n- **Worker.onmessage：**指定 `message` 事件的监听函数，发送过来的数据在`Event.data`属性中。\n- **Worker.onmessageerror：**指定 `messageerror` 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\n- **Worker.postMessage()：**向 `Worker` 线程发送消息。\n- **Worker.terminate()：**立即终止 `Worker` 线程。\n\n#### Worker 线程\n\n`Web Worker` 有自己的全局对象，不是主线程的`window`，而是一个专门为 `Worker` 定制的全局对象。因此定义在`window`上面的对象和方法不是全部都可以使用。\n\n`Worker` 线程有一些自己的全局属性和方法。\n\n- **self.name：**`Worker` 的名字。该属性只读，由构造函数指定。\n- **self.onmessage：**指定 `message` 事件的监听函数。\n- **self.onmessageerror：**指定 `messageerror` 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\n- **self.close()：**关闭 `Worker` 线程。\n- **self.postMessage()：**向产生这个 `Worker` 线程发送消息。\n- **self.importScripts()：**加载 `JS` 脚本。\n\n### 应用场景\n\nWeb Workers适用于以下场景：\n\n1. **大量数据处理：**如表格、图表等需要处理大量数据的场景，可以将数据处理任务放在 `Web Workers` 中执行，避免阻塞主线程。\n2. **复杂计算：**如图像处理、机器学习等需要执行复杂计算的场景，可以利用 `Web Workers` 实现并行计算，提高性能。\n3. **文件读写：**如读取大文件、处理文件数据等场景，可以使用 `Web Workers` 在后台进行文件读写操作，避免阻塞主线程。\n\n总之，`Web Workers` 为网页开发提供了一种有效的手段来优化性能和用户体验。通过合理利用 `Web Workers`，我们可以实现真正的并行处理，使网页更加流畅、响应更快。\n\n来源： https://www.ruanyifeng.com/blog/2018/07/web-worker.html","closed_by":null,"reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/640/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/640/timeline","performed_via_github_app":null,"state_reason":null},"menus":["## WebWorker 和 postMessage 使用指南\n\n### 概述\n\n在网页开发中，我们通常使用 `JavaScript` 来处理和响应用户的各种操作。然而，随着网页变得越来越复杂，我们需要执行的任务也变得越来越繁重。这些任务可能包括大量的计算、数据处理、文件读取等。如果我们直接在主线程中执行这些任务，可能会导致页面卡顿、响应变慢，甚至阻塞用户的其他操作。为了解决这个问题，`Web Worker` 应运而生。\n\n`JavaScript` 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 `CPU` 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。\n\n`Web Worker` 的作用，就是为 `JavaScript` 创造多线程环境，允许主线程创建 `Worker` 线程，将一些任务分配给后者运行。在主线程运行的同时，`Worker` 线程在后台运行，两者互不干扰。等到 `Worker` 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 `Worker` 线程负担了，主线程（通常负责 `UI` 交互）就会很流畅，不会被阻塞或拖慢。\n\n`Web Worker` 是一种在浏览器后台运行的 `JavaScript` 线程,`Worker` 线程一旦新建成功，就会始终运行，它独立于主线程运行，不会阻塞页面的渲染和用户交互，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 `Worker` 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。\n\n`Web Worker` 有以下几个使用注意点。\n\n#### （1）同源限制\n\n分配给 `Worker` 线程运行的脚本文件，必须与主线程的脚本文件同源。\n\n#### （2）DOM 限制\n\n`Worker` 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 `DOM` 对象，也无法使用`document`、`window`、`parent`这些对象。但是，`Worker` 线程可以`navigator`对象和`location`对象。\n\n#### （3）通信联系\n\n`Worker` 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。`(postMessage)`\n\n#### （4）脚本限制\n\n`Worker` 线程不能执行`alert()`方法和`confirm()`方法，但可以使用 `XMLHttpRequest` 对象发出 AJAX 请求。\n\n#### （5）文件限制\n\n`Worker` 线程无法读取本地文件，即不能打开本机的文件系统`（file://）`，它所加载的脚本，必须来自网络。\n\n### 基本用法\n\n#### 主线程\n\n主线程采用`new`命令，调用`Worker()`构造函数，新建一个 `Worker` 线程。\n\n``` js\nvar worker = new Worker('work.js');\n```\n\n`Worker()`构造函数的参数是一个脚本文件，该文件就是 `Worker` 线程所要执行的任务。由于 `Worker` 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），`Worker` 就会默默地失败。\n\n然后，主线程调用`worker.postMessage()`方法，向 `Worker` 发消息。\n\n``` js\nworker.postMessage('Hello World');\nworker.postMessage({method: 'echo', args: ['Work']});\n// worker.postMessage() 方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。\n```\n\n接着，主线程通过`worker.onmessage`指定监听函数，接收子线程发回来的消息。\n\n``` js\nworker.onmessage = function (event) {\n  console.log('Received message ' + event.data);\n  doSomething();\n}\n\nfunction doSomething() {\n  // 执行任务\n  worker.postMessage('Work done!');\n}\n```\n\n上面代码中，事件对象的data属性可以获取 `Worker` 发来的数据。\n\n`Worker` 完成任务以后，主线程就可以把它关掉。\n\n``` js\nworker.terminate();\n```\n\n#### Worker 线程\n\n`Worker` 线程内部需要有一个监听函数，监听`message`事件。\n\n``` js\nself.addEventListener('message', function (e) {\n  self.postMessage('You said: ' + e.data);\n}, false);\n```\n\n上面代码中，`self`代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。\n\n```js\n// 写法一\nthis.addEventListener('message', function (e) {\n  this.postMessage('You said: ' + e.data);\n}, false);\n\n// 写法二\naddEventListener('message', function (e) {\n  postMessage('You said: ' + e.data);\n}, false);\n```\n\n除了使用`self.addEventListener()`指定监听函数，也可以使用`self.onmessage`指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。`self.postMessage()`方法用来向主线程发送消息。\n\n根据主线程发来的数据，`Worker` 线程可以调用不同的方法，下面是一个例子。\n\n``` js\nself.addEventListener('message', function (e) {\n  var data = e.data;\n  switch (data.cmd) {\n    case 'start':\n      self.postMessage('WORKER STARTED: ' + data.msg);\n      break;\n    case 'stop':\n      self.postMessage('WORKER STOPPED: ' + data.msg);\n      self.close(); // Terminates the worker.\n      break;\n    default:\n      self.postMessage('Unknown command: ' + data.msg);\n  };\n}, false);\n```\n\n上面代码中，`self.close()`用于在 `Worker` 内部关闭自身。\n\n#### Worker 加载脚本\n\n`Worker` 内部如果要加载其他脚本，有一个专门的方法`importScripts()`。\n\n``` js\nimportScripts('script1.js');\n```\n\n该方法可以同时加载多个脚本。\n\n``` js\nimportScripts('script1.js', 'script2.js');\n```\n\n#### Worker 错误处理\n\n主线程可以监听 `Worker` 是否发生错误。如果发生错误，`Worker` 会触发主线程的error事件。\n\n``` js\nworker.onerror(function (event) {\n  console.log([\n    'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message\n  ].join(''));\n});\n\n// 或者\nworker.addEventListener('error', function (event) {\n  // ...\n});\n```\n\n`Worker` 内部也可以监听error事件。\n\n#### 关闭 Worker\n\n使用完毕，为了节省系统资源，必须关闭 `Worker` 。\n\n``` js\n// 主线程\nworker.terminate();\n\n// Worker 线程\nself.close();\n```\n\n### 数据通信\n\n前面说过，主线程与 `Worker` 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，`Worker` 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 `Worker`，后者再将它还原。\n\n主线程与 `Worker` 之间也可以交换二进制数据，比如 `File`、`Blob`、`ArrayBuffer` 等类型，也可以在线程之间发送。下面是一个例子。\n\n``` js\n// 主线程\nvar uInt8Array = new Uint8Array(new ArrayBuffer(10));\nfor (var i = 0; i < uInt8Array.length; ++i) {\n  uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]\n}\nworker.postMessage(uInt8Array);\n\n// Worker 线程\nself.onmessage = function (e) {\n  var uInt8Array = e.data;\n  postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString());\n  postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);\n};\n```\n\n但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 `Worker` 发送一个 `500MB` 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，`JavaScript` 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做`Transferable Objects`。这使得主线程可以快速把数据交给 `Worker`，对于影像处理、声音处理、`3D` 运算等就非常方便了，不会产生性能负担。\n\n如果要直接转移数据的控制权，就要使用下面的写法。\n\n``` js\n// Transferable Objects 格式\nworker.postMessage(arrayBuffer, [arrayBuffer]);\n\n// 例子\nvar ab = new ArrayBuffer(1);\nworker.postMessage(ab, [ab]);\n```\n\n### 同页面的 Web Worker\n\n通常情况下，`Worker` 载入的是一个单独的 `JavaScript` 脚本文件，但是也可以载入与主线程在同一个网页的代码。\n\n``` html\n<!DOCTYPE html>\n  <body>\n    <script id=\"worker\" type=\"app/worker\">\n      addEventListener('message', function () {\n        postMessage('some message');\n      }, false);\n    </script>\n  </body>\n</html>\n```\n\n上面是一段嵌入网页的脚本，注意必须指定`<script>`标签的type属性是一个浏览器不认识的值，上例是`app/worker`。\n\n然后，读取这一段嵌入页面的脚本，用 `Worker` 来处理。\n\n``` js\nvar blob = new Blob([document.querySelector('#worker').textContent]);\nvar url = window.URL.createObjectURL(blob);\nvar worker = new Worker(url);\n\nworker.onmessage = function (e) {\n  // e.data === 'some message'\n};\n```\n\n上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 `URL`，再让 `Worker` 加载这个 `URL`。这样就做到了，主线程和 `Worker` 的代码都在同一个网页上面。\n\n### Worker 线程完成轮询\n\n有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 `Worker` 里面。\n\n``` js\nfunction createWorker(f) {\n  var blob = new Blob(['(' + f.toString() +')()']);\n  var url = window.URL.createObjectURL(blob);\n  var worker = new Worker(url);\n  return worker;\n}\n\nvar pollingWorker = createWorker(function (e) {\n  var cache;\n\n  function compare(new, old) { ... };\n\n  setInterval(function () {\n    fetch('/my-api-endpoint').then(function (res) {\n      var data = res.json();\n\n      if (!compare(data, cache)) {\n        cache = data;\n        self.postMessage(data);\n      }\n    })\n  }, 1000)\n});\n\npollingWorker.onmessage = function () {\n  // render data\n}\n\npollingWorker.postMessage('init');\n```\n\n上面代码中，`Worker` 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。\n\n### Worker 新建 Worker\n\n`Worker` 线程内部还能再新建 `Worker` 线程（目前只有 `Firefox` 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 `Worker`。\n\n主线程代码如下。\n\n``` js\nvar worker = new Worker('worker.js');\nworker.onmessage = function (event) {\n  document.getElementById('result').textContent = event.data;\n};\n```\n\n`Worker` 线程代码如下:\n\n``` js\n// worker.js\n\n// settings\nvar num_workers = 10;\nvar items_per_worker = 1000000;\n\n// start the workers\nvar result = 0;\nvar pending_workers = num_workers;\nfor (var i = 0; i < num_workers; i += 1) {\n  var worker = new Worker('core.js');\n  worker.postMessage(i * items_per_worker);\n  worker.postMessage((i + 1) * items_per_worker);\n  worker.onmessage = storeResult;\n}\n\n// handle the results\nfunction storeResult(event) {\n  result += event.data;\n  pending_workers -= 1;\n  if (pending_workers <= 0)\n    postMessage(result); // finished!\n}\n```\n\n上面代码中，`Worker` 线程内部新建了10个 `Worker` 线程，并且依次向这10个 `Worker` 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。\n\n``` js\n// core.js\nvar start;\nonmessage = getStart;\nfunction getStart(event) {\n  start = event.data;\n  onmessage = getEnd;\n}\n\nvar end;\nfunction getEnd(event) {\n  end = event.data;\n  onmessage = null;\n  work();\n}\n\nfunction work() {\n  var result = 0;\n  for (var i = start; i < end; i += 1) {\n    // perform some complex calculation here\n    result += 1;\n  }\n  postMessage(result);\n  close();\n}\n```\n\n### API\n\n#### 主线程\n\n浏览器原生提供`Worker()`构造函数，用来供主线程生成 `Worker` 线程。\n\n``` js\nvar myWorker = new Worker(jsUrl, options);\n```\n\n`Worker()`构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 `JS` 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 `Worker` 的名称，用来区分多个 `Worker` 线程。\n\n``` js\n// 主线程\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\n\n// Worker 线程\nself.name // myWorker\n```\n\n`Worker()`构造函数返回一个 `Worker` 线程对象，用来供主线程操作 `Worker`。`Worker` 线程对象的属性和方法如下。\n\n- **Worker.onerror：**指定 `error` 事件的监听函数。\n- **Worker.onmessage：**指定 `message` 事件的监听函数，发送过来的数据在`Event.data`属性中。\n- **Worker.onmessageerror：**指定 `messageerror` 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\n- **Worker.postMessage()：**向 `Worker` 线程发送消息。\n- **Worker.terminate()：**立即终止 `Worker` 线程。\n\n#### Worker 线程\n\n`Web Worker` 有自己的全局对象，不是主线程的`window`，而是一个专门为 `Worker` 定制的全局对象。因此定义在`window`上面的对象和方法不是全部都可以使用。\n\n`Worker` 线程有一些自己的全局属性和方法。\n\n- **self.name：**`Worker` 的名字。该属性只读，由构造函数指定。\n- **self.onmessage：**指定 `message` 事件的监听函数。\n- **self.onmessageerror：**指定 `messageerror` 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\n- **self.close()：**关闭 `Worker` 线程。\n- **self.postMessage()：**向产生这个 `Worker` 线程发送消息。\n- **self.importScripts()：**加载 `JS` 脚本。\n\n### 应用场景\n\nWeb Workers适用于以下场景：\n\n1. **大量数据处理：**如表格、图表等需要处理大量数据的场景，可以将数据处理任务放在 `Web Workers` 中执行，避免阻塞主线程。\n2. **复杂计算：**如图像处理、机器学习等需要执行复杂计算的场景，可以利用 `Web Workers` 实现并行计算，提高性能。\n3. **文件读写：**如读取大文件、处理文件数据等场景，可以使用 `Web Workers` 在后台进行文件读写操作，避免阻塞主线程。\n\n总之，`Web Workers` 为网页开发提供了一种有效的手段来优化性能和用户体验。通过合理利用 `Web Workers`，我们可以实现真正的并行处理，使网页更加流畅、响应更快。\n\n来源： https://www.ruanyifeng.com/blog/2018/07/web-worker.html"]},"__N_SSG":true}